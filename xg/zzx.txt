/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V12.4 ä¸ªæ€§åŒ–ä¸å¯è§†åŒ–å¢å¼ºç‰ˆ
 * 
 * ä¸»è¦æ”¹è¿›:
 * 1. ç”¨æˆ·ä¸ªæ€§åŒ–ï¼šæ ¹æ®ç”¨æˆ·å†å²åå¥½è°ƒæ•´ç®—æ³•æƒé‡
 * 2. å¯è§†åŒ–æŠ¥å‘Šï¼šæ–‡æœ¬ç”Ÿæˆç»Ÿè®¡å›¾è¡¨å’Œåˆ†ææŠ¥å‘Š
 * 3. ç”¨æˆ·åé¦ˆç³»ç»Ÿï¼šè®°å½•ç”¨æˆ·å¯¹é¢„æµ‹ç»“æœçš„è¯„ä»·
 * 4. ä¸ªæ€§åŒ–ç®—æ³•æƒé‡è°ƒæ•´
 * 5. ASCIIå›¾è¡¨ç”Ÿæˆå™¨
 * 6. ç”¨æˆ·è¡Œä¸ºåˆ†æ
 * 7. å¢å¼ºçš„ç»Ÿè®¡æŠ¥å‘Š
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ¾³å…­é¢„æµ‹",
    VERSION: "V12.4 ä¸ªæ€§åŒ–ä¸å¯è§†åŒ–å¢å¼ºç‰ˆ",
    TIMEZONE_OFFSET: 8,
    HISTORY_LIMIT: 2000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    MONTECARLO_SIMULATIONS: 10000,
    MONTECARLO_BATCH_SIZE: 2000,
    MONTECARLO_MAX_BATCHES: 5,
    MAX_SIMULATIONS: 50000,
    MIN_SIMULATIONS: 2000,
    MAX_RUNTIME_MS: 10000,
    ASYNC_BATCH_DELAY: 20,
    MAX_SPECIAL_PREDICTIONS: 15,
    MAX_NORMAL_PREDICTIONS: 12,
    MONTE_CACHE_TTL: 5 * 60 * 1000,
    KNN_K_VALUE: 10,
    STATS_WINDOW_SIZE: 100,
    PREDICTION_TIMEOUT: 8000,
    ALGORITHM_TIMEOUTS: {
      traditional: 3000,
      knn: 4000,
      stats: 5000,
      advanced: 8000,
      personalized: 8500
    },
    MIN_HISTORY_FOR_ALGORITHMS: {
      traditional: 2,
      knn: 10,
      stats: 20,
      advanced: 5,
      personalized: 10
    },
    MESSAGE_MANAGER_MAX_USERS: 1000,
    MESSAGE_MANAGER_MAX_MESSAGES_PER_USER: 20,
    AUTO_CLEANUP_INTERVAL: 10 * 60 * 1000,
    USER_INACTIVITY_THRESHOLD: 30 * 60 * 1000,
    
    // ä¸ªæ€§åŒ–é…ç½®
    PERSONALIZATION: {
      MIN_FEEDBACK_FOR_PERSONALIZATION: 5,
      LEARNING_RATE: 0.1,
      MAX_WEIGHT_ADJUSTMENT: 0.5,
      DECAY_RATE: 0.99, // æƒé‡éšæ—¶é—´è¡°å‡
      INITIAL_WEIGHT_MULTIPLIER: 1.0,
      WEIGHT_UPDATE_THRESHOLD: 0.05
    },
    
    // å¯è§†åŒ–é…ç½®
    VISUALIZATION: {
      CHART_WIDTH: 40,
      MAX_BAR_HEIGHT: 10,
      EMOJI_SCALE: ["â–", "â–‚", "â–ƒ", "â–„", "â–…", "â–†", "â–‡", "â–ˆ"],
      TREND_INDICATORS: ["â†˜", "â†˜", "â†’", "â†’", "â†—", "â†—", "â†—â†‘"]
    }
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.5,
    w_zodiac_relation: 2.0,
    w_color_transfer: 1.8,
    w_tail_correlation: 1.5,
    w_number_frequency: 1.3,
    w_monte_carlo: 2.5,
    w_number_pattern: 1.2,
    w_hot_cold: 1.1,
    w_knn_similarity: 2.0,
    w_statistics_analysis: 2.8,
    w_tail_pattern: 1.8,
    w_head_pattern: 1.5,
    w_size_pattern: 1.4,
    w_odd_even_pattern: 1.4,
    w_user_preference: 1.0,
    _version: "12.4"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  NUMBER_PATTERNS: {
    prime: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47],
    composite: [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49],
    multiples_of_7: [7, 14, 21, 28, 35, 42, 49],
    multiples_of_8: [8, 16, 24, 32, 40, 48]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    home: "ğŸ ",
    trash: "ğŸ—‘ï¸",
    warning: "âš ï¸",
    database: "ğŸ’¾",
    clock: "â°",
    check: "âœ”ï¸",
    speed: "âš¡",
    fix: "ğŸ”§",
    bell: "ğŸ””",
    star: "â­",
    rocket: "ğŸš€",
    refresh: "ğŸ”„",
    eye: "ğŸ‘ï¸",
    lock: "ğŸ”’",
    dice: "ğŸ²",
    calendar: "ğŸ“…",
    hourglass: "â³",
    money: "ğŸ’°",
    target: "ğŸ¯",
    brain: "ğŸ§ ",
    science: "ğŸ”¬",
    chart_up: "ğŸ“ˆ",
    clock2: "ğŸ•’",
    alarm: "â°",
    repeat: "ğŸ”",
    progress: "ğŸ“ˆ",
    batch: "ğŸ”¢",
    history: "ğŸ“œ",
    memory: "ğŸ’¾",
    cpu: "âš™ï¸",
    magic: "âœ¨",
    sparkles: "ğŸŒŸ",
    atom: "âš›ï¸",
    brain_circuit: "ğŸ§©",
    crystal_ball: "ğŸ”®",
    comet: "â˜„ï¸",
    infinity: "â™¾ï¸",
    knn: "ğŸ”",
    statistics: "ğŸ“Š",
    tail: "ğŸ”Ÿ",
    head: "ğŸ“Œ",
    size: "âš–ï¸",
    odd_even: "ğŸ”„",
    lightning: "âš¡",
    bulb: "ğŸ’¡",
    gear: "âš™ï¸",
    hammer: "ğŸ”¨",
    zap: "âš¡",
    search: "ğŸ”",
    graph: "ğŸ“ˆ",
    medal: "ğŸ…",
    crown: "ğŸ‘‘",
    trophy2: "ğŸ†",
    first_place: "ğŸ¥‡",
    second_place: "ğŸ¥ˆ",
    third_place: "ğŸ¥‰",
    info: "â„¹ï¸",
    flag: "ğŸš©",
    chart2: "ğŸ“‰",
    up: "â¬†ï¸",
    down: "â¬‡ï¸",
    heart: "â¤ï¸",
    user: "ğŸ‘¤",
    trend_up: "ğŸ“ˆ",
    trend_down: "ğŸ“‰",
    trend_stable: "ğŸ“Š",
    settings: "âš™ï¸",
    report: "ğŸ“‹",
    analysis: "ğŸ”",
    personal: "ğŸ‘¤",
    bar_chart: "ğŸ“Š",
    pie_chart: "ğŸ¥§",
    line_chart: "ğŸ“ˆ",
    ranking: "ğŸ†",
    rating: "â­",
    feedback: "ğŸ’¬",
    thumbs_up: "ğŸ‘",
    thumbs_down: "ğŸ‘",
    profile: "ğŸ‘¤",
    customize: "ğŸ¨",
    history2: "ğŸ—“ï¸",
    target2: "ğŸ¯",
    brain2: "ğŸ§ ",
    diamond2: "ğŸ’"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    PREDICT: "prediction",
    PERSONALIZED: "personalized_prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_CONFIRM: "delete_confirm",
    DELETE_RESULT: "delete_result",
    FEEDBACK: "feedback",
    PROFILE: "profile",
    REPORT: "report",
    VISUALIZE: "visualize",
    STATS: "stats"
  },

  ALGORITHM_NAMES: {
    traditional: "ä¼ ç»Ÿç®—æ³•",
    knn: "KNNç®—æ³•",
    stats: "ç»Ÿè®¡ç®—æ³•",
    advanced: "å¢å¼ºç®—æ³•",
    personalized: "ä¸ªæ€§åŒ–ç®—æ³•"
  },

  // ç”¨æˆ·åå¥½ç±»å‹
  USER_PREFERENCE_TYPES: {
    ZODIAC: "zodiac",
    COLOR: "color",
    TAIL: "tail",
    SIZE: "size",
    ODD_EVEN: "odd_even",
    NUMBER_RANGE: "number_range",
    ALGORITHM: "algorithm"
  }
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•°
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
  
  static debug(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [DEBUG] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.debug] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
      }
      
      let zodiac = "æœªçŸ¥";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "æœªçŸ¥";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(2) + 'äº¿';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }

  static getRandomElement(array) {
    try {
      if (!array || !Array.isArray(array) || array.length === 0) return null;
      return array[Math.floor(Math.random() * array.length)];
    } catch (error) {
      return null;
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static formatDuration(ms) {
    try {
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms/1000).toFixed(2)}ç§’`;
      if (ms < 3600000) return `${Math.floor(ms/60000)}åˆ†${Math.floor((ms%60000)/1000)}ç§’`;
      return `${Math.floor(ms/3600000)}å°æ—¶${Math.floor((ms%3600000)/60000)}åˆ†`;
    } catch (error) {
      return `${ms}ms`;
    }
  }

  static formatProgress(current, total) {
    try {
      const percent = total > 0 ? ((current / total) * 100).toFixed(1) : 0;
      const progressBarLength = 20;
      const filled = Math.round((current / total) * progressBarLength);
      const empty = progressBarLength - filled;
      const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
      return `${bar} ${percent}% (${current}/${total})`;
    } catch (error) {
      return `${current}/${total}`;
    }
  }

  static isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    
    for (let i = 5; i * i <= num; i += 6) {
      if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
  }

  static calculateNumberPattern(num) {
    try {
      const patterns = [];
      
      if (this.isPrime(num)) {
        patterns.push("è´¨æ•°");
      } else {
        patterns.push("åˆæ•°");
      }
      
      if (num % 7 === 0) {
        patterns.push("7å€æ•°");
      }
      
      if (num % 8 === 0) {
        patterns.push("8å€æ•°");
      }
      
      return patterns;
    } catch (error) {
      return [];
    }
  }

  static calculateHotColdStatus(numbers, history) {
    try {
      if (!Array.isArray(numbers) || !Array.isArray(history) || history.length < 10) {
        return {};
      }
      
      const frequency = {};
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }
      
      const recentHistory = history.slice(0, Math.min(100, history.length));
      for (const record of recentHistory) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => this.safeInt(n, 0));
          for (const num of nums) {
            if (num >= 1 && num <= 49) {
              frequency[num]++;
            }
          }
        }
      }
      
      const status = {};
      const maxFrequency = Math.max(...Object.values(frequency));
      const avgFrequency = Object.values(frequency).reduce((a, b) => a + b, 0) / 49;
      
      for (const num of numbers) {
        if (num >= 1 && num <= 49) {
          const freq = frequency[num] || 0;
          if (freq >= maxFrequency * 0.8) {
            status[num] = "ğŸ”¥ çƒ­é—¨";
          } else if (freq <= avgFrequency * 0.5) {
            status[num] = "â„ï¸ å†·é—¨";
          } else if (freq <= avgFrequency * 0.8) {
            status[num] = "ğŸŒ¡ï¸ æ¸©ç ";
          } else {
            status[num] = "âš¡ æ´»è·ƒ";
          }
        }
      }
      
      return status;
    } catch (error) {
      return {};
    }
  }

  static calculateFeatures(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return null;
      }
      
      const attr = this.getAttributes(num);
      
      return {
        number: num,
        zodiac: attr.zodiac,
        color: attr.color,
        tail: num % 10,
        head: Math.floor(num / 10),
        isBig: num >= 25,
        isOdd: num % 2 !== 0,
        isPrime: this.isPrime(num)
      };
    } catch (error) {
      return null;
    }
  }

  static isAlgorithmSupported(algorithm, historyLength) {
    try {
      const minHistory = CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS[algorithm] || 2;
      return historyLength >= minHistory;
    } catch (error) {
      return historyLength >= 2;
    }
  }

  static getAlgorithmTimeout(algorithm) {
    try {
      return CONFIG.SYSTEM.ALGORITHM_TIMEOUTS[algorithm] || CONFIG.SYSTEM.PREDICTION_TIMEOUT;
    } catch (error) {
      return CONFIG.SYSTEM.PREDICTION_TIMEOUT;
    }
  }

  static normalizeScore(score, min, max) {
    try {
      if (max === min) return 0.5;
      return Math.max(0, Math.min(1, (score - min) / (max - min)));
    } catch (error) {
      return 0.5;
    }
  }

  static generateASCIIBar(value, maxValue, width = 20, useEmoji = false) {
    try {
      if (maxValue === 0) return "";
      
      const percentage = value / maxValue;
      const barWidth = Math.max(1, Math.round(width * percentage));
      
      if (useEmoji) {
        const emojiScale = CONFIG.SYSTEM.VISUALIZATION.EMOJI_SCALE;
        const emojiIndex = Math.min(emojiScale.length - 1, Math.floor(percentage * emojiScale.length));
        return emojiScale[emojiIndex].repeat(barWidth) + " " + (percentage * 100).toFixed(1) + "%";
      } else {
        return "â–ˆ".repeat(barWidth) + "â–‘".repeat(width - barWidth) + " " + (percentage * 100).toFixed(1) + "%";
      }
    } catch (error) {
      return "";
    }
  }

  static generateTrendIndicator(current, previous, threshold = 0.05) {
    try {
      if (previous === 0) return CONFIG.EMOJI.trend_stable;
      
      const change = (current - previous) / previous;
      const indicators = CONFIG.SYSTEM.VISUALIZATION.TREND_INDICATORS;
      const index = Math.min(indicators.length - 1, Math.max(0, 
        Math.floor((change + 0.15) / 0.05)
      ));
      
      return indicators[index];
    } catch (error) {
      return "â†’";
    }
  }
}

// ==============================================================================
// 3. æ¶ˆæ¯ç®¡ç†å™¨
// ==============================================================================

class MessageManager {
  static userMessages = new Map();
  static lastCleanupTime = Date.now();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static deleteUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.delete(messageType);
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
  
  static cleanupOldMessages(chatId, keepCount = 10) {
    try {
      this.initUser(chatId);
      const userMap = this.userMessages.get(chatId);
      
      if (userMap.size <= keepCount) {
        return 0;
      }
      
      const entries = Array.from(userMap.entries());
      const toRemove = entries.slice(0, entries.length - keepCount);
      
      let removed = 0;
      for (const [key, _] of toRemove) {
        if (userMap.delete(key)) {
          removed++;
        }
      }
      
      return removed;
    } catch (error) {
      Logger.error("MessageManager", "æ¸…ç†æ—§æ¶ˆæ¯å¤±è´¥", error);
      return 0;
    }
  }
  
  static autoCleanup() {
    try {
      const now = Date.now();
      if (now - this.lastCleanupTime < CONFIG.SYSTEM.AUTO_CLEANUP_INTERVAL) {
        return;
      }
      
      Logger.info("MessageManager", "å¼€å§‹è‡ªåŠ¨æ¸…ç†ç”¨æˆ·æ¶ˆæ¯ç¼“å­˜");
      
      let totalCleaned = 0;
      
      for (const [chatId, userMap] of this.userMessages.entries()) {
        if (userMap.size > CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_MESSAGES_PER_USER) {
          const cleaned = this.cleanupOldMessages(chatId, 10);
          totalCleaned += cleaned;
        }
      }
      
      this.lastCleanupTime = now;
      
      if (totalCleaned > 0) {
        Logger.info("MessageManager", `è‡ªåŠ¨æ¸…ç†å®Œæˆï¼Œæ¸…ç†äº† ${totalCleaned} æ¡æ¶ˆæ¯`);
      }
      
      if (this.userMessages.size > CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_USERS) {
        const keysToDelete = Array.from(this.userMessages.keys())
          .slice(0, this.userMessages.size - CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_USERS);
        
        keysToDelete.forEach(key => this.userMessages.delete(key));
        Logger.info("MessageManager", `æ¸…ç†äº† ${keysToDelete.length} ä¸ªä¸æ´»è·ƒç”¨æˆ·`);
      }
      
    } catch (error) {
      Logger.error("MessageManager", "è‡ªåŠ¨æ¸…ç†å¤±è´¥", error);
    }
  }
}

// ==============================================================================
// 4. ç¼“å­˜ç®¡ç†å™¨
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "è®¾ç½®ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
  
  static getStats() {
    try {
      const now = Date.now();
      let validCount = 0;
      let expiredCount = 0;
      
      for (const [_, item] of this.cache) {
        if (now > item.expireAt) {
          expiredCount++;
        } else {
          validCount++;
        }
      }
      
      return {
        total: this.cache.size,
        valid: validCount,
        expired: expiredCount
      };
    } catch (error) {
      return { total: 0, valid: 0, expired: 0 };
    }
  }
}

// ==============================================================================
// 5. æ•°æ®åº“æ“ä½œå±‚ï¼ˆæ–°å¢ç”¨æˆ·ä¸ªæ€§åŒ–è¡¨ï¼‰
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE INDEX IF NOT EXISTS idx_history_created_at ON lottery_history (created_at DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_deletion_log_created_at ON deletion_log (created_at DESC)`,
        `CREATE TABLE IF NOT EXISTS montecarlo_results (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          simulation_id TEXT,
          simulations INTEGER,
          sample_type TEXT,
          special_numbers TEXT,
          normal_numbers TEXT,
          confidence REAL,
          duration_ms INTEGER,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_montecarlo_created_at ON montecarlo_results (created_at DESC)`,
        `CREATE INDEX IF NOT EXISTS idx_montecarlo_simulation_id ON montecarlo_results (simulation_id)`,
        
        // æ–°å¢ï¼šç”¨æˆ·ä¸ªæ€§åŒ–ç›¸å…³è¡¨
        `CREATE TABLE IF NOT EXISTS user_feedback (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id TEXT,
          expect TEXT,
          algorithm_used TEXT,
          feedback_score INTEGER,
          feedback_text TEXT,
          predicted_numbers TEXT,
          actual_numbers TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_user_feedback_user_id ON user_feedback (user_id)`,
        `CREATE INDEX IF NOT EXISTS idx_user_feedback_created_at ON user_feedback (created_at DESC)`,
        `CREATE TABLE IF NOT EXISTS user_preferences (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id TEXT UNIQUE,
          algorithm_weights TEXT,
          preferred_zodiacs TEXT,
          preferred_colors TEXT,
          preferred_tails TEXT,
          preferred_size TEXT,
          preferred_odd_even TEXT,
          preferred_number_range TEXT,
          feedback_count INTEGER DEFAULT 0,
          accuracy_score REAL DEFAULT 0,
          last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_user_preferences_user_id ON user_preferences (user_id)`,
        `CREATE TABLE IF NOT EXISTS user_behavior (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id TEXT,
          action_type TEXT,
          action_data TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_user_behavior_user_id ON user_behavior (user_id)`,
        `CREATE INDEX IF NOT EXISTS idx_user_behavior_created_at ON user_behavior (created_at DESC)`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  checkExpectExists: async function(env, expect) {
    try {
      if (!expect) return false;
      
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(Formatter.safeString(expect)).first();
      
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code &&
          Formatter.isValidExpect(record.expect.toString())
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          weights = { ...defaultWeights, ...parsed };
          
          if (!weights.w_monte_carlo) {
            weights.w_monte_carlo = 2.5;
          }
          
          weights._version = weights._version || "12.4";
        } catch (parseError) {
          Logger.error("DB", "è§£ææƒé‡è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤", parseError);
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0",
        "TOTAL_MONTE": "0",
        "MONTE_SAMPLE_TYPE": "full_history",
        "TOTAL_FEEDBACK": "0",
        "AVERAGE_FEEDBACK_SCORE": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  getDeletionStats: async function(env) {
    try {
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM deletion_log"
      ).first();
      
      const recordsResult = await env.DB.prepare(
        "SELECT SUM(deleted_count) as total FROM deletion_log"
      ).first();
      
      const recentResult = await env.DB.prepare(
        "SELECT created_at FROM deletion_log ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalDeletions: totalResult ? totalResult.count : 0,
        totalRecordsDeleted: recordsResult ? (recordsResult.total || 0) : 0,
        lastDeletion: recentResult ? recentResult.created_at : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionStats failed", e);
      return {
        totalDeletions: 0,
        totalRecordsDeleted: 0,
        lastDeletion: null
      };
    }
  },

  // ============================================================================
  // ç”¨æˆ·ä¸ªæ€§åŒ–ç›¸å…³æ–¹æ³•
  // ============================================================================

  saveUserFeedback: async function(env, userId, feedbackData) {
    try {
      const { expect, algorithmUsed, feedbackScore, feedbackText, predictedNumbers, actualNumbers } = feedbackData;
      
      const result = await env.DB.prepare(
        `INSERT INTO user_feedback 
        (user_id, expect, algorithm_used, feedback_score, feedback_text, predicted_numbers, actual_numbers) 
        VALUES (?, ?, ?, ?, ?, ?, ?)`
      ).bind(
        Formatter.safeString(userId),
        Formatter.safeString(expect),
        Formatter.safeString(algorithmUsed),
        Formatter.safeInt(feedbackScore, 0),
        Formatter.safeString(feedbackText),
        JSON.stringify(predictedNumbers || []),
        Formatter.safeString(actualNumbers)
      ).run();
      
      // æ›´æ–°å…¨å±€åé¦ˆç»Ÿè®¡
      const totalFeedback = Formatter.safeInt(await this.getSetting(env, "TOTAL_FEEDBACK", "0"), 0) + 1;
      await this.saveSetting(env, "TOTAL_FEEDBACK", totalFeedback.toString());
      
      // æ›´æ–°ç”¨æˆ·åå¥½
      await this.updateUserPreferences(env, userId, feedbackData);
      
      Logger.info("DB", `ç”¨æˆ·åé¦ˆå·²ä¿å­˜: userId=${userId}, score=${feedbackScore}`);
      
      return { success: true, id: result.lastInsertId };
    } catch (e) {
      Logger.error("DB", "ä¿å­˜ç”¨æˆ·åé¦ˆå¤±è´¥", e);
      return { success: false, error: e.message };
    }
  },

  getUserFeedback: async function(env, userId, limit = 20) {
    try {
      const { results } = await env.DB.prepare(
        `SELECT * FROM user_feedback 
         WHERE user_id = ? 
         ORDER BY created_at DESC 
         LIMIT ?`
      ).bind(Formatter.safeString(userId), limit).all();
      
      return results || [];
    } catch (e) {
      Logger.error("DB", "è·å–ç”¨æˆ·åé¦ˆå¤±è´¥", e);
      return [];
    }
  },

  getUserFeedbackStats: async function(env, userId) {
    try {
      const result = await env.DB.prepare(
        `SELECT 
          COUNT(*) as total_feedback,
          AVG(feedback_score) as avg_score,
          COUNT(CASE WHEN feedback_score >= 4 THEN 1 END) as positive_count,
          COUNT(CASE WHEN feedback_score <= 2 THEN 1 END) as negative_count,
          MIN(created_at) as first_feedback,
          MAX(created_at) as last_feedback
         FROM user_feedback 
         WHERE user_id = ?`
      ).bind(Formatter.safeString(userId)).first();
      
      return {
        totalFeedback: result?.total_feedback || 0,
        averageScore: result?.avg_score || 0,
        positiveCount: result?.positive_count || 0,
        negativeCount: result?.negative_count || 0,
        firstFeedback: result?.first_feedback,
        lastFeedback: result?.last_feedback
      };
    } catch (e) {
      Logger.error("DB", "è·å–ç”¨æˆ·åé¦ˆç»Ÿè®¡å¤±è´¥", e);
      return {
        totalFeedback: 0,
        averageScore: 0,
        positiveCount: 0,
        negativeCount: 0
      };
    }
  },

  getUserPreferences: async function(env, userId) {
    try {
      const result = await env.DB.prepare(
        "SELECT * FROM user_preferences WHERE user_id = ?"
      ).bind(Formatter.safeString(userId)).first();
      
      if (!result) {
        // åˆ›å»ºé»˜è®¤ç”¨æˆ·åå¥½
        const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        return {
          user_id: userId,
          algorithm_weights: JSON.stringify(defaultWeights),
          preferred_zodiacs: null,
          preferred_colors: null,
          preferred_tails: null,
          preferred_size: null,
          preferred_odd_even: null,
          preferred_number_range: null,
          feedback_count: 0,
          accuracy_score: 0,
          last_updated: new Date().toISOString()
        };
      }
      
      return result;
    } catch (e) {
      Logger.error("DB", "è·å–ç”¨æˆ·åå¥½å¤±è´¥", e);
      return null;
    }
  },

  saveUserPreferences: async function(env, userId, preferences) {
    try {
      const existing = await this.getUserPreferences(env, userId);
      
      if (existing && existing.user_id) {
        // æ›´æ–°ç°æœ‰åå¥½
        const result = await env.DB.prepare(
          `UPDATE user_preferences 
           SET algorithm_weights = ?,
               preferred_zodiacs = ?,
               preferred_colors = ?,
               preferred_tails = ?,
               preferred_size = ?,
               preferred_odd_even = ?,
               preferred_number_range = ?,
               feedback_count = ?,
               accuracy_score = ?,
               last_updated = CURRENT_TIMESTAMP
           WHERE user_id = ?`
        ).bind(
          JSON.stringify(preferences.algorithm_weights || {}),
          JSON.stringify(preferences.preferred_zodiacs || []),
          JSON.stringify(preferences.preferred_colors || []),
          JSON.stringify(preferences.preferred_tails || []),
          Formatter.safeString(preferences.preferred_size),
          Formatter.safeString(preferences.preferred_odd_even),
          JSON.stringify(preferences.preferred_number_range || {}),
          Formatter.safeInt(preferences.feedback_count, 0),
          Formatter.safeInt(preferences.accuracy_score, 0),
          Formatter.safeString(userId)
        ).run();
        
        return { success: true, updated: true };
      } else {
        // æ’å…¥æ–°åå¥½
        const result = await env.DB.prepare(
          `INSERT INTO user_preferences 
           (user_id, algorithm_weights, preferred_zodiacs, preferred_colors, 
            preferred_tails, preferred_size, preferred_odd_even, 
            preferred_number_range, feedback_count, accuracy_score) 
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
        ).bind(
          Formatter.safeString(userId),
          JSON.stringify(preferences.algorithm_weights || {}),
          JSON.stringify(preferences.preferred_zodiacs || []),
          JSON.stringify(preferences.preferred_colors || []),
          JSON.stringify(preferences.preferred_tails || []),
          Formatter.safeString(preferences.preferred_size),
          Formatter.safeString(preferences.preferred_odd_even),
          JSON.stringify(preferences.preferred_number_range || {}),
          Formatter.safeInt(preferences.feedback_count, 0),
          Formatter.safeInt(preferences.accuracy_score, 0)
        ).run();
        
        return { success: true, inserted: true };
      }
    } catch (e) {
      Logger.error("DB", "ä¿å­˜ç”¨æˆ·åå¥½å¤±è´¥", e);
      return { success: false, error: e.message };
    }
  },

  updateUserPreferences: async function(env, userId, feedbackData) {
    try {
      const preferences = await this.getUserPreferences(env, userId);
      const feedbackStats = await this.getUserFeedbackStats(env, userId);
      
      if (!preferences) return;
      
      // åˆ†æé¢„æµ‹ç»“æœï¼Œæå–ç”¨æˆ·åå¥½
      const { predictedNumbers, actualNumbers, feedbackScore } = feedbackData;
      
      // å¦‚æœé¢„æµ‹å‡†ç¡®ï¼Œå¢å¼ºç›¸å…³ç‰¹å¾çš„æƒé‡
      if (feedbackScore >= 4 && predictedNumbers && actualNumbers) {
        const actualNum = Formatter.safeInt(actualNumbers.split(",")[6], 0);
        const predictedNums = Array.isArray(predictedNumbers) ? predictedNumbers : [];
        
        // æ£€æŸ¥å®é™…å·ç æ˜¯å¦åœ¨é¢„æµ‹ä¸­
        const isPredicted = predictedNums.some(p => p.number === actualNum);
        
        if (isPredicted) {
          const attr = Formatter.getAttributes(actualNum);
          const features = Formatter.calculateFeatures(actualNum);
          
          // æ›´æ–°åå¥½
          const newPrefs = { ...preferences };
          
          // æ›´æ–°ç”Ÿè‚–åå¥½
          const zodiacs = JSON.parse(newPrefs.preferred_zodiacs || "[]");
          if (!zodiacs.includes(attr.zodiac)) {
            zodiacs.push(attr.zodiac);
            newPrefs.preferred_zodiacs = JSON.stringify(zodiacs.slice(-5)); // åªä¿ç•™æœ€è¿‘5ä¸ª
          }
          
          // æ›´æ–°é¢œè‰²åå¥½
          const colors = JSON.parse(newPrefs.preferred_colors || "[]");
          if (!colors.includes(attr.color)) {
            colors.push(attr.color);
            newPrefs.preferred_colors = JSON.stringify(colors.slice(-3)); // åªä¿ç•™æœ€è¿‘3ä¸ª
          }
          
          // æ›´æ–°å°¾æ•°åå¥½
          const tails = JSON.parse(newPrefs.preferred_tails || "[]");
          const tail = actualNum % 10;
          if (!tails.includes(tail)) {
            tails.push(tail);
            newPrefs.preferred_tails = JSON.stringify(tails.slice(-5)); // åªä¿ç•™æœ€è¿‘5ä¸ª
          }
          
          // æ›´æ–°å¤§å°åå¥½
          if (features.isBig) {
            newPrefs.preferred_size = "å¤§";
          } else {
            newPrefs.preferred_size = "å°";
          }
          
          // æ›´æ–°å•åŒåå¥½
          if (features.isOdd) {
            newPrefs.preferred_odd_even = "å•";
          } else {
            newPrefs.preferred_odd_even = "åŒ";
          }
          
          // æ›´æ–°ç®—æ³•æƒé‡ï¼ˆæ ¹æ®åé¦ˆåˆ†æ•°ï¼‰
          let algoWeights = {};
          try {
            algoWeights = JSON.parse(newPrefs.algorithm_weights || "{}");
          } catch (e) {
            algoWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          }
          
          // æ ¹æ®åé¦ˆè°ƒæ•´æƒé‡
          const learningRate = CONFIG.SYSTEM.PERSONALIZATION.LEARNING_RATE;
          const adjustment = (feedbackScore - 3) * learningRate;
          
          // å¢åŠ æˆåŠŸç®—æ³•çš„æƒé‡
          const algorithmUsed = feedbackData.algorithmUsed || "traditional";
          switch (algorithmUsed) {
            case "knn":
              algoWeights.w_knn_similarity = Math.min(
                algoWeights.w_knn_similarity * (1 + adjustment),
                algoWeights.w_knn_similarity + CONFIG.SYSTEM.PERSONALIZATION.MAX_WEIGHT_ADJUSTMENT
              );
              break;
            case "stats":
              algoWeights.w_statistics_analysis = Math.min(
                algoWeights.w_statistics_analysis * (1 + adjustment),
                algoWeights.w_statistics_analysis + CONFIG.SYSTEM.PERSONALIZATION.MAX_WEIGHT_ADJUSTMENT
              );
              break;
            case "traditional":
              algoWeights.w_zodiac_transfer = Math.min(
                algoWeights.w_zodiac_transfer * (1 + adjustment),
                algoWeights.w_zodiac_transfer + CONFIG.SYSTEM.PERSONALIZATION.MAX_WEIGHT_ADJUSTMENT
              );
              break;
            case "advanced":
            case "personalized":
              // å¢å¼ºé¢„æµ‹æˆåŠŸï¼Œå¢åŠ å¤šä¸ªç®—æ³•çš„æƒé‡
              algoWeights.w_knn_similarity *= (1 + adjustment * 0.3);
              algoWeights.w_statistics_analysis *= (1 + adjustment * 0.3);
              algoWeights.w_zodiac_transfer *= (1 + adjustment * 0.2);
              algoWeights.w_monte_carlo *= (1 + adjustment * 0.2);
              break;
          }
          
          // ç¡®ä¿æƒé‡ä¸ä¼šè¿‡ä½
          Object.keys(algoWeights).forEach(key => {
            if (!key.startsWith('_')) {
              algoWeights[key] = Math.max(0.1, Math.min(5.0, algoWeights[key]));
            }
          });
          
          newPrefs.algorithm_weights = JSON.stringify(algoWeights);
          newPrefs.feedback_count = feedbackStats.totalFeedback;
          newPrefs.accuracy_score = feedbackStats.averageScore;
          
          // ä¿å­˜æ›´æ–°åçš„åå¥½
          await this.saveUserPreferences(env, userId, newPrefs);
          
          Logger.info("DB", `ç”¨æˆ·åå¥½å·²æ›´æ–°: userId=${userId}, ç®—æ³•æƒé‡å·²è°ƒæ•´`);
        }
      }
    } catch (e) {
      Logger.error("DB", "æ›´æ–°ç”¨æˆ·åå¥½å¤±è´¥", e);
    }
  },

  logUserBehavior: async function(env, userId, actionType, actionData = {}) {
    try {
      await env.DB.prepare(
        `INSERT INTO user_behavior (user_id, action_type, action_data) 
         VALUES (?, ?, ?)`
      ).bind(
        Formatter.safeString(userId),
        Formatter.safeString(actionType),
        JSON.stringify(actionData)
      ).run();
      
      Logger.debug("DB", `ç”¨æˆ·è¡Œä¸ºå·²è®°å½•: userId=${userId}, action=${actionType}`);
      
      return true;
    } catch (e) {
      Logger.error("DB", "è®°å½•ç”¨æˆ·è¡Œä¸ºå¤±è´¥", e);
      return false;
    }
  },

  getUserBehaviorStats: async function(env, userId, days = 30) {
    try {
      const { results } = await env.DB.prepare(
        `SELECT 
          action_type,
          COUNT(*) as count,
          DATE(created_at) as date
         FROM user_behavior 
         WHERE user_id = ? AND created_at > datetime('now', ? || ' days')
         GROUP BY action_type, DATE(created_at)
         ORDER BY date DESC`
      ).bind(Formatter.safeString(userId), `-${days}`).all();
      
      // æŒ‰æ—¥æœŸåˆ†ç»„
      const statsByDate = {};
      const actionTypes = new Set();
      
      results.forEach(row => {
        const date = row.date;
        if (!statsByDate[date]) {
          statsByDate[date] = {};
        }
        statsByDate[date][row.action_type] = row.count;
        actionTypes.add(row.action_type);
      });
      
      // è®¡ç®—æ€»ä½“ç»Ÿè®¡
      const totalStats = {};
      actionTypes.forEach(type => {
        totalStats[type] = results
          .filter(r => r.action_type === type)
          .reduce((sum, r) => sum + r.count, 0);
      });
      
      return {
        dailyStats: statsByDate,
        totalStats: totalStats,
        actionTypes: Array.from(actionTypes),
        daysAnalyzed: Object.keys(statsByDate).length
      };
    } catch (e) {
      Logger.error("DB", "è·å–ç”¨æˆ·è¡Œä¸ºç»Ÿè®¡å¤±è´¥", e);
      return { dailyStats: {}, totalStats: {}, actionTypes: [], daysAnalyzed: 0 };
    }
  },

  getUserPersonalizedWeights: async function(env, userId) {
    try {
      const prefs = await this.getUserPreferences(env, userId);
      
      if (!prefs || prefs.feedback_count < CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION) {
        // åé¦ˆä¸è¶³ï¼Œè¿”å›é»˜è®¤æƒé‡
        return { 
          weights: await this.getWeights(env), 
          isPersonalized: false,
          feedbackCount: prefs?.feedback_count || 0
        };
      }
      
      let personalizedWeights = {};
      try {
        personalizedWeights = JSON.parse(prefs.algorithm_weights || "{}");
      } catch (e) {
        personalizedWeights = await this.getWeights(env);
      }
      
      // ç¡®ä¿æ‰€æœ‰æƒé‡å­—æ®µéƒ½å­˜åœ¨
      const defaultWeights = await this.getWeights(env);
      const finalWeights = { ...defaultWeights, ...personalizedWeights };
      
      // åº”ç”¨ç”¨æˆ·åå¥½æƒé‡åŠ æˆ
      const userWeightMultiplier = 1.0 + (prefs.accuracy_score * 0.1); // å‡†ç¡®ç‡æ¯æé«˜1%ï¼Œæƒé‡åŠ æˆ0.1
      Object.keys(finalWeights).forEach(key => {
        if (!key.startsWith('_') && key !== 'w_user_preference') {
          finalWeights[key] *= userWeightMultiplier;
          // é™åˆ¶æƒé‡èŒƒå›´
          finalWeights[key] = Math.max(0.5, Math.min(5.0, finalWeights[key]));
        }
      });
      
      // æ·»åŠ ç”¨æˆ·åå¥½æƒé‡
      finalWeights.w_user_preference = Math.min(2.0, 1.0 + (prefs.feedback_count * 0.05));
      
      return { 
        weights: finalWeights, 
        isPersonalized: true,
        feedbackCount: prefs.feedback_count,
        accuracyScore: prefs.accuracy_score,
        preferences: {
          zodiacs: JSON.parse(prefs.preferred_zodiacs || "[]"),
          colors: JSON.parse(prefs.preferred_colors || "[]"),
          tails: JSON.parse(prefs.preferred_tails || "[]"),
          size: prefs.preferred_size,
          oddEven: prefs.preferred_odd_even
        }
      };
    } catch (e) {
      Logger.error("DB", "è·å–ç”¨æˆ·ä¸ªæ€§åŒ–æƒé‡å¤±è´¥", e);
      return { 
        weights: await this.getWeights(env), 
        isPersonalized: false,
        feedbackCount: 0
      };
    }
  },

  getSystemFeedbackStats: async function(env) {
    try {
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM user_feedback"
      ).first();
      
      const scoreResult = await env.DB.prepare(
        "SELECT AVG(feedback_score) as avg_score FROM user_feedback"
      ).first();
      
      const algorithmResult = await env.DB.prepare(
        `SELECT algorithm_used, COUNT(*) as count, AVG(feedback_score) as avg_score
         FROM user_feedback 
         GROUP BY algorithm_used`
      ).all();
      
      const recentResult = await env.DB.prepare(
        `SELECT 
          DATE(created_at) as date,
          COUNT(*) as count,
          AVG(feedback_score) as avg_score
         FROM user_feedback 
         WHERE created_at > datetime('now', '-30 days')
         GROUP BY DATE(created_at)
         ORDER BY date DESC`
      ).all();
      
      return {
        totalFeedback: totalResult?.count || 0,
        averageScore: scoreResult?.avg_score || 0,
        byAlgorithm: algorithmResult?.results || [],
        recentStats: recentResult?.results || []
      };
    } catch (e) {
      Logger.error("DB", "è·å–ç³»ç»Ÿåé¦ˆç»Ÿè®¡å¤±è´¥", e);
      return {
        totalFeedback: 0,
        averageScore: 0,
        byAlgorithm: [],
        recentStats: []
      };
    }
  }
};

// ==============================================================================
// 6. KNNç®—æ³•å®ç°
// ==============================================================================

class KNNAlgorithm {
  static findSimilarRecords(history, currentRecord, k = CONFIG.SYSTEM.KNN_K_VALUE) {
    try {
      if (!history || !Array.isArray(history) || history.length < 10 || !currentRecord) {
        return [];
      }
      
      const currentFeatures = this.extractFeatures(currentRecord);
      if (!currentFeatures) return [];
      
      const distances = [];
      
      const recentHistory = history.slice(0, Math.min(100, history.length));
      
      for (let i = 1; i < recentHistory.length; i++) {
        const record = recentHistory[i];
        if (!record || !record.open_code) continue;
        
        const recordFeatures = this.extractFeatures(record);
        if (!recordFeatures) continue;
        
        const distance = this.calculateDistance(currentFeatures, recordFeatures);
        const nextRecord = recentHistory[i - 1];
        
        if (nextRecord && nextRecord.open_code) {
          distances.push({
            record: nextRecord,
            distance: distance,
            similarity: 1 / (1 + distance)
          });
        }
      }
      
      distances.sort((a, b) => a.distance - b.distance);
      
      return distances.slice(0, k);
    } catch (error) {
      Logger.error("KNN", "å¯»æ‰¾ç›¸ä¼¼è®°å½•å¤±è´¥", error);
      return [];
    }
  }
  
  static extractFeatures(record) {
    try {
      if (!record || !record.open_code) return null;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (numbers.length < 7) return null;
      
      const special = numbers[6] || 1;
      const normals = numbers.slice(0, 6);
      
      const specialAttr = Formatter.getAttributes(special);
      const specialFeatures = Formatter.calculateFeatures(special);
      
      const normalFeatures = {
        zodiacCount: {},
        colorCount: {},
        tailCount: {},
        headCount: {},
        sizeCount: { big: 0, small: 0 },
        oddEvenCount: { odd: 0, even: 0 }
      };
      
      for (const num of normals) {
        const attr = Formatter.getAttributes(num);
        const features = Formatter.calculateFeatures(num);
        
        normalFeatures.zodiacCount[attr.zodiac] = (normalFeatures.zodiacCount[attr.zodiac] || 0) + 1;
        normalFeatures.colorCount[attr.color] = (normalFeatures.colorCount[attr.color] || 0) + 1;
        
        const tail = num % 10;
        normalFeatures.tailCount[tail] = (normalFeatures.tailCount[tail] || 0) + 1;
        
        const head = Math.floor(num / 10);
        normalFeatures.headCount[head] = (normalFeatures.headCount[head] || 0) + 1;
        
        if (num >= 25) {
          normalFeatures.sizeCount.big++;
        } else {
          normalFeatures.sizeCount.small++;
        }
        
        if (num % 2 !== 0) {
          normalFeatures.oddEvenCount.odd++;
        } else {
          normalFeatures.oddEvenCount.even++;
        }
      }
      
      return {
        special: specialFeatures,
        normals: normalFeatures,
        specialAttr: specialAttr,
        numbers: numbers
      };
    } catch (error) {
      Logger.error("KNN", "æå–ç‰¹å¾å¤±è´¥", error);
      return null;
    }
  }
  
  static calculateDistance(features1, features2) {
    try {
      let distance = 0;
      
      const f1 = features1.special;
      const f2 = features2.special;
      
      if (f1 && f2) {
        if (f1.zodiac === f2.zodiac) {
          distance -= 3;
        } else {
          distance += 1;
        }
        
        if (f1.color === f2.color) {
          distance -= 2;
        } else {
          distance += 0.5;
        }
        
        const tailDiff = Math.abs(f1.tail - f2.tail);
        distance += tailDiff * 0.1;
        
        const headDiff = Math.abs(f1.head - f2.head);
        distance += headDiff * 0.2;
        
        if (f1.isBig !== f2.isBig) {
          distance += 0.5;
        }
        
        if (f1.isOdd !== f2.isOdd) {
          distance += 0.5;
        }
      }
      
      const nf1 = features1.normals;
      const nf2 = features2.normals;
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      for (const zodiac of allZodiacs) {
        const count1 = nf1.zodiacCount[zodiac] || 0;
        const count2 = nf2.zodiacCount[zodiac] || 0;
        distance += Math.abs(count1 - count2) * 0.3;
      }
      
      const colors = ['red', 'blue', 'green'];
      for (const color of colors) {
        const count1 = nf1.colorCount[color] || 0;
        const count2 = nf2.colorCount[color] || 0;
        distance += Math.abs(count1 - count2) * 0.2;
      }
      
      for (let i = 0; i <= 9; i++) {
        const count1 = nf1.tailCount[i] || 0;
        const count2 = nf2.tailCount[i] || 0;
        distance += Math.abs(count1 - count2) * 0.1;
      }
      
      for (let i = 0; i <= 4; i++) {
        const count1 = nf1.headCount[i] || 0;
        const count2 = nf2.headCount[i] || 0;
        distance += Math.abs(count1 - count2) * 0.15;
      }
      
      distance += Math.abs(nf1.sizeCount.big - nf2.sizeCount.big) * 0.2;
      distance += Math.abs(nf1.sizeCount.small - nf2.sizeCount.small) * 0.2;
      
      distance += Math.abs(nf1.oddEvenCount.odd - nf2.oddEvenCount.odd) * 0.1;
      distance += Math.abs(nf1.oddEvenCount.even - nf2.oddEvenCount.even) * 0.1;
      
      return distance;
    } catch (error) {
      Logger.error("KNN", "è®¡ç®—è·ç¦»å¤±è´¥", error);
      return 1000;
    }
  }
  
  static predictFromSimilarRecords(similarRecords) {
    try {
      if (!similarRecords || similarRecords.length === 0) {
        return null;
      }
      
      const predictions = {
        specialNumbers: {},
        zodiacCount: {},
        colorCount: {},
        tailCount: {},
        headCount: {},
        sizeCount: { big: 0, small: 0 },
        oddEvenCount: { odd: 0, even: 0 },
        normalNumbers: {}
      };
      
      for (const item of similarRecords) {
        const record = item.record;
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6] || 1;
        const normals = numbers.slice(0, 6);
        
        predictions.specialNumbers[special] = (predictions.specialNumbers[special] || 0) + item.similarity;
        
        const specialAttr = Formatter.getAttributes(special);
        const specialFeatures = Formatter.calculateFeatures(special);
        
        if (specialAttr.zodiac) {
          predictions.zodiacCount[specialAttr.zodiac] = (predictions.zodiacCount[specialAttr.zodiac] || 0) + item.similarity;
        }
        
        if (specialAttr.color) {
          predictions.colorCount[specialAttr.color] = (predictions.colorCount[specialAttr.color] || 0) + item.similarity;
        }
        
        if (specialFeatures) {
          const tail = specialFeatures.tail;
          predictions.tailCount[tail] = (predictions.tailCount[tail] || 0) + item.similarity;
          
          const head = specialFeatures.head;
          predictions.headCount[head] = (predictions.headCount[head] || 0) + item.similarity;
          
          if (specialFeatures.isBig) {
            predictions.sizeCount.big += item.similarity;
          } else {
            predictions.sizeCount.small += item.similarity;
          }
          
          if (specialFeatures.isOdd) {
            predictions.oddEvenCount.odd += item.similarity;
          } else {
            predictions.oddEvenCount.even += item.similarity;
          }
        }
        
        for (const num of normals) {
          predictions.normalNumbers[num] = (predictions.normalNumbers[num] || 0) + item.similarity * 0.5;
        }
      }
      
      const result = {
        specialCandidates: this.getTopCandidates(predictions.specialNumbers, 10),
        zodiacCandidates: this.getTopCandidates(predictions.zodiacCount, 5),
        colorCandidates: this.getTopCandidates(predictions.colorCount, 3),
        tailCandidates: this.getTopCandidates(predictions.tailCount, 5),
        headCandidates: this.getTopCandidates(predictions.headCount, 3),
        sizePrediction: predictions.sizeCount.big > predictions.sizeCount.small ? "å¤§" : "å°",
        oddEvenPrediction: predictions.oddEvenCount.odd > predictions.oddEvenCount.even ? "å•" : "åŒ",
        normalCandidates: this.getTopCandidates(predictions.normalNumbers, 12)
      };
      
      return result;
    } catch (error) {
      Logger.error("KNN", "ä»ç›¸ä¼¼è®°å½•é¢„æµ‹å¤±è´¥", error);
      return null;
    }
  }
  
  static getTopCandidates(candidates, limit) {
    try {
      return Object.entries(candidates)
        .map(([key, value]) => ({
          value: key,
          score: value
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, limit)
        .map(item => ({
          value: isNaN(item.value) ? item.value : Formatter.safeInt(item.value),
          score: item.score
        }));
    } catch (error) {
      return [];
    }
  }
}

// ==============================================================================
// 7. å¢å¼ºçš„ç»Ÿè®¡ç®—æ³•
// ==============================================================================

class EnhancedStatistics {
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        return this.createEmptyStats();
      }

      const stats = this.createEmptyStats();
      const maxRecords = Math.min(history.length, CONFIG.SYSTEM.STATS_WINDOW_SIZE);
      const historySlice = history.slice(0, maxRecords);
      
      const processedHistory = this.processHistoryData(historySlice);
      
      if (processedHistory.length < 5) {
        return this.createEmptyStats();
      }
      
      this.analyzeZodiacPatterns(stats, processedHistory);
      this.analyzeColorPatterns(stats, processedHistory);
      this.analyzeTailPatterns(stats, processedHistory);
      this.analyzeHeadPatterns(stats, processedHistory);
      this.analyzeSizePatterns(stats, processedHistory);
      this.analyzeOddEvenPatterns(stats, processedHistory);
      this.analyzeNormalToSpecialPatterns(stats, processedHistory);
      
      this.calculateFrequencies(stats, processedHistory);
      
      stats.totalRecords = processedHistory.length;
      
      stats.summary = this.generateSummary(stats);
      
      return stats;
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå†å²æ•°æ®æ—¶å‡ºé”™", error);
      return this.createEmptyStats();
    }
  }

  static processHistoryData(history) {
    const processed = [];
    
    for (const record of history) {
      if (record && record.open_code) {
        const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (nums.length >= 7) {
          const special = nums[6] || 1;
          const normals = nums.slice(0, 6);
          const attr = Formatter.getAttributes(special);
          const features = Formatter.calculateFeatures(special);
          
          const normalFeatures = {
            zodiacs: normals.map(n => Formatter.getAttributes(n).zodiac),
            colors: normals.map(n => Formatter.getAttributes(n).color),
            tails: normals.map(n => n % 10),
            heads: normals.map(n => Math.floor(n / 10)),
            sizes: normals.map(n => n >= 25 ? "å¤§" : "å°"),
            oddEven: normals.map(n => n % 2 !== 0 ? "å•" : "åŒ")
          };
          
          processed.push({
            numbers: nums,
            special: special,
            normals: normals,
            zodiac: attr.zodiac,
            color: attr.color,
            tail: special % 10,
            head: Math.floor(special / 10),
            size: special >= 25 ? "å¤§" : "å°",
            oddEven: special % 2 !== 0 ? "å•" : "åŒ",
            features: features,
            normalFeatures: normalFeatures,
            expect: record.expect
          });
        }
      }
    }
    
    return processed;
  }

  static createEmptyStats() {
    return {
      totalRecords: 0,
      zodiacPatterns: {
        sameZodiac: {},
        zodiacGap: {},
        consecutiveZodiac: {},
        zodiacCombinations: {}
      },
      colorPatterns: {
        sameColor: {},
        colorGap: {},
        consecutiveColor: {}
      },
      tailPatterns: {
        tailTransfer: {},
        tailFromNormal: {},
        tailGap: {},
        consecutiveTail: {}
      },
      headPatterns: {
        headTransfer: {},
        headGap: {},
        consecutiveHead: {}
      },
      sizePatterns: {
        sizeTransfer: {},
        sizeGap: {},
        consecutiveSize: {},
        sizeRatio: { big: 0, small: 0 }
      },
      oddEvenPatterns: {
        oddEvenTransfer: {},
        oddEvenGap: {},
        consecutiveOddEven: {},
        oddEvenRatio: { odd: 0, even: 0 }
      },
      normalToSpecial: {
        tailInNormals: {},
        zodiacInNormals: {},
        colorInNormals: {},
        numberInNormals: {}
      },
      frequencies: {
        specialFrequency: {},
        normalFrequency: {},
        zodiacFrequency: {},
        colorFrequency: {},
        tailFrequency: {},
        headFrequency: {},
        sizeFrequency: {},
        oddEvenFrequency: {}
      },
      summary: {}
    };
  }

  static analyzeZodiacPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const key = `${current.zodiac}->${next.zodiac}`;
        stats.zodiacPatterns.sameZodiac[key] = (stats.zodiacPatterns.sameZodiac[key] || 0) + 1;
        
        if (current.zodiac === next.zodiac) {
          stats.zodiacPatterns.consecutiveZodiac[current.zodiac] = (stats.zodiacPatterns.consecutiveZodiac[current.zodiac] || 0) + 1;
        }
        
        for (const normalZodiac of current.normalFeatures.zodiacs) {
          const comboKey = `${normalZodiac}->${next.zodiac}`;
          stats.zodiacPatterns.zodiacCombinations[comboKey] = (stats.zodiacPatterns.zodiacCombinations[comboKey] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.zodiacPatterns.sameZodiac);
      this.calculateProbabilities(stats.zodiacPatterns.zodiacCombinations);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æç”Ÿè‚–æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeColorPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const key = `${current.color}->${next.color}`;
        stats.colorPatterns.sameColor[key] = (stats.colorPatterns.sameColor[key] || 0) + 1;
        
        if (current.color === next.color) {
          stats.colorPatterns.consecutiveColor[current.color] = (stats.colorPatterns.consecutiveColor[current.color] || 0) + 1;
        }
        
        for (const normalColor of current.normalFeatures.colors) {
          const comboKey = `${normalColor}->${next.color}`;
          stats.normalToSpecial.colorInNormals[comboKey] = (stats.normalToSpecial.colorInNormals[comboKey] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.colorPatterns.sameColor);
      this.calculateProbabilities(stats.normalToSpecial.colorInNormals);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æé¢œè‰²æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeTailPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const tailKey = `${current.tail}->${next.tail}`;
        stats.tailPatterns.tailTransfer[tailKey] = (stats.tailPatterns.tailTransfer[tailKey] || 0) + 1;
        
        for (const normalTail of current.normalFeatures.tails) {
          const tailFromNormalKey = `${normalTail}->${next.tail}`;
          stats.tailPatterns.tailFromNormal[tailFromNormalKey] = (stats.tailPatterns.tailFromNormal[tailFromNormalKey] || 0) + 1;
          
          stats.normalToSpecial.tailInNormals[normalTail] = (stats.normalToSpecial.tailInNormals[normalTail] || 0) + 1;
        }
        
        if (current.tail === next.tail) {
          stats.tailPatterns.consecutiveTail[current.tail] = (stats.tailPatterns.consecutiveTail[current.tail] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.tailPatterns.tailTransfer);
      this.calculateProbabilities(stats.tailPatterns.tailFromNormal);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå°¾æ•°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeHeadPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const headKey = `${current.head}->${next.head}`;
        stats.headPatterns.headTransfer[headKey] = (stats.headPatterns.headTransfer[headKey] || 0) + 1;
        
        if (current.head === next.head) {
          stats.headPatterns.consecutiveHead[current.head] = (stats.headPatterns.consecutiveHead[current.head] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.headPatterns.headTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå¤´æ•°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeSizePatterns(stats, processedHistory) {
    try {
      let bigCount = 0;
      let smallCount = 0;
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        if (current.size === "å¤§") bigCount++;
        else smallCount++;
        
        const sizeKey = `${current.size}->${next.size}`;
        stats.sizePatterns.sizeTransfer[sizeKey] = (stats.sizePatterns.sizeTransfer[sizeKey] || 0) + 1;
        
        if (current.size === next.size) {
          stats.sizePatterns.consecutiveSize[current.size] = (stats.sizePatterns.consecutiveSize[current.size] || 0) + 1;
        }
      }
      
      stats.sizePatterns.sizeRatio = {
        big: bigCount / processedHistory.length,
        small: smallCount / processedHistory.length
      };
      
      this.calculateProbabilities(stats.sizePatterns.sizeTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå¤§å°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeOddEvenPatterns(stats, processedHistory) {
    try {
      let oddCount = 0;
      let evenCount = 0;
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        if (current.oddEven === "å•") oddCount++;
        else evenCount++;
        
        const oddEvenKey = `${current.oddEven}->${next.oddEven}`;
        stats.oddEvenPatterns.oddEvenTransfer[oddEvenKey] = (stats.oddEvenPatterns.oddEvenTransfer[oddEvenKey] || 0) + 1;
        
        if (current.oddEven === next.oddEven) {
          stats.oddEvenPatterns.consecutiveOddEven[current.oddEven] = (stats.oddEvenPatterns.consecutiveOddEven[current.oddEven] || 0) + 1;
        }
      }
      
      stats.oddEvenPatterns.oddEvenRatio = {
        odd: oddCount / processedHistory.length,
        even: evenCount / processedHistory.length
      };
      
      this.calculateProbabilities(stats.oddEvenPatterns.oddEvenTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå•åŒæ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeNormalToSpecialPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        for (const normalNum of current.normals) {
          if (normalNum === next.special) {
            stats.normalToSpecial.numberInNormals[normalNum] = (stats.normalToSpecial.numberInNormals[normalNum] || 0) + 1;
          }
        }
        
        for (const normalZodiac of current.normalFeatures.zodiacs) {
          if (normalZodiac === next.zodiac) {
            stats.normalToSpecial.zodiacInNormals[normalZodiac] = (stats.normalToSpecial.zodiacInNormals[normalZodiac] || 0) + 1;
          }
        }
      }
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå¹³ç åˆ°ç‰¹ç æ¨¡å¼å¤±è´¥", error);
    }
  }

  static calculateFrequencies(stats, processedHistory) {
    try {
      for (let i = 1; i <= 49; i++) {
        stats.frequencies.specialFrequency[i] = 0;
        stats.frequencies.normalFrequency[i] = 0;
      }
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        stats.frequencies.zodiacFrequency[zodiac] = 0;
      });
      
      ['red', 'blue', 'green'].forEach(color => {
        stats.frequencies.colorFrequency[color] = 0;
      });
      
      for (let i = 0; i <= 9; i++) {
        stats.frequencies.tailFrequency[i] = 0;
      }
      
      for (let i = 0; i <= 4; i++) {
        stats.frequencies.headFrequency[i] = 0;
      }
      
      stats.frequencies.sizeFrequency = { å¤§: 0, å°: 0 };
      stats.frequencies.oddEvenFrequency = { å•: 0, åŒ: 0 };
      
      for (const record of processedHistory) {
        stats.frequencies.specialFrequency[record.special]++;
        
        for (const num of record.normals) {
          stats.frequencies.normalFrequency[num]++;
        }
        
        stats.frequencies.zodiacFrequency[record.zodiac]++;
        stats.frequencies.colorFrequency[record.color]++;
        stats.frequencies.tailFrequency[record.tail]++;
        stats.frequencies.headFrequency[record.head]++;
        stats.frequencies.sizeFrequency[record.size]++;
        stats.frequencies.oddEvenFrequency[record.oddEven]++;
      }
      
      const total = processedHistory.length;
      for (let i = 1; i <= 49; i++) {
        stats.frequencies.specialFrequency[i] /= total;
        stats.frequencies.normalFrequency[i] /= (total * 6);
      }
      
      Object.keys(stats.frequencies.zodiacFrequency).forEach(zodiac => {
        stats.frequencies.zodiacFrequency[zodiac] /= total;
      });
      
      Object.keys(stats.frequencies.colorFrequency).forEach(color => {
        stats.frequencies.colorFrequency[color] /= total;
      });
      
      Object.keys(stats.frequencies.sizeFrequency).forEach(size => {
        stats.frequencies.sizeFrequency[size] /= total;
      });
      
      Object.keys(stats.frequencies.oddEvenFrequency).forEach(oe => {
        stats.frequencies.oddEvenFrequency[oe] /= total;
      });
    } catch (error) {
      Logger.error("EnhancedStatistics", "è®¡ç®—é¢‘ç‡å¤±è´¥", error);
    }
  }

  static calculateProbabilities(patternMap) {
    try {
      const totals = {};
      
      Object.keys(patternMap).forEach(key => {
        const [from] = key.split('->');
        totals[from] = (totals[from] || 0) + patternMap[key];
      });
      
      Object.keys(patternMap).forEach(key => {
        const [from] = key.split('->');
        if (totals[from] > 0) {
          patternMap[key] = patternMap[key] / totals[from];
        }
      });
    } catch (error) {
      Logger.error("EnhancedStatistics", "è®¡ç®—æ¦‚ç‡å¤±è´¥", error);
    }
  }

  static generateSummary(stats) {
    const summary = {
      strongPatterns: [],
      recommendations: [],
      statistics: {}
    };
    
    try {
      const topZodiacTransfers = Object.entries(stats.zodiacPatterns.sameZodiac)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      topZodiacTransfers.forEach(([key, prob]) => {
        if (prob > 0.2) {
          const [from, to] = key.split('->');
          summary.strongPatterns.push(`ä¸ŠæœŸå¼€${from}ï¼Œä¸‹æœŸå¼€${to}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
          summary.recommendations.push(`ä¸ŠæœŸ${from}ï¼Œé‡ç‚¹å…³æ³¨${to}`);
        }
      });
      
      const topColorTransfers = Object.entries(stats.colorPatterns.sameColor)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2);
      
      topColorTransfers.forEach(([key, prob]) => {
        if (prob > 0.3) {
          const [from, to] = key.split('->');
          summary.strongPatterns.push(`${from}è‰²è½¬åˆ°${to}è‰²çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        }
      });
      
      const topTailFromNormal = Object.entries(stats.tailPatterns.tailFromNormal)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      topTailFromNormal.forEach(([key, prob]) => {
        if (prob > 0.15) {
          const [normalTail, specialTail] = key.split('->');
          summary.strongPatterns.push(`å¹³ç å°¾${normalTail}æå¤§å¯èƒ½ä¸‹æœŸç‰¹ç å°¾${specialTail} (${(prob * 100).toFixed(1)}%)`);
          summary.recommendations.push(`å…³æ³¨å¹³ç å°¾æ•°${normalTail}å¯¹åº”çš„ç‰¹ç å°¾æ•°${specialTail}`);
        }
      });
      
      summary.statistics.sizeRatio = {
        big: (stats.sizePatterns.sizeRatio.big * 100).toFixed(1) + '%',
        small: (stats.sizePatterns.sizeRatio.small * 100).toFixed(1) + '%'
      };
      
      summary.statistics.oddEvenRatio = {
        odd: (stats.oddEvenPatterns.oddEvenRatio.odd * 100).toFixed(1) + '%',
        even: (stats.oddEvenPatterns.oddEvenRatio.even * 100).toFixed(1) + '%'
      };
      
      const topTails = Object.entries(stats.frequencies.tailFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([tail, prob]) => ({ tail, prob: prob * 100 }));
      
      if (topTails.length > 0) {
        summary.statistics.topTails = topTails;
        summary.recommendations.push(`å¸¸è§å°¾æ•°: ${topTails.map(t => t.tail).join(', ')}`);
      }
      
      const topHeads = Object.entries(stats.frequencies.headFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2)
        .map(([head, prob]) => ({ head, prob: prob * 100 }));
      
      if (topHeads.length > 0) {
        summary.statistics.topHeads = topHeads;
      }
      
      const hotNumbers = Object.entries(stats.frequencies.specialFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, prob]) => ({ number: parseInt(num), prob: prob * 100 }));
      
      if (hotNumbers.length > 0) {
        summary.statistics.hotNumbers = hotNumbers;
        summary.recommendations.push(`çƒ­é—¨å·ç : ${hotNumbers.map(n => n.number).join(', ')}`);
      }
      
      const coldNumbers = Object.entries(stats.frequencies.specialFrequency)
        .sort((a, b) => a[1] - b[1])
        .slice(0, 5)
        .map(([num, prob]) => ({ number: parseInt(num), prob: prob * 100 }));
      
      if (coldNumbers.length > 0) {
        summary.statistics.coldNumbers = coldNumbers;
      }
      
    } catch (error) {
      Logger.error("EnhancedStatistics", "ç”Ÿæˆç»Ÿè®¡æ‘˜è¦å¤±è´¥", error);
    }
    
    return summary;
  }

  static getPredictionFromStatistics(stats, lastRecord) {
    try {
      if (!stats || !lastRecord) {
        return null;
      }
      
      const prediction = {
        specialNumbers: [],
        zodiacRecommendations: [],
        colorRecommendations: [],
        tailRecommendations: [],
        headRecommendations: [],
        sizePrediction: "",
        oddEvenPrediction: "",
        analysis: []
      };
      
      const lastZodiac = lastRecord.zodiac;
      const lastColor = lastRecord.color;
      const lastTail = lastRecord.tail;
      const lastHead = lastRecord.head;
      const lastSize = lastRecord.size;
      const lastOddEven = lastRecord.oddEven;
      
      if (stats.zodiacPatterns.sameZodiac) {
        const zodiacKeys = Object.keys(stats.zodiacPatterns.sameZodiac)
          .filter(key => key.startsWith(`${lastZodiac}->`))
          .sort((a, b) => stats.zodiacPatterns.sameZodiac[b] - stats.zodiacPatterns.sameZodiac[a])
          .slice(0, 3);
        
        zodiacKeys.forEach(key => {
          const toZodiac = key.split('->')[1];
          const prob = stats.zodiacPatterns.sameZodiac[key];
          
          prediction.zodiacRecommendations.push({
            zodiac: toZodiac,
            probability: prob,
            reason: `ä¸ŠæœŸå¼€${lastZodiac}`
          });
          
          const numbers = CONFIG.ZODIAC_MAP[toZodiac] || [];
          numbers.forEach(num => {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (!existing) {
              prediction.specialNumbers.push({
                number: num,
                probability: prob * 0.5,
                reason: `ç”Ÿè‚–${toZodiac} (ä¸ŠæœŸ${lastZodiac})`
              });
            }
          });
        });
      }
      
      if (stats.colorPatterns.sameColor) {
        const colorKeys = Object.keys(stats.colorPatterns.sameColor)
          .filter(key => key.startsWith(`${lastColor}->`))
          .sort((a, b) => stats.colorPatterns.sameColor[b] - stats.colorPatterns.sameColor[a])
          .slice(0, 2);
        
        colorKeys.forEach(key => {
          const toColor = key.split('->')[1];
          const prob = stats.colorPatterns.sameColor[key];
          
          prediction.colorRecommendations.push({
            color: toColor,
            probability: prob,
            reason: `ä¸ŠæœŸ${lastColor}è‰²`
          });
          
          prediction.analysis.push(`é¢œè‰²ä»${lastColor}è½¬åˆ°${toColor}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        });
      }
      
      if (stats.tailPatterns.tailTransfer) {
        const tailKeys = Object.keys(stats.tailPatterns.tailTransfer)
          .filter(key => key.startsWith(`${lastTail}->`))
          .sort((a, b) => stats.tailPatterns.tailTransfer[b] - stats.tailPatterns.tailTransfer[a])
          .slice(0, 3);
        
        tailKeys.forEach(key => {
          const toTail = parseInt(key.split('->')[1]);
          const prob = stats.tailPatterns.tailTransfer[key];
          
          prediction.tailRecommendations.push({
            tail: toTail,
            probability: prob,
            reason: `ä¸ŠæœŸå°¾${lastTail}`
          });
          
          for (let num = toTail; num <= 49; num += 10) {
            if (num >= 1 && num <= 49) {
              const existing = prediction.specialNumbers.find(item => item.number === num);
              if (existing) {
                existing.probability += prob * 0.3;
              } else {
                prediction.specialNumbers.push({
                  number: num,
                  probability: prob * 0.3,
                  reason: `å°¾æ•°${toTail} (ä¸ŠæœŸå°¾${lastTail})`
                });
              }
            }
          }
        });
      }
      
      if (stats.tailPatterns.tailFromNormal && lastRecord.normalFeatures) {
        const normalTails = lastRecord.normalFeatures.tails || [];
        normalTails.forEach(tail => {
          const tailKeys = Object.keys(stats.tailPatterns.tailFromNormal)
            .filter(key => key.startsWith(`${tail}->`))
            .sort((a, b) => stats.tailPatterns.tailFromNormal[b] - stats.tailPatterns.tailFromNormal[a])
            .slice(0, 2);
          
          tailKeys.forEach(key => {
            const toTail = parseInt(key.split('->')[1]);
            const prob = stats.tailPatterns.tailFromNormal[key];
            
            if (prob > 0.1) {
              prediction.analysis.push(`å¹³ç å°¾æ•°${tail}æå¤§å¯èƒ½ä¸‹æœŸç‰¹ç å°¾æ•°${toTail} (${(prob * 100).toFixed(1)}%)`);
              
              for (let num = toTail; num <= 49; num += 10) {
                if (num >= 1 && num <= 49) {
                  const existing = prediction.specialNumbers.find(item => item.number === num);
                  if (existing) {
                    existing.probability += prob * 0.4;
                    existing.reason += `, å¹³ç å°¾${tail}è½¬`;
                  } else {
                    prediction.specialNumbers.push({
                      number: num,
                      probability: prob * 0.4,
                      reason: `å¹³ç å°¾${tail}è½¬å°¾${toTail}`
                    });
                  }
                }
              }
            }
          });
        });
      }
      
      if (stats.sizePatterns.sizeTransfer) {
        const sizeKey = `${lastSize}->å¤§`;
        const sizeProb = stats.sizePatterns.sizeTransfer[sizeKey] || 0;
        
        if (sizeProb > 0.5) {
          prediction.sizePrediction = "å¤§";
          prediction.analysis.push(`ä¸ŠæœŸ${lastSize}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€å¤§ (${(sizeProb * 100).toFixed(1)}%)`);
          
          for (let num = 25; num <= 49; num++) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€å¤§`
              });
            }
          }
        } else if (sizeProb < 0.5) {
          prediction.sizePrediction = "å°";
          prediction.analysis.push(`ä¸ŠæœŸ${lastSize}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€å° (${(100 - sizeProb * 100).toFixed(1)}%)`);
          
          for (let num = 1; num <= 24; num++) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€å°`
              });
            }
          }
        }
      }
      
      if (stats.oddEvenPatterns.oddEvenTransfer) {
        const oeKey = `${lastOddEven}->å•`;
        const oeProb = stats.oddEvenPatterns.oddEvenTransfer[oeKey] || 0;
        
        if (oeProb > 0.5) {
          prediction.oddEvenPrediction = "å•";
          prediction.analysis.push(`ä¸ŠæœŸ${lastOddEven}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€å• (${(oeProb * 100).toFixed(1)}%)`);
          
          for (let num = 1; num <= 49; num += 2) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€å•`
              });
            }
          }
        } else if (oeProb < 0.5) {
          prediction.oddEvenPrediction = "åŒ";
          prediction.analysis.push(`ä¸ŠæœŸ${lastOddEven}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€åŒ (${(100 - oeProb * 100).toFixed(1)}%)`);
          
          for (let num = 2; num <= 49; num += 2) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€åŒ`
              });
            }
          }
        }
      }
      
      prediction.specialNumbers.forEach(item => {
        const freq = stats.frequencies.specialFrequency[item.number] || 0;
        if (freq > 0.03) {
          item.probability *= 1.2;
          item.reason += `, çƒ­é—¨å·ç `;
        } else if (freq < 0.01) {
          item.probability *= 0.8;
          item.reason += `, å†·é—¨å·ç `;
        }
      });
      
      prediction.specialNumbers.sort((a, b) => b.probability - a.probability);
      
      const seen = new Set();
      prediction.specialNumbers = prediction.specialNumbers.filter(item => {
        if (seen.has(item.number) || item.probability < 0.01) {
          return false;
        }
        seen.add(item.number);
        return true;
      }).slice(0, 15);
      
      return prediction;
    } catch (error) {
      Logger.error("EnhancedStatistics", "ä»ç»Ÿè®¡ç”Ÿæˆé¢„æµ‹å¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 8. ä¼˜åŒ–çš„è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¼•æ“
// ==============================================================================

class OptimizedMonteCarloEngine {
  static cache = new Map();
  
  static async runOptimizedSimulation(history, targetSimulations = 10000) {
    try {
      if (!history || history.length < 10) {
        return null;
      }
      
      const cacheKey = `monte_opt_${targetSimulations}_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.cache.get(cacheKey);
      
      if (cached && (Date.now() - cached.timestamp < 45000)) {
        Logger.debug("OptimizedMonteCarlo", "ä½¿ç”¨ç¼“å­˜ç»“æœ", { 
          key: cacheKey,
          age: Date.now() - cached.timestamp 
        });
        return cached.result;
      }
      
      const startTime = Date.now();
      
      const processedHistory = this.preprocessHistory(history.slice(0, Math.min(150, history.length)));
      
      if (processedHistory.length < 8) {
        Logger.warn("OptimizedMonteCarlo", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡æ¨¡æ‹Ÿ");
        return null;
      }
      
      const optimalSimulations = this.calculateOptimalSimulations(processedHistory.length, targetSimulations);
      
      const specialFrequency = {};
      const normalFrequency = {};
      
      for (let i = 1; i <= 49; i++) {
        specialFrequency[i] = 0;
        normalFrequency[i] = 0;
      }
      
      const batchSize = Math.min(1000, Math.floor(optimalSimulations / 10));
      const batches = Math.ceil(optimalSimulations / batchSize);
      
      Logger.info("OptimizedMonteCarlo", "å¼€å§‹æ‰¹æ¬¡æ¨¡æ‹Ÿ", {
        target: targetSimulations,
        optimal: optimalSimulations,
        batches: batches,
        batchSize: batchSize,
        historySize: processedHistory.length
      });
      
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
      
      for (let batch = 0; batch < batches; batch++) {
        const batchStart = Date.now();
        
        for (let i = 0; i < batchSize; i++) {
          const baseRecord = this.selectBaseRecord(processedHistory, batch, i);
          const simulated = this.simulateNextNumbersSmart(baseRecord, processedHistory);
          
          if (simulated.special >= 1 && simulated.special <= 49) {
            specialFrequency[simulated.special]++;
          }
          
          simulated.normals.forEach(num => {
            if (num >= 1 && num <= 49) {
              normalFrequency[num]++;
            }
          });
        }
        
        const batchTime = Date.now() - batchStart;
        
        if (batch < batches - 1 && batchTime < 50) {
          await delay(10);
        }
        
        if (Date.now() - startTime > 8000) {
          Logger.warn("OptimizedMonteCarlo", "æ¨¡æ‹Ÿè¶…æ—¶ï¼Œæå‰ç»“æŸ", {
            completedBatches: batch + 1,
            completedSimulations: (batch + 1) * batchSize
          });
          break;
        }
      }
      
      const completedSimulations = Object.values(specialFrequency).reduce((a, b) => a + b, 0);
      
      if (completedSimulations === 0) {
        Logger.warn("OptimizedMonteCarlo", "æ¨¡æ‹Ÿæœªç”Ÿæˆä»»ä½•ç»“æœ");
        return null;
      }
      
      const specialProbs = {};
      const normalProbs = {};
      
      for (let i = 1; i <= 49; i++) {
        specialProbs[i] = specialFrequency[i] / completedSimulations;
        normalProbs[i] = normalFrequency[i] / completedSimulations;
      }
      
      const result = {
        specialPredictions: Object.entries(specialProbs)
          .map(([num, prob]) => ({
            number: Formatter.safeInt(num),
            probability: prob,
            score: prob * 10000,
            frequency: specialFrequency[num]
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 12),
        
        normalPredictions: Object.entries(normalProbs)
          .map(([num, prob]) => ({
            number: Formatter.safeInt(num),
            probability: prob,
            score: prob * 8000,
            frequency: normalFrequency[num]
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 15),
        
        simulations: completedSimulations,
        batches: batches,
        duration: Date.now() - startTime,
        cacheKey: cacheKey
      };
      
      this.cache.set(cacheKey, {
        result: result,
        timestamp: Date.now()
      });
      
      this.cleanupCache();
      
      Logger.info("OptimizedMonteCarlo", "æ¨¡æ‹Ÿå®Œæˆ", {
        simulations: completedSimulations,
        duration: result.duration,
        topSpecial: result.specialPredictions[0]?.number || 0,
        topSpecialProb: result.specialPredictions[0]?.probability || 0
      });
      
      return result;
    } catch (error) {
      Logger.error("OptimizedMonteCarlo", "ä¼˜åŒ–æ¨¡æ‹Ÿå¤±è´¥", error);
      return null;
    }
  }
  
  static calculateOptimalSimulations(historyLength, targetSimulations) {
    let optimal = targetSimulations;
    
    if (historyLength < 30) {
      optimal = Math.min(3000, targetSimulations);
    } else if (historyLength < 50) {
      optimal = Math.min(6000, targetSimulations);
    } else if (historyLength < 100) {
      optimal = Math.min(8000, targetSimulations);
    }
    
    return optimal;
  }
  
  static selectBaseRecord(processedHistory, batch, index) {
    const total = processedHistory.length;
    const selectionMethod = (batch * 100 + index) % 7;
    
    switch (selectionMethod) {
      case 0:
        return processedHistory[Math.floor(Math.random() * total)];
      case 1:
        return processedHistory[0];
      case 2:
        return processedHistory[Math.min(10, total - 1)];
      case 3:
        return processedHistory[Math.floor(total / 2)];
      case 4:
        return processedHistory[batch % total];
      case 5:
        return processedHistory[index % total];
      default:
        const weights = processedHistory.map((_, i) => Math.exp(-i / 10));
        const sum = weights.reduce((a, b) => a + b, 0);
        let rand = Math.random() * sum;
        for (let i = 0; i < weights.length; i++) {
          rand -= weights[i];
          if (rand <= 0) return processedHistory[i];
        }
        return processedHistory[0];
    }
  }
  
  static simulateNextNumbersSmart(baseRecord, processedHistory) {
    const result = {
      normals: [],
      special: 0
    };
    
    const simulationStrategy = Math.random();
    
    if (simulationStrategy < 0.3) {
      const zodiacNumbers = CONFIG.ZODIAC_MAP[baseRecord.zodiac] || [];
      if (zodiacNumbers.length > 0) {
        result.special = zodiacNumbers[Math.floor(Math.random() * zodiacNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    } else if (simulationStrategy < 0.6) {
      const colorNumbers = CONFIG.COLORS[baseRecord.color] || [];
      if (colorNumbers.length > 0) {
        result.special = colorNumbers[Math.floor(Math.random() * colorNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    } else if (simulationStrategy < 0.8) {
      const similarIndex = Math.floor(Math.random() * Math.min(10, processedHistory.length));
      result.special = processedHistory[similarIndex]?.special || baseRecord.special;
    } else {
      const tail = baseRecord.tail;
      const possibleNumbers = [];
      for (let num = tail; num <= 49; num += 10) {
        if (num >= 1 && num <= 49) {
          possibleNumbers.push(num);
        }
      }
      if (possibleNumbers.length > 0) {
        result.special = possibleNumbers[Math.floor(Math.random() * possibleNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    }
    
    if (result.special < 1 || result.special > 49) {
      result.special = Math.floor(Math.random() * 49) + 1;
    }
    
    const usedNumbers = new Set([result.special]);
    let normalsNeeded = 6;
    
    for (const normal of baseRecord.normals) {
      if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
        result.normals.push(normal);
        usedNumbers.add(normal);
        normalsNeeded--;
        if (normalsNeeded <= 0) break;
      }
    }
    
    if (normalsNeeded > 0) {
      const similarRecords = processedHistory.slice(0, 5);
      for (const record of similarRecords) {
        if (normalsNeeded <= 0) break;
        
        for (const normal of record.normals) {
          if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
            result.normals.push(normal);
            usedNumbers.add(normal);
            normalsNeeded--;
            if (normalsNeeded <= 0) break;
          }
        }
      }
    }
    
    while (normalsNeeded > 0) {
      let num;
      let attempts = 0;
      do {
        num = Math.floor(Math.random() * 49) + 1;
        attempts++;
      } while (usedNumbers.has(num) && attempts < 20);
      
      if (!usedNumbers.has(num)) {
        result.normals.push(num);
        usedNumbers.add(num);
        normalsNeeded--;
      } else {
        for (let i = 1; i <= 49; i++) {
          if (!usedNumbers.has(i)) {
            result.normals.push(i);
            usedNumbers.add(i);
            normalsNeeded--;
            break;
          }
        }
      }
    }
    
    return result;
  }
  
  static preprocessHistory(history) {
    const processed = [];
    
    for (const record of history) {
      if (record && record.open_code) {
        const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (nums.length >= 7) {
          const special = nums[6] || 1;
          const normals = nums.slice(0, 6);
          const attr = Formatter.getAttributes(special);
          
          const normalFeatures = {
            zodiacs: normals.map(n => Formatter.getAttributes(n).zodiac),
            colors: normals.map(n => Formatter.getAttributes(n).color),
            tails: normals.map(n => n % 10),
            heads: normals.map(n => Math.floor(n / 10)),
            sizes: normals.map(n => n >= 25 ? "å¤§" : "å°"),
            oddEven: normals.map(n => n % 2 !== 0 ? "å•" : "åŒ"),
            primes: normals.map(n => Formatter.isPrime(n) ? "è´¨æ•°" : "åˆæ•°")
          };
          
          const normalStats = {
            zodiacCount: {},
            colorCount: {},
            tailCount: {},
            sizeCount: { big: 0, small: 0 },
            oddEvenCount: { odd: 0, even: 0 }
          };
          
          for (const num of normals) {
            const numAttr = Formatter.getAttributes(num);
            normalStats.zodiacCount[numAttr.zodiac] = (normalStats.zodiacCount[numAttr.zodiac] || 0) + 1;
            normalStats.colorCount[numAttr.color] = (normalStats.colorCount[numAttr.color] || 0) + 1;
            
            const tail = num % 10;
            normalStats.tailCount[tail] = (normalStats.tailCount[tail] || 0) + 1;
            
            if (num >= 25) {
              normalStats.sizeCount.big++;
            } else {
              normalStats.sizeCount.small++;
            }
            
            if (num % 2 !== 0) {
              normalStats.oddEvenCount.odd++;
            } else {
              normalStats.oddEvenCount.even++;
            }
          }
          
          processed.push({
            numbers: nums,
            special: special,
            normals: normals,
            zodiac: attr.zodiac,
            color: attr.color,
            tail: special % 10,
            head: Math.floor(special / 10),
            size: special >= 25 ? "å¤§" : "å°",
            oddEven: special % 2 !== 0 ? "å•" : "åŒ",
            features: Formatter.calculateFeatures(special),
            normalFeatures: normalFeatures,
            normalStats: normalStats,
            expect: record.expect,
            timestamp: record.created_at || Date.now()
          });
        }
      }
    }
    
    return processed;
  }
  
  static cleanupCache() {
    try {
      const now = Date.now();
      const maxCacheSize = 50;
      
      if (this.cache.size > maxCacheSize) {
        const keys = Array.from(this.cache.keys());
        const keysToDelete = keys.slice(0, Math.floor(keys.length / 2));
        
        for (const key of keysToDelete) {
          this.cache.delete(key);
        }
        
        Logger.info("OptimizedMonteCarlo", `æ¸…ç†ç¼“å­˜ï¼Œåˆ é™¤ ${keysToDelete.length} ä¸ªæ¡ç›®`);
      }
      
      for (const [key, value] of this.cache.entries()) {
        if (now - value.timestamp > 120000) {
          this.cache.delete(key);
        }
      }
    } catch (error) {
      Logger.error("OptimizedMonteCarlo", "æ¸…ç†ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static clearCache() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 9. å¯è§†åŒ–æŠ¥å‘Šç”Ÿæˆå™¨
// ==============================================================================

class VisualizationReport {
  static generateFrequencyChart(frequencyData, title, width = 30) {
    try {
      if (!frequencyData || typeof frequencyData !== 'object') {
        return `${title}: æ— æ•°æ®\n`;
      }
      
      const entries = Object.entries(frequencyData)
        .filter(([_, value]) => value > 0)
        .sort((a, b) => b[1] - a[1]);
      
      if (entries.length === 0) {
        return `${title}: æ— æœ‰æ•ˆæ•°æ®\n`;
      }
      
      const maxValue = Math.max(...entries.map(e => e[1]));
      const chartWidth = Math.min(width, entries.length);
      
      let chart = `ğŸ“Š ${title} (å…±${entries.length}é¡¹)\n`;
      chart += "â”€".repeat(chartWidth + 10) + "\n";
      
      entries.slice(0, chartWidth).forEach(([key, value]) => {
        const bar = Formatter.generateASCIIBar(value, maxValue, width, true);
        chart += `${key.toString().padStart(3)}: ${bar}\n`;
      });
      
      chart += "â”€".repeat(chartWidth + 10) + "\n";
      
      return chart;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆé¢‘ç‡å›¾è¡¨å¤±è´¥", error);
      return `${title}: å›¾è¡¨ç”Ÿæˆå¤±è´¥\n`;
    }
  }
  
  static generateNumberDistributionChart(history, topN = 15) {
    try {
      if (!history || !Array.isArray(history) || history.length === 0) {
        return "å·ç åˆ†å¸ƒ: æ— å†å²æ•°æ®\n";
      }
      
      const frequency = {};
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }
      
      for (const record of history.slice(0, 200)) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          for (const num of nums) {
            if (num >= 1 && num <= 49) {
              frequency[num]++;
            }
          }
        }
      }
      
      const entries = Object.entries(frequency)
        .map(([num, count]) => ({ number: parseInt(num), count }))
        .sort((a, b) => b.count - a.count);
      
      const maxCount = entries.length > 0 ? entries[0].count : 1;
      
      let chart = `${CONFIG.EMOJI.bar_chart} <b>å·ç å‡ºç°é¢‘ç‡åˆ†å¸ƒ</b>\n`;
      chart += "<code>\n";
      
      entries.slice(0, topN).forEach((item, index) => {
        const rank = index + 1;
        const num = item.number;
        const count = item.count;
        const attr = Formatter.getAttributes(num);
        const percentage = (count / history.length * 100).toFixed(1);
        
        const emojiScale = CONFIG.SYSTEM.VISUALIZATION.EMOJI_SCALE;
        const emojiIndex = Math.min(emojiScale.length - 1, 
          Math.floor((count / maxCount) * emojiScale.length)
        );
        const bar = emojiScale[emojiIndex].repeat(Math.ceil(count / maxCount * 15));
        
        chart += `${rank.toString().padStart(2)}. ${num.toString().padStart(2)} ${attr.zodiac}${CONFIG.EMOJI[attr.color]} ${bar} ${count}æ¬¡ (${percentage}%)\n`;
      });
      
      chart += "</code>\n";
      
      // ç»Ÿè®¡æ‘˜è¦
      const hotNumbers = entries.slice(0, 5).map(e => e.number);
      const coldNumbers = entries.slice(-5).map(e => e.number);
      
      chart += `\n${CONFIG.EMOJI.fire} <b>æœ€çƒ­é—¨å·ç </b>: ${hotNumbers.join(", ")}\n`;
      chart += `${CONFIG.EMOJI.snowflake} <b>æœ€å†·é—¨å·ç </b>: ${coldNumbers.join(", ")}\n`;
      
      return chart;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆå·ç åˆ†å¸ƒå›¾è¡¨å¤±è´¥", error);
      return "å·ç åˆ†å¸ƒå›¾è¡¨ç”Ÿæˆå¤±è´¥\n";
    }
  }
  
  static generateZodiacAnalysisChart(history) {
    try {
      if (!history || history.length === 0) {
        return "ç”Ÿè‚–åˆ†æ: æ— å†å²æ•°æ®\n";
      }
      
      const zodiacStats = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        zodiacStats[zodiac] = { count: 0, numbers: [] };
      });
      
      for (const record of history.slice(0, 200)) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const special = nums[6] || 0;
          if (special >= 1 && special <= 49) {
            const zodiac = Formatter.getAttributes(special).zodiac;
            if (zodiacStats[zodiac]) {
              zodiacStats[zodiac].count++;
              zodiacStats[zodiac].numbers.push(special);
            }
          }
        }
      }
      
      const entries = Object.entries(zodiacStats)
        .map(([zodiac, data]) => ({ zodiac, count: data.count }))
        .sort((a, b) => b.count - a.count);
      
      const maxCount = entries.length > 0 ? entries[0].count : 1;
      const totalSpecial = entries.reduce((sum, item) => sum + item.count, 0);
      
      let chart = `${CONFIG.EMOJI.brain} <b>ç”Ÿè‚–ç‰¹ç å‡ºç°åˆ†æ</b>\n`;
      chart += "<code>\n";
      
      entries.forEach((item, index) => {
        const zodiac = item.zodiac;
        const count = item.count;
        const percentage = totalSpecial > 0 ? (count / totalSpecial * 100).toFixed(1) : 0;
        
        const emojiScale = CONFIG.SYSTEM.VISUALIZATION.EMOJI_SCALE;
        const emojiIndex = Math.min(emojiScale.length - 1, 
          Math.floor((count / maxCount) * emojiScale.length)
        );
        const bar = emojiScale[emojiIndex].repeat(Math.ceil(count / maxCount * 20));
        
        chart += `${zodiac.padEnd(2)}: ${bar} ${count}æ¬¡ (${percentage}%)\n`;
      });
      
      chart += "</code>\n";
      
      // ç”Ÿè‚–æ¨è
      const topZodiacs = entries.slice(0, 3).map(e => e.zodiac);
      const bottomZodiacs = entries.slice(-3).map(e => e.zodiac);
      
      chart += `\n${CONFIG.EMOJI.star} <b>çƒ­é—¨ç”Ÿè‚–</b>: ${topZodiacs.join(", ")}\n`;
      chart += `${CONFIG.EMOJI.warning} <b>å†·é—¨ç”Ÿè‚–</b>: ${bottomZodiacs.join(", ")}\n`;
      
      // ç”Ÿè‚–å…³è”åˆ†æ
      const zodiacNumbers = entries.slice(0, 3).map(item => {
        const numbers = CONFIG.ZODIAC_MAP[item.zodiac];
        return `${item.zodiac}: ${numbers?.slice(0, 3).join(",")}...`;
      }).join(" | ");
      
      chart += `${CONFIG.EMOJI.info} <b>å¯¹åº”å·ç </b>: ${zodiacNumbers}\n`;
      
      return chart;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆç”Ÿè‚–åˆ†æå›¾è¡¨å¤±è´¥", error);
      return "ç”Ÿè‚–åˆ†æå›¾è¡¨ç”Ÿæˆå¤±è´¥\n";
    }
  }
  
  static generateColorAnalysisChart(history) {
    try {
      if (!history || history.length === 0) {
        return "æ³¢è‰²åˆ†æ: æ— å†å²æ•°æ®\n";
      }
      
      const colorStats = {
        red: { count: 0, emoji: CONFIG.EMOJI.red },
        blue: { count: 0, emoji: CONFIG.EMOJI.blue },
        green: { count: 0, emoji: CONFIG.EMOJI.green }
      };
      
      for (const record of history.slice(0, 200)) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const special = nums[6] || 0;
          if (special >= 1 && special <= 49) {
            const color = Formatter.getAttributes(special).color;
            if (colorStats[color]) {
              colorStats[color].count++;
            }
          }
        }
      }
      
      const entries = Object.entries(colorStats)
        .map(([color, data]) => ({ color, count: data.count, emoji: data.emoji }))
        .sort((a, b) => b.count - a.count);
      
      const maxCount = Math.max(...entries.map(e => e.count), 1);
      const totalSpecial = entries.reduce((sum, item) => sum + item.count, 0);
      
      let chart = `${CONFIG.EMOJI.diamond} <b>æ³¢è‰²ç‰¹ç å‡ºç°åˆ†æ</b>\n`;
      chart += "<code>\n";
      
      entries.forEach(item => {
        const color = item.color;
        const count = item.count;
        const emoji = item.emoji;
        const percentage = totalSpecial > 0 ? (count / totalSpecial * 100).toFixed(1) : 0;
        
        const emojiScale = CONFIG.SYSTEM.VISUALIZATION.EMOJI_SCALE;
        const emojiIndex = Math.min(emojiScale.length - 1, 
          Math.floor((count / maxCount) * emojiScale.length)
        );
        const bar = emojiScale[emojiIndex].repeat(Math.ceil(count / maxCount * 25));
        
        chart += `${emoji} ${color.padEnd(6)}: ${bar} ${count}æ¬¡ (${percentage}%)\n`;
      });
      
      chart += "</code>\n";
      
      // æ³¢è‰²è½¬ç§»åˆ†æ
      if (history.length > 10) {
        let redToRed = 0, redToBlue = 0, redToGreen = 0;
        let blueToRed = 0, blueToBlue = 0, blueToGreen = 0;
        let greenToRed = 0, greenToBlue = 0, greenToGreen = 0;
        
        for (let i = 0; i < history.length - 1 && i < 100; i++) {
          const current = history[i];
          const next = history[i + 1];
          
          if (current && next && current.open_code && next.open_code) {
            const currentSpecial = Formatter.safeInt(current.open_code.split(",")[6], 0);
            const nextSpecial = Formatter.safeInt(next.open_code.split(",")[6], 0);
            
            if (currentSpecial >= 1 && currentSpecial <= 49 && nextSpecial >= 1 && nextSpecial <= 49) {
              const currentColor = Formatter.getAttributes(currentSpecial).color;
              const nextColor = Formatter.getAttributes(nextSpecial).color;
              
              if (currentColor === 'red') {
                if (nextColor === 'red') redToRed++;
                else if (nextColor === 'blue') redToBlue++;
                else if (nextColor === 'green') redToGreen++;
              } else if (currentColor === 'blue') {
                if (nextColor === 'red') blueToRed++;
                else if (nextColor === 'blue') blueToBlue++;
                else if (nextColor === 'green') blueToGreen++;
              } else if (currentColor === 'green') {
                if (nextColor === 'red') greenToRed++;
                else if (nextColor === 'blue') greenToBlue++;
                else if (nextColor === 'green') greenToGreen++;
              }
            }
          }
        }
        
        const totalTransitions = redToRed + redToBlue + redToGreen + blueToRed + blueToBlue + blueToGreen + greenToRed + greenToBlue + greenToGreen;
        
        if (totalTransitions > 0) {
          chart += `\n${CONFIG.EMOJI.trend_up} <b>æ³¢è‰²è½¬ç§»è¶‹åŠ¿</b>\n`;
          chart += `<code>\n`;
          
          const redTotal = redToRed + redToBlue + redToGreen;
          const blueTotal = blueToRed + blueToBlue + blueToGreen;
          const greenTotal = greenToRed + greenToBlue + greenToGreen;
          
          if (redTotal > 0) {
            chart += `ğŸ”´â†’ğŸ”´ ${((redToRed/redTotal)*100).toFixed(1)}% | ğŸ”´â†’ğŸ”µ ${((redToBlue/redTotal)*100).toFixed(1)}% | ğŸ”´â†’ğŸŸ¢ ${((redToGreen/redTotal)*100).toFixed(1)}%\n`;
          }
          if (blueTotal > 0) {
            chart += `ğŸ”µâ†’ğŸ”´ ${((blueToRed/blueTotal)*100).toFixed(1)}% | ğŸ”µâ†’ğŸ”µ ${((blueToBlue/blueTotal)*100).toFixed(1)}% | ğŸ”µâ†’ğŸŸ¢ ${((blueToGreen/blueTotal)*100).toFixed(1)}%\n`;
          }
          if (greenTotal > 0) {
            chart += `ğŸŸ¢â†’ğŸ”´ ${((greenToRed/greenTotal)*100).toFixed(1)}% | ğŸŸ¢â†’ğŸ”µ ${((greenToBlue/greenTotal)*100).toFixed(1)}% | ğŸŸ¢â†’ğŸŸ¢ ${((greenToGreen/greenTotal)*100).toFixed(1)}%\n`;
          }
          
          chart += `</code>\n`;
        }
      }
      
      return chart;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆæ³¢è‰²åˆ†æå›¾è¡¨å¤±è´¥", error);
      return "æ³¢è‰²åˆ†æå›¾è¡¨ç”Ÿæˆå¤±è´¥\n";
    }
  }
  
  static generateTailAnalysisChart(history) {
    try {
      if (!history || history.length === 0) {
        return "å°¾æ•°åˆ†æ: æ— å†å²æ•°æ®\n";
      }
      
      const tailStats = {};
      for (let i = 0; i <= 9; i++) {
        tailStats[i] = 0;
      }
      
      for (const record of history.slice(0, 200)) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          for (const num of nums) {
            if (num >= 1 && num <= 49) {
              const tail = num % 10;
              tailStats[tail]++;
            }
          }
        }
      }
      
      const entries = Object.entries(tailStats)
        .map(([tail, count]) => ({ tail: parseInt(tail), count }))
        .sort((a, b) => b.count - a.count);
      
      const maxCount = entries.length > 0 ? entries[0].count : 1;
      const totalNumbers = entries.reduce((sum, item) => sum + item.count, 0);
      
      let chart = `${CONFIG.EMOJI.tail} <b>å°¾æ•°å‡ºç°é¢‘ç‡åˆ†æ</b>\n`;
      chart += "<code>\n";
      
      entries.forEach(item => {
        const tail = item.tail;
        const count = item.count;
        const percentage = totalNumbers > 0 ? (count / totalNumbers * 100).toFixed(1) : 0;
        
        const emojiScale = CONFIG.SYSTEM.VISUALIZATION.EMOJI_SCALE;
        const emojiIndex = Math.min(emojiScale.length - 1, 
          Math.floor((count / maxCount) * emojiScale.length)
        );
        const bar = emojiScale[emojiIndex].repeat(Math.ceil(count / maxCount * 20));
        
        chart += `å°¾${tail}: ${bar} ${count}æ¬¡ (${percentage}%)\n`;
      });
      
      chart += "</code>\n";
      
      // å°¾æ•°å¯¹åº”çš„å·ç 
      const topTail = entries[0]?.tail || 0;
      if (topTail >= 0 && topTail <= 9) {
        const tailNumbers = [];
        for (let num = topTail; num <= 49; num += 10) {
          if (num >= 1 && num <= 49) {
            tailNumbers.push(num);
          }
        }
        
        chart += `\n${CONFIG.EMOJI.info} <b>å°¾${topTail}å¯¹åº”å·ç </b>: ${tailNumbers.slice(0, 5).join(", ")}${tailNumbers.length > 5 ? "..." : ""}\n`;
      }
      
      // å°¾æ•°è¶‹åŠ¿
      if (history.length > 20) {
        const recentTails = [];
        for (let i = 0; i < Math.min(10, history.length); i++) {
          const record = history[i];
          if (record && record.open_code) {
            const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            const special = nums[6] || 0;
            if (special >= 1 && special <= 49) {
              recentTails.push(special % 10);
            }
          }
        }
        
        if (recentTails.length > 0) {
          const uniqueTails = [...new Set(recentTails)];
          chart += `${CONFIG.EMOJI.trend_stable} <b>æœ€è¿‘${recentTails.length}æœŸå°¾æ•°</b>: ${recentTails.join(", ")}\n`;
          chart += `${CONFIG.EMOJI.analysis} <b>æœ€è¿‘ä¸é‡å¤å°¾æ•°</b>: ${uniqueTails.join(", ")}\n`;
        }
      }
      
      return chart;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆå°¾æ•°åˆ†æå›¾è¡¨å¤±è´¥", error);
      return "å°¾æ•°åˆ†æå›¾è¡¨ç”Ÿæˆå¤±è´¥\n";
    }
  }
  
  static generateSizeOddEvenAnalysis(history) {
    try {
      if (!history || history.length === 0) {
        return "å¤§å°å•åŒåˆ†æ: æ— å†å²æ•°æ®\n";
      }
      
      let bigCount = 0, smallCount = 0;
      let oddCount = 0, evenCount = 0;
      let bigOdd = 0, bigEven = 0, smallOdd = 0, smallEven = 0;
      
      for (const record of history.slice(0, 200)) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const special = nums[6] || 0;
          if (special >= 1 && special <= 49) {
            const isBig = special >= 25;
            const isOdd = special % 2 !== 0;
            
            if (isBig) bigCount++;
            else smallCount++;
            
            if (isOdd) oddCount++;
            else evenCount++;
            
            if (isBig && isOdd) bigOdd++;
            else if (isBig && !isOdd) bigEven++;
            else if (!isBig && isOdd) smallOdd++;
            else if (!isBig && !isOdd) smallEven++;
          }
        }
      }
      
      const total = bigCount + smallCount;
      if (total === 0) return "å¤§å°å•åŒåˆ†æ: æ— æœ‰æ•ˆæ•°æ®\n";
      
      const bigPercentage = (bigCount / total * 100).toFixed(1);
      const smallPercentage = (smallCount / total * 100).toFixed(1);
      const oddPercentage = (oddCount / total * 100).toFixed(1);
      const evenPercentage = (evenCount / total * 100).toFixed(1);
      
      let chart = `${CONFIG.EMOJI.size} <b>å¤§å°å•åŒåˆ†å¸ƒåˆ†æ</b>\n`;
      chart += "<code>\n";
      
      // å¤§å°åˆ†å¸ƒ
      const sizeMax = Math.max(bigCount, smallCount);
      const bigBar = Formatter.generateASCIIBar(bigCount, sizeMax, 20, true);
      const smallBar = Formatter.generateASCIIBar(smallCount, sizeMax, 20, true);
      
      chart += `å¤§æ•°: ${bigBar}\n`;
      chart += `å°æ•°: ${smallBar}\n`;
      
      // å•åŒåˆ†å¸ƒ
      const oddEvenMax = Math.max(oddCount, evenCount);
      const oddBar = Formatter.generateASCIIBar(oddCount, oddEvenMax, 20, true);
      const evenBar = Formatter.generateASCIIBar(evenCount, oddEvenMax, 20, true);
      
      chart += `å•æ•°: ${oddBar}\n`;
      chart += `åŒæ•°: ${evenBar}\n`;
      
      chart += "</code>\n";
      
      // ç»„åˆåˆ†æ
      const totalCombinations = bigOdd + bigEven + smallOdd + smallEven;
      if (totalCombinations > 0) {
        chart += `\n${CONFIG.EMOJI.gear} <b>ç»„åˆåˆ†å¸ƒ</b>\n`;
        chart += `<code>\n`;
        
        chart += `å¤§å•: ${bigOdd}æ¬¡ (${(bigOdd/totalCombinations*100).toFixed(1)}%)\n`;
        chart += `å¤§åŒ: ${bigEven}æ¬¡ (${(bigEven/totalCombinations*100).toFixed(1)}%)\n`;
        chart += `å°å•: ${smallOdd}æ¬¡ (${(smallOdd/totalCombinations*100).toFixed(1)}%)\n`;
        chart += `å°åŒ: ${smallEven}æ¬¡ (${(smallEven/totalCombinations*100).toFixed(1)}%)\n`;
        
        chart += `</code>\n`;
      }
      
      // è¶‹åŠ¿åˆ†æ
      if (history.length > 10) {
        const recentSizes = [];
        const recentOddEvens = [];
        
        for (let i = 0; i < Math.min(10, history.length); i++) {
          const record = history[i];
          if (record && record.open_code) {
            const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            const special = nums[6] || 0;
            if (special >= 1 && special <= 49) {
              recentSizes.push(special >= 25 ? "å¤§" : "å°");
              recentOddEvens.push(special % 2 !== 0 ? "å•" : "åŒ");
            }
          }
        }
        
        chart += `\n${CONFIG.EMOJI.trend_up} <b>æœ€è¿‘${recentSizes.length}æœŸè¶‹åŠ¿</b>\n`;
        chart += `å¤§å°: ${recentSizes.join("")}\n`;
        chart += `å•åŒ: ${recentOddEvens.join("")}\n`;
        
        // è¿ç»­åˆ†æ
        let consecutiveBig = 0, consecutiveSmall = 0;
        let consecutiveOdd = 0, consecutiveEven = 0;
        
        for (let i = 1; i < recentSizes.length; i++) {
          if (recentSizes[i] === recentSizes[i-1]) {
            if (recentSizes[i] === "å¤§") consecutiveBig++;
            else consecutiveSmall++;
          }
          if (recentOddEvens[i] === recentOddEvens[i-1]) {
            if (recentOddEvens[i] === "å•") consecutiveOdd++;
            else consecutiveEven++;
          }
        }
        
        if (consecutiveBig > 0) chart += `è¿ç»­å¤§æ•°: ${consecutiveBig}æœŸ\n`;
        if (consecutiveSmall > 0) chart += `è¿ç»­å°æ•°: ${consecutiveSmall}æœŸ\n`;
        if (consecutiveOdd > 0) chart += `è¿ç»­å•æ•°: ${consecutiveOdd}æœŸ\n`;
        if (consecutiveEven > 0) chart += `è¿ç»­åŒæ•°: ${consecutiveEven}æœŸ\n`;
      }
      
      // æ¨è
      const recommendations = [];
      if (bigPercentage > 55) recommendations.push("è¿‘æœŸå¤§æ•°åå¤šï¼Œå¯å…³æ³¨å°æ•°åå¼¹");
      else if (smallPercentage > 55) recommendations.push("è¿‘æœŸå°æ•°åå¤šï¼Œå¯å…³æ³¨å¤§æ•°åå¼¹");
      
      if (oddPercentage > 55) recommendations.push("è¿‘æœŸå•æ•°åå¤šï¼Œå¯å…³æ³¨åŒæ•°åå¼¹");
      else if (evenPercentage > 55) recommendations.push("è¿‘æœŸåŒæ•°åå¤šï¼Œå¯å…³æ³¨å•æ•°åå¼¹");
      
      if (recommendations.length > 0) {
        chart += `\n${CONFIG.EMOJI.bulb} <b>ç­–ç•¥å»ºè®®</b>\n`;
        recommendations.forEach(rec => {
          chart += `â€¢ ${rec}\n`;
        });
      }
      
      return chart;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆå¤§å°å•åŒåˆ†æå›¾è¡¨å¤±è´¥", error);
      return "å¤§å°å•åŒåˆ†æå›¾è¡¨ç”Ÿæˆå¤±è´¥\n";
    }
  }
  
  static generateTrendAnalysis(history, periods = 30) {
    try {
      if (!history || history.length < periods) {
        return "è¶‹åŠ¿åˆ†æ: æ•°æ®ä¸è¶³\n";
      }
      
      const recentHistory = history.slice(0, periods);
      const analysisData = [];
      
      for (let i = 0; i < recentHistory.length; i++) {
        const record = recentHistory[i];
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const special = nums[6] || 0;
          if (special >= 1 && special <= 49) {
            const attr = Formatter.getAttributes(special);
            const features = Formatter.calculateFeatures(special);
            
            analysisData.push({
              expect: record.expect,
              special: special,
              zodiac: attr.zodiac,
              color: attr.color,
              tail: special % 10,
              size: features.isBig ? "å¤§" : "å°",
              oddEven: features.isOdd ? "å•" : "åŒ",
              isPrime: features.isPrime
            });
          }
        }
      }
      
      if (analysisData.length < 10) {
        return "è¶‹åŠ¿åˆ†æ: æœ‰æ•ˆæ•°æ®ä¸è¶³\n";
      }
      
      let report = `${CONFIG.EMOJI.trend_up} <b>${periods}æœŸè¶‹åŠ¿åˆ†ææŠ¥å‘Š</b>\n`;
      report += `åˆ†æèŒƒå›´: ${analysisData.length}æœŸæœ‰æ•ˆæ•°æ®\n`;
      report += "â”€".repeat(30) + "\n\n";
      
      // ç”Ÿè‚–è¶‹åŠ¿
      const zodiacTrends = {};
      analysisData.forEach(data => {
        zodiacTrends[data.zodiac] = (zodiacTrends[data.zodiac] || 0) + 1;
      });
      
      const sortedZodiacs = Object.entries(zodiacTrends)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      report += `${CONFIG.EMOJI.brain} <b>çƒ­é—¨ç”Ÿè‚–è¶‹åŠ¿</b>\n`;
      sortedZodiacs.forEach(([zodiac, count], index) => {
        const percentage = (count / analysisData.length * 100).toFixed(1);
        const trend = Formatter.generateTrendIndicator(count, analysisData.length / 12);
        report += `${index + 1}. ${zodiac}: ${count}æ¬¡ (${percentage}%) ${trend}\n`;
      });
      
      // é¢œè‰²è¶‹åŠ¿
      const colorTrends = { red: 0, blue: 0, green: 0 };
      analysisData.forEach(data => {
        if (colorTrends[data.color]) {
          colorTrends[data.color]++;
        }
      });
      
      report += `\n${CONFIG.EMOJI.diamond} <b>æ³¢è‰²è¶‹åŠ¿</b>\n`;
      Object.entries(colorTrends).forEach(([color, count]) => {
        const percentage = (count / analysisData.length * 100).toFixed(1);
        const emoji = CONFIG.EMOJI[color] || "";
        const expected = analysisData.length / 3;
        const trend = Formatter.generateTrendIndicator(count, expected);
        report += `${emoji} ${color}: ${count}æ¬¡ (${percentage}%) ${trend}\n`;
      });
      
      // å°¾æ•°è¶‹åŠ¿
      const tailTrends = {};
      analysisData.forEach(data => {
        tailTrends[data.tail] = (tailTrends[data.tail] || 0) + 1;
      });
      
      const sortedTails = Object.entries(tailTrends)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      report += `\n${CONFIG.EMOJI.tail} <b>çƒ­é—¨å°¾æ•°</b>\n`;
      sortedTails.forEach(([tail, count], index) => {
        const percentage = (count / analysisData.length * 100).toFixed(1);
        const expected = analysisData.length / 10;
        const trend = Formatter.generateTrendIndicator(count, expected);
        const tailNumbers = [];
        for (let num = parseInt(tail); num <= 49; num += 10) {
          if (num >= 1 && num <= 49) tailNumbers.push(num);
        }
        report += `å°¾${tail}: ${count}æ¬¡ (${percentage}%) ${trend}\n`;
      });
      
      // å¤§å°å•åŒè¶‹åŠ¿
      const sizeStats = { å¤§: 0, å°: 0 };
      const oddEvenStats = { å•: 0, åŒ: 0 };
      
      analysisData.forEach(data => {
        sizeStats[data.size]++;
        oddEvenStats[data.oddEven]++;
      });
      
      report += `\n${CONFIG.EMOJI.size} <b>å¤§å°åˆ†å¸ƒ</b>\n`;
      report += `å¤§: ${sizeStats["å¤§"]}æ¬¡ (${(sizeStats["å¤§"]/analysisData.length*100).toFixed(1)}%)\n`;
      report += `å°: ${sizeStats["å°"]}æ¬¡ (${(sizeStats["å°"]/analysisData.length*100).toFixed(1)}%)\n`;
      
      report += `\n${CONFIG.EMOJI.odd_even} <b>å•åŒåˆ†å¸ƒ</b>\n`;
      report += `å•: ${oddEvenStats["å•"]}æ¬¡ (${(oddEvenStats["å•"]/analysisData.length*100).toFixed(1)}%)\n`;
      report += `åŒ: ${oddEvenStats["åŒ"]}æ¬¡ (${(oddEvenStats["åŒ"]/analysisData.length*100).toFixed(1)}%)\n`;
      
      // è¿‘æœŸæ¨¡å¼è¯†åˆ«
      if (analysisData.length >= 5) {
        const recentPatterns = [];
        
        // æ£€æŸ¥è¿ç»­æ¨¡å¼
        for (let i = 1; i < Math.min(5, analysisData.length); i++) {
          const current = analysisData[i];
          const previous = analysisData[i-1];
          
          if (current.zodiac === previous.zodiac) {
            recentPatterns.push(`è¿ç»­å¼€${current.zodiac}`);
          }
          if (current.color === previous.color) {
            recentPatterns.push(`è¿ç»­å¼€${current.color}è‰²`);
          }
          if (current.size === previous.size) {
            recentPatterns.push(`è¿ç»­å¼€${current.size}`);
          }
          if (current.oddEven === previous.oddEven) {
            recentPatterns.push(`è¿ç»­å¼€${current.oddEven}`);
          }
        }
        
        const uniquePatterns = [...new Set(recentPatterns)];
        if (uniquePatterns.length > 0) {
          report += `\n${CONFIG.EMOJI.analysis} <b>è¿‘æœŸæ¨¡å¼</b>\n`;
          uniquePatterns.forEach(pattern => {
            report += `â€¢ ${pattern}\n`;
          });
        }
      }
      
      // é¢„æµ‹å»ºè®®
      const recommendations = [];
      
      const mostCommonZodiac = sortedZodiacs[0]?.[0];
      const mostCommonColor = Object.entries(colorTrends).sort((a, b) => b[1] - a[1])[0]?.[0];
      const mostCommonTail = sortedTails[0]?.[0];
      
      if (mostCommonZodiac) {
        recommendations.push(`å…³æ³¨${mostCommonZodiac}ç”Ÿè‚–ç›¸å…³å·ç `);
      }
      if (mostCommonColor) {
        recommendations.push(`å…³æ³¨${mostCommonColor}è‰²å·ç  (${CONFIG.EMOJI[mostCommonColor]})`);
      }
      if (mostCommonTail) {
        recommendations.push(`å…³æ³¨å°¾${mostCommonTail}å·ç `);
      }
      
      if (sizeStats["å¤§"] > sizeStats["å°"] * 1.2) {
        recommendations.push("è¿‘æœŸå¤§æ•°åå¤šï¼Œå…³æ³¨å°æ•°åå¼¹å¯èƒ½");
      } else if (sizeStats["å°"] > sizeStats["å¤§"] * 1.2) {
        recommendations.push("è¿‘æœŸå°æ•°åå¤šï¼Œå…³æ³¨å¤§æ•°åå¼¹å¯èƒ½");
      }
      
      if (oddEvenStats["å•"] > oddEvenStats["åŒ"] * 1.2) {
        recommendations.push("è¿‘æœŸå•æ•°åå¤šï¼Œå…³æ³¨åŒæ•°åå¼¹å¯èƒ½");
      } else if (oddEvenStats["åŒ"] > oddEvenStats["å•"] * 1.2) {
        recommendations.push("è¿‘æœŸåŒæ•°åå¤šï¼Œå…³æ³¨å•æ•°åå¼¹å¯èƒ½");
      }
      
      if (recommendations.length > 0) {
        report += `\n${CONFIG.EMOJI.bulb} <b>é¢„æµ‹å»ºè®®</b>\n`;
        recommendations.forEach(rec => {
          report += `â€¢ ${rec}\n`;
        });
      }
      
      return report;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆè¶‹åŠ¿åˆ†æå¤±è´¥", error);
      return "è¶‹åŠ¿åˆ†æç”Ÿæˆå¤±è´¥\n";
    }
  }
  
  static generateComprehensiveReport(history, userStats = null) {
    try {
      if (!history || history.length === 0) {
        return "ğŸ“Š <b>ç»¼åˆåˆ†ææŠ¥å‘Š</b>\n\næš‚æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”ŸæˆæŠ¥å‘Šã€‚";
      }
      
      let report = `${CONFIG.EMOJI.report} <b>æ¾³å…­ç»¼åˆåˆ†ææŠ¥å‘Š</b>\n`;
      report += `æ•°æ®èŒƒå›´: ${history.length}æœŸå†å²è®°å½•\n`;
      report += `ç”Ÿæˆæ—¶é—´: ${Formatter.formatDateTime()}\n`;
      report += "â”€".repeat(30) + "\n\n";
      
      // åŸºç¡€ç»Ÿè®¡
      const totalRecords = history.length;
      const latestRecord = history[0];
      const oldestRecord = history[history.length - 1];
      
      report += `${CONFIG.EMOJI.database} <b>æ•°æ®æ¦‚è§ˆ</b>\n`;
      report += `â€¢ æ•°æ®æ€»é‡: ${totalRecords}æœŸ\n`;
      report += `â€¢ æ•°æ®èŒƒå›´: ${oldestRecord?.expect || "æœªçŸ¥"} è‡³ ${latestRecord?.expect || "æœªçŸ¥"}\n`;
      
      if (latestRecord && latestRecord.open_code) {
        const special = Formatter.safeInt(latestRecord.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        report += `â€¢ æœ€æ–°å¼€å¥–: ${latestRecord.expect}æœŸ (${special} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]})\n`;
      }
      
      report += "\n";
      
      // å·ç åˆ†å¸ƒå›¾è¡¨
      report += VisualizationReport.generateNumberDistributionChart(history, 12);
      report += "\n";
      
      // ç”Ÿè‚–åˆ†æ
      report += VisualizationReport.generateZodiacAnalysisChart(history);
      report += "\n";
      
      // æ³¢è‰²åˆ†æ
      report += VisualizationReport.generateColorAnalysisChart(history);
      report += "\n";
      
      // å°¾æ•°åˆ†æ
      report += VisualizationReport.generateTailAnalysisChart(history);
      report += "\n";
      
      // å¤§å°å•åŒåˆ†æ
      report += VisualizationReport.generateSizeOddEvenAnalysis(history);
      report += "\n";
      
      // è¶‹åŠ¿åˆ†æ
      const trendPeriods = Math.min(30, history.length);
      if (trendPeriods >= 10) {
        report += VisualizationReport.generateTrendAnalysis(history, trendPeriods);
        report += "\n";
      }
      
      // ç”¨æˆ·ä¸ªæ€§åŒ–åˆ†æï¼ˆå¦‚æœæœ‰ï¼‰
      if (userStats) {
        report += `${CONFIG.EMOJI.personal} <b>æ‚¨çš„ä¸ªæ€§åŒ–åˆ†æ</b>\n`;
        report += `â€¢ åé¦ˆæ¬¡æ•°: ${userStats.totalFeedback}\n`;
        report += `â€¢ å¹³å‡è¯„åˆ†: ${userStats.averageScore.toFixed(1)}/5.0\n`;
        report += `â€¢ æ­£é¢åé¦ˆ: ${userStats.positiveCount}\n`;
        report += `â€¢ è´Ÿé¢åé¦ˆ: ${userStats.negativeCount}\n`;
        
        if (userStats.preferences) {
          const prefs = userStats.preferences;
          if (prefs.zodiacs && prefs.zodiacs.length > 0) {
            report += `â€¢ åå¥½ç”Ÿè‚–: ${prefs.zodiacs.join(", ")}\n`;
          }
          if (prefs.colors && prefs.colors.length > 0) {
            report += `â€¢ åå¥½æ³¢è‰²: ${prefs.colors.map(c => CONFIG.EMOJI[c]).join("")}\n`;
          }
          if (prefs.tails && prefs.tails.length > 0) {
            report += `â€¢ åå¥½å°¾æ•°: ${prefs.tails.join(", ")}\n`;
          }
        }
        
        report += "\n";
      }
      
      // æ€»ç»“ä¸å»ºè®®
      report += `${CONFIG.EMOJI.crystal_ball} <b>æ€»ç»“ä¸å»ºè®®</b>\n`;
      report += `1. æœ¬æŠ¥å‘ŠåŸºäº${totalRecords}æœŸå†å²æ•°æ®åˆ†æ\n`;
      report += `2. å»ºè®®ç»“åˆå¤šç§ç®—æ³•è¿›è¡Œé¢„æµ‹\n`;
      report += `3. å®šæœŸæŸ¥çœ‹è¶‹åŠ¿åˆ†æä»¥æŠŠæ¡è§„å¾‹\n`;
      report += `4. ä½¿ç”¨ä¸ªæ€§åŒ–é¢„æµ‹å¯è·å¾—æ›´é€‚åˆæ‚¨çš„æ¨è\n`;
      
      report += `\n${CONFIG.EMOJI.info} <b>å‘½ä»¤æç¤º</b>\n`;
      report += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹\n`;
      report += `<code>/predict personalized</code> - ä¸ªæ€§åŒ–é¢„æµ‹\n`;
      report += `<code>/stats</code> - æŸ¥çœ‹ç»Ÿè®¡æŠ¥å‘Š\n`;
      report += `<code>/profile</code> - æŸ¥çœ‹ä¸ªäººèµ„æ–™\n`;
      
      return report;
    } catch (error) {
      Logger.error("VisualizationReport", "ç”Ÿæˆç»¼åˆåˆ†ææŠ¥å‘Šå¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} <b>æŠ¥å‘Šç”Ÿæˆå¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚`;
    }
  }
}

// ==============================================================================
// 10. æ”¹è¿›çš„é¢„æµ‹å¼•æ“ï¼ˆæ–°å¢ä¸ªæ€§åŒ–é¢„æµ‹ï¼‰
// ==============================================================================

class PredictionEngine {
  static async generate(env, history, weights, algorithm = "traditional", userId = null) {
    try {
      if (!history || history.length < 2) {
        return this.generateStaticFallback();
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      // æ£€æŸ¥ç®—æ³•æ˜¯å¦æ”¯æŒå½“å‰å†å²æ•°æ®é‡
      if (!Formatter.isAlgorithmSupported(algorithm, history.length)) {
        Logger.warn("PredictionEngine", `ç®—æ³• ${algorithm} éœ€è¦æ›´å¤šå†å²æ•°æ®ï¼Œä½¿ç”¨ä¼ ç»Ÿç®—æ³•æ›¿ä»£`, {
          algorithm,
          historyLength: history.length,
          minRequired: CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS[algorithm]
        });
        
        if (algorithm !== "traditional") {
          algorithm = "traditional";
        }
      }
      
      // è®¡ç®—ä¸‹ä¸€æœŸæœŸå·
      let nextExpect = "2025001";
      const latestExpect = lastRecord.expect;
      if (latestExpect && Formatter.isValidExpect(latestExpect)) {
        const latestNum = Formatter.safeInt(latestExpect, 2025000);
        nextExpect = (latestNum + 1).toString();
      }
      
      // æ ¹æ®ç®—æ³•é€‰æ‹©é¢„æµ‹æ–¹æ³•
      let prediction;
      const algorithmTimeout = Formatter.getAlgorithmTimeout(algorithm);
      
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error(`é¢„æµ‹ç”Ÿæˆè¶…æ—¶ (${algorithmTimeout}ms)`)), algorithmTimeout);
        });
        
        const predictionPromise = (async () => {
          switch (algorithm) {
            case "knn":
              return await this.generateKNNPrediction(history, weights);
            case "stats":
              return await this.generateStatsPrediction(history, weights);
            case "advanced":
              return await this.generateAdvancedPrediction(env, history, weights);
            case "personalized":
              return await this.generatePersonalizedPrediction(env, history, weights, userId);
            case "traditional":
            default:
              return await this.generateTraditionalPrediction(history, weights);
          }
        })();
        
        prediction = await Promise.race([predictionPromise, timeoutPromise]);
      } catch (timeoutError) {
        Logger.error("PredictionEngine", `é¢„æµ‹ç”Ÿæˆè¶…æ—¶ï¼Œç®—æ³•: ${algorithm}`, timeoutError);
        prediction = await this.generateTraditionalPrediction(history, weights);
        prediction.algorithmTimeout = true;
        prediction.originalAlgorithm = algorithm;
      }
      
      // ç¡®ä¿é¢„æµ‹ç»“æœæœ‰æ•ˆ
      if (!prediction || !prediction.specialNumbers || prediction.specialNumbers.length === 0) {
        Logger.warn("PredictionEngine", `ç®—æ³• ${algorithm} è¿”å›æ— æ•ˆé¢„æµ‹ï¼Œä½¿ç”¨ä¼ ç»Ÿç®—æ³•æ›¿ä»£`);
        prediction = await this.generateTraditionalPrediction(history, weights);
      }
      
      // æ·»åŠ åŸºç¡€ä¿¡æ¯
      prediction.nextExpect = nextExpect;
      prediction.basedOnLastRecord = {
        expect: lastRecord.expect || "æœªçŸ¥",
        openCode: lastOpenCode,
        special: lastSpecial,
        zodiac: Formatter.getAttributes(lastSpecial).zodiac,
        color: Formatter.getAttributes(lastSpecial).color
      };
      
      prediction.totalHistoryRecords = history.length;
      prediction.generatedAt = new Date().toISOString();
      prediction.algorithmVersion = `V12.4-${CONFIG.ALGORITHM_NAMES[algorithm] || algorithm}`;
      prediction.algorithmUsed = algorithm;
      
      if (prediction.algorithmTimeout) {
        prediction.algorithmUsed = `timeout_fallback_${prediction.originalAlgorithm}_to_traditional`;
      }
      
      return prediction;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback();
    }
  }
  
  static async generatePersonalizedPrediction(env, history, weights, userId) {
    try {
      Logger.info("PredictionEngine", "å¼€å§‹ç”Ÿæˆä¸ªæ€§åŒ–é¢„æµ‹", { userId });
      
      // è·å–ç”¨æˆ·ä¸ªæ€§åŒ–æƒé‡å’Œåå¥½
      const personalizedData = await DB.getUserPersonalizedWeights(env, userId);
      const userPreferences = personalizedData.preferences || {};
      const isPersonalized = personalizedData.isPersonalized;
      const feedbackCount = personalizedData.feedbackCount || 0;
      
      // è®°å½•ç”¨æˆ·è¡Œä¸º
      await DB.logUserBehavior(env, userId, "personalized_prediction", {
        isPersonalized: isPersonalized,
        feedbackCount: feedbackCount
      });
      
      // ä½¿ç”¨ä¸ªæ€§åŒ–æƒé‡æˆ–é»˜è®¤æƒé‡
      const personalizedWeights = personalizedData.weights || weights;
      
      // ç”Ÿæˆå¢å¼ºé¢„æµ‹ä½œä¸ºåŸºç¡€
      const basePrediction = await this.generateAdvancedPrediction(env, history, personalizedWeights);
      
      if (!basePrediction) {
        return await this.generateAdvancedPrediction(env, history, weights);
      }
      
      // åº”ç”¨ç”¨æˆ·åå¥½
      if (isPersonalized && userPreferences) {
        Logger.info("PredictionEngine", "åº”ç”¨ç”¨æˆ·åå¥½", userPreferences);
        
        // å¢å¼ºç”¨æˆ·åå¥½çš„å·ç æƒé‡
        const enhancedSpecialNumbers = basePrediction.specialNumbers.map(item => {
          let enhancedScore = item.score || 0;
          let enhancedProbability = item.probability || 0;
          
          // æ£€æŸ¥æ˜¯å¦åŒ¹é…ç”¨æˆ·åå¥½
          const attr = Formatter.getAttributes(item.number);
          const features = Formatter.calculateFeatures(item.number);
          
          // ç”Ÿè‚–åå¥½
          if (userPreferences.zodiacs && userPreferences.zodiacs.includes(attr.zodiac)) {
            enhancedScore *= 1.3;
            enhancedProbability *= 1.2;
            item.reason = item.reason ? `${item.reason}, æ‚¨åå¥½çš„ç”Ÿè‚–` : "æ‚¨åå¥½çš„ç”Ÿè‚–";
          }
          
          // é¢œè‰²åå¥½
          if (userPreferences.colors && userPreferences.colors.includes(attr.color)) {
            enhancedScore *= 1.2;
            enhancedProbability *= 1.1;
            item.reason = item.reason ? `${item.reason}, æ‚¨åå¥½çš„é¢œè‰²` : "æ‚¨åå¥½çš„é¢œè‰²";
          }
          
          // å°¾æ•°åå¥½
          if (userPreferences.tails && userPreferences.tails.includes(features.tail)) {
            enhancedScore *= 1.15;
            enhancedProbability *= 1.05;
            item.reason = item.reason ? `${item.reason}, æ‚¨åå¥½çš„å°¾æ•°` : "æ‚¨åå¥½çš„å°¾æ•°";
          }
          
          // å¤§å°åå¥½
          if (userPreferences.size && 
              ((userPreferences.size === "å¤§" && features.isBig) || 
               (userPreferences.size === "å°" && !features.isBig))) {
            enhancedScore *= 1.1;
          }
          
          // å•åŒåå¥½
          if (userPreferences.oddEven && 
              ((userPreferences.oddEven === "å•" && features.isOdd) || 
               (userPreferences.oddEven === "åŒ" && !features.isOdd))) {
            enhancedScore *= 1.1;
          }
          
          return {
            ...item,
            score: enhancedScore,
            probability: Math.min(0.95, enhancedProbability)
          };
        });
        
        // é‡æ–°æ’åº
        basePrediction.specialNumbers = enhancedSpecialNumbers
          .sort((a, b) => b.score - a.score)
          .slice(0, 5);
        
        // æ›´æ–°ç”Ÿè‚–æ¨è
        if (userPreferences.zodiacs && userPreferences.zodiacs.length > 0) {
          basePrediction.zodiac = {
            main: [...new Set([...userPreferences.zodiacs.slice(0, 2), ...(basePrediction.zodiac?.main || [])])].slice(0, 3),
            guard: basePrediction.zodiac?.guard || [],
            scores: basePrediction.zodiac?.scores || {}
          };
        }
        
        // æ›´æ–°é¢œè‰²æ¨è
        if (userPreferences.colors && userPreferences.colors.length > 0) {
          basePrediction.color = {
            main: userPreferences.colors[0] || basePrediction.color?.main,
            guard: basePrediction.color?.guard || "blue",
            scores: basePrediction.color?.scores || {}
          };
        }
        
        // æ·»åŠ ä¸ªæ€§åŒ–æ ‡è®°
        basePrediction.personalized = true;
        basePrediction.personalizationLevel = Math.min(100, feedbackCount * 10);
        basePrediction.userPreferences = {
          zodiacs: userPreferences.zodiacs || [],
          colors: userPreferences.colors || [],
          tails: userPreferences.tails || []
        };
      }
      
      // æ›´æ–°ç®—æ³•ä¿¡æ¯
      basePrediction.algorithmUsed = "personalized";
      basePrediction.algorithmVersion = `V12.4-Personalized-${isPersonalized ? 'Custom' : 'Basic'}`;
      basePrediction.personalizationInfo = {
        isPersonalized: isPersonalized,
        feedbackCount: feedbackCount,
        accuracyScore: personalizedData.accuracyScore || 0,
        preferencesApplied: isPersonalized
      };
      
      // è°ƒæ•´ç½®ä¿¡åº¦
      if (isPersonalized) {
        const personalizationBoost = Math.min(15, feedbackCount * 2);
        basePrediction.confidence = Math.min(95, (basePrediction.confidence || 0) + personalizationBoost);
      }
      
      return basePrediction;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆä¸ªæ€§åŒ–é¢„æµ‹å¤±è´¥", error);
      // å¤±è´¥æ—¶å›é€€åˆ°å¢å¼ºé¢„æµ‹
      return await this.generateAdvancedPrediction(env, history, weights);
    }
  }
  
  // å…¶ä»–é¢„æµ‹ç”Ÿæˆæ–¹æ³•ä¿æŒä¸å˜...
  static async generateTraditionalPrediction(history, weights) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
    return this.generateStaticFallback();
  }
  
  static async generateKNNPrediction(history, weights) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
    return this.generateStaticFallback();
  }
  
  static async generateStatsPrediction(history, weights) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
    return this.generateStaticFallback();
  }
  
  static async generateAdvancedPrediction(env, history, weights) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
    return this.generateStaticFallback();
  }
  
  static generateStaticFallback() {
    // ... ä¿æŒåŸæœ‰å®ç° ...
    return {
      nextExpect: "2025001",
      zodiac: { main: ["é¼ ", "é¾™", "çŒ´"], guard: ["ç‰›", "è›‡"], scores: {} },
      color: { main: "red", guard: "blue", scores: {} },
      head: "0å¤´",
      shape: "å°å•",
      specialNumbers: [
        { number: 1, score: 50, probability: 0.1, zodiac: "è›‡", color: "red" },
        { number: 13, score: 45, probability: 0.09, zodiac: "è›‡", color: "blue" },
        { number: 25, score: 40, probability: 0.08, zodiac: "è›‡", color: "green" },
        { number: 37, score: 35, probability: 0.07, zodiac: "è›‡", color: "red" },
        { number: 49, score: 30, probability: 0.06, zodiac: "è›‡", color: "blue" }
      ],
      normalNumbers: [
        { number: 2, zodiac: "é¾™", color: "red", score: 45, probability: 0.05 },
        { number: 3, zodiac: "å…”", color: "blue", score: 40, probability: 0.04 },
        { number: 4, zodiac: "è™", color: "blue", score: 35, probability: 0.03 },
        { number: 5, zodiac: "ç‰›", color: "green", score: 30, probability: 0.02 },
        { number: 6, zodiac: "é¼ ", color: "green", score: 25, probability: 0.01 },
        { number: 7, zodiac: "çŒª", color: "red", score: 20, probability: 0.01 }
      ],
      confidence: 10,
      analysisBased: false,
      algorithmUsed: "emergency",
      totalHistoryRecords: 0,
      generatedAt: new Date().toISOString(),
      algorithmVersion: "V12.4-Emergency"
    };
  }
}

// ==============================================================================
// 11. æ¶ˆæ¯æ¸²æŸ“å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰
// ==============================================================================

class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME} - å‘½ä»¤æ¨¡æ¿</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `${CONFIG.EMOJI.refresh} <i>é˜²åˆ·å±æ¨¡å¼ï¼Œæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</i>\n\n`;
      
      message += `<b>${CONFIG.EMOJI.magic} ä¸»è¦å‘½ä»¤ï¼š</b>\n`;
      message += `<code>/predict</code> - ä¼ ç»Ÿç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict knn</code> - KNNç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict stats</code> - ç»Ÿè®¡ç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹ï¼ˆæ•´åˆå…¨éƒ¨ç®—æ³•ï¼‰${CONFIG.EMOJI.crown}\n`;
      message += `<code>/predict personalized</code> - ä¸ªæ€§åŒ–é¢„æµ‹ï¼ˆåŸºäºæ‚¨çš„åå¥½ï¼‰${CONFIG.EMOJI.personal}\n`;
      message += `<code>/history [é¡µç ]</code> - æŸ¥çœ‹å†å²è®°å½•\n`;
      message += `<code>/stats</code> - ç»Ÿè®¡åˆ†ææŠ¥å‘Š${CONFIG.EMOJI.chart}\n`;
      message += `<code>/profile</code> - æŸ¥çœ‹ä¸ªäººèµ„æ–™${CONFIG.EMOJI.user}\n`;
      message += `<code>/feedback æœŸå· è¯„åˆ†</code> - åé¦ˆé¢„æµ‹ç»“æœ${CONFIG.EMOJI.feedback}\n`;
      message += `<code>/ccc</code> - æ˜¾ç¤ºæ­¤å‘½ä»¤æ¨¡æ¿\n`;
      
      message += `\n<b>${CONFIG.EMOJI.bar_chart} å¯è§†åŒ–æŠ¥å‘Šï¼š</b>\n`;
      message += `<code>/stats detailed</code> - è¯¦ç»†ç»Ÿè®¡æŠ¥å‘Š\n`;
      message += `<code>/stats numbers</code> - å·ç åˆ†å¸ƒåˆ†æ\n`;
      message += `<code>/stats zodiac</code> - ç”Ÿè‚–åˆ†æ\n`;
      message += `<code>/stats color</code> - æ³¢è‰²åˆ†æ\n`;
      message += `<code>/stats trend</code> - è¶‹åŠ¿åˆ†æ\n`;
      
      if (isAdmin) {
        message += `\n<b>${CONFIG.EMOJI.lock} ç®¡ç†å‘˜å‘½ä»¤ï¼š</b>\n`;
        message += `<code>/sync</code> - åŒæ­¥å†å²æ•°æ®\n`;
        message += `<code>/push</code> - æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
        message += `<code>/delete [æœŸå·]</code> - åˆ é™¤å•æœŸè®°å½•\n`;
      }
      
      message += `\n<b>${CONFIG.EMOJI.crystal_ball} å¢å¼ºé¢„æµ‹ç®—æ³•ï¼š</b>\n`;
      message += `${CONFIG.EMOJI.brain} ä¼ ç»Ÿç®—æ³• - åŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°\n`;
      message += `${CONFIG.EMOJI.knn} KNNç®—æ³• - K-è¿‘é‚»ç®—æ³•ï¼Œå¯»æ‰¾ç›¸ä¼¼å†å²\n`;
      message += `${CONFIG.EMOJI.statistics} ç»Ÿè®¡ç®—æ³• - ç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ã€å¤´æ•°ã€å¤§å°ã€å•åŒå…¨é¢ç»Ÿè®¡\n`;
      message += `${CONFIG.EMOJI.crown} å¢å¼ºé¢„æµ‹ - æ•´åˆæ‰€æœ‰ç®—æ³•çš„æœ€å¼ºé¢„æµ‹\n`;
      message += `${CONFIG.EMOJI.personal} ä¸ªæ€§åŒ–é¢„æµ‹ - åŸºäºæ‚¨çš„å†å²åé¦ˆå’Œåå¥½\n`;
      
      message += `\n<b>${CONFIG.EMOJI.rocket} ä½¿ç”¨ç¤ºä¾‹ï¼š</b>\n`;
      message += `<code>/predict</code> - ä¼ ç»Ÿç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict knn</code> - KNNç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict stats</code> - ç»Ÿè®¡ç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹ï¼ˆæ¨èï¼‰\n`;
      message += `<code>/predict personalized</code> - ä¸ªæ€§åŒ–é¢„æµ‹${CONFIG.EMOJI.rocket}\n`;
      message += `<code>/history 1</code> - æŸ¥çœ‹ç¬¬1é¡µå†å²\n`;
      message += `<code>/stats</code> - æŸ¥çœ‹ç»Ÿè®¡æŠ¥å‘Š\n`;
      message += `<code>/feedback 2025001 5</code> - åé¦ˆç¬¬2025001æœŸé¢„æµ‹è¯„åˆ†ä¸º5\n`;
      
      message += `\n${CONFIG.EMOJI.atom} <b>æ–°å¢ç‰¹æ€§ï¼š</b>\n`;
      message += `${CONFIG.EMOJI.personal} ç”¨æˆ·ä¸ªæ€§åŒ– - æ ¹æ®æ‚¨çš„åå¥½è°ƒæ•´ç®—æ³•æƒé‡\n`;
      message += `${CONFIG.EMOJI.chart} å¯è§†åŒ–æŠ¥å‘Š - æ–‡æœ¬å›¾è¡¨å’Œç»Ÿè®¡åˆ†æ\n`;
      message += `${CONFIG.EMOJI.feedback} åé¦ˆç³»ç»Ÿ - è®°å½•é¢„æµ‹å‡†ç¡®æ€§\n`;
      message += `${CONFIG.EMOJI.user} ä¸ªäººèµ„æ–™ - æŸ¥çœ‹æ‚¨çš„ä½¿ç”¨ç»Ÿè®¡\n`;
      message += `${CONFIG.EMOJI.bar_chart} æ•°æ®å¯è§†åŒ– - ASCIIå›¾è¡¨å±•ç¤ºç»Ÿè®¡\n`;
      
      message += `\n${CONFIG.EMOJI.refresh} <b>é˜²åˆ·å±ç‰¹æ€§ï¼š</b>\n`;
      message += `${CONFIG.EMOJI.trash} æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `${CONFIG.EMOJI.repeat} å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `${CONFIG.EMOJI.eye} ä¿æŒèŠå¤©ç•Œé¢æ•´æ´\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å‘½ä»¤æ¨¡æ¿å¤±è´¥", error);
      return `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME}</b>\n\nä½¿ç”¨ /ccc æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨ã€‚`;
    }
  }
  
  static renderPrediction(prediction) {
    // ... ä¿æŒåŸæœ‰å®ç°ï¼Œå¢åŠ ä¸ªæ€§åŒ–æ ‡è®° ...
    if (prediction.personalized) {
      // æ·»åŠ ä¸ªæ€§åŒ–ä¿¡æ¯
      let personalizedInfo = "";
      if (prediction.personalizationInfo?.isPersonalized) {
        personalizedInfo = `\n${CONFIG.EMOJI.personal} <b>ä¸ªæ€§åŒ–é¢„æµ‹</b> (åŸºäº${prediction.personalizationInfo.feedbackCount}æ¬¡åé¦ˆ)\n`;
      }
      // ... å…¶ä»–æ¸²æŸ“é€»è¾‘ ...
    }
    return "é¢„æµ‹æ¸²æŸ“å†…å®¹...";
  }
  
  static renderProfile(env, userId, userStats, behaviorStats) {
    try {
      let profile = `${CONFIG.EMOJI.profile} <b>æ‚¨çš„ä¸ªäººèµ„æ–™</b>\n\n`;
      
      profile += `${CONFIG.EMOJI.id} <b>ç”¨æˆ·ID</b>: ${userId}\n\n`;
      
      // åé¦ˆç»Ÿè®¡
      profile += `${CONFIG.EMOJI.feedback} <b>åé¦ˆç»Ÿè®¡</b>\n`;
      profile += `â€¢ æ€»åé¦ˆæ¬¡æ•°: ${userStats.totalFeedback || 0}\n`;
      profile += `â€¢ å¹³å‡è¯„åˆ†: ${userStats.averageScore.toFixed(1)}/5.0\n`;
      profile += `â€¢ æ­£é¢åé¦ˆ: ${userStats.positiveCount || 0}\n`;
      profile += `â€¢ è´Ÿé¢åé¦ˆ: ${userStats.negativeCount || 0}\n`;
      
      if (userStats.firstFeedback) {
        profile += `â€¢ é¦–æ¬¡åé¦ˆ: ${userStats.firstFeedback.substr(0, 10)}\n`;
      }
      if (userStats.lastFeedback) {
        profile += `â€¢ æœ€è¿‘åé¦ˆ: ${userStats.lastFeedback.substr(0, 10)}\n`;
      }
      
      profile += `\n`;
      
      // è¡Œä¸ºç»Ÿè®¡
      if (behaviorStats && behaviorStats.totalStats) {
        profile += `${CONFIG.EMOJI.history2} <b>ä½¿ç”¨ç»Ÿè®¡</b>\n`;
        Object.entries(behaviorStats.totalStats).forEach(([action, count]) => {
          const actionName = this.getActionName(action);
          profile += `â€¢ ${actionName}: ${count}æ¬¡\n`;
        });
        profile += `â€¢ åˆ†æå¤©æ•°: ${behaviorStats.daysAnalyzed}å¤©\n`;
      }
      
      profile += `\n`;
      
      // ä¸ªæ€§åŒ–çŠ¶æ€
      const isPersonalized = userStats.totalFeedback >= CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION;
      profile += `${CONFIG.EMOJI.personal} <b>ä¸ªæ€§åŒ–çŠ¶æ€</b>\n`;
      profile += `â€¢ ä¸ªæ€§åŒ–: ${isPersonalized ? CONFIG.EMOJI.check + " å·²å¯ç”¨" : CONFIG.EMOJI.warning + " æœªå¯ç”¨"}\n`;
      profile += `â€¢ æ‰€éœ€åé¦ˆ: ${userStats.totalFeedback || 0}/${CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION}\n`;
      
      if (isPersonalized && userStats.preferences) {
        const prefs = userStats.preferences;
        profile += `\n${CONFIG.EMOJI.settings} <b>æ‚¨çš„åå¥½</b>\n`;
        
        if (prefs.zodiacs && prefs.zodiacs.length > 0) {
          profile += `â€¢ åå¥½ç”Ÿè‚–: ${prefs.zodiacs.join(", ")}\n`;
        }
        
        if (prefs.colors && prefs.colors.length > 0) {
          const colorEmojis = prefs.colors.map(c => CONFIG.EMOJI[c]).join("");
          profile += `â€¢ åå¥½æ³¢è‰²: ${colorEmojis}\n`;
        }
        
        if (prefs.tails && prefs.tails.length > 0) {
          profile += `â€¢ åå¥½å°¾æ•°: ${prefs.tails.join(", ")}\n`;
        }
        
        if (prefs.size) {
          profile += `â€¢ åå¥½å¤§å°: ${prefs.size}\n`;
        }
        
        if (prefs.oddEven) {
          profile += `â€¢ åå¥½å•åŒ: ${prefs.oddEven}\n`;
        }
      }
      
      profile += `\n${CONFIG.EMOJI.bulb} <b>å»ºè®®</b>\n`;
      if (!isPersonalized) {
        const needed = CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION - (userStats.totalFeedback || 0);
        profile += `â€¢ è¿˜éœ€è¦ ${needed} æ¬¡åé¦ˆæ¥å¯ç”¨ä¸ªæ€§åŒ–é¢„æµ‹\n`;
        profile += `â€¢ ä½¿ç”¨ <code>/feedback æœŸå· è¯„åˆ†</code> åé¦ˆé¢„æµ‹ç»“æœ\n`;
      } else {
        profile += `â€¢ ä½¿ç”¨ <code>/predict personalized</code> è·å–ä¸ªæ€§åŒ–é¢„æµ‹\n`;
        profile += `â€¢ ç»§ç»­åé¦ˆå¯ä»¥æé«˜é¢„æµ‹å‡†ç¡®æ€§\n`;
      }
      
      profile += `\n${CONFIG.EMOJI.info} <b>ç›¸å…³å‘½ä»¤</b>\n`;
      profile += `<code>/predict personalized</code> - ä¸ªæ€§åŒ–é¢„æµ‹\n`;
      profile += `<code>/feedback æœŸå· è¯„åˆ†</code> - åé¦ˆé¢„æµ‹ç»“æœ\n`;
      profile += `<code>/stats</code> - æŸ¥çœ‹ç»Ÿè®¡æŠ¥å‘Š\n`;
      
      return profile;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“ä¸ªäººèµ„æ–™å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} è·å–ä¸ªäººèµ„æ–™å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }
  
  static getActionName(actionType) {
    const actionMap = {
      "traditional_prediction": "ä¼ ç»Ÿé¢„æµ‹",
      "knn_prediction": "KNNé¢„æµ‹",
      "stats_prediction": "ç»Ÿè®¡é¢„æµ‹",
      "advanced_prediction": "å¢å¼ºé¢„æµ‹",
      "personalized_prediction": "ä¸ªæ€§åŒ–é¢„æµ‹",
      "history_view": "æŸ¥çœ‹å†å²",
      "feedback_submitted": "æäº¤åé¦ˆ",
      "profile_view": "æŸ¥çœ‹èµ„æ–™",
      "stats_view": "æŸ¥çœ‹ç»Ÿè®¡"
    };
    
    return actionMap[actionType] || actionType;
  }
  
  static renderStatsReport(env, history, reportType = "comprehensive", userId = null) {
    try {
      let report = "";
      
      switch (reportType.toLowerCase()) {
        case "detailed":
        case "comprehensive":
          let userStats = null;
          if (userId) {
            userStats = await DB.getUserFeedbackStats(env, userId);
            const prefs = await DB.getUserPreferences(env, userId);
            if (prefs) {
              userStats.preferences = {
                zodiacs: JSON.parse(prefs.preferred_zodiacs || "[]"),
                colors: JSON.parse(prefs.preferred_colors || "[]"),
                tails: JSON.parse(prefs.preferred_tails || "[]"),
                size: prefs.preferred_size,
                oddEven: prefs.preferred_odd_even
              };
            }
          }
          report = VisualizationReport.generateComprehensiveReport(history, userStats);
          break;
          
        case "numbers":
          report = VisualizationReport.generateNumberDistributionChart(history, 15);
          break;
          
        case "zodiac":
          report = VisualizationReport.generateZodiacAnalysisChart(history);
          break;
          
        case "color":
          report = VisualizationReport.generateColorAnalysisChart(history);
          break;
          
        case "tail":
          report = VisualizationReport.generateTailAnalysisChart(history);
          break;
          
        case "trend":
          report = VisualizationReport.generateTrendAnalysis(history, Math.min(30, history.length));
          break;
          
        case "size":
          report = VisualizationReport.generateSizeOddEvenAnalysis(history);
          break;
          
        default:
          report = `${CONFIG.EMOJI.warning} <b>æ— æ•ˆçš„æŠ¥å‘Šç±»å‹</b>\n\n`;
          report += `å¯ç”¨ç±»å‹: comprehensive, numbers, zodiac, color, tail, trend, size\n`;
          report += `ç¤ºä¾‹: <code>/stats trend</code>\n`;
          break;
      }
      
      return report;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“ç»Ÿè®¡æŠ¥å‘Šå¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Šå¤±è´¥ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }
  
  static renderFeedbackResult(success, feedbackData) {
    try {
      if (success) {
        let message = `${CONFIG.EMOJI.feedback} <b>åé¦ˆå·²è®°å½•</b>\n\n`;
        message += `${CONFIG.EMOJI.check} æ„Ÿè°¢æ‚¨çš„åé¦ˆï¼\n\n`;
        
        if (feedbackData) {
          message += `${CONFIG.EMOJI.info} <b>åé¦ˆè¯¦æƒ…</b>\n`;
          message += `â€¢ æœŸå·: ${feedbackData.expect || "æœªçŸ¥"}\n`;
          message += `â€¢ è¯„åˆ†: ${feedbackData.feedbackScore}/5\n`;
          
          if (feedbackData.feedbackText) {
            message += `â€¢ å¤‡æ³¨: ${feedbackData.feedbackText}\n`;
          }
          
          // æ˜¾ç¤ºä¸ªæ€§åŒ–è¿›åº¦
          if (feedbackData.totalFeedback !== undefined) {
            const needed = CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION;
            const remaining = Math.max(0, needed - feedbackData.totalFeedback);
            
            message += `\n${CONFIG.EMOJI.personal} <b>ä¸ªæ€§åŒ–è¿›åº¦</b>\n`;
            message += `â€¢ æ€»åé¦ˆ: ${feedbackData.totalFeedback}æ¬¡\n`;
            
            if (remaining > 0) {
              message += `â€¢ è¿˜éœ€ ${remaining} æ¬¡åé¦ˆå¯ç”¨ä¸ªæ€§åŒ–é¢„æµ‹\n`;
              const progressBar = Formatter.generateASCIIBar(
                feedbackData.totalFeedback, 
                needed, 
                15, 
                false
              );
              message += `â€¢ è¿›åº¦: ${progressBar}\n`;
            } else {
              message += `â€¢ ä¸ªæ€§åŒ–é¢„æµ‹å·²å¯ç”¨ ${CONFIG.EMOJI.check}\n`;
            }
          }
        }
        
        message += `\n${CONFIG.EMOJI.bulb} <b>å»ºè®®</b>\n`;
        message += `â€¢ ä½¿ç”¨ <code>/predict personalized</code> è·å–ä¸ªæ€§åŒ–é¢„æµ‹\n`;
        message += `â€¢ ä½¿ç”¨ <code>/profile</code> æŸ¥çœ‹æ‚¨çš„ä¸ªäººèµ„æ–™\n`;
        
        return message;
      } else {
        return `${CONFIG.EMOJI.warning} <b>åé¦ˆå¤±è´¥</b>\n\nè¯·æ£€æŸ¥æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚\næ­£ç¡®æ ¼å¼: <code>/feedback æœŸå· è¯„åˆ† [å¤‡æ³¨]</code>\nç¤ºä¾‹: <code>/feedback 2025001 5 é¢„æµ‹å‡†ç¡®</code>`;
      }
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åé¦ˆç»“æœå¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†åé¦ˆæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }
  
  // å…¶ä»–æ¸²æŸ“æ–¹æ³•ä¿æŒä¸å˜...
}

// ==============================================================================
// 12. å¤–éƒ¨æ¥å£å°è£…
// ==============================================================================

class ExternalService {
  // ... ä¿æŒåŸæœ‰å®ç° ...
}

// ==============================================================================
// 13. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ï¼ˆæ–°å¢ä¸ªæ€§åŒ–åŠŸèƒ½ï¼‰
// ==============================================================================

class Controller {
  static pendingDeletions = new Map();

  // å¤„ç†å¼€å§‹å‘½ä»¤
  static async handleStart(env, chatId, isAdmin, userId) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
      // è®°å½•ç”¨æˆ·è¡Œä¸º
      await DB.logUserBehavior(env, userId, "start_command", {});
    } catch (error) {
      Logger.error("Controller", "å¤„ç†startå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  // å¤„ç†å‘½ä»¤æ¨¡æ¿
  static async handleCommandTemplate(env, chatId, isAdmin, userId) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
      // è®°å½•ç”¨æˆ·è¡Œä¸º
      await DB.logUserBehavior(env, userId, "command_template_view", {});
    } catch (error) {
      Logger.error("Controller", "å¤„ç†cccå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  // å¤„ç†é¢„æµ‹
  static async handlePredict(env, chatId, algorithm = "traditional", userId) {
    try {
      // è®°å½•ç”¨æˆ·è¡Œä¸º
      await DB.logUserBehavior(env, userId, `${algorithm}_prediction`, {});
      
      const algorithmName = CONFIG.ALGORITHM_NAMES[algorithm] || "ä¼ ç»Ÿç®—æ³•";
      
      const processingMessage = `${CONFIG.EMOJI.hourglass} <b>æ­£åœ¨ç”Ÿæˆé¢„æµ‹...</b>\n\nç®—æ³•: ${algorithmName}\næ•°æ®: å…¨éƒ¨å†å²è®°å½•\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      // ç”Ÿæˆé¢„æµ‹
      const prediction = await PredictionEngine.generate(
        env, 
        history, 
        weights, 
        algorithm, 
        algorithm === "personalized" ? userId : null
      );
      
      if (!prediction) {
        const message = "âŒ <b>é¢„æµ‹ç”Ÿæˆå¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const message = MessageRenderer.renderPrediction(prediction);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, 
        algorithm === "personalized" ? CONFIG.COMMAND_TYPES.PERSONALIZED : CONFIG.COMMAND_TYPES.PREDICT, 
        message
      );
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†predictå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>ç”Ÿæˆé¢„æµ‹å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message || "æœªçŸ¥é”™è¯¯"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†ç»Ÿè®¡æŠ¥å‘Š
  static async handleStats(env, chatId, reportType = "comprehensive", userId) {
    try {
      // è®°å½•ç”¨æˆ·è¡Œä¸º
      await DB.logUserBehavior(env, userId, "stats_view", { reportType });
      
      const processingMessage = `${CONFIG.EMOJI.bar_chart} <b>æ­£åœ¨ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š...</b>\n\næŠ¥å‘Šç±»å‹: ${reportType}\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATS, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Šã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.STATS, message
        );
        return;
      }
      
      const message = await MessageRenderer.renderStatsReport(env, history, reportType, userId);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATS, message
      );
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†statså‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Šå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message || "æœªçŸ¥é”™è¯¯"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†ä¸ªäººèµ„æ–™
  static async handleProfile(env, chatId, userId) {
    try {
      // è®°å½•ç”¨æˆ·è¡Œä¸º
      await DB.logUserBehavior(env, userId, "profile_view", {});
      
      const processingMessage = `${CONFIG.EMOJI.profile} <b>æ­£åœ¨è·å–ä¸ªäººèµ„æ–™...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PROFILE, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      // è·å–ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
      const userStats = await DB.getUserFeedbackStats(env, userId);
      const behaviorStats = await DB.getUserBehaviorStats(env, userId, 30);
      
      const message = MessageRenderer.renderProfile(env, userId, userStats, behaviorStats);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PROFILE, message
      );
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†profileå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>è·å–ä¸ªäººèµ„æ–™å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message || "æœªçŸ¥é”™è¯¯"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PROFILE, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†åé¦ˆ
  static async handleFeedback(env, chatId, userId, commandText) {
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 3) {
        const message = `${CONFIG.EMOJI.warning} <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\næ­£ç¡®æ ¼å¼: <code>/feedback æœŸå· è¯„åˆ† [å¤‡æ³¨]</code>\nç¤ºä¾‹: <code>/feedback 2025001 5 é¢„æµ‹å‡†ç¡®</code>\n\nè¯„åˆ†èŒƒå›´: 1-5 (5è¡¨ç¤ºæœ€å‡†ç¡®)`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expect = parts[1];
      const score = Formatter.safeInt(parts[2], 0);
      const feedbackText = parts.slice(3).join(" ") || "";
      
      if (!Formatter.isValidExpect(expect)) {
        const message = `${CONFIG.EMOJI.warning} <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\næœŸå·åº”ä¸º7ä½æ•°å­—ï¼Œä¾‹å¦‚: 2025001`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      if (score < 1 || score > 5) {
        const message = `${CONFIG.EMOJI.warning} <b>è¯„åˆ†èŒƒå›´é”™è¯¯</b>\n\nè¯„åˆ†åº”ä¸º1-5ä¹‹é—´çš„æ•´æ•°`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      // æ£€æŸ¥è¯¥æœŸæ˜¯å¦å­˜åœ¨
      const exists = await DB.checkExpectExists(env, expect);
      if (!exists) {
        const message = `${CONFIG.EMOJI.warning} <b>æœŸå·ä¸å­˜åœ¨</b>\n\næ•°æ®åº“ä¸­ä¸å­˜åœ¨ç¬¬ ${expect} æœŸçš„å¼€å¥–è®°å½•`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      // ä¿å­˜åé¦ˆ
      const feedbackData = {
        expect: expect,
        feedbackScore: score,
        feedbackText: feedbackText,
        algorithmUsed: "unknown", // å®é™…ä½¿ç”¨ä¸­éœ€è¦è®°å½•ä½¿ç”¨çš„ç®—æ³•
        actualNumbers: "" // å®é™…å¼€å¥–å·ç 
      };
      
      const result = await DB.saveUserFeedback(env, userId, feedbackData);
      
      if (result.success) {
        // è·å–æ›´æ–°åçš„ç»Ÿè®¡
        const userStats = await DB.getUserFeedbackStats(env, userId);
        
        const feedbackResult = MessageRenderer.renderFeedbackResult(true, {
          expect: expect,
          feedbackScore: score,
          feedbackText: feedbackText,
          totalFeedback: userStats.totalFeedback
        });
        
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, feedbackResult
        );
        
        // è®°å½•ç”¨æˆ·è¡Œä¸º
        await DB.logUserBehavior(env, userId, "feedback_submitted", {
          expect: expect,
          score: score,
          textLength: feedbackText.length
        });
      } else {
        const message = `${CONFIG.EMOJI.warning} <b>ä¿å­˜åé¦ˆå¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚`;
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, message
        );
      }
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†feedbackå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>å¤„ç†åé¦ˆå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message || "æœªçŸ¥é”™è¯¯"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.FEEDBACK, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å…¶ä»–å¤„ç†æ–¹æ³•ä¿æŒä¸å˜...
  static async handleHistory(env, chatId, pageStr = "1", userId) {
    // ... ä¿æŒåŸæœ‰å®ç°ï¼Œæ·»åŠ ç”¨æˆ·è¡Œä¸ºè®°å½• ...
  }
  
  static async handleSync(env, chatId, isAdmin, userId) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
  }
  
  static async handlePush(env, chatId, isAdmin, userId) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
  }
  
  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
  }
  
  static async confirmDelete(env, chatId, userId, confirmText) {
    // ... ä¿æŒåŸæœ‰å®ç° ...
  }
}

// ==============================================================================
// 14. äº‹ä»¶å¤„ç†å™¨
// ==============================================================================

async function handleUpdate(env, payload) {
  try {
    // è‡ªåŠ¨æ¸…ç†
    if (Math.random() < 0.01) {
      MessageManager.autoCleanup();
    }
    
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId, isAdmin });
    
    // å¤„ç†ç¡®è®¤åˆ é™¤
    if (text.startsWith('ç¡®è®¤åˆ é™¤ ')) {
      if (isAdmin) {
        await Controller.confirmDelete(env, chatId, userId, text);
      } else {
        const message = "âŒ <b>æƒé™ä¸è¶³</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, "permission_error", message
        );
      }
      return;
    }
    
    // å¤„ç†å‘½ä»¤
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin, userId);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin, userId);
          break;
          
        case '/predict':
        case '/p':
          // æ£€æŸ¥ç®—æ³•å‚æ•°
          const predictMatch = text.match(/\/predict\s+(knn|stats|advanced|personalized)/i);
          if (predictMatch) {
            await Controller.handlePredict(env, chatId, predictMatch[1].toLowerCase(), userId);
          } else {
            await Controller.handlePredict(env, chatId, "traditional", userId);
          }
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page, userId);
          break;
          
        case '/stats':
          const statsMatch = text.match(/\/stats\s+(\w+)/i);
          const reportType = statsMatch ? statsMatch[1].toLowerCase() : "comprehensive";
          await Controller.handleStats(env, chatId, reportType, userId);
          break;
          
        case '/profile':
          await Controller.handleProfile(env, chatId, userId);
          break;
          
        case '/feedback':
          await Controller.handleFeedback(env, chatId, userId, text);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin, userId);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin, userId);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        default:
          await Controller.handleCommandTemplate(env, chatId, isAdmin, userId);
          break;
      }
    } else {
      await Controller.handleCommandTemplate(env, chatId, isAdmin, userId);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}

// ==============================================================================
// 15. Worker å…¥å£ç‚¹
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      // ç¯å¢ƒå˜é‡éªŒè¯
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const optionalEnvVars = ['TG_CHANNEL_ID', 'LOTTERY_DATA_URL'];
      
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(JSON.stringify({
          status: "ERROR",
          message: `Missing required environment variables: ${missingVars.join(', ')}`,
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      // æ£€æŸ¥å¯é€‰ç¯å¢ƒå˜é‡
      const optionalMissing = optionalEnvVars.filter(key => !env[key]);
      if (optionalMissing.length > 0) {
        Logger.warn("Worker", `ç¼ºå°‘å¯é€‰ç¯å¢ƒå˜é‡: ${optionalMissing.join(', ')}`);
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response(JSON.stringify({
          status: "ERROR",
          message: "Database Initialization Failed. Please check D1 binding.",
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const deletionStats = await DB.getDeletionStats(env);
            const systemFeedbackStats = await DB.getSystemFeedbackStats(env);
            
            const cacheStats = CacheManager.getStats();
            
            const messageManagerStats = {
              totalUsers: MessageManager.userMessages.size
            };
            
            const weights = await DB.getWeights(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              environment: {
                hasChannel: !!env.TG_CHANNEL_ID,
                hasLotteryUrl: !!env.LOTTERY_DATA_URL,
                requiredVars: requiredEnvVars.filter(k => env[k]).length + "/" + requiredEnvVars.length,
                optionalVars: optionalEnvVars.filter(k => env[k]).length + "/" + optionalEnvVars.length
              },
              database: {
                historyCount: historyCount,
                deletionStats: deletionStats,
                feedbackStats: systemFeedbackStats
              },
              cache: cacheStats,
              messageManager: messageManagerStats,
              algorithms: {
                weights: weights,
                traditional: "Enabled",
                knn: "Enabled",
                statistics: "Enabled",
                advanced: "Enabled",
                personalized: "Enabled"
              },
              personalization: {
                enabled: true,
                minFeedback: CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION,
                learningRate: CONFIG.SYSTEM.PERSONALIZATION.LEARNING_RATE
              },
              visualization: {
                enabled: true,
                chartWidth: CONFIG.SYSTEM.VISUALIZATION.CHART_WIDTH
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            OptimizedMonteCarloEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤",
              cleared: {
                cache: true,
                monteCarlo: true,
                messageManager: true
              }
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/test-personalization") {
          try {
            const testUserId = "test_user_123";
            
            // æµ‹è¯•ç”¨æˆ·åå¥½
            const personalizedData = await DB.getUserPersonalizedWeights(env, testUserId);
            
            // æµ‹è¯•å¯è§†åŒ–
            const history = await DB.getAllHistory(env);
            let visualizationTest = "æœªæµ‹è¯•";
            if (history.length >= 10) {
              visualizationTest = `å¯ç”Ÿæˆ ${history.length} æœŸæ•°æ®çš„æŠ¥å‘Š`;
            }
            
            return new Response(JSON.stringify({
              status: "OK",
              timestamp: new Date().toISOString(),
              personalization: {
                testUser: testUserId,
                isPersonalized: personalizedData.isPersonalized,
                feedbackCount: personalizedData.feedbackCount,
                weights: personalizedData.weights
              },
              visualization: {
                status: visualizationTest,
                features: ["å·ç åˆ†å¸ƒ", "ç”Ÿè‚–åˆ†æ", "æ³¢è‰²åˆ†æ", "å°¾æ•°åˆ†æ", "å¤§å°å•åŒåˆ†æ", "è¶‹åŠ¿åˆ†æ"]
              },
              commands: {
                personalized: "/predict personalized",
                stats: "/stats [type]",
                profile: "/profile",
                feedback: "/feedback æœŸå· è¯„åˆ†"
              }
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // ä¸»é¡µæ˜¾ç¤º
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .feature-list {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .feature-item {
                  margin-bottom: 10px;
                  color: #2d3748;
                }
                .feature-item:before {
                  content: "âœ… ";
                  margin-right: 8px;
                }
                .command-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .command {
                  margin-bottom: 8px;
                  color: #276749;
                  font-family: monospace;
                  background: #e6fffa;
                  padding: 5px 10px;
                  border-radius: 5px;
                  display: inline-block;
                }
                .personalization-info {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .visualization-info {
                  background: #fff5f5;
                  border: 1px solid #fc8181;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #742a2a;
                }
                .algorithm-knn { background: linear-gradient(45deg, #4299e1, #38b2ac); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-stats { background: linear-gradient(45deg, #ed8936, #f56565); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-advanced { background: linear-gradient(45deg, #9f7aea, #d53f8c); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-personalized { background: linear-gradient(45deg, #68d391, #38a169); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .new-feature {
                  background: linear-gradient(45deg, #d53f8c, #ed64a6);
                  color: white;
                  padding: 3px 8px;
                  border-radius: 4px;
                  font-weight: bold;
                  display: inline-block;
                  margin: 2px;
                  font-size: 0.7em;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION} - ä¸ªæ€§åŒ–ä¸å¯è§†åŒ–å¢å¼ºç‰ˆ</div>
                
                <div class="feature-list">
                  <h3>æ–°å¢ç‰¹æ€§ <span class="new-feature">NEW</span></h3>
                  <div class="feature-item"><span class="algorithm-personalized">ç”¨æˆ·ä¸ªæ€§åŒ–</span>ï¼šæ ¹æ®æ‚¨çš„å†å²åé¦ˆè°ƒæ•´ç®—æ³•æƒé‡</div>
                  <div class="feature-item"><span class="new-feature">å¯è§†åŒ–æŠ¥å‘Š</span>ï¼šæ–‡æœ¬å›¾è¡¨å±•ç¤ºç»Ÿè®¡åˆ†æ</div>
                  <div class="feature-item"><span class="new-feature">åé¦ˆç³»ç»Ÿ</span>ï¼šè®°å½•é¢„æµ‹å‡†ç¡®æ€§ï¼Œä¼˜åŒ–ä¸ªæ€§åŒ–</div>
                  <div class="feature-item"><span class="new-feature">ä¸ªäººèµ„æ–™</span>ï¼šæŸ¥çœ‹æ‚¨çš„ä½¿ç”¨ç»Ÿè®¡å’Œåå¥½</div>
                  <div class="feature-item"><span class="new-feature">ASCIIå›¾è¡¨</span>ï¼šæ–‡æœ¬å½¢å¼çš„æ•°æ®å¯è§†åŒ–</div>
                </div>
                
                <div class="command-list">
                  <h3>ä¸»è¦å‘½ä»¤</h3>
                  <div class="command">/start - æ¬¢è¿ä¿¡æ¯</div>
                  <div class="command">/ccc - æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿</div>
                  <div class="command">/predict - ä¼ ç»Ÿç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict knn - KNNç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict stats - ç»Ÿè®¡ç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict advanced - å¢å¼ºé¢„æµ‹</div>
                  <div class="command">/predict personalized - ä¸ªæ€§åŒ–é¢„æµ‹ <span class="new-feature">NEW</span></div>
                  <div class="command">/history [é¡µç ] - æŸ¥çœ‹å†å²</div>
                  <div class="command">/stats - ç»Ÿè®¡åˆ†ææŠ¥å‘Š <span class="new-feature">NEW</span></div>
                  <div class="command">/profile - æŸ¥çœ‹ä¸ªäººèµ„æ–™ <span class="new-feature">NEW</span></div>
                  <div class="command">/feedback æœŸå· è¯„åˆ† - åé¦ˆé¢„æµ‹ <span class="new-feature">NEW</span></div>
                  <div class="command">/sync - åŒæ­¥æ•°æ®(ç®¡ç†å‘˜)</div>
                  <div class="command">/delete [æœŸå·] - åˆ é™¤è®°å½•(ç®¡ç†å‘˜)</div>
                </div>
                
                <div class="personalization-info">
                  <strong>${CONFIG.EMOJI.personal} ä¸ªæ€§åŒ–é¢„æµ‹ç³»ç»Ÿï¼š</strong><br>
                  â€¢ æ ¹æ®æ‚¨çš„å†å²åé¦ˆè°ƒæ•´ç®—æ³•æƒé‡<br>
                  â€¢ å­¦ä¹ æ‚¨çš„åå¥½ï¼ˆç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ç­‰ï¼‰<br>
                  â€¢ åé¦ˆè¶Šå¤šï¼Œé¢„æµ‹è¶Šç²¾å‡†<br>
                  â€¢ æœ€å°‘éœ€è¦ ${CONFIG.SYSTEM.PERSONALIZATION.MIN_FEEDBACK_FOR_PERSONALIZATION} æ¬¡åé¦ˆå¯ç”¨<br>
                  â€¢ å‘½ä»¤: <code>/predict personalized</code><br>
                  â€¢ å‘½ä»¤: <code>/feedback æœŸå· è¯„åˆ†</code> æä¾›åé¦ˆ<br>
                  â€¢ å‘½ä»¤: <code>/profile</code> æŸ¥çœ‹ä¸ªäººèµ„æ–™
                </div>
                
                <div class="visualization-info">
                  <strong>${CONFIG.EMOJI.chart} å¯è§†åŒ–æŠ¥å‘Šç³»ç»Ÿï¼š</strong><br>
                  â€¢ ASCIIå›¾è¡¨å±•ç¤ºæ•°æ®åˆ†å¸ƒ<br>
                  â€¢ å…¨é¢ç»Ÿè®¡æŠ¥å‘Šï¼ˆå·ç ã€ç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ç­‰ï¼‰<br>
                  â€¢ è¶‹åŠ¿åˆ†æå’Œæ¨¡å¼è¯†åˆ«<br>
                  â€¢ ä¸ªæ€§åŒ–åˆ†ææŠ¥å‘Š<br>
                  â€¢ å‘½ä»¤: <code>/stats</code> - ç»¼åˆæŠ¥å‘Š<br>
                  â€¢ å‘½ä»¤: <code>/stats numbers</code> - å·ç åˆ†å¸ƒ<br>
                  â€¢ å‘½ä»¤: <code>/stats zodiac</code> - ç”Ÿè‚–åˆ†æ<br>
                  â€¢ å‘½ä»¤: <code>/stats color</code> - æ³¢è‰²åˆ†æ<br>
                  â€¢ å‘½ä»¤: <code>/stats trend</code> - è¶‹åŠ¿åˆ†æ<br>
                  â€¢ å‘½ä»¤: <code>/stats tail</code> - å°¾æ•°åˆ†æ<br>
                  â€¢ å‘½ä»¤: <code>/stats size</code> - å¤§å°å•åŒåˆ†æ
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 8px;">
                  <strong>ä½¿ç”¨å»ºè®®ï¼š</strong><br>
                  â€¢ é¦–æ¬¡ä½¿ç”¨è¯·å…ˆæ‰§è¡Œ <code>/sync</code> åŒæ­¥å†å²æ•°æ®<br>
                  â€¢ ä½¿ç”¨ <code>/feedback</code> æä¾›åé¦ˆä»¥å¯ç”¨ä¸ªæ€§åŒ–<br>
                  â€¢ æ¨èä½¿ç”¨ <code>/predict personalized</code> è·å–ä¸ªæ€§åŒ–é¢„æµ‹<br>
                  â€¢ ä½¿ç”¨ <code>/stats</code> æŸ¥çœ‹è¯¦ç»†ç»Ÿè®¡åˆ†æ<br>
                  â€¢ å®šæœŸåé¦ˆå¯ä»¥æé«˜é¢„æµ‹å‡†ç¡®æ€§<br>
                  â€¢ ç¡®ä¿ç¯å¢ƒå˜é‡é…ç½®æ­£ç¡®
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response(JSON.stringify({
        status: "ERROR",
        error: "Internal Server Error",
        message: error.message,
        system: CONFIG.SYSTEM.NAME,
        version: CONFIG.SYSTEM.VERSION
      }, null, 2), { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
};
