export default {
    async fetch(request, env, ctx) {
        const url = new URL(request.url);
        const pathname = url.pathname;
        
        console.log(`[${new Date().toISOString()}] è¯·æ±‚è·¯å¾„: ${pathname}, æ–¹æ³•: ${request.method}`);
        
        // å¤„ç† OPTIONS è¯·æ±‚ï¼ˆCORS é¢„æ£€ï¼‰
        if (request.method === 'OPTIONS') {
            return handleCORS();
        }
        
        // è·¯ç”±å¤„ç†
        if (pathname === '/init-db' && request.method === 'GET') {
            return await handleInitDB(env);
        }
        
        if (pathname === '/test-db' && request.method === 'GET') {
            return await testDBConnection(env);
        }
        
        if (pathname === '/telegram-webhook' && request.method === 'POST') {
            return await handleTelegramWebhook(request, env);
        }
        
        // ç®¡ç†æ¥å£ - éœ€è¦APIå¯†é’¥éªŒè¯
        if (pathname === '/admin/import' && request.method === 'POST') {
            return await handleAdminImport(request, env);
        }
        
        if (pathname === '/admin/records' && request.method === 'GET') {
            return await handleListRecords(request, env);
        }
        
        if (pathname.startsWith('/admin/record/') && request.method === 'GET') {
            return await handleGetRecord(request, env, pathname);
        }
        
        if (pathname.startsWith('/admin/record/') && request.method === 'PUT') {
            return await handleUpdateRecord(request, env, pathname);
        }
        
        if (pathname.startsWith('/admin/record/') && request.method === 'DELETE') {
            return await handleDeleteRecord(request, env, pathname);
        }
        
        if (pathname.startsWith('/history/')) {
            return await handleHistoryAPI(request, env, pathname);
        }
        
        if (pathname === '/health' || pathname === '/status') {
            return await handleHealthCheck(env);
        }
        
        if (pathname === '/test' || pathname === '/ping') {
            return new Response(JSON.stringify({
                status: 'ok',
                message: 'Worker is running',
                timestamp: new Date().toISOString(),
                environment: {
                    hasDB: !!env.DB,
                    hasTelegramToken: !!env.TELEGRAM_BOT_TOKEN
                }
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // æ ¹è·¯å¾„è¿”å› API æ–‡æ¡£
        return new Response(JSON.stringify({
            result: true,
            message: 'å½©ç¥¨å¼€å¥–è®°å½• API',
            endpoints: {
                init_db: '/init-db (GET, åˆå§‹åŒ–æ•°æ®åº“)',
                test_db: '/test-db (GET, æµ‹è¯•æ•°æ®åº“è¿æ¥)',
                health_check: '/health (GET, å¥åº·æ£€æŸ¥)',
                test: '/test (GET, æµ‹è¯•Worker)',
                telegram_webhook: '/telegram-webhook (POST)',
                history_api: '/history/{type}/y/{year}',
                admin_list: '/admin/records (GET, éœ€è¦APIå¯†é’¥)',
                admin_get: '/admin/record/{expect} (GET, éœ€è¦APIå¯†é’¥)',
                admin_update: '/admin/record/{expect} (PUT, éœ€è¦APIå¯†é’¥)',
                admin_delete: '/admin/record/{expect} (DELETE, éœ€è¦APIå¯†é’¥)',
                admin_import: '/admin/import (POST, éœ€è¦APIå¯†é’¥)'
            },
            examples: {
                get_2025_history: '/history/macaujc2/y/2025',
                get_current_year: '/history/macaujc2/y/' + new Date().getFullYear(),
                get_record: '/admin/record/2025127',
                update_record: 'PUT /admin/record/2025127',
                delete_record: 'DELETE /admin/record/2025127'
            }
        }, null, 2), {
            headers: { 
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            }
        });
    }
};

// CORS å¤„ç†
function handleCORS() {
    return new Response(null, {
        status: 204,
        headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, X-API-Key, Authorization',
            'Access-Control-Max-Age': '86400'
        }
    });
}

// éªŒè¯APIå¯†é’¥
function validateApiKey(request, env) {
    const apiKey = request.headers.get('X-API-Key');
    if (!env.ADMIN_API_KEY) {
        return { valid: false, message: 'æœåŠ¡å™¨æœªé…ç½®APIå¯†é’¥' };
    }
    if (!apiKey) {
        return { valid: false, message: 'ç¼ºå°‘APIå¯†é’¥' };
    }
    if (apiKey !== env.ADMIN_API_KEY) {
        return { valid: false, message: 'æ— æ•ˆçš„APIå¯†é’¥' };
    }
    return { valid: true };
}

// æµ‹è¯•æ•°æ®åº“è¿æ¥
async function testDBConnection(env) {
    try {
        if (!env.DB) {
            return jsonResponse({
                result: false,
                message: 'æ•°æ®åº“ç»‘å®šä¸å­˜åœ¨'
            }, 500);
        }
        
        // æµ‹è¯•1: ç®€å•æŸ¥è¯¢
        console.log('æµ‹è¯•1: æ‰§è¡Œç®€å•æŸ¥è¯¢...');
        const test1 = await env.DB.prepare('SELECT 1 as test_value').first();
        
        // æµ‹è¯•2: æŸ¥è¯¢ç°æœ‰è¡¨
        console.log('æµ‹è¯•2: æŸ¥è¯¢ç°æœ‰è¡¨...');
        const test2 = await env.DB.prepare(
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
        ).all();
        
        // æµ‹è¯•3: æŸ¥çœ‹æ•°æ®åº“ä¿¡æ¯
        console.log('æµ‹è¯•3: æŸ¥çœ‹æ•°æ®åº“ä¿¡æ¯...');
        const test3 = await env.DB.prepare('PRAGMA database_list').all();
        
        // æµ‹è¯•4: æŸ¥çœ‹æ•°æ®åº“å¤§å°
        console.log('æµ‹è¯•4: æŸ¥çœ‹æ•°æ®åº“å¤§å°...');
        const test4 = await env.DB.prepare('PRAGMA page_count').first();
        
        return jsonResponse({
            result: true,
            message: 'æ•°æ®åº“è¿æ¥æµ‹è¯•å®Œæˆ',
            tests: {
                simpleQuery: test1 ? 'æˆåŠŸ' : 'å¤±è´¥',
                existingTables: test2.results ? test2.results.map(t => t.name) : [],
                databaseInfo: test3.results || [],
                pageCount: test4 ? test4.page_count : 'æœªçŸ¥'
            },
            rawResults: {
                test1,
                test2: test2.results,
                test3: test3.results,
                test4
            }
        });
    } catch (error) {
        console.error('æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥:', error);
        return jsonResponse({
            result: false,
            message: 'æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥',
            error: error.message,
            stack: error.stack
        }, 500);
    }
}

// æ•°æ®åº“åˆå§‹åŒ–
async function handleInitDB(env) {
    console.log('å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“...');
    
    try {
        if (!env.DB) {
            return jsonResponse({
                result: false,
                message: 'æ•°æ®åº“ç»‘å®šä¸å­˜åœ¨',
                error: 'DB binding not found',
                solution: 'è¯·åœ¨Workerè®¾ç½®ä¸­æ·»åŠ DBå˜é‡ç»‘å®šåˆ°D1æ•°æ®åº“'
            }, 500);
        }
        
        // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰è¡¨
        const existingTables = await env.DB.prepare(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='lottery_records'"
        ).first();
        
        if (existingTables) {
            console.log('è¡¨å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º');
            return jsonResponse({
                result: true,
                message: 'è¡¨å·²å­˜åœ¨ï¼Œæ— éœ€é‡æ–°åˆ›å»º',
                existing: true
            });
        }
        
        // åˆ›å»ºè¡¨çš„SQLï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å…é”™è¯¯ï¼‰
        const createTableSQL = `
            CREATE TABLE lottery_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                expect TEXT UNIQUE NOT NULL,
                openTime TEXT NOT NULL,
                type TEXT DEFAULT 'macaujc2',
                openCode TEXT NOT NULL,
                zodiac TEXT,
                verify INTEGER DEFAULT 0,
                info TEXT DEFAULT 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com',
                createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
                updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `;
        
        console.log('æ‰§è¡Œåˆ›å»ºè¡¨SQL...');
        await env.DB.prepare(createTableSQL).run();
        console.log('è¡¨åˆ›å»ºæˆåŠŸ');
        
        // ç­‰å¾…ä¸€ä¸‹
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // åˆ›å»ºç´¢å¼•
        const indexSQLs = [
            "CREATE INDEX idx_expect ON lottery_records(expect)",
            "CREATE INDEX idx_openTime ON lottery_records(openTime)",
            "CREATE INDEX idx_type ON lottery_records(type)"
        ];
        
        const indexResults = [];
        for (const sql of indexSQLs) {
            try {
                await env.DB.prepare(sql).run();
                indexResults.push({ sql, success: true });
                console.log('åˆ›å»ºç´¢å¼•æˆåŠŸ:', sql);
            } catch (error) {
                indexResults.push({ sql, success: false, error: error.message });
                console.warn('åˆ›å»ºç´¢å¼•å¤±è´¥:', error.message);
            }
        }
        
        // éªŒè¯è¡¨åˆ›å»ºæˆåŠŸ
        const verifyTable = await env.DB.prepare(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='lottery_records'"
        ).first();
        
        // å°è¯•æ’å…¥æµ‹è¯•æ•°æ®
        let testResult = 'æœªæ‰§è¡Œ';
        if (verifyTable) {
            try {
                const testData = {
                    expect: `TEST${Date.now().toString().slice(-6)}`,
                    openTime: new Date().toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, ''),
                    openCode: '01,02,03,04,05,06,07',
                    zodiac: 'é¼ ,ç‰›,è™,å…”,é¾,è›‡,é¦¬'
                };
                
                await env.DB.prepare(`
                    INSERT INTO lottery_records (expect, openTime, openCode, zodiac)
                    VALUES (?, ?, ?, ?)
                `).bind(testData.expect, testData.openTime, testData.openCode, testData.zodiac).run();
                
                testResult = 'æµ‹è¯•æ•°æ®æ’å…¥æˆåŠŸ';
                console.log('æµ‹è¯•æ•°æ®æ’å…¥æˆåŠŸ');
            } catch (insertError) {
                testResult = `æµ‹è¯•æ•°æ®æ’å…¥å¤±è´¥: ${insertError.message}`;
                console.warn('æµ‹è¯•æ•°æ®æ’å…¥å¤±è´¥:', insertError.message);
            }
        }
        
        // è·å–æ‰€æœ‰è¡¨
        const allTablesResult = await env.DB.prepare(
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
        ).all();
        const allTables = allTablesResult.results ? allTablesResult.results.map(t => t.name) : [];
        
        return jsonResponse({
            result: true,
            message: 'æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ',
            details: {
                tableCreated: !!verifyTable,
                allTables: allTables,
                indexes: indexResults,
                testInsert: testResult
            }
        });
        
    } catch (error) {
        console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
        
        return jsonResponse({
            result: false,
            message: 'æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥',
            error: error.message,
            troubleshooting: [
                '1. è¯·å…ˆè®¿é—® /test-db æµ‹è¯•æ•°æ®åº“è¿æ¥',
                '2. åœ¨Cloudflare Dashboardä¸­æ‰‹åŠ¨æ‰§è¡ŒSQL',
                '3. æ£€æŸ¥æ•°æ®åº“ç»‘å®šæ˜¯å¦æ­£ç¡®'
            ]
        }, 500);
    }
}

// å¥åº·æ£€æŸ¥
async function handleHealthCheck(env) {
    try {
        let dbStatus = 'unknown';
        let dbError = null;
        
        if (env.DB) {
            try {
                const result = await env.DB.prepare('SELECT 1 as test').first();
                dbStatus = result ? 'connected' : 'error';
            } catch (error) {
                dbStatus = 'error';
                dbError = error.message;
                console.error('æ•°æ®åº“è¿æ¥é”™è¯¯:', error);
            }
        } else {
            dbStatus = 'no-binding';
        }
        
        return jsonResponse({
            status: 'ok',
            timestamp: new Date().toISOString(),
            services: {
                worker: 'running',
                database: dbStatus,
                telegram: env.TELEGRAM_BOT_TOKEN ? 'configured' : 'not-configured'
            },
            environment: {
                hasDB: !!env.DB,
                hasTelegramToken: !!env.TELEGRAM_BOT_TOKEN,
                hasAdminId: !!env.TELEGRAM_ADMIN_ID,
                hasApiKey: !!env.ADMIN_API_KEY
            },
            error: dbError
        });
    } catch (error) {
        return jsonResponse({
            status: 'error',
            error: error.message,
            timestamp: new Date().toISOString()
        }, 500);
    }
}

// Telegram Webhook å¤„ç†
async function handleTelegramWebhook(request, env) {
    try {
        const update = await request.json();
        console.log('æ”¶åˆ°Telegramæ¶ˆæ¯:', JSON.stringify(update, null, 2));
        
        // å¤„ç†é¢‘é“æ¶ˆæ¯
        if (update.channel_post) {
            const message = update.channel_post;
            await processLotteryMessage(message, env);
        }
        
        // å¤„ç†ç®¡ç†å‘˜ç§èŠ
        if (update.message && update.message.from.id.toString() === env.TELEGRAM_ADMIN_ID) {
            await processAdminMessage(update.message, env);
        }
        
        return new Response('OK');
    } catch (error) {
        console.error('Telegram webhooké”™è¯¯:', error);
        return new Response('Error', { status: 500 });
    }
}

// å¤„ç†å½©ç¥¨æ¶ˆæ¯
async function processLotteryMessage(message, env) {
    try {
        const text = message.text || '';
        console.log('å¤„ç†æ¶ˆæ¯:', text);
        
        // è§£ææ ¼å¼ï¼šé¦™æ¸¯å…­åˆå½©ç¬¬:2025127æœŸå¼€å¥–ç»“æœ:
        // 06  40  04  34  26  28  25
        // é¼   è™  è™  çŒ´  é¾  è™  è›‡
        
        const lines = text.split('\n').map(line => line.trim()).filter(line => line);
        
        if (lines.length < 3) {
            console.log('æ¶ˆæ¯æ ¼å¼æ— æ•ˆ');
            return;
        }
        
        // è§£ææœŸå·
        const expectMatch = lines[0].match(/ç¬¬:?(\d{7})æœŸ/);
        if (!expectMatch) {
            console.log('æœªæ‰¾åˆ°æœŸå·');
            return;
        }
        
        const expect = expectMatch[1];
        console.log('æœŸå·:', expect);
        
        // è§£æå¼€å¥–å·ç ï¼ˆç¬¬äºŒè¡Œï¼‰
        const numbersLine = lines[1];
        const numbers = numbersLine.trim().split(/\s+/).map(num => {
            return num.padStart(2, '0');
        });
        
        if (numbers.length !== 7) {
            console.log('å·ç æ•°é‡æ— æ•ˆ:', numbers.length);
            return;
        }
        
        const openCode = numbers.join(',');
        console.log('å¼€å¥–å·ç :', openCode);
        
        // è§£æç”Ÿè‚–ï¼ˆç¬¬ä¸‰è¡Œï¼‰
        const zodiacLine = lines[2];
        const zodiacs = zodiacLine.trim().split(/\s+/);
        const zodiac = zodiacs.join(',');
        console.log('ç”Ÿè‚–:', zodiac);
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const existing = await env.DB.prepare(
            'SELECT id FROM lottery_records WHERE expect = ?'
        ).bind(expect).first();
        
        if (existing) {
            console.log('è®°å½•å·²å­˜åœ¨:', expect);
            return;
        }
        
        // å¼€å¥–æ—¶é—´
        const openTime = new Date(message.date * 1000).toISOString()
            .replace('T', ' ')
            .replace(/\.\d{3}Z$/, '');
        
        // æ’å…¥æ•°æ®åº“
        await env.DB.prepare(`
            INSERT INTO lottery_records (expect, openTime, openCode, zodiac, verify)
            VALUES (?, ?, ?, ?, ?)
        `).bind(expect, openTime, openCode, zodiac, false).run();
        
        console.log('è®°å½•ä¿å­˜æˆåŠŸ:', expect);
        
        // å‘é€ç¡®è®¤æ¶ˆæ¯ç»™ç®¡ç†å‘˜
        if (env.TELEGRAM_ADMIN_ID && env.TELEGRAM_BOT_TOKEN) {
            const botResponse = `âœ… ä¿å­˜å¼€å¥–è®°å½•æˆåŠŸ\næœŸå·ï¼š${expect}\nå·ç ï¼š${openCode}\næ—¶é—´ï¼š${openTime}`;
            await sendTelegramMessage(env.TELEGRAM_ADMIN_ID, botResponse, env.TELEGRAM_BOT_TOKEN);
        }
        
    } catch (error) {
        console.error('å¤„ç†å½©ç¥¨æ¶ˆæ¯é”™è¯¯:', error);
    }
}

// å¤„ç†ç®¡ç†å‘˜æ¶ˆæ¯
async function processAdminMessage(message, env) {
    const text = message.text.trim();
    const chatId = message.chat.id;
    
    const commands = {
        '/start': 'æ¬¢è¿ä½¿ç”¨å½©ç¥¨å¼€å¥–è®°å½•Botï¼\n\nå¯ç”¨å‘½ä»¤ï¼š\n/list - æŸ¥çœ‹æœ€æ–°è®°å½•\n/stats - ç»Ÿè®¡æ•°æ®\n/delete [æœŸå·] - åˆ é™¤è®°å½•\n/update [æœŸå·] [æ–°å·ç ] [æ–°ç”Ÿè‚–] - æ›´æ–°è®°å½•\n/help - å¸®åŠ©ä¿¡æ¯',
        
        '/list': async () => {
            const records = await env.DB.prepare(
                'SELECT expect, openTime, openCode FROM lottery_records ORDER BY expect DESC LIMIT 10'
            ).all();
            
            if (!records.results || records.results.length === 0) {
                return 'æš‚æ— å¼€å¥–è®°å½•';
            }
            
            let response = 'ğŸ“‹ æœ€æ–°10æœŸå¼€å¥–è®°å½•ï¼š\n\n';
            records.results.forEach((record, index) => {
                response += `${index + 1}. æœŸå·ï¼š${record.expect}\n`;
                response += `   æ—¶é—´ï¼š${record.openTime}\n`;
                response += `   å·ç ï¼š${record.openCode}\n\n`;
            });
            
            return response;
        },
        
        '/stats': async () => {
            const total = await env.DB.prepare('SELECT COUNT(*) as count FROM lottery_records').first();
            const latest = await env.DB.prepare(
                'SELECT expect, openTime FROM lottery_records ORDER BY openTime DESC LIMIT 1'
            ).first();
            
            const byYear = await env.DB.prepare(`
                SELECT 
                    strftime('%Y', openTime) as year,
                    COUNT(*) as count
                FROM lottery_records 
                GROUP BY strftime('%Y', openTime)
                ORDER BY year DESC
            `).all();
            
            let response = 'ğŸ“Š æ•°æ®ç»Ÿè®¡\n\n';
            response += `æ€»è®°å½•æ•°ï¼š${total ? total.count : 0}\n\n`;
            
            if (byYear.results && byYear.results.length > 0) {
                response += 'æŒ‰å¹´ç»Ÿè®¡ï¼š\n';
                byYear.results.forEach(stat => {
                    response += `  ${stat.year}å¹´ï¼š${stat.count}æœŸ\n`;
                });
            }
            
            if (latest) {
                response += `\næœ€æ–°ä¸€æœŸï¼š${latest.expect}\n`;
                response += `å¼€å¥–æ—¶é—´ï¼š${latest.openTime}`;
            }
            
            return response;
        },
        
        '/delete': async (args) => {
            if (!args || args.length === 0) {
                return 'è¯·æä¾›è¦åˆ é™¤çš„æœŸå·ï¼Œä¾‹å¦‚: /delete 2025127';
            }
            
            const expect = args[0];
            
            try {
                // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
                const record = await env.DB.prepare(
                    'SELECT id FROM lottery_records WHERE expect = ?'
                ).bind(expect).first();
                
                if (!record) {
                    return `âŒ æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`;
                }
                
                // åˆ é™¤è®°å½•
                const result = await env.DB.prepare(
                    'DELETE FROM lottery_records WHERE expect = ?'
                ).bind(expect).run();
                
                if (result.success) {
                    return `âœ… æˆåŠŸåˆ é™¤æœŸå· ${expect} çš„è®°å½•`;
                } else {
                    return `âŒ åˆ é™¤è®°å½•å¤±è´¥: ${result.error}`;
                }
            } catch (error) {
                return `âŒ åˆ é™¤è®°å½•æ—¶å‡ºé”™: ${error.message}`;
            }
        },
        
        '/update': async (args) => {
            if (!args || args.length < 3) {
                return 'è¯·æä¾›æœŸå·ã€æ–°å·ç å’Œæ–°ç”Ÿè‚–ï¼Œä¾‹å¦‚: /update 2025127 01,02,03,04,05,06,07 é¼ ,ç‰›,è™,å…”,é¾,è›‡,é¦¬';
            }
            
            const expect = args[0];
            const openCode = args[1];
            const zodiac = args[2];
            
            try {
                // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
                const record = await env.DB.prepare(
                    'SELECT id FROM lottery_records WHERE expect = ?'
                ).bind(expect).first();
                
                if (!record) {
                    return `âŒ æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`;
                }
                
                // éªŒè¯å·ç æ ¼å¼
                const numbers = openCode.split(',');
                if (numbers.length !== 7) {
                    return 'âŒ å·ç æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º7ä¸ªå·ç ï¼Œç”¨é€—å·åˆ†éš”';
                }
                
                // æ›´æ–°è®°å½•
                const openTime = new Date().toISOString()
                    .replace('T', ' ')
                    .replace(/\.\d{3}Z$/, '');
                
                const result = await env.DB.prepare(`
                    UPDATE lottery_records 
                    SET openCode = ?, zodiac = ?, openTime = ?, updatedAt = CURRENT_TIMESTAMP
                    WHERE expect = ?
                `).bind(openCode, zodiac, openTime, expect).run();
                
                if (result.success) {
                    return `âœ… æˆåŠŸæ›´æ–°æœŸå· ${expect} çš„è®°å½•\næ–°å·ç : ${openCode}\næ–°ç”Ÿè‚–: ${zodiac}`;
                } else {
                    return `âŒ æ›´æ–°è®°å½•å¤±è´¥: ${result.error}`;
                }
            } catch (error) {
                return `âŒ æ›´æ–°è®°å½•æ—¶å‡ºé”™: ${error.message}`;
            }
        },
        
        '/help': 'å¯ç”¨å‘½ä»¤ï¼š\n/list - æŸ¥çœ‹æœ€æ–°è®°å½•\n/stats - ç»Ÿè®¡æ•°æ®\n/delete [æœŸå·] - åˆ é™¤è®°å½•\n/update [æœŸå·] [æ–°å·ç ] [æ–°ç”Ÿè‚–] - æ›´æ–°è®°å½•\n/help - å¸®åŠ©ä¿¡æ¯'
    };
    
    // æŸ¥æ‰¾åŒ¹é…çš„å‘½ä»¤
    for (const [command, handler] of Object.entries(commands)) {
        if (text.startsWith(command)) {
            try {
                let response;
                const args = text.substring(command.length).trim().split(/\s+/);
                
                if (typeof handler === 'function') {
                    response = await handler(args);
                } else {
                    response = handler;
                }
                
                await sendTelegramMessage(chatId, response, env.TELEGRAM_BOT_TOKEN);
            } catch (error) {
                console.error('å‘½ä»¤æ‰§è¡Œé”™è¯¯:', error);
                await sendTelegramMessage(chatId, 'å‘½ä»¤æ‰§è¡Œå‡ºé”™: ' + error.message, env.TELEGRAM_BOT_TOKEN);
            }
            break;
        }
    }
}

// å†å²æ•°æ® API
async function handleHistoryAPI(request, env, pathname) {
    try {
        // è§£æè·¯å¾„ï¼š/history/macaujc2/y/2025
        const parts = pathname.split('/');
        
        if (parts.length < 5) {
            return jsonResponse({
                result: false,
                message: 'è·¯å¾„æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º: /history/{type}/y/{year}',
                code: 400
            }, 400);
        }
        
        const type = parts[2];
        const year = parts[4];
        
        if (!/^\d{4}$/.test(year)) {
            return jsonResponse({
                result: false,
                message: 'å¹´ä»½æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º4ä½æ•°å­—',
                code: 400
            }, 400);
        }
        
        // æŸ¥è¯¢æ•°æ®
        const query = env.DB.prepare(`
            SELECT 
                expect,
                strftime('%Y-%m-%d %H:%M:%S', openTime) as openTime,
                type,
                openCode,
                zodiac,
                verify,
                info
            FROM lottery_records 
            WHERE strftime('%Y', openTime) = ?
            ORDER BY expect DESC
        `).bind(year);
        
        const records = await query.all();
        
        // æ ¼å¼åŒ–è¿”å›æ•°æ®
        const formattedData = (records.results || []).map(record => ({
            expect: record.expect,
            openTime: record.openTime,
            type: record.type || '8',
            openCode: record.openCode,
            wave: null,
            zodiac: record.zodiac || '',
            oddEven: null,
            allOddEven: null,
            bigSmall: null,
            allBigSmall: null,
            firstsecend: 0,
            left3: null,
            mid3: null,
            right3: null,
            pet: null,
            pk: null,
            vs: null,
            verify: record.verify || false,
            info: record.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
        }));
        
        return jsonResponse({
            result: true,
            message: 'æ“ä½œæˆåŠŸï¼',
            code: 200,
            data: formattedData,
            timestamp: Date.now()
        });
        
    } catch (error) {
        console.error('å†å²APIé”™è¯¯:', error);
        return jsonResponse({
            result: false,
            message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
            code: 500,
            error: error.message
        }, 500);
    }
}

// ç®¡ç†å‘˜å¯¼å…¥æ¥å£
async function handleAdminImport(request, env) {
    try {
        // éªŒè¯ API å¯†é’¥
        const validation = validateApiKey(request, env);
        if (!validation.valid) {
            return jsonResponse({
                result: false,
                message: validation.message,
                code: 401
            }, 401);
        }
        
        const data = await request.json();
        
        if (!Array.isArray(data)) {
            return jsonResponse({
                result: false,
                message: 'æ•°æ®æ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºæ•°ç»„',
                code: 400
            }, 400);
        }
        
        let successCount = 0;
        let errorCount = 0;
        const errors = [];
        
        for (const record of data) {
            try {
                if (!record.expect || !record.openCode) {
                    errorCount++;
                    errors.push(`è®°å½•ç¼ºå°‘å¿…è¦å­—æ®µ: ${JSON.stringify(record)}`);
                    continue;
                }
                
                await env.DB.prepare(`
                    INSERT OR REPLACE INTO lottery_records 
                    (expect, openTime, openCode, zodiac, verify, info)
                    VALUES (?, ?, ?, ?, ?, ?)
                `).bind(
                    record.expect,
                    record.openTime || new Date().toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, ''),
                    record.openCode,
                    record.zodiac || '',
                    record.verify || false,
                    record.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
                ).run();
                
                successCount++;
            } catch (error) {
                errorCount++;
                errors.push(`${record.expect}: ${error.message}`);
                console.error('å¯¼å…¥è®°å½•é”™è¯¯:', error);
            }
        }
        
        return jsonResponse({
            result: true,
            message: `æ•°æ®å¯¼å…¥å®Œæˆï¼ŒæˆåŠŸï¼š${successCount}ï¼Œå¤±è´¥ï¼š${errorCount}`,
            code: 200,
            summary: {
                total: data.length,
                success: successCount,
                error: errorCount
            },
            errors: errors.length > 0 ? errors : undefined
        });
        
    } catch (error) {
        console.error('å¯¼å…¥APIé”™è¯¯:', error);
        return jsonResponse({
            result: false,
            message: 'å¯¼å…¥å¤±è´¥',
            code: 500,
            error: error.message
        }, 500);
    }
}

// è·å–è®°å½•åˆ—è¡¨
async function handleListRecords(request, env) {
    try {
        // éªŒè¯ API å¯†é’¥
        const validation = validateApiKey(request, env);
        if (!validation.valid) {
            return jsonResponse({
                result: false,
                message: validation.message,
                code: 401
            }, 401);
        }
        
        const url = new URL(request.url);
        const page = parseInt(url.searchParams.get('page') || '1');
        const limit = parseInt(url.searchParams.get('limit') || '20');
        const offset = (page - 1) * limit;
        
        // è·å–æ€»è®°å½•æ•°
        const countResult = await env.DB.prepare(
            'SELECT COUNT(*) as total FROM lottery_records'
        ).first();
        
        const total = countResult ? countResult.total : 0;
        
        // è·å–è®°å½•
        const records = await env.DB.prepare(`
            SELECT 
                id,
                expect,
                strftime('%Y-%m-%d %H:%M:%S', openTime) as openTime,
                type,
                openCode,
                zodiac,
                verify,
                info,
                strftime('%Y-%m-%d %H:%M:%S', createdAt) as createdAt,
                strftime('%Y-%m-%d %H:%M:%S', updatedAt) as updatedAt
            FROM lottery_records 
            ORDER BY expect DESC
            LIMIT ? OFFSET ?
        `).bind(limit, offset).all();
        
        return jsonResponse({
            result: true,
            message: 'è·å–è®°å½•åˆ—è¡¨æˆåŠŸ',
            code: 200,
            data: {
                records: records.results || [],
                pagination: {
                    page,
                    limit,
                    total,
                    pages: Math.ceil(total / limit)
                }
            }
        });
        
    } catch (error) {
        console.error('è·å–è®°å½•åˆ—è¡¨é”™è¯¯:', error);
        return jsonResponse({
            result: false,
            message: 'è·å–è®°å½•åˆ—è¡¨å¤±è´¥',
            code: 500,
            error: error.message
        }, 500);
    }
}

// è·å–å•ä¸ªè®°å½•
async function handleGetRecord(request, env, pathname) {
    try {
        // éªŒè¯ API å¯†é’¥
        const validation = validateApiKey(request, env);
        if (!validation.valid) {
            return jsonResponse({
                result: false,
                message: validation.message,
                code: 401
            }, 401);
        }
        
        // ä»è·¯å¾„ä¸­æå–æœŸå·
        const parts = pathname.split('/');
        const expect = parts[3];
        
        if (!expect) {
            return jsonResponse({
                result: false,
                message: 'è¯·æä¾›æœŸå·',
                code: 400
            }, 400);
        }
        
        // æŸ¥è¯¢è®°å½•
        const record = await env.DB.prepare(`
            SELECT 
                id,
                expect,
                strftime('%Y-%m-%d %H:%M:%S', openTime) as openTime,
                type,
                openCode,
                zodiac,
                verify,
                info,
                strftime('%Y-%m-%d %H:%M:%S', createdAt) as createdAt,
                strftime('%Y-%m-%d %H:%M:%S', updatedAt) as updatedAt
            FROM lottery_records 
            WHERE expect = ?
        `).bind(expect).first();
        
        if (!record) {
            return jsonResponse({
                result: false,
                message: `æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`,
                code: 404
            }, 404);
        }
        
        return jsonResponse({
            result: true,
            message: 'è·å–è®°å½•æˆåŠŸ',
            code: 200,
            data: record
        });
        
    } catch (error) {
        console.error('è·å–è®°å½•é”™è¯¯:', error);
        return jsonResponse({
            result: false,
            message: 'è·å–è®°å½•å¤±è´¥',
            code: 500,
            error: error.message
        }, 500);
    }
}

// æ›´æ–°è®°å½•
async function handleUpdateRecord(request, env, pathname) {
    try {
        // éªŒè¯ API å¯†é’¥
        const validation = validateApiKey(request, env);
        if (!validation.valid) {
            return jsonResponse({
                result: false,
                message: validation.message,
                code: 401
            }, 401);
        }
        
        // ä»è·¯å¾„ä¸­æå–æœŸå·
        const parts = pathname.split('/');
        const expect = parts[3];
        
        if (!expect) {
            return jsonResponse({
                result: false,
                message: 'è¯·æä¾›æœŸå·',
                code: 400
            }, 400);
        }
        
        // è·å–è¯·æ±‚æ•°æ®
        const data = await request.json();
        
        // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
        const existing = await env.DB.prepare(
            'SELECT id FROM lottery_records WHERE expect = ?'
        ).bind(expect).first();
        
        if (!existing) {
            return jsonResponse({
                result: false,
                message: `æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`,
                code: 404
            }, 404);
        }
        
        // æ„å»ºæ›´æ–°å­—æ®µ
        const updates = [];
        const values = [];
        
        if (data.openTime !== undefined) {
            updates.push('openTime = ?');
            values.push(data.openTime);
        }
        
        if (data.openCode !== undefined) {
            // éªŒè¯å·ç æ ¼å¼
            const numbers = data.openCode.split(',');
            if (numbers.length !== 7) {
                return jsonResponse({
                    result: false,
                    message: 'å·ç æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º7ä¸ªå·ç ï¼Œç”¨é€—å·åˆ†éš”',
                    code: 400
                }, 400);
            }
            updates.push('openCode = ?');
            values.push(data.openCode);
        }
        
        if (data.zodiac !== undefined) {
            updates.push('zodiac = ?');
            values.push(data.zodiac);
        }
        
        if (data.verify !== undefined) {
            updates.push('verify = ?');
            values.push(data.verify ? 1 : 0);
        }
        
        if (data.info !== undefined) {
            updates.push('info = ?');
            values.push(data.info);
        }
        
        if (data.type !== undefined) {
            updates.push('type = ?');
            values.push(data.type);
        }
        
        if (updates.length === 0) {
            return jsonResponse({
                result: false,
                message: 'æ²¡æœ‰æä¾›è¦æ›´æ–°çš„å­—æ®µ',
                code: 400
            }, 400);
        }
        
        // æ·»åŠ æ›´æ–°æ—¶é—´
        updates.push('updatedAt = CURRENT_TIMESTAMP');
        
        // æ·»åŠ WHEREæ¡ä»¶å€¼
        values.push(expect);
        
        // æ‰§è¡Œæ›´æ–°
        const sql = `UPDATE lottery_records SET ${updates.join(', ')} WHERE expect = ?`;
        const result = await env.DB.prepare(sql).bind(...values).run();
        
        if (result.success) {
            // è·å–æ›´æ–°åçš„è®°å½•
            const updatedRecord = await env.DB.prepare(`
                SELECT 
                    id,
                    expect,
                    strftime('%Y-%m-%d %H:%M:%S', openTime) as openTime,
                    type,
                    openCode,
                    zodiac,
                    verify,
                    info,
                    strftime('%Y-%m-%d %H:%M:%S', createdAt) as createdAt,
                    strftime('%Y-%m-%d %H:%M:%S', updatedAt) as updatedAt
                FROM lottery_records 
                WHERE expect = ?
            `).bind(expect).first();
            
            return jsonResponse({
                result: true,
                message: 'æ›´æ–°è®°å½•æˆåŠŸ',
                code: 200,
                data: updatedRecord
            });
        } else {
            return jsonResponse({
                result: false,
                message: 'æ›´æ–°è®°å½•å¤±è´¥',
                code: 500
            }, 500);
        }
        
    } catch (error) {
        console.error('æ›´æ–°è®°å½•é”™è¯¯:', error);
        return jsonResponse({
            result: false,
            message: 'æ›´æ–°è®°å½•å¤±è´¥',
            code: 500,
            error: error.message
        }, 500);
    }
}

// åˆ é™¤è®°å½•
async function handleDeleteRecord(request, env, pathname) {
    try {
        // éªŒè¯ API å¯†é’¥
        const validation = validateApiKey(request, env);
        if (!validation.valid) {
            return jsonResponse({
                result: false,
                message: validation.message,
                code: 401
            }, 401);
        }
        
        // ä»è·¯å¾„ä¸­æå–æœŸå·
        const parts = pathname.split('/');
        const expect = parts[3];
        
        if (!expect) {
            return jsonResponse({
                result: false,
                message: 'è¯·æä¾›æœŸå·',
                code: 400
            }, 400);
        }
        
        // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
        const existing = await env.DB.prepare(
            'SELECT id, expect, openTime FROM lottery_records WHERE expect = ?'
        ).bind(expect).first();
        
        if (!existing) {
            return jsonResponse({
                result: false,
                message: `æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`,
                code: 404
            }, 404);
        }
        
        // æ‰§è¡Œåˆ é™¤
        const result = await env.DB.prepare(
            'DELETE FROM lottery_records WHERE expect = ?'
        ).bind(expect).run();
        
        if (result.success) {
            return jsonResponse({
                result: true,
                message: `æˆåŠŸåˆ é™¤æœŸå·ä¸º ${expect} çš„è®°å½•`,
                code: 200,
                deletedRecord: existing
            });
        } else {
            return jsonResponse({
                result: false,
                message: 'åˆ é™¤è®°å½•å¤±è´¥',
                code: 500
            }, 500);
        }
        
    } catch (error) {
        console.error('åˆ é™¤è®°å½•é”™è¯¯:', error);
        return jsonResponse({
            result: false,
            message: 'åˆ é™¤è®°å½•å¤±è´¥',
            code: 500,
            error: error.message
        }, 500);
    }
}

// å‘é€ Telegram æ¶ˆæ¯
async function sendTelegramMessage(chatId, text, botToken) {
    try {
        const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
        
        await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'HTML'
            })
        });
    } catch (error) {
        console.error('å‘é€Telegramæ¶ˆæ¯é”™è¯¯:', error);
    }
}

// è¾…åŠ©å‡½æ•°ï¼šJSONå“åº”
function jsonResponse(data, status = 200) {
    return new Response(JSON.stringify(data, null, 2), {
        status: status,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, X-API-Key',
            'Cache-Control': 'public, max-age=300'
        }
    });
}
