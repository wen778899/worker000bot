/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V7.0 çœŸå®æ¨¡æ‹Ÿç‰ˆ
 * 
 * æ ¸å¿ƒæ”¹è¿›:
 * 1. ç§»é™¤æ‰€æœ‰è™šå‡çš„5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿè¿›åº¦
 * 2. å®ç°çœŸæ­£çš„è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿé¢„æµ‹
 * 3. åŸºäºå†å²æ•°æ®çš„ç»Ÿè®¡æ¦‚ç‡åˆ†æ
 * 4. å®æ—¶è®¡ç®—ï¼Œç§’çº§å“åº”
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰ - ç²¾ç®€ç‰ˆ
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ–°æ¾³å…­åˆå½©Â·çœŸå®æ¨¡æ‹Ÿç‰ˆ",
    VERSION: "V7.0 çœŸå®æ¨¡æ‹Ÿç‰ˆ",
    SIMULATION_ITERATIONS: 500000, // 50ä¸‡æ¬¡çœŸå®æ¨¡æ‹Ÿ
    BATCH_SIZE: 10000,
    HISTORY_LIMIT: 100,
    CACHE_TTL: 60 * 1000,
    MIN_HISTORY_RECORDS: 10 // æœ€å°‘éœ€è¦çš„å†å²è®°å½•æ•°
  },

  SIMULATION_CONFIG: {
    ZODIAC_WEIGHT: 3.0,
    COLOR_WEIGHT: 2.0,
    TAIL_WEIGHT: 1.5,
    FREQUENCY_WEIGHT: 1.2,
    SHAPE_WEIGHT: 1.0,
    RANDOM_VARIATION: 0.1 // 10%éšæœºæ‰°åŠ¨
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    sync: "ğŸ”„",
    history: "ğŸ“œ",
    preview: "ğŸ‘€",
    gold: "ğŸ’°",
    star: "â­",
    diamond: "ğŸ’",
    rocket: "ğŸš€",
    trophy: "ğŸ†",
    cpu: "ğŸ’»",
    check: "âœ”ï¸",
    warning: "âš ï¸"
  }
};

const CALLBACK_DATA = {
  MAIN_MENU: "main_menu",
  PREVIEW: "preview",
  HISTORY: "history",
  SYNC: "sync",
  DELETE: "delete"
};

// ==============================================================================
// 2. å·¥å…·ç±» - ç²¾ç®€ç‰ˆ
// ==============================================================================

class Logger {
  static info(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.log(`[${timestamp}] [INFO] [${context}] ${message}`);
  }

  static error(context, message, error = null) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    const errorStr = error ? ` | ${error.message}` : '';
    console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
      }
      
      let zodiac = "æœªçŸ¥";
      let color = "æœªçŸ¥";
      
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString) return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'ç™¾ä¸‡';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }
}

// ==============================================================================
// 3. æ•°æ®åº“æ“ä½œå±‚ - ç²¾ç®€ç‰ˆ
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      return result ? result.count : 0;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      return result ? result.expect : null;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (const record of records) {
        try {
          if (record && record.expect && record.open_code) {
            const result = await env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            ).run();
            
            totalAdded += (result.changes || 0);
            totalSkipped += (1 - (result.changes || 0));
          } else {
            totalSkipped++;
          }
        } catch (singleError) {
          Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥`, singleError);
          totalSkipped++;
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ€»è®¡æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      return r ? r.value : def;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId) {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      
      return { 
        success: true, 
        deleted: deletedCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½•`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message
      };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": ""
      };

      for (const [key, value] of Object.entries(defaultSettings)) {
        await env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value).run();
      }
      
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  }
};

// ==============================================================================
// 4. çœŸå®è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¼•æ“ - æ ¸å¿ƒå®ç°
// ==============================================================================

class MonteCarloSimulator {
  /**
   * ä»å†å²æ•°æ®ä¸­å­¦ä¹ æ¦‚ç‡åˆ†å¸ƒ
   */
  static learnProbabilityDistributions(history) {
    const distributions = {
      specialFrequency: new Array(50).fill(0), // ç‰¹ç é¢‘ç‡
      normalFrequency: new Array(50).fill(0),  // å¹³ç é¢‘ç‡
      zodiacFrequency: {},                     // ç”Ÿè‚–é¢‘ç‡
      colorFrequency: { red: 0, blue: 0, green: 0 }, // æ³¢è‰²é¢‘ç‡
      tailFrequency: new Array(10).fill(0),    // å°¾æ•°é¢‘ç‡
      shapeFrequency: { bigOdd: 0, bigEven: 0, smallOdd: 0, smallEven: 0 } // å½¢æ€é¢‘ç‡
    };
    
    if (!history || history.length === 0) {
      return distributions;
    }
    
    // åˆå§‹åŒ–ç”Ÿè‚–é¢‘ç‡
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
      distributions.zodiacFrequency[zodiac] = 0;
    });
    
    // åˆ†æå†å²æ•°æ®
    history.forEach(record => {
      if (!record || !record.open_code) return;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (numbers.length < 7) return;
      
      // ç‰¹ç 
      const special = numbers[6];
      if (special >= 1 && special <= 49) {
        distributions.specialFrequency[special]++;
      }
      
      // å¹³ç 
      for (let i = 0; i < 6; i++) {
        const num = numbers[i];
        if (num >= 1 && num <= 49) {
          distributions.normalFrequency[num]++;
        }
      }
      
      // ç”Ÿè‚–
      const specialAttr = Formatter.getAttributes(special);
      if (distributions.zodiacFrequency[specialAttr.zodiac] !== undefined) {
        distributions.zodiacFrequency[specialAttr.zodiac]++;
      }
      
      // æ³¢è‰²
      if (CONFIG.COLORS.red.includes(special)) {
        distributions.colorFrequency.red++;
      } else if (CONFIG.COLORS.blue.includes(special)) {
        distributions.colorFrequency.blue++;
      } else if (CONFIG.COLORS.green.includes(special)) {
        distributions.colorFrequency.green++;
      }
      
      // å°¾æ•°
      const tail = special % 10;
      if (tail >= 0 && tail <= 9) {
        distributions.tailFrequency[tail]++;
      }
      
      // å½¢æ€
      const isBig = special >= 25;
      const isOdd = special % 2 !== 0;
      if (isBig && isOdd) {
        distributions.shapeFrequency.bigOdd++;
      } else if (isBig && !isOdd) {
        distributions.shapeFrequency.bigEven++;
      } else if (!isBig && isOdd) {
        distributions.shapeFrequency.smallOdd++;
      } else {
        distributions.shapeFrequency.smallEven++;
      }
    });
    
    return distributions;
  }
  
  /**
   * åŸºäºæ¦‚ç‡åˆ†å¸ƒç”Ÿæˆéšæœºå·ç 
   */
  static generateRandomNumbers(distributions, excludeNumbers = []) {
    const excludeSet = new Set(excludeNumbers);
    const result = {
      special: 0,
      normals: []
    };
    
    // ç”Ÿæˆç‰¹ç ï¼ˆåŸºäºç‰¹ç é¢‘ç‡ï¼‰
    const specialProbabilities = distributions.specialFrequency.slice(1);
    const totalSpecial = specialProbabilities.reduce((a, b) => a + b, 0) || 1;
    const specialWeights = specialProbabilities.map(p => p / totalSpecial);
    
    let attempts = 0;
    do {
      const rand = Math.random();
      let accum = 0;
      
      for (let i = 0; i < specialWeights.length; i++) {
        accum += specialWeights[i];
        if (rand <= accum) {
          result.special = i + 1;
          break;
        }
      }
      attempts++;
    } while ((excludeSet.has(result.special) || result.special === 0) && attempts < 100);
    
    if (result.special === 0) {
      // å›é€€ï¼šéšæœºç”Ÿæˆ
      do {
        result.special = Math.floor(Math.random() * 49) + 1;
      } while (excludeSet.has(result.special));
    }
    
    excludeSet.add(result.special);
    
    // ç”Ÿæˆ6ä¸ªå¹³ç ï¼ˆåŸºäºå¹³ç é¢‘ç‡ï¼‰
    const normalProbabilities = distributions.normalFrequency.slice(1);
    const totalNormal = normalProbabilities.reduce((a, b) => a + b, 0) || 1;
    const normalWeights = normalProbabilities.map(p => p / totalNormal);
    
    while (result.normals.length < 6) {
      const rand = Math.random();
      let accum = 0;
      let found = false;
      
      for (let i = 0; i < normalWeights.length; i++) {
        const num = i + 1;
        if (excludeSet.has(num)) continue;
        
        accum += normalWeights[i];
        if (rand <= accum) {
          result.normals.push(num);
          excludeSet.add(num);
          found = true;
          break;
        }
      }
      
      if (!found) {
        // å›é€€ï¼šéšæœºç”Ÿæˆ
        let randomNum;
        do {
          randomNum = Math.floor(Math.random() * 49) + 1;
        } while (excludeSet.has(randomNum));
        
        result.normals.push(randomNum);
        excludeSet.add(randomNum);
      }
    }
    
    return result;
  }
  
  /**
   * æ‰§è¡Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ
   */
  static simulate(history, iterations = CONFIG.SYSTEM.SIMULATION_ITERATIONS) {
    const startTime = Date.now();
    
    if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_RECORDS) {
      Logger.warn("Simulator", "å†å²æ•°æ®ä¸è¶³ï¼Œè¿”å›éšæœºç»“æœ");
      return this.getRandomFallback();
    }
    
    // å­¦ä¹ æ¦‚ç‡åˆ†å¸ƒ
    const distributions = this.learnProbabilityDistributions(history);
    
    // ç»Ÿè®¡ç»“æœ
    const specialCounts = new Array(50).fill(0);
    const normalCounts = new Array(50).fill(0);
    const zodiacCounts = {};
    const colorCounts = { red: 0, blue: 0, green: 0 };
    const shapeCounts = { bigOdd: 0, bigEven: 0, smallOdd: 0, smallEven: 0 };
    
    // åˆå§‹åŒ–ç”Ÿè‚–ç»Ÿè®¡
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
      zodiacCounts[zodiac] = 0;
    });
    
    // æ‰§è¡Œæ¨¡æ‹Ÿ
    let completedIterations = 0;
    const batchSize = Math.min(10000, iterations);
    
    for (let i = 0; i < iterations; i += batchSize) {
      const currentBatch = Math.min(batchSize, iterations - i);
      
      for (let j = 0; j < currentBatch; j++) {
        // ç”Ÿæˆä¸€ç»„éšæœºå·ç 
        const numbers = this.generateRandomNumbers(distributions);
        
        // ç»Ÿè®¡ç‰¹ç 
        specialCounts[numbers.special]++;
        
        // ç»Ÿè®¡å¹³ç 
        numbers.normals.forEach(num => {
          normalCounts[num]++;
        });
        
        // ç»Ÿè®¡ç”Ÿè‚–
        const attr = Formatter.getAttributes(numbers.special);
        if (zodiacCounts[attr.zodiac] !== undefined) {
          zodiacCounts[attr.zodiac]++;
        }
        
        // ç»Ÿè®¡æ³¢è‰²
        if (CONFIG.COLORS.red.includes(numbers.special)) {
          colorCounts.red++;
        } else if (CONFIG.COLORS.blue.includes(numbers.special)) {
          colorCounts.blue++;
        } else if (CONFIG.COLORS.green.includes(numbers.special)) {
          colorCounts.green++;
        }
        
        // ç»Ÿè®¡å½¢æ€
        const isBig = numbers.special >= 25;
        const isOdd = numbers.special % 2 !== 0;
        if (isBig && isOdd) {
          shapeCounts.bigOdd++;
        } else if (isBig && !isOdd) {
          shapeCounts.bigEven++;
        } else if (!isBig && isOdd) {
          shapeCounts.smallOdd++;
        } else {
          shapeCounts.smallEven++;
        }
        
        completedIterations++;
      }
      
      // æ¯æ‰¹å¤„ç†åå¯ä»¥æ›´æ–°è¿›åº¦ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (batchSize >= 10000) {
        Logger.info("Simulator", `æ¨¡æ‹Ÿè¿›åº¦: ${completedIterations}/${iterations}`);
      }
    }
    
    // è®¡ç®—æ¦‚ç‡
    const specialProbabilities = specialCounts.map(count => count / iterations);
    const normalProbabilities = normalCounts.map(count => count / iterations);
    
    const zodiacProbabilities = {};
    Object.keys(zodiacCounts).forEach(zodiac => {
      zodiacProbabilities[zodiac] = zodiacCounts[zodiac] / iterations;
    });
    
    const colorProbabilities = {
      red: colorCounts.red / iterations,
      blue: colorCounts.blue / iterations,
      green: colorCounts.green / iterations
    };
    
    const shapeProbabilities = {
      bigOdd: shapeCounts.bigOdd / iterations,
      bigEven: shapeCounts.bigEven / iterations,
      smallOdd: shapeCounts.smallOdd / iterations,
      smallEven: shapeCounts.smallEven / iterations
    };
    
    const duration = Date.now() - startTime;
    Logger.info("Simulator", `æ¨¡æ‹Ÿå®Œæˆ: ${iterations}æ¬¡, è€—æ—¶: ${duration}ms`);
    
    return {
      specialProbabilities,
      normalProbabilities,
      zodiacProbabilities,
      colorProbabilities,
      shapeProbabilities,
      iterations,
      duration,
      specialCounts,
      normalCounts
    };
  }
  
  /**
   * ä»æ¨¡æ‹Ÿç»“æœä¸­æå–é¢„æµ‹
   */
  static extractPredictions(simulationResults, history) {
    const { 
      specialProbabilities, 
      normalProbabilities, 
      zodiacProbabilities,
      colorProbabilities,
      shapeProbabilities,
      iterations,
      duration 
    } = simulationResults;
    
    // ç‰¹ç æ¨èï¼ˆæŒ‰æ¦‚ç‡æ’åºï¼‰
    const specialCandidates = [];
    for (let i = 1; i <= 49; i++) {
      specialCandidates.push({
        number: i,
        probability: specialProbabilities[i],
        zodiac: Formatter.getAttributes(i).zodiac,
        color: Formatter.getAttributes(i).color
      });
    }
    
    specialCandidates.sort((a, b) => b.probability - a.probability);
    const topSpecials = specialCandidates.slice(0, 10);
    
    // å¹³ç æ¨èï¼ˆæ’é™¤ç‰¹ç å€™é€‰åæŒ‰æ¦‚ç‡æ’åºï¼‰
    const normalCandidates = [];
    const specialSet = new Set(topSpecials.slice(0, 5).map(s => s.number));
    
    for (let i = 1; i <= 49; i++) {
      if (!specialSet.has(i)) {
        normalCandidates.push({
          number: i,
          probability: normalProbabilities[i],
          zodiac: Formatter.getAttributes(i).zodiac,
          color: Formatter.getAttributes(i).color
        });
      }
    }
    
    normalCandidates.sort((a, b) => b.probability - a.probability);
    const topNormals = normalCandidates.slice(0, 6);
    
    // ç”Ÿè‚–æ¨èï¼ˆæŒ‰æ¦‚ç‡æ’åºï¼‰
    const zodiacCandidates = Object.entries(zodiacProbabilities)
      .map(([zodiac, probability]) => ({ zodiac, probability }))
      .sort((a, b) => b.probability - a.probability);
    
    const topZodiacs = zodiacCandidates.slice(0, 6);
    
    // æ³¢è‰²æ¨è
    const colorCandidates = Object.entries(colorProbabilities)
      .map(([color, probability]) => ({ color, probability }))
      .sort((a, b) => b.probability - a.probability);
    
    // å½¢æ€æ¨è
    const shapeCandidates = Object.entries(shapeProbabilities)
      .map(([shape, probability]) => ({ shape, probability }))
      .sort((a, b) => b.probability - a.probability);
    
    // è®¡ç®—ç½®ä¿¡åº¦ï¼ˆåŸºäºæœ€é«˜æ¦‚ç‡å’Œæ¨¡æ‹Ÿæ¬¡æ•°ï¼‰
    const maxSpecialProb = Math.max(...specialCandidates.map(s => s.probability));
    const confidence = Math.min(99, Math.max(10, Math.floor(maxSpecialProb * 100 * 1.5)));
    
    // åŸºäºçš„å†å²è®°å½•
    let basedOnRecord = null;
    if (history && history.length > 0) {
      const latest = history[0];
      if (latest && latest.open_code) {
        const special = Formatter.safeInt(latest.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        basedOnRecord = {
          expect: latest.expect,
          special: special,
          zodiac: attr.zodiac,
          color: attr.color
        };
      }
    }
    
    return {
      specials: topSpecials,
      normals: topNormals,
      zodiacs: topZodiacs,
      colors: colorCandidates,
      shapes: shapeCandidates,
      confidence,
      basedOnRecord,
      simulationStats: {
        iterations,
        duration,
        maxSpecialProbability: maxSpecialProb,
        totalHistoryRecords: history ? history.length : 0
      }
    };
  }
  
  /**
   * å†å²æ•°æ®ä¸è¶³æ—¶çš„éšæœºå›é€€
   */
  static getRandomFallback() {
    // éšæœºç”Ÿæˆä¸€äº›æ•°æ®
    const allNumbers = Array.from({length: 49}, (_, i) => i + 1);
    
    // éšæœºç‰¹ç 
    const specials = [];
    const specialSet = new Set();
    while (specials.length < 10) {
      const idx = Math.floor(Math.random() * allNumbers.length);
      const num = allNumbers[idx];
      if (!specialSet.has(num)) {
        const attr = Formatter.getAttributes(num);
        specials.push({
          number: num,
          probability: 0.02 + Math.random() * 0.03,
          zodiac: attr.zodiac,
          color: attr.color
        });
        specialSet.add(num);
      }
    }
    
    // éšæœºå¹³ç ï¼ˆæ’é™¤ç‰¹ç ï¼‰
    const normals = [];
    const normalSet = new Set();
    while (normals.length < 6) {
      const idx = Math.floor(Math.random() * allNumbers.length);
      const num = allNumbers[idx];
      if (!specialSet.has(num) && !normalSet.has(num)) {
        const attr = Formatter.getAttributes(num);
        normals.push({
          number: num,
          probability: 0.05 + Math.random() * 0.05,
          zodiac: attr.zodiac,
          color: attr.color
        });
        normalSet.add(num);
      }
    }
    
    return {
      specials,
      normals,
      zodiacs: Object.keys(CONFIG.ZODIAC_MAP).slice(0, 6).map(z => ({ zodiac: z, probability: 0.08 })),
      colors: [
        { color: 'red', probability: 0.35 },
        { color: 'blue', probability: 0.33 },
        { color: 'green', probability: 0.32 }
      ],
      shapes: [
        { shape: 'bigOdd', probability: 0.25 },
        { shape: 'bigEven', probability: 0.25 },
        { shape: 'smallOdd', probability: 0.25 },
        { shape: 'smallEven', probability: 0.25 }
      ],
      confidence: 15,
      basedOnRecord: null,
      simulationStats: {
        iterations: 0,
        duration: 0,
        maxSpecialProbability: 0.02,
        totalHistoryRecords: 0
      }
    };
  }
}

// ==============================================================================
// 5. é¢„æµ‹å¼•æ“ - åŸºäºçœŸå®æ¨¡æ‹Ÿ
// ==============================================================================

class RealPredictionEngine {
  /**
   * ç”Ÿæˆé¢„æµ‹
   */
  static async generatePrediction(env) {
    const startTime = Date.now();
    
    try {
      // è·å–å†å²æ•°æ®
      const history = await DB.getAllHistory(env);
      const historyCount = history.length;
      
      // è®¡ç®—ä¸‹ä¸€æœŸæœŸå·
      let nextExpect = "2025001";
      const latestExpect = await DB.getLatestExpect(env);
      if (latestExpect && Formatter.isValidExpect(latestExpect)) {
        const latestNum = Formatter.safeInt(latestExpect, 2025000);
        nextExpect = (latestNum + 1).toString();
      }
      
      // æ£€æŸ¥å†å²æ•°æ®æ˜¯å¦è¶³å¤Ÿ
      if (historyCount < CONFIG.SYSTEM.MIN_HISTORY_RECORDS) {
        Logger.warn("Prediction", `å†å²æ•°æ®ä¸è¶³ (${historyCount}/${CONFIG.SYSTEM.MIN_HISTORY_RECORDS})ï¼Œä½¿ç”¨éšæœºå›é€€`);
        const fallback = MonteCarloSimulator.getRandomFallback();
        
        return {
          nextExpect,
          prediction: fallback,
          isBasedOnSimulation: false,
          historyCount,
          generatedAt: new Date().toISOString(),
          algorithmVersion: "V7.0-RandomFallback"
        };
      }
      
      // æ‰§è¡ŒçœŸå®æ¨¡æ‹Ÿ
      Logger.info("Prediction", `å¼€å§‹çœŸå®æ¨¡æ‹Ÿ: ${CONFIG.SYSTEM.SIMULATION_ITERATIONS}æ¬¡è¿­ä»£`);
      const simulationResults = MonteCarloSimulator.simulate(history, CONFIG.SYSTEM.SIMULATION_ITERATIONS);
      
      // æå–é¢„æµ‹ç»“æœ
      const predictions = MonteCarloSimulator.extractPredictions(simulationResults, history);
      
      const duration = Date.now() - startTime;
      Logger.info("Prediction", `é¢„æµ‹ç”Ÿæˆå®Œæˆï¼Œè€—æ—¶: ${duration}msï¼Œç½®ä¿¡åº¦: ${predictions.confidence}%`);
      
      return {
        nextExpect,
        prediction: predictions,
        isBasedOnSimulation: true,
        historyCount,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V7.0-RealSimulation",
        simulationInfo: {
          iterations: simulationResults.iterations,
          duration: simulationResults.duration,
          maxProbability: simulationResults.maxProbability
        }
      };
      
    } catch (error) {
      Logger.error("Prediction", "ç”Ÿæˆé¢„æµ‹å¤±è´¥", error);
      
      return {
        nextExpect: "2025001",
        prediction: MonteCarloSimulator.getRandomFallback(),
        isBasedOnSimulation: false,
        historyCount: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V7.0-ErrorFallback",
        error: error.message
      };
    }
  }
}

// ==============================================================================
// 6. æ¶ˆæ¯æ¸²æŸ“å™¨ - ç²¾ç®€ç‰ˆ
// ==============================================================================

class MessageRenderer {
  static generateMainMenuKeyboard(isAdmin = false) {
    try {
      const keyboard = {
        inline_keyboard: [
          [
            { text: `${CONFIG.EMOJI.preview} å®æ—¶é¢„æµ‹`, callback_data: CALLBACK_DATA.PREVIEW },
            { text: `${CONFIG.EMOJI.history} å†å²è®°å½•`, callback_data: CALLBACK_DATA.HISTORY }
          ]
        ]
      };
      
      if (isAdmin) {
        keyboard.inline_keyboard.push([
          { text: `${CONFIG.EMOJI.sync} åŒæ­¥æ•°æ®`, callback_data: CALLBACK_DATA.SYNC },
          { text: `${CONFIG.EMOJI.sync} åˆ é™¤è®°å½•`, callback_data: CALLBACK_DATA.DELETE }
        ]);
      }
      
      return keyboard;
    } catch (error) {
      return { inline_keyboard: [[{ text: "è¿”å›", callback_data: CALLBACK_DATA.MAIN_MENU }]] };
    }
  }

  static renderMainMenu(historyCount = 0, lastSync = "") {
    try {
      let message = `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `ğŸ“Š ç³»ç»ŸçŠ¶æ€:\n`;
      message += `â€¢ å†å²è®°å½•: ${historyCount} æœŸ\n`;
      
      if (lastSync) {
        message += `â€¢ æœ€ååŒæ­¥: ${lastSync}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.cpu} <b>çœŸå®æ¨¡æ‹Ÿå¼•æ“</b>\n`;
      message += `â€¢ æ¯æ¬¡é¢„æµ‹: ${Formatter.formatLargeNumber(CONFIG.SYSTEM.SIMULATION_ITERATIONS)}æ¬¡æ¨¡æ‹Ÿ\n`;
      message += `â€¢ å“åº”æ—¶é—´: æ•°ç§’å†…å®Œæˆ\n`;
      message += `â€¢ åŸºäºå†å²: æ¦‚ç‡ç»Ÿè®¡åˆ†æ\n`;
      
      message += `\n${CONFIG.EMOJI.check} <b>ç§»é™¤è™šå‡è¿›åº¦</b>\n`;
      message += `â€¢ æ— 5å°æ—¶è™šå‡ç­‰å¾…\n`;
      message += `â€¢ çœŸå®è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ\n`;
      message += `â€¢ å³æ—¶ç”Ÿæˆç»“æœ\n`;
      
      message += `\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹ï¼š`;
      
      return message;
    } catch (error) {
      return `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n\nç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\nç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œè¯·é€‰æ‹©åŠŸèƒ½ã€‚`;
    }
  }

  static renderPrediction(predictionData) {
    try {
      const { nextExpect, prediction, isBasedOnSimulation, historyCount, generatedAt, simulationInfo } = predictionData;
      
      let message = `ğŸ”® <b>${CONFIG.SYSTEM.NAME} - å®æ—¶é¢„æµ‹</b>\n`;
      message += `ç¬¬ <b>${nextExpect}</b> æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      
      // æ•°æ®æ¥æºè¯´æ˜
      if (isBasedOnSimulation) {
        message += `${CONFIG.EMOJI.cpu} <b>åŸºäºçœŸå®æ¨¡æ‹Ÿåˆ†æ</b>\n`;
        message += `æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(simulationInfo?.iterations || CONFIG.SYSTEM.SIMULATION_ITERATIONS)}\n`;
        message += `å†å²æ•°æ®: ${historyCount} æœŸ\n\n`;
      } else {
        message += `${CONFIG.EMOJI.warning} <b>åŸºäºéšæœºç®—æ³•</b>\n`;
        message += `å†å²æ•°æ®ä¸è¶³ï¼Œå»ºè®®åŒæ­¥æ›´å¤šå†å²è®°å½•\n\n`;
      }
      
      // ç‰¹ç æ¨è
      if (prediction.specials && prediction.specials.length > 0) {
        message += `${CONFIG.EMOJI.star} <b>ç‰¹ç æ¨è</b> (æŒ‰æ¦‚ç‡æ’åº):\n`;
        prediction.specials.slice(0, 5).forEach((item, index) => {
          const probPercent = (item.probability * 100).toFixed(1);
          message += `${index + 1}. ${item.number}(${item.zodiac}${CONFIG.EMOJI[item.color]}) - ${probPercent}%\n`;
        });
        message += `\n`;
      }
      
      // å¹³ç æ¨è
      if (prediction.normals && prediction.normals.length > 0) {
        message += `${CONFIG.EMOJI.diamond} <b>å¹³ç æ¨è</b>:\n`;
        const normalNumbers = prediction.normals.slice(0, 6).map(item => 
          `${item.number}(${item.zodiac}${CONFIG.EMOJI[item.color]})`
        ).join("  ");
        message += `${normalNumbers}\n\n`;
      }
      
      // ç”Ÿè‚–æ¨è
      if (prediction.zodiacs && prediction.zodiacs.length > 0) {
        message += `${CONFIG.EMOJI.trophy} <b>ç”Ÿè‚–æ¨è</b>:\n`;
        const zodiacList = prediction.zodiacs.slice(0, 5).map((item, index) => {
          const probPercent = (item.probability * 100).toFixed(1);
          return `${item.zodiac}(${probPercent}%)`;
        }).join("  ");
        message += `${zodiacList}\n\n`;
      }
      
      // æ³¢è‰²æ¨è
      if (prediction.colors && prediction.colors.length > 0) {
        message += `${CONFIG.EMOJI.fire} <b>æ³¢è‰²æ¨è</b>:\n`;
        prediction.colors.slice(0, 3).forEach((item, index) => {
          const probPercent = (item.probability * 100).toFixed(1);
          message += `${index + 1}. ${CONFIG.EMOJI[item.color]} ${item.color} - ${probPercent}%\n`;
        });
        message += `\n`;
      }
      
      // å½¢æ€æ¨è
      if (prediction.shapes && prediction.shapes.length > 0) {
        const topShape = prediction.shapes[0];
        if (topShape) {
          const shapeNames = {
            bigOdd: "å¤§å•",
            bigEven: "å¤§åŒ",
            smallOdd: "å°å•",
            smallEven: "å°åŒ"
          };
          const probPercent = (topShape.probability * 100).toFixed(1);
          message += `${CONFIG.EMOJI.chart} <b>å½¢æ€æ¨è</b>: ${shapeNames[topShape.shape] || topShape.shape} (${probPercent}%)\n`;
        }
      }
      
      // ç½®ä¿¡åº¦
      message += `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      message += `${CONFIG.EMOJI.check} <b>ç½®ä¿¡åº¦</b>: ${prediction.confidence || 0}%\n`;
      
      // é¢„æµ‹æ—¶é—´
      try {
        const genDate = new Date(generatedAt);
        message += `${CONFIG.EMOJI.cpu} <b>ç”Ÿæˆæ—¶é—´</b>: ${genDate.toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}\n`;
      } catch (e) {
        message += `${CONFIG.EMOJI.cpu} <b>ç”Ÿæˆæ—¶é—´</b>: ${Formatter.formatDateTime()}\n`;
      }
      
      // ç®—æ³•ç‰ˆæœ¬
      message += `${CONFIG.EMOJI.rocket} <b>ç®—æ³•ç‰ˆæœ¬</b>: ${predictionData.algorithmVersion || "V7.0"}\n`;
      
      // å†å²æ•°æ®æ¥æº
      if (prediction.basedOnRecord) {
        const { expect, special, zodiac, color } = prediction.basedOnRecord;
        message += `${CONFIG.EMOJI.history} <b>åŸºäº</b>: ç¬¬ ${expect} æœŸ (ç‰¹ç ${special} | ${zodiac}${CONFIG.EMOJI[color]})\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„æµ‹æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} <b>é¢„æµ‹æ¸²æŸ“å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.history} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      return message;
    } catch (error) {
      return `${CONFIG.EMOJI.warning} è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯`;
    }
  }

  static generateHistoryKeyboard(page, totalPages) {
    try {
      const keyboard = { inline_keyboard: [] };
      const navRow = [];
      
      if (page > 1) {
        navRow.push({ text: "â—€ï¸ ä¸Šä¸€é¡µ", callback_data: `history_page_${page - 1}` });
      }
      
      navRow.push({ text: `ğŸ“„ ${page}/${totalPages}`, callback_data: "current_page" });
      
      if (page < totalPages) {
        navRow.push({ text: "ä¸‹ä¸€é¡µ â–¶ï¸", callback_data: `history_page_${page + 1}` });
      }
      
      if (navRow.length > 0) {
        keyboard.inline_keyboard.push(navRow);
      }
      
      keyboard.inline_keyboard.push([{ text: "ğŸ”™ è¿”å›ä¸»èœå•", callback_data: CALLBACK_DATA.MAIN_MENU }]);
      
      return keyboard;
    } catch (error) {
      return { inline_keyboard: [[{ text: "è¿”å›", callback_data: CALLBACK_DATA.MAIN_MENU }]] };
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.sync} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
      } else {
        message += `âŒ <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      return message;
    } catch (error) {
      return `${CONFIG.EMOJI.warning} å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteInfo() {
    return `
${CONFIG.EMOJI.warning} <b>åˆ é™¤è®°å½•åŠŸèƒ½è¯´æ˜</b>

ä½¿ç”¨ä»¥ä¸‹æ ¼å¼åˆ é™¤å†å²è®°å½•ï¼š

<b>å•ä¸ªæœŸå·åˆ é™¤</b>
<code>/delete 2025001</code>

<b>æœŸå·èŒƒå›´åˆ é™¤</b>
<code>/delete 2025001-2025010</code>

<b>æ³¨æ„äº‹é¡¹ï¼š</b>
1. åˆ é™¤æ“ä½œä¸å¯æ¢å¤
2. åˆ é™¤åé¢„æµ‹ä¼šåŸºäºå‰©ä½™æ•°æ®é‡æ–°è®¡ç®—

è¯·ç›´æ¥å‘é€åˆ é™¤å‘½ä»¤åˆ°èŠå¤©æ¡†ã€‚
    `.trim();
  }

  static renderDeleteResult(result, expectRange) {
    try {
      let message = `${CONFIG.EMOJI.sync} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åˆ é™¤æˆåŠŸ</b>\n`;
        message += `åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
        message += `åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `âŒ <b>åˆ é™¤å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\næ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
      
      return message;
    } catch (error) {
      return `${CONFIG.EMOJI.warning} å¤„ç†åˆ é™¤ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }
}

// ==============================================================================
// 7. å¤–éƒ¨æ¥å£å°è£… - ç²¾ç®€ç‰ˆ
// ==============================================================================

class ExternalService {
  static async sendOrEditMessage(env, chatId, text, keyboard = null, messageId = null, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };
      
      if (keyboard) body.reply_markup = keyboard;

      let url;
      
      if (messageId) {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;
        body.message_id = messageId;
      } else {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;
      }

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendOrEditMessage failed: ${result.description}`);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendOrEditMessage network error", error);
      return null;
    }
  }

  static async answerCallbackQuery(env, callbackQueryId, text = "å¤„ç†ä¸­...", showAlert = false) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/answerCallbackQuery`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          callback_query_id: callbackQueryId,
          text: text,
          show_alert: showAlert
        })
      });
      
      return await response.json();
    } catch (error) {
      Logger.error("Telegram", "answerCallbackQuery failed", error);
      return null;
    }
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/7.0',
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => {
        const numA = Formatter.safeInt(a.expect, 0);
        const numB = Formatter.safeInt(b.expect, 0);
        return numB - numA; // é™åºæ’åº
      });

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => {
          const recordExpect = Formatter.safeInt(r.expect, 0);
          const dbExpect = Formatter.safeInt(latestInDB, 0);
          return recordExpect > dbExpect;
        });
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.join(",")
            });
          }
        }
      } catch (e) {
        // å¿½ç•¥è§£æé”™è¯¯
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.join(",")
          });
        }
      } catch (e) {
        // å¿½ç•¥è§£æé”™è¯¯
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 8. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ - ç²¾ç®€ç‰ˆ
// ==============================================================================

class Controller {
  static async showMainMenu(env, chatId, messageId = null, isAdmin = false) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const lastSync = await DB.getSetting(env, "LAST_SYNC", "");
      
      const message = MessageRenderer.renderMainMenu(historyCount, lastSync);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(isAdmin);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºä¸»èœå•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºä¸»èœå•ï¼Œè¯·é‡è¯•ã€‚",
        null, messageId
      );
    }
  }

  static async handlePreview(env, chatId, messageId) {
    const startTime = Date.now();
    try {
      Logger.info("Preview", `å¤„ç†é¢„è§ˆè¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      // å‘é€å¤„ç†ä¸­æ¶ˆæ¯
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.cpu} <b>æ­£åœ¨æ‰§è¡ŒçœŸå®æ¨¡æ‹Ÿé¢„æµ‹...</b>\n\næ­£åœ¨è¿›è¡Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿï¼Œè¯·ç¨å€™...`,
        null, messageId
      );
      
      // ç”ŸæˆçœŸå®é¢„æµ‹
      const predictionData = await RealPredictionEngine.generatePrediction(env);
      
      const message = MessageRenderer.renderPrediction(predictionData);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      const duration = Date.now() - startTime;
      Logger.info("Preview", `é¢„æµ‹å®Œæˆï¼Œè€—æ—¶: ${duration}msï¼Œç½®ä¿¡åº¦: ${predictionData.prediction.confidence || 0}%`);
      
    } catch (error) {
      Logger.error("Preview", "å¤„ç†é¢„è§ˆå¤±è´¥", error);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç”Ÿæˆé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}\n\nè¯·ç¨åé‡è¯•ã€‚`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleHistory(env, chatId, page = 1, messageId = null) {
    try {
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      const keyboard = MessageRenderer.generateHistoryKeyboard(page, totalPages);

      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºå†å²è®°å½•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleSync(env, chatId, messageId) {
    try {
      Logger.info("Sync", `æ‰‹åŠ¨åŒæ­¥è¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.sync} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      const message = MessageRenderer.renderSyncResult(result);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleDelete(env, chatId, messageId) {
    try {
      const message = MessageRenderer.renderDeleteInfo();
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `æ˜¾ç¤ºåˆ é™¤åŠŸèƒ½è¯´æ˜ï¼ŒchatId: ${chatId}`);
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤åŠŸèƒ½å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>æ˜¾ç¤ºåˆ é™¤åŠŸèƒ½å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async handleDeleteCommand(env, chatId, userId, commandText, messageId = null) {
    try {
      Logger.info("Delete", `å¤„ç†åˆ é™¤å‘½ä»¤: ${commandText}, userId: ${userId}`);
      
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.sync} <b>æ­£åœ¨åˆ é™¤è®°å½•...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      const result = await DB.deleteHistoryByRange(
        env, 
        rangeInfo.start, 
        rangeInfo.end,
        Formatter.safeString(userId)
      );
      
      const message = MessageRenderer.renderDeleteResult(result, expectRange);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå®Œæˆ: ${expectRange}, åˆ é™¤è®°å½•æ•°: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }
}

// ==============================================================================
// 9. äº‹ä»¶å¤„ç†å™¨ - ç²¾ç®€ç‰ˆ
// ==============================================================================

async function handleCallback(env, query) {
  try {
    const data = query.data;
    const chatId = query.message.chat.id;
    const messageId = query.message.message_id;
    const userId = query.from.id;
    
    Logger.info("Callback", `æ”¶åˆ°å›è°ƒ: ${data}`, { chatId, userId });
    
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†ä¸­...");
    
    const isAdmin = (String(userId) === String(env.TG_ADMIN_ID));
    
    if (data === CALLBACK_DATA.MAIN_MENU) {
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
      
    } else if (data === CALLBACK_DATA.PREVIEW) {
      await Controller.handlePreview(env, chatId, messageId);
      
    } else if (data === CALLBACK_DATA.HISTORY) {
      await Controller.handleHistory(env, chatId, 1, messageId);
      
    } else if (data.startsWith("history_page_")) {
      const page = Formatter.safeInt(data.replace("history_page_", ''), 1);
      await Controller.handleHistory(env, chatId, page, messageId);
      
    } else if (data === CALLBACK_DATA.SYNC) {
      if (isAdmin) {
        await Controller.handleSync(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.DELETE) {
      if (isAdmin) {
        await Controller.handleDelete(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === "current_page") {
      await ExternalService.answerCallbackQuery(env, query.id, "å½“å‰é¡µé¢", true);
      
    } else {
      await ExternalService.answerCallbackQuery(env, query.id, "æœªçŸ¥æ“ä½œ", true);
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
    }
  } catch (error) {
    Logger.error("Callback", "å¤„ç†å›è°ƒå¤±è´¥", error);
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", true);
  }
}

async function handleUpdate(env, payload) {
  try {
    if (payload.callback_query) {
      await handleCallback(env, payload.callback_query);
      return;
    }

    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId });
    
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    if (text === "/start" || text === "/menu") {
      await Controller.showMainMenu(env, chatId, null, isAdmin);
      return;
    }
    
    // å¤„ç†åˆ é™¤å‘½ä»¤
    if (text.startsWith('/delete') && isAdmin) {
      await Controller.handleDeleteCommand(env, chatId, userId, text, null);
      return;
    }
    
    // å…¶ä»–æ–‡æœ¬å‘½ä»¤å¤„ç†
    if (text.includes("é¢„è§ˆ") || text.includes("é¢„æµ‹")) {
      await Controller.handlePreview(env, chatId, null);
    } else if (text.includes("å†å²") || text.includes("è®°å½•")) {
      await Controller.handleHistory(env, chatId, 1, null);
    } else if (text.includes("åŒæ­¥") && isAdmin) {
      await Controller.handleSync(env, chatId, null);
    } else if (text.includes("åˆ é™¤") && isAdmin) {
      await Controller.handleDelete(env, chatId, null);
    } else {
      await Controller.showMainMenu(env, chatId, null, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}

// ==============================================================================
// 10. Worker å…¥å£ç‚¹ - ç²¾ç®€ç‰ˆ
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response("Database Initialization Failed. Please check D1 binding.", { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const latestExpect = await DB.getLatestExpect(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              database: {
                historyCount: historyCount,
                latestExpect: latestExpect
              },
              simulation: {
                iterations: CONFIG.SYSTEM.SIMULATION_ITERATIONS,
                minHistoryRequired: CONFIG.SYSTEM.MIN_HISTORY_RECORDS
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // ä¸»é¡µæ˜¾ç¤º
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                  color: white;
                }
                .container {
                  background: rgba(255, 255, 255, 0.95);
                  border-radius: 15px;
                  padding: 30px;
                  color: #333;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                }
                .features {
                  margin: 20px 0;
                }
                .feature {
                  background: #f7fafc;
                  border-radius: 8px;
                  padding: 15px;
                  margin-bottom: 10px;
                  border-left: 4px solid #4299e1;
                }
                .status {
                  background: #c6f6d5;
                  color: #22543d;
                  padding: 10px;
                  border-radius: 8px;
                  text-align: center;
                  margin: 20px 0;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <p style="text-align: center; color: #4a5568;">${CONFIG.SYSTEM.VERSION}</p>
                
                <div class="status">
                  âœ… çœŸå®è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿç³»ç»Ÿ | ç§»é™¤è™šå‡è¿›åº¦
                </div>
                
                <div class="features">
                  <div class="feature">
                    <strong>ğŸ¯ çœŸå®æ¨¡æ‹Ÿé¢„æµ‹</strong>
                    <p>åŸºäºå†å²æ•°æ®çš„æ¦‚ç‡ç»Ÿè®¡åˆ†æï¼Œæ¯æ¬¡é¢„æµ‹è¿›è¡Œ${Formatter.formatLargeNumber(CONFIG.SYSTEM.SIMULATION_ITERATIONS)}æ¬¡è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ</p>
                  </div>
                  
                  <div class="feature">
                    <strong>ğŸš« æ— è™šå‡ç­‰å¾…</strong>
                    <p>ç§»é™¤äº†5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿçš„è™šå‡è¿›åº¦ï¼Œé¢„æµ‹åœ¨æ•°ç§’å†…çœŸå®å®Œæˆ</p>
                  </div>
                  
                  <div class="feature">
                    <strong>ğŸ“Š æ¦‚ç‡ç»Ÿè®¡</strong>
                    <p>åŸºäºå†å²é¢‘ç‡ã€ç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ç­‰å¤šç»´åº¦æ¦‚ç‡åˆ†æ</p>
                  </div>
                  
                  <div class="feature">
                    <strong>âš¡ å³æ—¶å“åº”</strong>
                    <p>æ— éœ€é•¿æ—¶é—´ç­‰å¾…ï¼Œå®æ—¶ç”Ÿæˆé«˜è´¨é‡é¢„æµ‹ç»“æœ</p>
                  </div>
                </div>
                
                <p style="text-align: center; color: #718096;">
                  é€šè¿‡Telegramæœºå™¨äººä½¿ç”¨å®Œæ•´åŠŸèƒ½<br>
                  ç³»ç»Ÿå¥åº·æ£€æŸ¥: <a href="/health">/health</a>
                </p>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response("Internal Server Error", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};
