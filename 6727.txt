/**
 * Êæ≥Èó®ÂÖ≠ÂêàÂΩ©È¢ÑÊµãÊú∫Âô®‰∫∫ (Macau Mark Six Prediction Bot)
 * ÁâàÊú¨: V11.1 ‰øÆÂ§çÂ¢ûÂº∫Áâà
 * 
 * ‰øÆÂ§çÂÜÖÂÆπ:
 * 1. ‰øÆÂ§çÂÆöÊó∂‰ªªÂä°Êó∂Èó¥Ê†ºÂºèËØÜÂà´ÈóÆÈ¢ò
 * 2. ‰øÆÂ§çËíôÁâπÂç°Ê¥õÂºÇÊ≠•Ê®°ÊãüÊöÇÂÅúÈóÆÈ¢ò
 * 3. ‰ºòÂåñÂéÜÂè≤ËÆ∞ÂΩï‰ΩøÁî®Á≠ñÁï•‰∏∫ÂÖ®ÈÉ®ËÆ∞ÂΩï
 * 4. ÊîπËøõÈîôËØØÂ§ÑÁêÜÂíåÁ®≥ÂÆöÊÄß
 */

// ==============================================================================
// 1. ÂÖ®Â±ÄÈÖçÁΩÆ‰∏éÂ∏∏ÈáèÂÆö‰πâ
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "üá≤üá¥ Êæ≥ÂÖ≠È¢ÑÊµã",
    VERSION: "V11.1 ‰øÆÂ§çÂ¢ûÂº∫Áâà",
    TIMEZONE_OFFSET: 8,
    CHANNEL_ID: null,
    ADMIN_ID: null,
    HISTORY_LIMIT: 1000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    MONTECARLO_SIMULATIONS: 20000,
    MONTECARLO_BATCH_SIZE: 1000,
    MONTECARLO_MAX_BATCHES: 100,
    MAX_SIMULATIONS: 100000,
    MIN_SIMULATIONS: 2000,
    MAX_RUNTIME_MS: 25000,
    SAVE_PROGRESS_INTERVAL: 1000,
    ASYNC_BATCH_DELAY: 50  // ÂºÇÊ≠•ÊâπÊ¨°Èó¥Âª∂Ëøü
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.5,
    w_zodiac_relation: 2.0,
    w_color_transfer: 1.8,
    w_tail_correlation: 1.5,
    w_number_frequency: 1.3,
    w_monte_carlo: 3.0,
    _version: "11.1"
  },

  ZODIAC_MAP: {
    "Èº†": [6, 18, 30, 42],
    "Áâõ": [5, 17, 29, 41],
    "Ëôé": [4, 16, 28, 40],
    "ÂÖî": [3, 15, 27, 39],
    "Èæô": [2, 14, 26, 38],
    "Ëõá": [1, 13, 25, 37, 49],
    "È©¨": [12, 24, 36, 48],
    "Áæä": [11, 23, 35, 47],
    "Áå¥": [10, 22, 34, 46],
    "È∏°": [9, 21, 33, 45],
    "Áãó": [8, 20, 32, 44],
    "Áå™": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "Èº†": "Áâõ", "Áâõ": "Èº†",
      "Ëôé": "Áå™", "Áå™": "Ëôé",
      "ÂÖî": "Áãó", "Áãó": "ÂÖî",
      "Èæô": "È∏°", "È∏°": "Èæô",
      "Ëõá": "Áå¥", "Áå¥": "Ëõá",
      "È©¨": "Áæä", "Áæä": "È©¨"
    },
    
    THREE_HARMONY: {
      "Èº†": ["Èæô", "Áå¥"],
      "Áâõ": ["Ëõá", "È∏°"],
      "Ëôé": ["È©¨", "Áãó"],
      "ÂÖî": ["Áæä", "Áå™"],
      "Èæô": ["Èº†", "Áå¥"],
      "Ëõá": ["Áâõ", "È∏°"],
      "È©¨": ["Ëôé", "Áãó"],
      "Áæä": ["ÂÖî", "Áå™"],
      "Áå¥": ["Èº†", "Èæô"],
      "È∏°": ["Áâõ", "Ëõá"],
      "Áãó": ["Ëôé", "È©¨"],
      "Áå™": ["ÂÖî", "Áæä"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "üî¥",
    blue: "üîµ",
    green: "üü¢",
    win: "‚úÖ",
    loss: "‚ùå",
    chart: "üìä",
    fire: "üî•",
    shield: "üõ°Ô∏è",
    diamond: "üíé",
    trophy: "üèÜ",
    home: "üè†",
    trash: "üóëÔ∏è",
    warning: "‚ö†Ô∏è",
    database: "üíæ",
    clock: "‚è∞",
    check: "‚úîÔ∏è",
    speed: "‚ö°",
    fix: "üîß",
    bell: "üîî",
    star: "‚≠ê",
    rocket: "üöÄ",
    refresh: "üîÑ",
    eye: "üëÅÔ∏è",
    lock: "üîí",
    dice: "üé≤",
    calendar: "üìÖ",
    hourglass: "‚è≥",
    money: "üí∞",
    target: "üéØ",
    brain: "üß†",
    science: "üî¨",
    chart_up: "üìà",
    clock2: "üïí",
    alarm: "‚è∞",
    repeat: "üîÅ",
    progress: "üìà",
    batch: "üî¢",
    history: "üìú",
    memory: "üíæ",
    cpu: "‚öôÔ∏è"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    STATS: "stats",
    PREDICT: "prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_CONFIRM: "delete_confirm",
    DELETE_RESULT: "delete_result",
    MONTECARLO: "montecarlo",
    MONTECARLO_PROGRESS: "montecarlo_progress",
    SCHEDULE: "schedule",
    SCHEDULE_LIST: "schedule_list",
    SCHEDULE_ADD: "schedule_add",
    SCHEDULE_REMOVE: "schedule_remove",
    SCHEDULE_TEST: "schedule_test"
  },

  SCHEDULE_TYPES: {
    SYNC: "sync",
    PREDICT: "predict",
    PUSH: "push",
    CLEANUP: "cleanup",
    BACKUP: "backup",
    MONTE: "monte"
  }
};

// ==============================================================================
// 2. Â∑•ÂÖ∑Á±ª‰∏éËæÖÂä©ÂáΩÊï∞
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
  
  static debug(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [DEBUG] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.debug] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "Êú™Áü•", color: "Êú™Áü•" };
      }
      
      let zodiac = "Êú™Áü•";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "Êú™Áü•";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "Êú™Áü•", color: "Êú™Áü•" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "Êú™Áü•Êó∂Èó¥";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(2) + '‰∫ø';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + '‰∏á';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }

  // ‰øÆÂ§çÊó∂Èó¥Ëß£ÊûêÂáΩÊï∞
  static parseTimeString(timeStr) {
    try {
      if (!timeStr || typeof timeStr !== 'string') {
        Logger.debug("Formatter", "Êó∂Èó¥Â≠óÁ¨¶‰∏≤‰∏∫Á©∫ÊàñÈùûÂ≠óÁ¨¶‰∏≤", { timeStr });
        return null;
      }
      
      const trimmed = timeStr.trim();
      
      Logger.debug("Formatter", "Ëß£ÊûêÊó∂Èó¥Â≠óÁ¨¶‰∏≤", { trimmed });
      
      // 1. Â∞ùËØïËß£Êûê‰∏∫CronË°®ËææÂºèÔºà5‰∏™ÈÉ®ÂàÜÔºâ
      const cronParts = trimmed.split(' ');
      if (cronParts.length === 5) {
        Logger.debug("Formatter", "ËØÜÂà´‰∏∫CronË°®ËææÂºè", { cronParts });
        return { cron: trimmed, type: "cron" };
      }
      
      // 2. Â∞ùËØïËß£Êûê‰∏∫ÊØèÊó•Êó∂Èó¥ "HH:MM"
      const dailyMatch = trimmed.match(/^(\d{1,2}):(\d{2})$/);
      if (dailyMatch) {
        const hours = parseInt(dailyMatch[1]);
        const minutes = parseInt(dailyMatch[2]);
        
        if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
          Logger.debug("Formatter", "ËØÜÂà´‰∏∫ÊØèÊó•Êó∂Èó¥", { hours, minutes });
          return { hours, minutes, type: "daily" };
        }
      }
      
      // 3. Â∞ùËØïËß£Êûê‰∏∫ÂÖ∑‰ΩìÊó∂Èó¥ "YYYY-MM-DD HH:MM"
      const dateTimeMatch = trimmed.match(/^(\d{4})-(\d{1,2})-(\d{1,2})\s+(\d{1,2}):(\d{2})$/);
      if (dateTimeMatch) {
        const year = parseInt(dateTimeMatch[1]);
        const month = parseInt(dateTimeMatch[2]) - 1;
        const day = parseInt(dateTimeMatch[3]);
        const hours = parseInt(dateTimeMatch[4]);
        const minutes = parseInt(dateTimeMatch[5]);
        
        const date = new Date(year, month, day, hours, minutes, 0, 0);
        if (!isNaN(date.getTime())) {
          Logger.debug("Formatter", "ËØÜÂà´‰∏∫ÂÖ∑‰ΩìÊó∂Èó¥", { date });
          return { date, type: "once" };
        }
      }
      
      // 4. Â∞ùËØïËß£Êûê‰∏∫Áõ∏ÂØπÊó∂Èó¥ "tomorrow HH:MM" Êàñ "next week HH:MM"
      if (trimmed.startsWith("tomorrow ")) {
        const timePart = trimmed.replace("tomorrow ", "");
        const timeMatch = timePart.match(/^(\d{1,2}):(\d{2})$/);
        if (timeMatch) {
          const hours = parseInt(timeMatch[1]);
          const minutes = parseInt(timeMatch[2]);
          
          if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
            const date = new Date();
            date.setDate(date.getDate() + 1);
            date.setHours(hours, minutes, 0, 0);
            
            Logger.debug("Formatter", "ËØÜÂà´‰∏∫ÊòéÂ§©Êó∂Èó¥", { date });
            return { date, type: "once" };
          }
        }
      }
      
      // 5. Â∞ùËØïËß£Êûê‰∏∫Áõ∏ÂØπÂàÜÈíüÊï∞ "in X minutes"
      const minutesMatch = trimmed.match(/^in\s+(\d+)\s+minutes?$/i);
      if (minutesMatch) {
        const minutes = parseInt(minutesMatch[1]);
        if (minutes > 0) {
          const date = new Date();
          date.setMinutes(date.getMinutes() + minutes);
          
          Logger.debug("Formatter", "ËØÜÂà´‰∏∫Áõ∏ÂØπÂàÜÈíüÊï∞", { date, minutes });
          return { date, type: "once" };
        }
      }
      
      Logger.warn("Formatter", "Êó†Ê≥ïËØÜÂà´Êó∂Èó¥Ê†ºÂºè", { timeStr: trimmed });
      return null;
    } catch (error) {
      Logger.error("Formatter", "Ëß£ÊûêÊó∂Èó¥Â≠óÁ¨¶‰∏≤Â§±Ë¥•", error);
      return null;
    }
  }

  static formatCronDescription(cronStr) {
    try {
      const parts = cronStr.split(' ');
      if (parts.length !== 5) return cronStr;
      
      const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
      
      const descriptions = [];
      
      if (minute === '*') {
        descriptions.push("ÊØèÂàÜÈíü");
      } else if (minute.includes('/')) {
        const [, interval] = minute.split('/');
        descriptions.push(`ÊØè${interval}ÂàÜÈíü`);
      } else if (minute === '0') {
        descriptions.push("Êï¥ÁÇπ");
      } else {
        descriptions.push(`${minute}ÂàÜ`);
      }
      
      if (hour === '*') {
        descriptions.push("ÊØèÂ∞èÊó∂");
      } else if (hour.includes('/')) {
        const [, interval] = hour.split('/');
        descriptions.push(`ÊØè${interval}Â∞èÊó∂`);
      } else if (hour === '0') {
      } else {
        descriptions.push(`${hour}Êó∂`);
      }
      
      if (dayOfMonth === '*') {
        descriptions.push("ÊØèÂ§©");
      } else if (dayOfMonth.includes('/')) {
        const [, interval] = dayOfMonth.split('/');
        descriptions.push(`ÊØè${interval}Â§©`);
      } else {
        descriptions.push(`ÊØèÊúà${dayOfMonth}Êó•`);
      }
      
      if (month === '*') {
      } else if (month.includes('/')) {
        const [, interval] = month.split('/');
        descriptions.push(`ÊØè${interval}‰∏™Êúà`);
      } else {
        const months = ['‰∏ÄÊúà', '‰∫åÊúà', '‰∏âÊúà', 'ÂõõÊúà', '‰∫îÊúà', 'ÂÖ≠Êúà', '‰∏ÉÊúà', 'ÂÖ´Êúà', '‰πùÊúà', 'ÂçÅÊúà', 'ÂçÅ‰∏ÄÊúà', 'ÂçÅ‰∫åÊúà'];
        descriptions.push(`${months[parseInt(month) - 1] || month}Êúà`);
      }
      
      if (dayOfWeek === '*') {
      } else if (dayOfWeek.includes('/')) {
        const [, interval] = dayOfWeek.split('/');
        descriptions.push(`ÊØè${interval}Âë®`);
      } else {
        const days = ['Âë®Êó•', 'Âë®‰∏Ä', 'Âë®‰∫å', 'Âë®‰∏â', 'Âë®Âõõ', 'Âë®‰∫î', 'Âë®ÂÖ≠'];
        const dayInt = parseInt(dayOfWeek);
        descriptions.push(days[dayInt] || `ÊòüÊúü${dayOfWeek}`);
      }
      
      return descriptions.join(' ');
    } catch (error) {
      return cronStr;
    }
  }

  static getRandomElement(array) {
    try {
      if (!array || !Array.isArray(array) || array.length === 0) return null;
      return array[Math.floor(Math.random() * array.length)];
    } catch (error) {
      return null;
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static formatDuration(ms) {
    try {
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms/1000).toFixed(2)}Áßí`;
      if (ms < 3600000) return `${Math.floor(ms/60000)}ÂàÜ${Math.floor((ms%60000)/1000)}Áßí`;
      return `${Math.floor(ms/3600000)}Â∞èÊó∂${Math.floor((ms%3600000)/60000)}ÂàÜ`;
    } catch (error) {
      return `${ms}ms`;
    }
  }

  static formatProgress(current, total) {
    try {
      const percent = total > 0 ? ((current / total) * 100).toFixed(1) : 0;
      const progressBarLength = 20;
      const filled = Math.round((current / total) * progressBarLength);
      const empty = progressBarLength - filled;
      const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
      return `${bar} ${percent}% (${current}/${total})`;
    } catch (error) {
      return `${current}/${total}`;
    }
  }
}

// ==============================================================================
// 3. Ê∂àÊÅØÁÆ°ÁêÜÂô®
// ==============================================================================

class MessageManager {
  static userMessages = new Map();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static deleteUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.delete(messageType);
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
  
  static getUserStats(chatId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return {
      totalTypes: userMap.size,
      types: Array.from(userMap.keys())
    };
  }
  
  static getAllUserMessages(chatId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return Array.from(userMap.entries()).map(([type, id]) => ({ type, id }));
  }
  
  static cleanupOldMessages(chatId, keepCount = 10) {
    try {
      this.initUser(chatId);
      const userMap = this.userMessages.get(chatId);
      
      if (userMap.size <= keepCount) {
        return 0;
      }
      
      const entries = Array.from(userMap.entries());
      const toRemove = entries.slice(0, entries.length - keepCount);
      
      let removed = 0;
      for (const [key, _] of toRemove) {
        if (userMap.delete(key)) {
          removed++;
        }
      }
      
      Logger.info("MessageManager", `Ê∏ÖÁêÜ‰∫Ü ${removed} Êù°ÊóßÊ∂àÊÅØ`, { chatId });
      return removed;
    } catch (error) {
      Logger.error("MessageManager", "Ê∏ÖÁêÜÊóßÊ∂àÊÅØÂ§±Ë¥•", error);
      return 0;
    }
  }
}

// ==============================================================================
// 4. ÁºìÂ≠òÁÆ°ÁêÜÂô®
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "ËÆæÁΩÆÁºìÂ≠òÂ§±Ë¥•", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  }
  
  static getStats() {
    try {
      const now = Date.now();
      let validCount = 0;
      let expiredCount = 0;
      
      for (const [_, item] of this.cache) {
        if (now > item.expireAt) {
          expiredCount++;
        } else {
          validCount++;
        }
      }
      
      return {
        total: this.cache.size,
        valid: validCount,
        expired: expiredCount
      };
    } catch (error) {
      return { total: 0, valid: 0, expired: 0 };
    }
  }
}

// ==============================================================================
// 5. Êï∞ÊçÆÂ∫ìÊìç‰ΩúÂ±ÇÔºà‰øÆÂ§çÂíåÊîπËøõÔºâ
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "ÂºÄÂßãÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS schedule_tasks (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT,
          task_type TEXT,
          schedule TEXT,
          params TEXT,
          enabled INTEGER DEFAULT 1,
          last_run TIMESTAMP,
          next_run TIMESTAMP,
          run_count INTEGER DEFAULT 0,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_schedule_enabled ON schedule_tasks (enabled, next_run)`,
        `CREATE TABLE IF NOT EXISTS montecarlo_results (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          simulation_id TEXT,
          simulations INTEGER,
          sample_type TEXT,
          special_numbers TEXT,
          normal_numbers TEXT,
          confidence REAL,
          duration_ms INTEGER,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS montecarlo_progress (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          session_id TEXT,
          chat_id TEXT,
          total_simulations INTEGER,
          completed_simulations INTEGER,
          batch_size INTEGER,
          special_frequency TEXT,
          normal_frequency TEXT,
          zodiac_frequency TEXT,
          color_frequency TEXT,
          tail_frequency TEXT,
          last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂÆåÊàê");
      return true;
      
    } catch (e) {
      Logger.error("DB", "Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  // ‰ΩøÁî®ÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩï
  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  checkExpectExists: async function(env, expect) {
    try {
      if (!expect) return false;
      
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(Formatter.safeString(expect)).first();
      
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `ÂºÄÂßãÊâπÈáèÊ∑ªÂä† ${records.length} Êù°ËÆ∞ÂΩï`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code &&
          Formatter.isValidExpect(record.expect.toString())
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `ÊâπÊ¨°ÊèíÂÖ•Â§±Ë¥•`, chunkError);
          
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `ÂçïÊù°ÊèíÂÖ•Â§±Ë¥• ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `ÊâπÈáèÊ∑ªÂä†ÂÆåÊàê: Ê∑ªÂä† ${totalAdded} Êù°ÔºåË∑≥Ëøá ${totalSkipped} Êù°`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          weights = { ...defaultWeights, ...parsed };
        } catch (parseError) {
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0",
        "TOTAL_SCHEDULES": "0",
        "TOTAL_MONTE": "0",
        "MONTE_SAMPLE_TYPE": "full_history"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "ÈªòËÆ§ËÆæÁΩÆÂàùÂßãÂåñÂÆåÊàê");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "ÊâãÂä®Âà†Èô§") {
    try {
      Logger.info("DB", `ÂºÄÂßãÂà†Èô§ËÆ∞ÂΩï: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "ÊåáÂÆöËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊâæÂà∞ËÆ∞ÂΩï"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `Âà†Èô§ÂÆåÊàê: Âà†Èô§‰∫Ü ${deletedCount} Êù°ËÆ∞ÂΩï`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `ÊàêÂäüÂà†Èô§ ${deletedCount} Êù°ËÆ∞ÂΩï (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "Âà†Èô§Êìç‰ΩúÂ§±Ë¥•"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  getDeletionStats: async function(env) {
    try {
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM deletion_log"
      ).first();
      
      const recordsResult = await env.DB.prepare(
        "SELECT SUM(deleted_count) as total FROM deletion_log"
      ).first();
      
      const recentResult = await env.DB.prepare(
        "SELECT created_at FROM deletion_log ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalDeletions: totalResult ? totalResult.count : 0,
        totalRecordsDeleted: recordsResult ? (recordsResult.total || 0) : 0,
        lastDeletion: recentResult ? recentResult.created_at : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionStats failed", e);
      return {
        totalDeletions: 0,
        totalRecordsDeleted: 0,
        lastDeletion: null
      };
    }
  },

  // ============== ËíôÁâπÂç°Ê¥õÁõ∏ÂÖ≥ÊñπÊ≥ï ==============
  saveMonteCarloResult: async function(env, result) {
    try {
      const { simulation_id, simulations, sample_type, special_numbers, normal_numbers, confidence, duration_ms } = result;
      
      const sql = `
        INSERT INTO montecarlo_results 
        (simulation_id, simulations, sample_type, special_numbers, normal_numbers, confidence, duration_ms) 
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `;
      
      const dbResult = await env.DB.prepare(sql).bind(
        Formatter.safeString(simulation_id),
        simulations,
        Formatter.safeString(sample_type),
        Formatter.safeString(JSON.stringify(special_numbers || [])),
        Formatter.safeString(JSON.stringify(normal_numbers || [])),
        confidence,
        duration_ms
      ).run();
      
      if (dbResult && dbResult.lastRowId) {
        const totalMonte = Formatter.safeInt(await this.getSetting(env, "TOTAL_MONTE", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_MONTE", totalMonte.toString());
        
        return { success: true, id: dbResult.lastRowId };
      }
      
      return { success: false, error: "‰øùÂ≠òÂ§±Ë¥•" };
    } catch (e) {
      Logger.error("DB", "saveMonteCarloResult failed", e);
      return { success: false, error: e.message };
    }
  },

  getMonteCarloResults: async function(env, limit = 10) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM montecarlo_results ORDER BY created_at DESC LIMIT ?"
      ).bind(limit).all();
      
      return results || [];
    } catch (e) {
      Logger.error("DB", "getMonteCarloResults failed", e);
      return [];
    }
  },

  getMonteCarloStats: async function(env) {
    try {
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count, AVG(simulations) as avg_simulations, AVG(confidence) as avg_confidence, AVG(duration_ms) as avg_duration FROM montecarlo_results"
      ).first();
      
      const recentResult = await env.DB.prepare(
        "SELECT created_at, sample_type FROM montecarlo_results ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      const sampleTypes = await env.DB.prepare(
        "SELECT sample_type, COUNT(*) as count FROM montecarlo_results GROUP BY sample_type"
      ).all();
      
      return {
        total: totalResult ? totalResult.count : 0,
        avgSimulations: totalResult ? Math.round(totalResult.avg_simulations || 0) : 0,
        avgConfidence: totalResult ? Math.round((totalResult.avg_confidence || 0) * 10) / 10 : 0,
        avgDuration: totalResult ? Math.round(totalResult.avg_duration || 0) : 0,
        lastRun: recentResult ? recentResult.created_at : null,
        lastSampleType: recentResult ? recentResult.sample_type : null,
        sampleTypes: sampleTypes.results || []
      };
    } catch (e) {
      Logger.error("DB", "getMonteCarloStats failed", e);
      return {
        total: 0,
        avgSimulations: 0,
        avgConfidence: 0,
        avgDuration: 0,
        lastRun: null,
        lastSampleType: null,
        sampleTypes: []
      };
    }
  },

  // ËíôÁâπÂç°Ê¥õËøõÂ∫¶Ë∑üË∏™
  saveMonteCarloProgress: async function(env, progress) {
    try {
      const { session_id, chat_id, total_simulations, completed_simulations, batch_size, 
              special_frequency, normal_frequency, zodiac_frequency, color_frequency, tail_frequency } = progress;
      
      const existing = await env.DB.prepare(
        "SELECT id FROM montecarlo_progress WHERE session_id = ? AND chat_id = ?"
      ).bind(session_id, chat_id).first();
      
      let result;
      if (existing) {
        result = await env.DB.prepare(`
          UPDATE montecarlo_progress 
          SET total_simulations = ?, completed_simulations = ?, batch_size = ?,
              special_frequency = ?, normal_frequency = ?, zodiac_frequency = ?,
              color_frequency = ?, tail_frequency = ?, last_updated = CURRENT_TIMESTAMP
          WHERE session_id = ? AND chat_id = ?
        `).bind(
          total_simulations,
          completed_simulations,
          batch_size,
          Formatter.safeString(JSON.stringify(special_frequency)),
          Formatter.safeString(JSON.stringify(normal_frequency)),
          Formatter.safeString(JSON.stringify(zodiac_frequency)),
          Formatter.safeString(JSON.stringify(color_frequency)),
          Formatter.safeString(JSON.stringify(tail_frequency)),
          session_id,
          chat_id
        ).run();
      } else {
        result = await env.DB.prepare(`
          INSERT INTO montecarlo_progress 
          (session_id, chat_id, total_simulations, completed_simulations, batch_size,
           special_frequency, normal_frequency, zodiac_frequency, color_frequency, tail_frequency)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
          session_id,
          chat_id,
          total_simulations,
          completed_simulations,
          batch_size,
          Formatter.safeString(JSON.stringify(special_frequency)),
          Formatter.safeString(JSON.stringify(normal_frequency)),
          Formatter.safeString(JSON.stringify(zodiac_frequency)),
          Formatter.safeString(JSON.stringify(color_frequency)),
          Formatter.safeString(JSON.stringify(tail_frequency))
        ).run();
      }
      
      return { success: true, changes: result.changes || 0 };
    } catch (e) {
      Logger.error("DB", "saveMonteCarloProgress failed", e);
      return { success: false, error: e.message };
    }
  },

  getMonteCarloProgress: async function(env, session_id, chat_id) {
    try {
      const result = await env.DB.prepare(
        "SELECT * FROM montecarlo_progress WHERE session_id = ? AND chat_id = ?"
      ).bind(session_id, chat_id).first();
      
      if (!result) return null;
      
      return {
        session_id: result.session_id,
        chat_id: result.chat_id,
        total_simulations: result.total_simulations,
        completed_simulations: result.completed_simulations,
        batch_size: result.batch_size,
        special_frequency: JSON.parse(result.special_frequency || "{}"),
        normal_frequency: JSON.parse(result.normal_frequency || "{}"),
        zodiac_frequency: JSON.parse(result.zodiac_frequency || "{}"),
        color_frequency: JSON.parse(result.color_frequency || "{}"),
        tail_frequency: JSON.parse(result.tail_frequency || "{}"),
        last_updated: result.last_updated
      };
    } catch (e) {
      Logger.error("DB", "getMonteCarloProgress failed", e);
      return null;
    }
  },

  deleteMonteCarloProgress: async function(env, session_id, chat_id) {
    try {
      const result = await env.DB.prepare(
        "DELETE FROM montecarlo_progress WHERE session_id = ? AND chat_id = ?"
      ).bind(session_id, chat_id).run();
      
      return { success: true, deleted: result.changes || 0 };
    } catch (e) {
      Logger.error("DB", "deleteMonteCarloProgress failed", e);
      return { success: false, error: e.message };
    }
  },

  cleanupOldMonteCarloProgress: async function(env, hours = 24) {
    try {
      const result = await env.DB.prepare(
        `DELETE FROM montecarlo_progress WHERE datetime(last_updated) < datetime('now', ?)`
      ).bind(`-${hours} hours`).run();
      
      Logger.info("DB", `Ê∏ÖÁêÜ‰∫Ü ${result.changes || 0} Êù°ÊóßÁöÑËíôÁâπÂç°Ê¥õËøõÂ∫¶ËÆ∞ÂΩï`);
      return { success: true, deleted: result.changes || 0 };
    } catch (e) {
      Logger.error("DB", "cleanupOldMonteCarloProgress failed", e);
      return { success: false, error: e.message };
    }
  },

  // ============== ÂÆöÊó∂‰ªªÂä°Áõ∏ÂÖ≥ÊñπÊ≥ïÔºà‰øÆÂ§çËÆ°ÁÆó‰∏ãÊ¨°ËøêË°åÊó∂Èó¥Ôºâ ==============
  addScheduleTask: async function(env, name, taskType, schedule, params = "") {
    try {
      Logger.debug("DB", "Ê∑ªÂä†ÂÆöÊó∂‰ªªÂä°", { name, taskType, schedule, params });
      
      const nextRun = this.calculateNextRun(schedule);
      
      Logger.debug("DB", "ËÆ°ÁÆó‰∏ãÊ¨°ËøêË°åÊó∂Èó¥", { schedule, nextRun });
      
      if (!nextRun) {
        return { success: false, error: "Êó†ÊïàÁöÑÂÆöÊó∂Ë°®ËææÂºè" };
      }
      
      const result = await env.DB.prepare(
        "INSERT INTO schedule_tasks (name, task_type, schedule, params, next_run) VALUES (?, ?, ?, ?, ?)"
      ).bind(
        Formatter.safeString(name),
        Formatter.safeString(taskType),
        Formatter.safeString(schedule),
        Formatter.safeString(params),
        nextRun.toISOString()
      ).run();
      
      if (result && result.lastRowId) {
        const totalSchedules = Formatter.safeInt(await this.getSetting(env, "TOTAL_SCHEDULES", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_SCHEDULES", totalSchedules.toString());
        
        return { 
          success: true, 
          id: result.lastRowId,
          name: name,
          nextRun: nextRun
        };
      }
      
      return { success: false, error: "ÊèíÂÖ•Â§±Ë¥•" };
    } catch (e) {
      Logger.error("DB", "addScheduleTask failed", e);
      return { success: false, error: e.message };
    }
  },

  getScheduleTasks: async function(env, enabledOnly = true) {
    try {
      let sql = "SELECT * FROM schedule_tasks";
      let params = [];
      
      if (enabledOnly) {
        sql += " WHERE enabled = 1";
      }
      
      sql += " ORDER BY next_run ASC";
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getScheduleTasks failed", e);
      return [];
    }
  },

  getScheduleTaskById: async function(env, id) {
    try {
      const result = await env.DB.prepare(
        "SELECT * FROM schedule_tasks WHERE id = ?"
      ).bind(id).first();
      
      return result || null;
    } catch (e) {
      Logger.error("DB", "getScheduleTaskById failed", e);
      return null;
    }
  },

  updateScheduleTask: async function(env, id, updates) {
    try {
      const validFields = ['name', 'task_type', 'schedule', 'params', 'enabled', 'next_run'];
      const setClauses = [];
      const values = [];
      
      for (const [key, value] of Object.entries(updates)) {
        if (validFields.includes(key)) {
          setClauses.push(`${key} = ?`);
          values.push(value);
        }
      }
      
      if (setClauses.length === 0) {
        return { success: false, error: "Ê≤°ÊúâÊúâÊïàÂ≠óÊÆµÊõ¥Êñ∞" };
      }
      
      values.push(id);
      
      const sql = `UPDATE schedule_tasks SET ${setClauses.join(', ')} WHERE id = ?`;
      const result = await env.DB.prepare(sql).bind(...values).run();
      
      return { success: true, changes: result.changes || 0 };
    } catch (e) {
      Logger.error("DB", "updateScheduleTask failed", e);
      return { success: false, error: e.message };
    }
  },

  deleteScheduleTask: async function(env, id) {
    try {
      const result = await env.DB.prepare(
        "DELETE FROM schedule_tasks WHERE id = ?"
      ).bind(id).run();
      
      return { success: true, deleted: result.changes || 0 };
    } catch (e) {
      Logger.error("DB", "deleteScheduleTask failed", e);
      return { success: false, error: e.message };
    }
  },

  getPendingScheduleTasks: async function(env) {
    try {
      const now = new Date().toISOString();
      
      const { results } = await env.DB.prepare(
        "SELECT * FROM schedule_tasks WHERE enabled = 1 AND next_run <= ? ORDER BY next_run ASC"
      ).bind(now).all();
      
      return results || [];
    } catch (e) {
      Logger.error("DB", "getPendingScheduleTasks failed", e);
      return [];
    }
  },

  markScheduleTaskAsRun: async function(env, id) {
    try {
      const now = new Date();
      const task = await this.getScheduleTaskById(env, id);
      
      if (!task) {
        return { success: false, error: "‰ªªÂä°‰∏çÂ≠òÂú®" };
      }
      
      const nextRun = this.calculateNextRun(task.schedule);
      
      Logger.debug("DB", "Ê†áËÆ∞‰ªªÂä°‰∏∫Â∑≤ËøêË°å", { id, now, nextRun });
      
      const result = await env.DB.prepare(
        "UPDATE schedule_tasks SET last_run = ?, next_run = ?, run_count = run_count + 1 WHERE id = ?"
      ).bind(
        now.toISOString(),
        nextRun ? nextRun.toISOString() : null,
        id
      ).run();
      
      return { success: true, changes: result.changes || 0 };
    } catch (e) {
      Logger.error("DB", "markScheduleTaskAsRun failed", e);
      return { success: false, error: e.message };
    }
  },

  // ‰øÆÂ§çËÆ°ÁÆó‰∏ãÊ¨°ËøêË°åÊó∂Èó¥ÂáΩÊï∞
  calculateNextRun: function(schedule) {
    try {
      Logger.debug("DB", "ËÆ°ÁÆó‰∏ãÊ¨°ËøêË°åÊó∂Èó¥", { schedule });
      
      const parsed = Formatter.parseTimeString(schedule);
      
      if (!parsed) {
        Logger.warn("DB", "Êó†Ê≥ïËß£ÊûêÊó∂Èó¥Ê†ºÂºè", { schedule });
        return null;
      }
      
      Logger.debug("DB", "Ëß£ÊûêÊó∂Èó¥ÁªìÊûú", parsed);
      
      const now = new Date();
      
      if (parsed.type === "daily") {
        const next = new Date(now);
        next.setHours(parsed.hours, parsed.minutes, 0, 0);
        
        if (next <= now) {
          next.setDate(next.getDate() + 1);
        }
        
        Logger.debug("DB", "ÊØèÊó•‰ªªÂä°‰∏ãÊ¨°ËøêË°åÊó∂Èó¥", { next, now });
        return next;
      } else if (parsed.type === "once") {
        if (parsed.date <= now) {
          Logger.warn("DB", "‰∏ÄÊ¨°ÊÄß‰ªªÂä°Êó∂Èó¥Â∑≤Ëøá", { date: parsed.date, now });
          return null;
        }
        return parsed.date;
      } else if (parsed.type === "cron") {
        try {
          return this.calculateCronNextRun(parsed.cron, now);
        } catch (cronError) {
          Logger.error("DB", "ËÆ°ÁÆóCronË°®ËææÂºèÂ§±Ë¥•", cronError);
          return null;
        }
      }
      
      return null;
    } catch (e) {
      Logger.error("DB", "calculateNextRunÂ§±Ë¥•", e);
      return null;
    }
  },
  
  // Ê∑ªÂä†CronË°®ËææÂºèËß£ÊûêÂáΩÊï∞
  calculateCronNextRun: function(cronExpr, now = new Date()) {
    try {
      const parts = cronExpr.split(' ');
      if (parts.length !== 5) {
        throw new Error("CronË°®ËææÂºèÂøÖÈ°ªÊòØ5‰∏™ÈÉ®ÂàÜ");
      }
      
      const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
      
      // ÂàõÂª∫‰∏ã‰∏Ä‰∏™Êó∂Èó¥ÁöÑÂâØÊú¨
      let next = new Date(now);
      
      // Â¢ûÂä†‰∏ÄÂàÜÈíüÔºåÁ°Æ‰øù‰∏ãÊ¨°ËøêË°åÂú®Êú™Êù•
      next.setMinutes(next.getMinutes() + 1);
      
      // ËÆæÁΩÆÁßíÂíåÊØ´Áßí‰∏∫0
      next.setSeconds(0, 0);
      
      // ÁÆÄÂçïÂÆûÁé∞ÔºöÂè™Â§ÑÁêÜÂàÜÈíüÂíåÂ∞èÊó∂ÈÉ®ÂàÜ
      if (minute !== '*') {
        const minuteVal = parseInt(minute);
        if (!isNaN(minuteVal)) {
          next.setMinutes(minuteVal);
        }
      }
      
      if (hour !== '*') {
        const hourVal = parseInt(hour);
        if (!isNaN(hourVal)) {
          next.setHours(hourVal);
        }
      }
      
      // Â¶ÇÊûúËÆæÁΩÆÁöÑÊó∂Èó¥Â∑≤ÁªèÂú®ËøáÂéªÔºåÂàôÊé®Âà∞‰∏ã‰∏ÄÂ§©
      if (next <= now) {
        next.setDate(next.getDate() + 1);
      }
      
      return next;
    } catch (error) {
      Logger.error("DB", "calculateCronNextRunÂ§±Ë¥•", error);
      return null;
    }
  }
};

// ==============================================================================
// 6. Â¢ûÂº∫ÁöÑËíôÁâπÂç°Ê¥õÊ®°ÊãüÂºïÊìéÔºà‰øÆÂ§çÂºÇÊ≠•ÊöÇÂÅúÈóÆÈ¢òÔºâ
// ==============================================================================

class EnhancedMonteCarloEngine {
  static cache = new Map();
  static activeSessions = new Map();
  static asyncQueue = [];
  static isProcessingQueue = false;
  
  static async runSimulation(env, simulations = null, sampleType = "full_history") {
    try {
      const startTime = Date.now();
      
      // Ëé∑ÂèñÂÖ®ÈÉ®ÂéÜÂè≤Êï∞ÊçÆ
      const allHistory = await DB.getAllHistory(env);
      
      if (allHistory.length < 10) {
        Logger.warn("EnhancedMonteCarlo", "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåÊó†Ê≥ïËøõË°åËíôÁâπÂç°Ê¥õÊ®°Êãü");
        return this.generateRandomFallback();
      }
      
      // ËÆæÁΩÆÊ®°ÊãüÂèÇÊï∞
      const simCount = simulations || CONFIG.SYSTEM.MONTECARLO_SIMULATIONS;
      const batchSize = CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE;
      
      // ÈôêÂà∂Ê®°ÊãüÊ¨°Êï∞
      const safeSimCount = Math.min(
        Math.max(simCount, CONFIG.SYSTEM.MIN_SIMULATIONS),
        CONFIG.SYSTEM.MAX_SIMULATIONS
      );
      
      // ËÆ°ÁÆóÊâπÊ¨°Êï∞
      const totalBatches = Math.ceil(safeSimCount / batchSize);
      const safeTotalBatches = Math.min(totalBatches, CONFIG.SYSTEM.MONTECARLO_MAX_BATCHES);
      const adjustedSimCount = safeTotalBatches * batchSize;
      
      Logger.info("EnhancedMonteCarlo", `ÂºÄÂßãÂ¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü`, {
        simulations: adjustedSimCount,
        batches: safeTotalBatches,
        batchSize: batchSize,
        historyCount: allHistory.length,
        sampleType: sampleType
      });
      
      // È¢ÑÂ§ÑÁêÜÂéÜÂè≤Êï∞ÊçÆÔºàÊèêÈ´òÊÄßËÉΩÔºâ
      const processedHistory = this.preprocessHistory(allHistory);
      
      // ÂàùÂßãÂåñÁªüËÆ°Êï∞ÊçÆ
      const specialFrequency = {};
      const normalFrequency = {};
      const zodiacFrequency = {};
      const colorFrequency = {};
      const tailFrequency = {};
      
      // ÂàùÂßãÂåñÊï∞ÁªÑ
      for (let i = 1; i <= 49; i++) {
        specialFrequency[i] = 0;
        normalFrequency[i] = 0;
      }
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        zodiacFrequency[zodiac] = 0;
      });
      
      ['red', 'blue', 'green'].forEach(color => {
        colorFrequency[color] = 0;
      });
      
      for (let i = 0; i <= 9; i++) {
        tailFrequency[i] = 0;
      }
      
      // ÂàÜÊâπÊ®°Êãü
      let completedSimulations = 0;
      const batchStartTime = Date.now();
      
      for (let batch = 0; batch < safeTotalBatches; batch++) {
        const batchSimStart = Date.now();
        
        // ÊâßË°åÊâπÊ¨°Ê®°Êãü
        this.runBatchSimulation(
          processedHistory,
          batchSize,
          specialFrequency,
          normalFrequency,
          zodiacFrequency,
          colorFrequency,
          tailFrequency
        );
        
        completedSimulations += batchSize;
        
        // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖÊó∂
        const elapsedTime = Date.now() - batchStartTime;
        if (elapsedTime > CONFIG.SYSTEM.MAX_RUNTIME_MS) {
          Logger.warn("EnhancedMonteCarlo", "Ê®°ÊãüË∂ÖÊó∂ÔºåÊèêÂâçÁªìÊùü", {
            completed: completedSimulations,
            target: adjustedSimCount,
            elapsed: elapsedTime
          });
          break;
        }
        
        // ÊØèÊâπÊ¨°ÊòæÁ§∫ËøõÂ∫¶
        const progress = ((batch + 1) / safeTotalBatches * 100).toFixed(1);
        const batchDuration = Date.now() - batchSimStart;
        
        Logger.debug("EnhancedMonteCarlo", `ÊâπÊ¨°ËøõÂ∫¶: ${progress}%`, { 
          batch: batch + 1,
          totalBatches: safeTotalBatches,
          completed: completedSimulations,
          target: adjustedSimCount,
          batchDuration: `${batchDuration}ms`,
          totalDuration: `${elapsedTime}ms`
        });
        
        // Ê∑ªÂä†Â∞èÂª∂ËøüÔºåÈÅøÂÖçWorkerË∂ÖÊó∂
        if (batch < safeTotalBatches - 1) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      // ËÆ°ÁÆóÊ¶ÇÁéá
      const specialProbabilities = {};
      const normalProbabilities = {};
      
      for (let i = 1; i <= 49; i++) {
        specialProbabilities[i] = specialFrequency[i] / completedSimulations;
        normalProbabilities[i] = normalFrequency[i] / completedSimulations;
      }
      
      // ËÆ°ÁÆóÁîüËÇñÊ¶ÇÁéá
      const zodiacProbabilities = {};
      Object.keys(zodiacFrequency).forEach(zodiac => {
        zodiacProbabilities[zodiac] = zodiacFrequency[zodiac] / completedSimulations;
      });
      
      // ËÆ°ÁÆóÈ¢úËâ≤Ê¶ÇÁéá
      const colorProbabilities = {};
      Object.keys(colorFrequency).forEach(color => {
        colorProbabilities[color] = colorFrequency[color] / completedSimulations;
      });
      
      // ËÆ°ÁÆóÂ∞æÊï∞Ê¶ÇÁéá
      const tailProbabilities = {};
      Object.keys(tailFrequency).forEach(tail => {
        tailProbabilities[tail] = tailFrequency[tail] / completedSimulations;
      });
      
      // ÁîüÊàêÈ¢ÑÊµãÁªìÊûú
      const result = this.generatePredictionFromProbabilities(
        specialProbabilities,
        normalProbabilities,
        zodiacProbabilities,
        colorProbabilities,
        tailProbabilities,
        completedSimulations,
        allHistory
      );
      
      const duration = Date.now() - startTime;
      result.duration_ms = duration;
      result.total_simulations = completedSimulations;
      result.sample_type = sampleType;
      result.history_count = allHistory.length;
      
      Logger.info("EnhancedMonteCarlo", `Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂÆåÊàê`, {
        duration: `${duration}ms`,
        simulations: completedSimulations,
        sampleType: sampleType,
        historyCount: allHistory.length,
        confidence: result.confidence
      });
      
      // ‰øùÂ≠òÁªìÊûúÂà∞Êï∞ÊçÆÂ∫ì
      const simulationId = `monte_${Date.now()}_${completedSimulations}`;
      const saveResult = {
        simulation_id: simulationId,
        simulations: completedSimulations,
        sample_type: sampleType,
        special_numbers: result.specialNumbers || [],
        normal_numbers: result.normalNumbers || [],
        confidence: result.confidence || 0,
        duration_ms: duration
      };
      
      await DB.saveMonteCarloResult(env, saveResult);
      
      return result;
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•", error);
      return this.generateRandomFallback();
    }
  }
  
  static preprocessHistory(history) {
    try {
      const processed = [];
      
      for (const record of history) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          if (nums.length >= 7) {
            const special = nums[6] || 1;
            const normals = nums.slice(0, 6);
            const attr = Formatter.getAttributes(special);
            
            processed.push({
              numbers: nums,
              special: special,
              normals: normals,
              zodiac: attr.zodiac,
              color: attr.color,
              tail: special % 10
            });
          }
        }
      }
      
      return processed;
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "È¢ÑÂ§ÑÁêÜÂéÜÂè≤Êï∞ÊçÆÂ§±Ë¥•", error);
      return [];
    }
  }
  
  static runBatchSimulation(processedHistory, batchSize, specialFreq, normalFreq, zodiacFreq, colorFreq, tailFreq) {
    if (processedHistory.length === 0) {
      return;
    }
    
    const historyLength = processedHistory.length;
    
    for (let i = 0; i < batchSize; i++) {
      try {
        // ‰ªéÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÈöèÊú∫ÈÄâÊã©‰∏ÄÊù°‰Ωú‰∏∫"ÊúÄÂêé"‰∏ÄÊúü
        const randomIndex = Math.floor(Math.random() * historyLength);
        const lastRecord = processedHistory[randomIndex];
        
        // ‰ΩøÁî®ÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÊù•Ê®°Êãü‰∏ã‰∏ÄÊúü
        const simulatedNumbers = this.simulateNextNumbersEnhanced(lastRecord, processedHistory);
        
        // ÁªüËÆ°ÁâπÁ†Å
        if (simulatedNumbers.special >= 1 && simulatedNumbers.special <= 49) {
          specialFreq[simulatedNumbers.special]++;
          
          // ÁªüËÆ°ÁîüËÇñÂíåÈ¢úËâ≤
          const attr = Formatter.getAttributes(simulatedNumbers.special);
          if (zodiacFreq[attr.zodiac] !== undefined) {
            zodiacFreq[attr.zodiac]++;
          }
          if (colorFreq[attr.color] !== undefined) {
            colorFreq[attr.color]++;
          }
          
          // ÁªüËÆ°Â∞æÊï∞
          const tail = simulatedNumbers.special % 10;
          if (tailFreq[tail] !== undefined) {
            tailFreq[tail]++;
          }
        }
        
        // ÁªüËÆ°Âπ≥Á†Å
        simulatedNumbers.normals.forEach(num => {
          if (num >= 1 && num <= 49) {
            normalFreq[num]++;
          }
        });
        
      } catch (error) {
        // ÂøΩÁï•ÂçïÊ¨°Ê®°ÊãüÈîôËØØ
        continue;
      }
    }
  }
  
  static simulateNextNumbersEnhanced(lastRecord, allProcessedHistory) {
    try {
      const result = {
        normals: [],
        special: 0
      };
      
      if (allProcessedHistory.length === 0) {
        return this.generateRandomNumbers();
      }
      
      const lastAttr = lastRecord ? {
        zodiac: lastRecord.zodiac,
        color: lastRecord.color,
        tail: lastRecord.tail
      } : { zodiac: "Èº†", color: "red", tail: 0 };
      
      // Âü∫‰∫éÁîüËÇñÂÖ≥ËÅîÊÄß
      const sameZodiacRecords = allProcessedHistory.filter(record => 
        record.zodiac === lastAttr.zodiac
      );
      
      // Âü∫‰∫éÈ¢úËâ≤ÂÖ≥ËÅîÊÄß
      const sameColorRecords = allProcessedHistory.filter(record => 
        record.color === lastAttr.color
      );
      
      // Âü∫‰∫éÂ∞æÊï∞ÂÖ≥ËÅîÊÄß
      const sameTailRecords = allProcessedHistory.filter(record => 
        record.tail === lastAttr.tail
      );
      
      // ‰ºòÂÖà‰ΩøÁî®Áõ∏ÂêåÁîüËÇñÁöÑËÆ∞ÂΩï
      let candidateRecords = sameZodiacRecords;
      if (candidateRecords.length === 0) {
        candidateRecords = sameColorRecords;
      }
      if (candidateRecords.length === 0) {
        candidateRecords = sameTailRecords;
      }
      if (candidateRecords.length === 0) {
        candidateRecords = allProcessedHistory;
      }
      
      // ÈöèÊú∫ÈÄâÊã©‰∏ÄÊù°ËÆ∞ÂΩï‰Ωú‰∏∫ÂèÇËÄÉ
      const randomIndex = Math.floor(Math.random() * candidateRecords.length);
      const referenceRecord = candidateRecords[randomIndex];
      
      // ÁîüÊàêÁâπÁ†ÅÔºàÂü∫‰∫éÂèÇËÄÉËÆ∞ÂΩïÔºâ
      if (referenceRecord) {
        // Êúâ‰∏ÄÂÆöÊ¶ÇÁéá‰ΩøÁî®ÂèÇËÄÉËÆ∞ÂΩïÁöÑÁâπÁ†Å
        if (Math.random() < 0.3) {
          result.special = referenceRecord.special;
        } else {
          // ÊàñËÄÖ‰ªéÂèÇËÄÉËÆ∞ÂΩïÁöÑÂêåÁîüËÇñÂè∑Á†Å‰∏≠ÈÄâÊã©
          const zodiacNumbers = CONFIG.ZODIAC_MAP[referenceRecord.zodiac] || [];
          if (zodiacNumbers.length > 0) {
            result.special = zodiacNumbers[Math.floor(Math.random() * zodiacNumbers.length)];
          } else {
            result.special = referenceRecord.special;
          }
        }
      } else {
        // Â¶ÇÊûúÊ≤°ÊúâÂèÇËÄÉËÆ∞ÂΩïÔºåÈöèÊú∫ÁîüÊàê
        result.special = Math.floor(Math.random() * 49) + 1;
      }
      
      // Á°Æ‰øùÁâπÁ†ÅÊúâÊïà
      if (result.special < 1 || result.special > 49) {
        result.special = Math.floor(Math.random() * 49) + 1;
      }
      
      // ÁîüÊàêÂπ≥Á†ÅÔºà6‰∏™‰∏çÈáçÂ§çÁöÑÂè∑Á†ÅÔºå‰∏çÂåÖÊã¨ÁâπÁ†ÅÔºâ
      const usedNumbers = new Set([result.special]);
      
      // ‰ΩøÁî®ÂèÇËÄÉËÆ∞ÂΩïÁöÑÂπ≥Á†Å‰Ωú‰∏∫Âü∫Á°Ä
      if (referenceRecord && referenceRecord.normals) {
        for (const normal of referenceRecord.normals) {
          if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
            result.normals.push(normal);
            usedNumbers.add(normal);
            if (result.normals.length >= 6) break;
          }
        }
      }
      
      // Â¶ÇÊûúÂπ≥Á†Å‰∏çË∂≥Ôºå‰ªéÂéÜÂè≤ËÆ∞ÂΩï‰∏≠Ë°•ÂÖÖ
      while (result.normals.length < 6 && allProcessedHistory.length > 0) {
        const randomRecord = allProcessedHistory[Math.floor(Math.random() * allProcessedHistory.length)];
        if (randomRecord && randomRecord.normals) {
          const randomNormal = randomRecord.normals[Math.floor(Math.random() * randomRecord.normals.length)];
          if (randomNormal >= 1 && randomNormal <= 49 && !usedNumbers.has(randomNormal)) {
            result.normals.push(randomNormal);
            usedNumbers.add(randomNormal);
          }
        }
        
        // Èò≤Ê≠¢Êó†ÈôêÂæ™ÁéØ
        if (usedNumbers.size >= 49) {
          break;
        }
      }
      
      // Â¶ÇÊûúËøòÊòØ‰∏çË∂≥ÔºåÈöèÊú∫ÁîüÊàê
      while (result.normals.length < 6) {
        let num;
        do {
          num = Math.floor(Math.random() * 49) + 1;
        } while (usedNumbers.has(num) && usedNumbers.size < 49);
        
        if (!usedNumbers.has(num)) {
          result.normals.push(num);
          usedNumbers.add(num);
        }
      }
      
      return result;
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "Ê®°Êãü‰∏ã‰∏ÄÊúüÂè∑Á†ÅÂ§±Ë¥•", error);
      return this.generateRandomNumbers();
    }
  }
  
  static generateRandomNumbers() {
    const result = {
      normals: [],
      special: 0
    };
    
    const used = new Set();
    
    // ÁîüÊàêÁâπÁ†Å
    result.special = Math.floor(Math.random() * 49) + 1;
    used.add(result.special);
    
    // ÁîüÊàê6‰∏™Âπ≥Á†Å
    while (result.normals.length < 6) {
      const num = Math.floor(Math.random() * 49) + 1;
      if (!used.has(num)) {
        result.normals.push(num);
        used.add(num);
      }
      
      if (used.size >= 49) {
        break;
      }
    }
    
    return result;
  }
  
  static generatePredictionFromProbabilities(
    specialProbs, 
    normalProbs, 
    zodiacProbs, 
    colorProbs, 
    tailProbs,
    totalSimulations,
    history
  ) {
    try {
      // ÁîüÊàêÁâπÁ†ÅÈ¢ÑÊµãÔºàÊåâÊ¶ÇÁéáÊéíÂ∫èÔºâ
      const specialPredictions = Object.entries(specialProbs)
        .map(([num, prob]) => ({
          number: Formatter.safeInt(num, 0),
          probability: prob,
          score: prob * 10000 + Math.random() * 10 // Ê∑ªÂä†ÂæÆÂ∞èÈöèÊú∫Êâ∞Âä®
        }))
        .filter(item => item.number >= 1 && item.number <= 49)
        .sort((a, b) => b.score - a.score)
        .slice(0, 15);
      
      // ÁîüÊàêÂπ≥Á†ÅÈ¢ÑÊµãÔºàÊéíÈô§ÁâπÁ†ÅÔºâ
      const excludeNumbers = specialPredictions.slice(0, 8).map(item => item.number);
      const excludeSet = new Set(excludeNumbers);
      
      const normalPredictions = Object.entries(normalProbs)
        .map(([num, prob]) => ({
          number: Formatter.safeInt(num, 0),
          probability: prob,
          score: prob * 8000 + Math.random() * 8
        }))
        .filter(item => 
          item.number >= 1 && 
          item.number <= 49 && 
          !excludeSet.has(item.number)
        )
        .sort((a, b) => b.score - a.score)
        .slice(0, 12);
      
      // ÁîüÊàêÁîüËÇñÈ¢ÑÊµã
      const zodiacPredictions = Object.entries(zodiacProbs)
        .map(([zodiac, prob]) => ({
          zodiac: zodiac,
          probability: prob,
          score: prob * 12000
        }))
        .sort((a, b) => b.score - a.score);
      
      // ÁîüÊàêÈ¢úËâ≤È¢ÑÊµã
      const colorPredictions = Object.entries(colorProbs)
        .map(([color, prob]) => ({
          color: color,
          probability: prob,
          score: prob * 10000
        }))
        .sort((a, b) => b.score - a.score);
      
      // ÁîüÊàêÂ∞æÊï∞È¢ÑÊµã
      const tailPredictions = Object.entries(tailProbs)
        .map(([tail, prob]) => ({
          tail: Formatter.safeInt(tail, 0),
          probability: prob,
          score: prob * 8000
        }))
        .sort((a, b) => b.score - a.score);
      
      // ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶
      const maxSpecialProb = specialPredictions.length > 0 ? specialPredictions[0].probability : 0;
      const avgSpecialProb = specialPredictions.length > 0 ? 
        specialPredictions.slice(0, 5).reduce((sum, item) => sum + item.probability, 0) / 5 : 0;
      
      const maxZodiacProb = zodiacPredictions.length > 0 ? zodiacPredictions[0].probability : 0;
      const maxColorProb = colorPredictions.length > 0 ? colorPredictions[0].probability : 0;
      
      let confidence = 25;
      
      if (maxSpecialProb > 0) {
        confidence += Math.min(35, maxSpecialProb * 200);
        
        if (specialPredictions.length >= 2) {
          const diffRatio = (specialPredictions[0].probability - specialPredictions[1].probability) / 
                           Math.max(0.001, specialPredictions[1].probability);
          confidence += Math.min(15, diffRatio * 8);
        }
        
        confidence += Math.min(12, totalSimulations / 2000);
        
        const historyFactor = Math.min(10, history.length / 30);
        confidence += historyFactor;
        
        if (maxZodiacProb > 0) {
          confidence += Math.min(5, maxZodiacProb * 20);
        }
        
        if (maxColorProb > 0) {
          confidence += Math.min(5, maxColorProb * 20);
        }
      }
      
      confidence = Math.min(98, Math.max(20, Math.round(confidence)));
      
      // Ëé∑ÂèñÊúÄÊñ∞‰∏ÄÊúüÊï∞ÊçÆ
      let latestExpect = "Êú™Áü•";
      let latestSpecial = 1;
      
      if (history && history.length > 0) {
        const latestRecord = history[0];
        latestExpect = latestRecord.expect || "Êú™Áü•";
        
        if (latestRecord.open_code) {
          const nums = latestRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          latestSpecial = nums[6] || 1;
        }
      }
      
      // ÁîüÊàê‰∏ã‰∏ÄÊúüÊúüÂè∑
      const nextExpectNum = latestExpect !== "Êú™Áü•" ? Formatter.safeInt(latestExpect, 2025000) + 1 : 2025001;
      const nextExpect = nextExpectNum.toString();
      
      // Ê†ºÂºèÂåñÁªìÊûú
      const formattedSpecials = specialPredictions.slice(0, 5).map(item => {
        const attr = Formatter.getAttributes(item.number);
        return {
          number: item.number,
          probability: item.probability,
          zodiac: attr.zodiac,
          color: attr.color,
          score: item.score
        };
      });
      
      const formattedNormals = normalPredictions.slice(0, 6).map(item => {
        const attr = Formatter.getAttributes(item.number);
        return {
          number: item.number,
          probability: item.probability,
          zodiac: attr.zodiac,
          color: attr.color,
          score: item.score
        };
      });
      
      // ÁîüÊàêÁîüËÇñÊé®Ëçê
      const mainZodiacs = zodiacPredictions.slice(0, 4).map(item => item.zodiac);
      const guardZodiacs = zodiacPredictions.slice(4, 8).map(item => item.zodiac);
      
      // ÁîüÊàêÈ¢úËâ≤Êé®Ëçê
      const mainColor = colorPredictions.length > 0 ? colorPredictions[0].color : "red";
      const guardColor = colorPredictions.length > 1 ? colorPredictions[1].color : "blue";
      
      // ÁîüÊàêÂ∞æÊï∞Êé®Ëçê
      const mainTails = tailPredictions.slice(0, 3).map(item => item.tail);
      const guardTails = tailPredictions.slice(3, 6).map(item => item.tail);
      
      // ÁîüÊàêÂ§¥Êï∞ÂíåÂΩ¢ÊÄÅ
      const bestSpecial = formattedSpecials[0]?.number || 1;
      const isBig = bestSpecial >= 25;
      const isOdd = bestSpecial % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(bestSpecial / 10);
      
      // ËÆ°ÁÆóÁÉ≠Â∫¶
      const hotNumbers = specialPredictions
        .filter(item => item.probability > maxSpecialProb * 0.7)
        .slice(0, 3)
        .map(item => item.number);
      
      return {
        nextExpect: nextExpect,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        zodiac: {
          main: mainZodiacs,
          guard: guardZodiacs,
          probabilities: zodiacProbs
        },
        color: {
          main: mainColor,
          guard: guardColor,
          probabilities: colorProbs
        },
        tail: {
          main: mainTails,
          guard: guardTails,
          probabilities: tailProbs
        },
        head: `${head}Â§¥`,
        shape: shape,
        hotNumbers: hotNumbers,
        confidence: confidence,
        simulationStats: {
          totalSimulations: totalSimulations,
          maxProbability: maxSpecialProb,
          avgProbability: avgSpecialProb,
          historyCount: history.length
        },
        basedOnLastRecord: {
          expect: latestExpect,
          special: latestSpecial
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V11.1-EnhancedMonteCarlo"
      };
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "‰ªéÊ¶ÇÁéáÁîüÊàêÈ¢ÑÊµãÂ§±Ë¥•", error);
      return this.generateRandomFallback();
    }
  }
  
  static generateRandomFallback() {
    try {
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = Math.floor(Math.random() * allZodiacs.length);
      const colorIndex = Math.floor(Math.random() * colors.length);
      
      const mainZodiac = allZodiacs[zodiacIndex] || "Èº†";
      const mainColor = colors[colorIndex] || "red";
      
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        const num = Math.floor(Math.random() * 49) + 1;
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          probability: Math.random() * 0.1,
          zodiac: attr.zodiac,
          color: attr.color,
          score: Math.random() * 100
        });
      }
      
      const normalNumbers = [];
      const usedNumbers = new Set(specialNumbers.map(item => item.number));
      
      for (let i = 0; i < 6; i++) {
        let num;
        do {
          num = Math.floor(Math.random() * 49) + 1;
        } while (usedNumbers.has(num) && usedNumbers.size < 49);
        
        if (!usedNumbers.has(num)) {
          const attr = Formatter.getAttributes(num);
          normalNumbers.push({
            number: num,
            probability: Math.random() * 0.05,
            zodiac: attr.zodiac,
            color: attr.color,
            score: Math.random() * 80
          });
          usedNumbers.add(num);
        }
      }
      
      const bestSpecial = specialNumbers[0]?.number || 1;
      const isBig = bestSpecial >= 25;
      const isOdd = bestSpecial % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(bestSpecial / 10);
      
      return {
        nextExpect: "2025001",
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        zodiac: {
          main: [mainZodiac, allZodiacs[(zodiacIndex + 1) % allZodiacs.length]],
          guard: [allZodiacs[(zodiacIndex + 2) % allZodiacs.length]],
          probabilities: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length],
          probabilities: {}
        },
        head: `${head}Â§¥`,
        shape: shape,
        confidence: 15,
        simulationStats: {
          totalSimulations: 0,
          maxProbability: 0,
          avgProbability: 0
        },
        basedOnLastRecord: {
          expect: "Êú™Áü•",
          special: 1
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V11.1-RandomFallback"
      };
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "ÁîüÊàêÈöèÊú∫ÂõûÈÄÄÂ§±Ë¥•", error);
      
      return {
        nextExpect: "2025001",
        specialNumbers: [],
        normalNumbers: [],
        zodiac: { main: [], guard: [], probabilities: {} },
        color: { main: "red", guard: "blue", probabilities: {} },
        head: "0Â§¥",
        shape: "Â∞èÂçï",
        confidence: 10,
        simulationStats: { totalSimulations: 0, maxProbability: 0, avgProbability: 0 },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V11.1-Error"
      };
    }
  }
  
  // ‰øÆÂ§çÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°Êãü
  static async runAsyncSimulation(env, chatId, simulations = null) {
    try {
      const sessionId = `monte_async_${Date.now()}_${chatId}_${Math.random().toString(36).substr(2, 9)}`;
      const startTime = Date.now();
      
      // Ëé∑ÂèñÂÖ®ÈÉ®ÂéÜÂè≤Êï∞ÊçÆ
      const allHistory = await DB.getAllHistory(env);
      
      if (allHistory.length < 10) {
        return {
          success: false,
          error: "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåÊó†Ê≥ïËøõË°åËíôÁâπÂç°Ê¥õÊ®°Êãü"
        };
      }
      
      // ËÆæÁΩÆÊ®°ÊãüÂèÇÊï∞
      const simCount = simulations || CONFIG.SYSTEM.MONTECARLO_SIMULATIONS;
      const batchSize = CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE;
      
      // ÈôêÂà∂Ê®°ÊãüÊ¨°Êï∞
      const safeSimCount = Math.min(
        Math.max(simCount, CONFIG.SYSTEM.MIN_SIMULATIONS),
        CONFIG.SYSTEM.MAX_SIMULATIONS
      );
      
      // ËÆ°ÁÆóÊâπÊ¨°Êï∞
      const totalBatches = Math.ceil(safeSimCount / batchSize);
      const safeTotalBatches = Math.min(totalBatches, CONFIG.SYSTEM.MONTECARLO_MAX_BATCHES);
      const adjustedSimCount = safeTotalBatches * batchSize;
      
      // ÂàùÂßãÂåñÁªüËÆ°Êï∞ÊçÆ
      const specialFrequency = {};
      const normalFrequency = {};
      const zodiacFrequency = {};
      const colorFrequency = {};
      const tailFrequency = {};
      
      for (let i = 1; i <= 49; i++) {
        specialFrequency[i] = 0;
        normalFrequency[i] = 0;
      }
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        zodiacFrequency[zodiac] = 0;
      });
      
      ['red', 'blue', 'green'].forEach(color => {
        colorFrequency[color] = 0;
      });
      
      for (let i = 0; i <= 9; i++) {
        tailFrequency[i] = 0;
      }
      
      // È¢ÑÂ§ÑÁêÜÂéÜÂè≤Êï∞ÊçÆ
      const processedHistory = this.preprocessHistory(allHistory);
      
      // ‰øùÂ≠òÂàùÂßãËøõÂ∫¶
      const initialProgress = {
        session_id: sessionId,
        chat_id: chatId,
        total_simulations: adjustedSimCount,
        completed_simulations: 0,
        batch_size: batchSize,
        special_frequency: specialFrequency,
        normal_frequency: normalFrequency,
        zodiac_frequency: zodiacFrequency,
        color_frequency: colorFrequency,
        tail_frequency: tailFrequency
      };
      
      await DB.saveMonteCarloProgress(env, initialProgress);
      
      // Ê≥®ÂÜåÊ¥ªÂä®‰ºöËØù
      this.activeSessions.set(sessionId, {
        chatId: chatId,
        startTime: startTime,
        totalSimulations: adjustedSimCount,
        completedSimulations: 0,
        totalBatches: safeTotalBatches,
        processedHistory: processedHistory,
        specialFrequency: specialFrequency,
        normalFrequency: normalFrequency,
        zodiacFrequency: zodiacFrequency,
        colorFrequency: colorFrequency,
        tailFrequency: tailFrequency,
        status: "running",
        lastUpdated: Date.now(),
        env: env // ‰øùÂ≠òenvÂºïÁî®Áî®‰∫éÂêéÁª≠Â§ÑÁêÜ
      });
      
      Logger.info("EnhancedMonteCarlo", `ÂêØÂä®ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°Êãü`, {
        sessionId: sessionId,
        chatId: chatId,
        simulations: adjustedSimCount,
        batches: safeTotalBatches,
        historyCount: allHistory.length
      });
      
      // ÂêØÂä®ÂºÇÊ≠•Â§ÑÁêÜ
      this.processAsyncSimulationInBackground(sessionId);
      
      return {
        success: true,
        sessionId: sessionId,
        totalSimulations: adjustedSimCount,
        totalBatches: safeTotalBatches,
        batchSize: batchSize,
        historyCount: allHistory.length,
        message: `ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ∑≤ÂêØÂä®Ôºå‰ΩøÁî® /monte progress ${sessionId} Êü•ÁúãËøõÂ∫¶`
      };
      
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "ÂêØÂä®ÂºÇÊ≠•Ê®°ÊãüÂ§±Ë¥•", error);
      return {
        success: false,
        error: error.message || "ÂêØÂä®Ê®°ÊãüÂ§±Ë¥•"
      };
    }
  }
  
  // ‰øÆÂ§çÔºöÂú®ÂêéÂè∞Â§ÑÁêÜÂºÇÊ≠•Ê®°Êãü
  static async processAsyncSimulationInBackground(sessionId) {
    try {
      const session = this.activeSessions.get(sessionId);
      if (!session) {
        Logger.warn("EnhancedMonteCarlo", "‰ºöËØù‰∏çÂ≠òÂú®", { sessionId });
        return;
      }
      
      const {
        chatId,
        env,
        totalSimulations,
        completedSimulations,
        totalBatches,
        processedHistory,
        specialFrequency,
        normalFrequency,
        zodiacFrequency,
        colorFrequency,
        tailFrequency
      } = session;
      
      Logger.info("EnhancedMonteCarlo", "ÂºÄÂßãÂú®ÂêéÂè∞Â§ÑÁêÜÂºÇÊ≠•Ê®°Êãü", {
        sessionId,
        completedSimulations,
        totalSimulations
      });
      
      let currentBatch = Math.floor(completedSimulations / CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE);
      
      // Â§ÑÁêÜÊâÄÊúâÊâπÊ¨°
      while (currentBatch < totalBatches) {
        try {
          // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖÊó∂
          const elapsedTime = Date.now() - session.startTime;
          if (elapsedTime > CONFIG.SYSTEM.MAX_RUNTIME_MS * 3) {
            Logger.warn("EnhancedMonteCarlo", "ÂºÇÊ≠•Ê®°ÊãüË∂ÖÊó∂", {
              sessionId,
              elapsedTime,
              maxRuntime: CONFIG.SYSTEM.MAX_RUNTIME_MS * 3
            });
            session.status = "timeout";
            break;
          }
          
          // Â§ÑÁêÜÂΩìÂâçÊâπÊ¨°
          const batchStartTime = Date.now();
          this.runBatchSimulation(
            processedHistory,
            CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE,
            specialFrequency,
            normalFrequency,
            zodiacFrequency,
            colorFrequency,
            tailFrequency
          );
          
          const newCompleted = completedSimulations + CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE;
          session.completedSimulations = newCompleted;
          session.lastUpdated = Date.now();
          
          // ‰øùÂ≠òËøõÂ∫¶Âà∞Êï∞ÊçÆÂ∫ì
          const progress = {
            session_id: sessionId,
            chat_id: chatId,
            total_simulations: totalSimulations,
            completed_simulations: newCompleted,
            batch_size: CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE,
            special_frequency: specialFrequency,
            normal_frequency: normalFrequency,
            zodiac_frequency: zodiacFrequency,
            color_frequency: colorFrequency,
            tail_frequency: tailFrequency
          };
          
          await DB.saveMonteCarloProgress(env, progress);
          
          currentBatch++;
          
          const batchDuration = Date.now() - batchStartTime;
          const progressPercent = (newCompleted / totalSimulations * 100).toFixed(1);
          
          Logger.debug("EnhancedMonteCarlo", `ÂºÇÊ≠•ÊâπÊ¨°Â§ÑÁêÜÂÆåÊàê`, {
            sessionId: sessionId,
            batch: currentBatch,
            totalBatches: totalBatches,
            completed: newCompleted,
            total: totalSimulations,
            progress: `${progressPercent}%`,
            duration: `${batchDuration}ms`
          });
          
          // Ê∑ªÂä†Âª∂ËøüÔºåÈÅøÂÖçÈòªÂ°û
          await new Promise(resolve => setTimeout(resolve, CONFIG.SYSTEM.ASYNC_BATCH_DELAY));
          
        } catch (batchError) {
          Logger.error("EnhancedMonteCarlo", "Â§ÑÁêÜÂºÇÊ≠•ÊâπÊ¨°Â§±Ë¥•", batchError);
          
          // Â∞ùËØïÊÅ¢Â§ç
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Â¶ÇÊûúËøûÁª≠Â§±Ë¥•3Ê¨°ÔºåÂÅúÊ≠¢Ê®°Êãü
          if (session.errorCount && session.errorCount >= 3) {
            Logger.error("EnhancedMonteCarlo", "ÂºÇÊ≠•Ê®°ÊãüËøûÁª≠Â§±Ë¥•3Ê¨°ÔºåÂÅúÊ≠¢", {
              sessionId,
              errorCount: session.errorCount
            });
            session.status = "failed";
            break;
          }
          
          session.errorCount = (session.errorCount || 0) + 1;
        }
      }
      
      // Ê†áËÆ∞ÂÆåÊàê
      if (session.completedSimulations >= session.totalSimulations) {
        session.status = "completed";
        Logger.info("EnhancedMonteCarlo", "ÂºÇÊ≠•Ê®°ÊãüÂÆåÊàê", {
          sessionId,
          completedSimulations: session.completedSimulations,
          totalSimulations: session.totalSimulations
        });
      }
      
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "ÂêéÂè∞Â§ÑÁêÜÂºÇÊ≠•Ê®°ÊãüÂ§±Ë¥•", error);
      
      const session = this.activeSessions.get(sessionId);
      if (session) {
        session.status = "error";
        session.error = error.message;
      }
    }
  }
  
  // Â§ÑÁêÜ‰∏ÄÊâπÊ®°Êãü
  static async processBatch(env, sessionId) {
    try {
      const session = this.activeSessions.get(sessionId);
      if (!session) {
        return { success: false, error: "‰ºöËØù‰∏çÂ≠òÂú®ÊàñÂ∑≤ËøáÊúü" };
      }
      
      const {
        chatId,
        totalSimulations,
        completedSimulations,
        totalBatches,
        processedHistory,
        specialFrequency,
        normalFrequency,
        zodiacFrequency,
        colorFrequency,
        tailFrequency
      } = session;
      
      // ËÆ°ÁÆóÂΩìÂâçÊâπÊ¨°
      const batchIndex = Math.floor(completedSimulations / CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE);
      
      if (batchIndex >= totalBatches) {
        return { success: false, error: "ÊâÄÊúâÊâπÊ¨°Â∑≤ÂÆåÊàê" };
      }
      
      // ÊâßË°åÊâπÊ¨°Ê®°Êãü
      const batchStartTime = Date.now();
      this.runBatchSimulation(
        processedHistory,
        CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE,
        specialFrequency,
        normalFrequency,
        zodiacFrequency,
        colorFrequency,
        tailFrequency
      );
      
      const newCompleted = completedSimulations + CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE;
      
      // Êõ¥Êñ∞‰ºöËØùÁä∂ÊÄÅ
      session.completedSimulations = newCompleted;
      session.lastUpdated = Date.now();
      
      // ‰øùÂ≠òËøõÂ∫¶Âà∞Êï∞ÊçÆÂ∫ì
      const progress = {
        session_id: sessionId,
        chat_id: chatId,
        total_simulations: totalSimulations,
        completed_simulations: newCompleted,
        batch_size: CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE,
        special_frequency: specialFrequency,
        normal_frequency: normalFrequency,
        zodiac_frequency: zodiacFrequency,
        color_frequency: colorFrequency,
        tail_frequency: tailFrequency
      };
      
      await DB.saveMonteCarloProgress(env, progress);
      
      const batchDuration = Date.now() - batchStartTime;
      const progressPercent = (newCompleted / totalSimulations * 100).toFixed(1);
      
      return {
        success: true,
        sessionId: sessionId,
        batch: batchIndex + 1,
        totalBatches: totalBatches,
        completed: newCompleted,
        total: totalSimulations,
        progress: progressPercent,
        duration: batchDuration
      };
      
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "Â§ÑÁêÜÊâπÊ¨°Â§±Ë¥•", error);
      return {
        success: false,
        error: error.message || "Â§ÑÁêÜÊâπÊ¨°Â§±Ë¥•"
      };
    }
  }
  
  // ÂÆåÊàêÂºÇÊ≠•Ê®°ÊãüÂπ∂ÁîüÊàêÁªìÊûú
  static async completeAsyncSimulation(env, sessionId) {
    try {
      const session = this.activeSessions.get(sessionId);
      let progress;
      
      if (!session) {
        // Â∞ùËØï‰ªéÊï∞ÊçÆÂ∫ìÊÅ¢Â§ç
        progress = await DB.getMonteCarloProgress(env, sessionId, "any");
        if (!progress) {
          return { success: false, error: "‰ºöËØù‰∏çÂ≠òÂú®ÊàñÂ∑≤ËøáÊúü" };
        }
      } else {
        progress = {
          session_id: sessionId,
          chat_id: session.chatId,
          total_simulations: session.totalSimulations,
          completed_simulations: session.completedSimulations,
          special_frequency: session.specialFrequency,
          normal_frequency: session.normalFrequency,
          zodiac_frequency: session.zodiacFrequency,
          color_frequency: session.colorFrequency,
          tail_frequency: session.tailFrequency
        };
      }
      
      const allHistory = await DB.getAllHistory(env);
      
      // ÁîüÊàêÊúÄÁªàÁªìÊûú
      const result = await this.generateResultFromFrequency(
        progress.special_frequency,
        progress.normal_frequency,
        progress.zodiac_frequency,
        progress.color_frequency,
        progress.tail_frequency,
        progress.completed_simulations,
        allHistory
      );
      
      const duration = session ? Date.now() - session.startTime : 0;
      result.duration_ms = duration;
      result.total_simulations = progress.completed_simulations;
      result.sample_type = "full_history_async";
      
      // ‰øùÂ≠òÁªìÊûúÂà∞Êï∞ÊçÆÂ∫ì
      const simulationId = `monte_${Date.now()}_${progress.completed_simulations}`;
      const saveResult = {
        simulation_id: simulationId,
        simulations: progress.completed_simulations,
        sample_type: result.sample_type,
        special_numbers: result.specialNumbers || [],
        normal_numbers: result.normalNumbers || [],
        confidence: result.confidence || 0,
        duration_ms: duration
      };
      
      await DB.saveMonteCarloResult(env, saveResult);
      
      // Ê∏ÖÁêÜ‰ºöËØù
      this.activeSessions.delete(sessionId);
      if (progress.chat_id) {
        await DB.deleteMonteCarloProgress(env, sessionId, progress.chat_id);
      }
      
      Logger.info("EnhancedMonteCarlo", `ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂÆåÊàê`, {
        sessionId: sessionId,
        duration: `${duration}ms`,
        simulations: progress.completed_simulations,
        confidence: result.confidence
      });
      
      return {
        success: true,
        result: result,
        sessionId: sessionId,
        duration: duration,
        simulations: progress.completed_simulations
      };
      
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "ÂÆåÊàêÂºÇÊ≠•Ê®°ÊãüÂ§±Ë¥•", error);
      return {
        success: false,
        error: error.message || "ÂÆåÊàêÊ®°ÊãüÂ§±Ë¥•"
      };
    }
  }
  
  static async generateResultFromFrequency(
    specialFreq,
    normalFreq,
    zodiacFreq,
    colorFreq,
    tailFreq,
    totalSimulations,
    history
  ) {
    try {
      // ËÆ°ÁÆóÊ¶ÇÁéá
      const specialProbabilities = {};
      const normalProbabilities = {};
      
      for (let i = 1; i <= 49; i++) {
        specialProbabilities[i] = (specialFreq[i] || 0) / totalSimulations;
        normalProbabilities[i] = (normalFreq[i] || 0) / totalSimulations;
      }
      
      // ËÆ°ÁÆóÁîüËÇñÊ¶ÇÁéá
      const zodiacProbabilities = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        zodiacProbabilities[zodiac] = (zodiacFreq[zodiac] || 0) / totalSimulations;
      });
      
      // ËÆ°ÁÆóÈ¢úËâ≤Ê¶ÇÁéá
      const colorProbabilities = {};
      ['red', 'blue', 'green'].forEach(color => {
        colorProbabilities[color] = (colorFreq[color] || 0) / totalSimulations;
      });
      
      // ËÆ°ÁÆóÂ∞æÊï∞Ê¶ÇÁéá
      const tailProbabilities = {};
      for (let i = 0; i <= 9; i++) {
        tailProbabilities[i] = (tailFreq[i] || 0) / totalSimulations;
      }
      
      // ÁîüÊàêÈ¢ÑÊµãÁªìÊûú
      const result = this.generatePredictionFromProbabilities(
        specialProbabilities,
        normalProbabilities,
        zodiacProbabilities,
        colorProbabilities,
        tailProbabilities,
        totalSimulations,
        history
      );
      
      return result;
      
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "‰ªéÈ¢ëÁéáÁîüÊàêÁªìÊûúÂ§±Ë¥•", error);
      return this.generateRandomFallback();
    }
  }
  
  // Ëé∑Âèñ‰ºöËØùËøõÂ∫¶
  static async getSessionProgress(env, sessionId, chatId) {
    try {
      // È¶ñÂÖàÊ£ÄÊü•Ê¥ªÂä®‰ºöËØù
      const session = this.activeSessions.get(sessionId);
      if (session) {
        const progressPercent = (session.completedSimulations / session.totalSimulations * 100).toFixed(1);
        const elapsedTime = Date.now() - session.startTime;
        const status = session.status || "running";
        
        return {
          success: true,
          sessionId: sessionId,
          active: status === "running",
          status: status,
          completed: session.completedSimulations,
          total: session.totalSimulations,
          progress: progressPercent,
          elapsedTime: elapsedTime,
          batchesCompleted: Math.floor(session.completedSimulations / CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE),
          totalBatches: session.totalBatches,
          estimatedRemaining: this.estimateRemainingTime(elapsedTime, parseFloat(progressPercent)),
          lastUpdated: new Date(session.lastUpdated).toISOString()
        };
      }
      
      // Ê£ÄÊü•Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑËøõÂ∫¶
      const progress = await DB.getMonteCarloProgress(env, sessionId, chatId);
      if (progress) {
        const progressPercent = (progress.completed_simulations / progress.total_simulations * 100).toFixed(1);
        const elapsedTime = new Date().getTime() - new Date(progress.last_updated).getTime();
        
        return {
          success: true,
          sessionId: sessionId,
          active: false,
          status: "stored",
          completed: progress.completed_simulations,
          total: progress.total_simulations,
          progress: progressPercent,
          lastUpdated: progress.last_updated,
          elapsedTime: elapsedTime
        };
      }
      
      return {
        success: false,
        error: "‰ºöËØù‰∏çÂ≠òÂú®ÊàñÂ∑≤ËøáÊúü"
      };
      
    } catch (error) {
      Logger.error("EnhancedMonteCarlo", "Ëé∑Âèñ‰ºöËØùËøõÂ∫¶Â§±Ë¥•", error);
      return {
        success: false,
        error: error.message || "Ëé∑ÂèñËøõÂ∫¶Â§±Ë¥•"
      };
    }
  }
  
  static estimateRemainingTime(elapsedMs, progressPercent) {
    if (progressPercent <= 0 || progressPercent >= 100) {
      return "Êú™Áü•";
    }
    
    const remainingPercent = 100 - progressPercent;
    const timePerPercent = elapsedMs / progressPercent;
    const remainingMs = timePerPercent * remainingPercent;
    
    return Formatter.formatDuration(remainingMs);
  }
  
  static clearCache() {
    try {
      this.cache.clear();
      this.activeSessions.clear();
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  }
}

// ==============================================================================
// 7. ÁªüËÆ°ÂºïÊìé
// ==============================================================================

class AdvancedStatsEngine {
  static statsCache = new Map();
  
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        return this.createEmptyStats();
      }

      const cacheKey = `stats_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.statsCache.get(cacheKey);
      if (cached) {
        return cached;
      }

      const stats = this.createEmptyStats();
      const maxRecords = Math.min(history.length, 200);
      const historySlice = history.slice(0, maxRecords);
      
      for (let i = 0; i < historySlice.length - 1; i++) {
        const currentRecord = historySlice[i];
        const nextRecord = historySlice[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNums = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNums = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNums.length < 7 || nextNums.length < 7) {
          continue;
        }
        
        const currentSpecial = currentNums[6] || 1;
        const nextSpecial = nextNums[6] || 1;
        const nextNormals = nextNums.slice(0, 6);
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        // ÁîüËÇñËΩ¨ÁßªÁªüËÆ°
        if (currentAttr.zodiac && nextAttr.zodiac && 
            stats.zodiacTransfer[currentAttr.zodiac] && 
            stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac] !== undefined) {
          stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac]++;
        }
        
        // Ê≥¢Ëâ≤ËΩ¨ÁßªÁªüËÆ°
        if (currentAttr.color && nextAttr.color && 
            stats.colorTransfer[currentAttr.color] && 
            stats.colorTransfer[currentAttr.color][nextAttr.color] !== undefined) {
          stats.colorTransfer[currentAttr.color][nextAttr.color]++;
        }
        
        // Â∞æÊï∞ÂÖ≥ËÅîÁªüËÆ°
        const currentNormalTails = currentNums.slice(0, 6).map(n => n % 10);
        const nextSpecialTail = nextSpecial % 10;
        
        currentNormalTails.forEach(tail => {
          if (tail >= 0 && tail <= 9 && nextSpecialTail >= 0 && nextSpecialTail <= 9 &&
              stats.tailCorrelation[tail] && 
              stats.tailCorrelation[tail][nextSpecialTail] !== undefined) {
            stats.tailCorrelation[tail][nextSpecialTail]++;
          }
        });
        
        // ÁâπÁ†ÅÈ¢ëÁéáÁªüËÆ°
        if (nextSpecial >= 1 && nextSpecial <= 49) {
          stats.specialFrequency[nextSpecial] = (stats.specialFrequency[nextSpecial] || 0) + 1;
        }
        
        // Âπ≥Á†ÅÈ¢ëÁéáÁªüËÆ°
        nextNormals.forEach(num => {
          if (num >= 1 && num <= 49) {
            stats.normalFrequency[num] = (stats.normalFrequency[num] || 0) + 1;
          }
        });
      }

      this.normalizeStatistics(stats);
      stats.totalRecords = historySlice.length;
      
      this.statsCache.set(cacheKey, stats);
      return stats;
    } catch (error) {
      Logger.error("Stats", "ÂàÜÊûêÂéÜÂè≤Êï∞ÊçÆÊó∂Âá∫Èîô", error);
      return this.createEmptyStats();
    }
  }

  static createEmptyStats() {
    try {
      const stats = {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: { 
          red: { red: 0, blue: 0, green: 0 }, 
          blue: { red: 0, blue: 0, green: 0 }, 
          green: { red: 0, blue: 0, green: 0 } 
        },
        tailCorrelation: {},
        zodiacRelations: { sixHarmony: {}, threeHarmony: {}, opposition: {} },
        specialFrequency: {},
        normalFrequency: {}
      };
      
      this.initializeStatsStructure(stats);
      return stats;
    } catch (error) {
      return {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: { red: { red: 0, blue: 0, green: 0 }, blue: { red: 0, blue: 0, green: 0 }, green: { red: 0, blue: 0, green: 0 } },
        tailCorrelation: {},
        specialFrequency: {},
        normalFrequency: {}
      };
    }
  }

  static initializeStatsStructure(stats) {
    try {
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac1 => {
        if (!stats.zodiacTransfer[zodiac1]) {
          stats.zodiacTransfer[zodiac1] = {};
        }
        
        Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac2 => {
          if (!stats.zodiacTransfer[zodiac1][zodiac2]) {
            stats.zodiacTransfer[zodiac1][zodiac2] = 0;
          }
        });
      });
      
      for (let i = 0; i < 10; i++) {
        if (!stats.tailCorrelation[i]) {
          stats.tailCorrelation[i] = {};
        }
        for (let j = 0; j < 10; j++) {
          if (!stats.tailCorrelation[i][j]) {
            stats.tailCorrelation[i][j] = 0;
          }
        }
      }
      
      for (let i = 1; i <= 49; i++) {
        if (stats.specialFrequency[i] === undefined) {
          stats.specialFrequency[i] = 0;
        }
        if (stats.normalFrequency[i] === undefined) {
          stats.normalFrequency[i] = 0;
        }
      }
    } catch (error) {
      Logger.error("Stats", "ÂàùÂßãÂåñÁªüËÆ°ÁªìÊûÑÂ§±Ë¥•", error);
    }
  }

  static normalizeStatistics(stats) {
    try {
      Object.keys(stats.zodiacTransfer).forEach(zodiac1 => {
        const total = Object.values(stats.zodiacTransfer[zodiac1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          Object.keys(stats.zodiacTransfer[zodiac1]).forEach(zodiac2 => {
            stats.zodiacTransfer[zodiac1][zodiac2] = stats.zodiacTransfer[zodiac1][zodiac2] / total;
          });
        }
      });
      
      Object.keys(stats.colorTransfer).forEach(color1 => {
        const total = Object.values(stats.colorTransfer[color1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          Object.keys(stats.colorTransfer[color1]).forEach(color2 => {
            stats.colorTransfer[color1][color2] = stats.colorTransfer[color1][color2] / total;
          });
        }
      });
      
      Object.keys(stats.tailCorrelation).forEach(tail1 => {
        const total = Object.values(stats.tailCorrelation[tail1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          Object.keys(stats.tailCorrelation[tail1]).forEach(tail2 => {
            stats.tailCorrelation[tail1][tail2] = stats.tailCorrelation[tail1][tail2] / total;
          });
        }
      });
    } catch (error) {
      Logger.error("Stats", "ÂΩí‰∏ÄÂåñÁªüËÆ°Â§±Ë¥•", error);
    }
  }

  static clearCache() {
    try {
      this.statsCache.clear();
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  }
}

// ==============================================================================
// 8. È¢ÑÊµãÂºïÊìé
// ==============================================================================

class AdvancedPredictionEngine {
  static predictionCache = new Map();
  
  static async generate(env, history, weights, useMonteCarlo = false) {
    try {
      if (!history || history.length < 2) {
        return this.generateStaticFallback();
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      // ËÆ°ÁÆó‰∏ã‰∏ÄÊúüÊúüÂè∑
      let nextExpect = "2025001";
      const latestExpect = lastRecord.expect;
      if (latestExpect && Formatter.isValidExpect(latestExpect)) {
        const latestNum = Formatter.safeInt(latestExpect, 2025000);
        nextExpect = (latestNum + 1).toString();
      }
      
      const cacheKey = `prediction_${lastSpecial}_${history.length}_${weights._version || '1.0'}_${useMonteCarlo}`;
      const cached = this.predictionCache.get(cacheKey);
      
      if (cached) {
        cached.nextExpect = nextExpect;
        return cached;
      }
      
      // Â¶ÇÊûú‰ΩøÁî®Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü
      let monteCarloResult = null;
      if (useMonteCarlo && history.length >= 10) {
        try {
          monteCarloResult = await EnhancedMonteCarloEngine.runSimulation(
            env, 
            CONFIG.SYSTEM.MONTECARLO_SIMULATIONS,
            "full_history"
          );
        } catch (monteError) {
          Logger.error("PredictionEngine", "Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•Ôºå‰ΩøÁî®‰º†ÁªüÁÆóÊ≥ï", monteError);
        }
      }
      
      const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(history);
      const scores = this.generatePredictionScores(lastSpecial, historyStats, weights, monteCarloResult);
      
      const topSpecialNumbers = this.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = this.getZodiacPredictions(scores);
      const colorPrediction = this.getColorPredictions(scores);
      const zodiacBestNumbers = this.getZodiacBestNumbers(scores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = this.generateNormalPredictions(historyStats, weights, excludeSpecials, monteCarloResult);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const bestAttr = Formatter.getAttributes(bestNumber);
      
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      
      const head = Math.floor(bestNumber / 10);
      
      // ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶
      let confidence = 30;
      
      if (monteCarloResult && monteCarloResult.confidence) {
        confidence = monteCarloResult.confidence;
      } else {
        const maxScore = topSpecialNumbers[0]?.score || 50;
        const avgScore = topSpecialNumbers.reduce((sum, item) => sum + (item?.score || 0), 0) / Math.max(1, topSpecialNumbers.length);
        const scoreRatio = maxScore / Math.max(1, avgScore);
        
        confidence += scoreRatio * 40;
        confidence += (history.length / 100) * 30;
      }
      
      confidence = Math.min(98, Math.max(20, Math.floor(confidence)));

      const formattedNormals = (normalPredictions || []).map(item => {
        const attr = Formatter.getAttributes(item?.number || 1);
        return {
          number: item?.number || 1,
          zodiac: attr.zodiac,
          color: attr.color,
          score: item?.score || 0,
          probability: item?.probability || 0
        };
      });

      const formattedSpecials = (topSpecialNumbers || []).slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));

      const prediction = {
        nextExpect: nextExpect,
        zodiac: zodiacPrediction || { main: [], guard: [], scores: {} },
        color: colorPrediction || { main: "red", guard: "blue", scores: {} },
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        zodiacBestNumbers: zodiacBestNumbers,
        confidence: confidence,
        analysisBased: true,
        monteCarloUsed: !!monteCarloResult,
        monteCarloEnhanced: monteCarloResult?.algorithmVersion?.includes("Enhanced") || false,
        totalHistoryRecords: historyStats?.totalRecords || 0,
        basedOnLastRecord: {
          expect: lastRecord.expect || "Êú™Áü•",
          openCode: lastOpenCode,
          special: lastSpecial,
          zodiac: bestAttr.zodiac,
          color: bestAttr.color
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V11.1" + (monteCarloResult ? "-EnhancedMonteCarlo" : "")
      };
      
      this.predictionCache.set(cacheKey, prediction);
      return prediction;
    } catch (error) {
      Logger.error("PredictionEngine", "ÁîüÊàêÈ¢ÑÊµãÊó∂Âá∫Èîô", error);
      return this.generateStaticFallback();
    }
  }

  static generatePredictionScores(lastSpecial, stats, weights, monteCarloResult = null) {
    const scores = {};
    
    try {
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      for (let num = 1; num <= 49; num++) {
        const attr = Formatter.getAttributes(num);
        let score = 0;
        
        // ÁîüËÇñËΩ¨Áßª
        if (lastAttr.zodiac && attr.zodiac && 
            stats.zodiacTransfer[lastAttr.zodiac] && 
            stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac]) {
          score += stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac] * 100 * weights.w_zodiac_transfer;
        }
        
        // ÂÖ≠ÂêàÂÖ≥Á≥ª
        if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
          const relationCount = stats.zodiacRelations.sixHarmony[attr.zodiac] || 0;
          const relationProbability = relationCount / Math.max(1, stats.totalRecords);
          score += relationProbability * 80 * weights.w_zodiac_relation;
        }
        
        // Ê≥¢Ëâ≤ËΩ¨Áßª
        if (lastAttr.color && attr.color && 
            stats.colorTransfer[lastAttr.color] && 
            stats.colorTransfer[lastAttr.color][attr.color]) {
          const colorProb = stats.colorTransfer[lastAttr.color][attr.color];
          score += colorProb * 100 * weights.w_color_transfer;
        }
        
        // Â∞æÊï∞ÂÖ≥ËÅî
        const lastTail = lastSpecial % 10;
        const currentTail = num % 10;
        
        if (lastTail >= 0 && lastTail <= 9 && currentTail >= 0 && currentTail <= 9 &&
            stats.tailCorrelation[lastTail] && 
            stats.tailCorrelation[lastTail][currentTail]) {
          const tailProb = stats.tailCorrelation[lastTail][currentTail];
          score += tailProb * 80 * weights.w_tail_correlation;
        }
        
        // ÁâπÁ†ÅÈ¢ëÁéá
        if (stats.specialFrequency[num]) {
          const freq = stats.specialFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 60 * weights.w_number_frequency;
        }
        
        // Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ¶ÇÁéá
        if (monteCarloResult && monteCarloResult.specialNumbers) {
          const monteItem = monteCarloResult.specialNumbers.find(item => item.number === num);
          if (monteItem && monteItem.probability) {
            score += monteItem.probability * 200 * weights.w_monte_carlo;
          }
        }
        
        // ËΩªÂæÆÈöèÊú∫Êâ∞Âä®
        const randomFactor = 0.95 + Math.random() * 0.1;
        score *= randomFactor;
        
        scores[num] = {
          score: score,
          probability: monteCarloResult ? 
            (monteCarloResult.specialNumbers.find(item => item.number === num)?.probability || 0) : 0
        };
      }
      
      return scores;
    } catch (error) {
      Logger.error("Stats", "ÁîüÊàêÈ¢ÑÊµãÂàÜÊï∞Â§±Ë¥•", error);
      
      for (let num = 1; num <= 49; num++) {
        scores[num] = {
          score: Math.random() * 100,
          probability: 0
        };
      }
      
      return scores;
    }
  }

  static getTopSpecialPredictions(scores, topN = 10) {
    try {
      const scoreArray = Object.entries(scores || {})
        .map(([num, data]) => ({
          number: Formatter.safeInt(num, 0),
          score: data.score,
          probability: data.probability
        }))
        .filter(item => item.number >= 1 && item.number <= 49);
      
      scoreArray.sort((a, b) => b.score - a.score);
      return scoreArray.slice(0, topN);
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÁâπÁ†ÅÈ¢ÑÊµãÂ§±Ë¥•", error);
      return [];
    }
  }

  static getZodiacPredictions(scores) {
    try {
      const zodiacScores = {};
      
      for (let num = 1; num <= 49; num++) {
        const zodiac = Formatter.getAttributes(num).zodiac;
        const scoreData = scores[num] || { score: 0, probability: 0 };
        
        if (!zodiacScores[zodiac]) {
          zodiacScores[zodiac] = { total: 0, count: 0, numbers: [] };
        }
        zodiacScores[zodiac].total += scoreData.score;
        zodiacScores[zodiac].count++;
        zodiacScores[zodiac].numbers.push(num);
      }
      
      const zodiacAvgScores = {};
      Object.keys(zodiacScores).forEach(zodiac => {
        const data = zodiacScores[zodiac];
        zodiacAvgScores[zodiac] = {
          average: data.total / Math.max(1, data.count),
          total: data.total,
          count: data.count,
          numbers: data.numbers
        };
      });
      
      const sortedZodiacs = Object.entries(zodiacAvgScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedZodiacs.slice(0, 3),
        guard: sortedZodiacs.slice(3, 6),
        scores: zodiacAvgScores
      };
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÁîüËÇñÈ¢ÑÊµãÂ§±Ë¥•", error);
      return {
        main: [],
        guard: [],
        scores: {}
      };
    }
  }

  static getColorPredictions(scores) {
    try {
      const colorScores = {};
      
      ['red', 'blue', 'green'].forEach(color => {
        const numbers = CONFIG.COLORS[color] || [];
        let total = 0;
        let maxScore = -Infinity;
        let bestNumber = 0;
        
        numbers.forEach(num => {
          const scoreData = scores[num] || { score: 0, probability: 0 };
          total += scoreData.score;
          if (scoreData.score > maxScore) {
            maxScore = scoreData.score;
            bestNumber = num;
          }
        });
        
        colorScores[color] = {
          average: total / Math.max(1, numbers.length),
          total: total,
          count: numbers.length,
          bestNumber: bestNumber,
          maxScore: maxScore
        };
      });
      
      const sortedColors = Object.entries(colorScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedColors[0],
        guard: sortedColors[1],
        scores: colorScores
      };
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÈ¢úËâ≤È¢ÑÊµãÂ§±Ë¥•", error);
      return {
        main: "red",
        guard: "blue",
        scores: {}
      };
    }
  }

  static getZodiacBestNumbers(scores) {
    try {
      const zodiacBestNumbers = {};
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        let bestNumber = numbers[0] || 1;
        let bestScore = -Infinity;
        
        numbers.forEach(num => {
          const scoreData = scores[num] || { score: 0, probability: 0 };
          if (scoreData.score > bestScore) {
            bestScore = scoreData.score;
            bestNumber = num;
          }
        });
        
        zodiacBestNumbers[zodiac] = {
          number: bestNumber,
          score: bestScore,
          color: Formatter.getAttributes(bestNumber).color
        };
      });
      
      return zodiacBestNumbers;
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÁîüËÇñÊúÄ‰Ω≥Âè∑Á†ÅÂ§±Ë¥•", error);
      
      const defaultBestNumbers = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        defaultBestNumbers[zodiac] = {
          number: numbers[0] || 1,
          score: 50,
          color: Formatter.getAttributes(numbers[0] || 1).color
        };
      });
      
      return defaultBestNumbers;
    }
  }

  static generateNormalPredictions(stats, weights, excludeNumbers = [], monteCarloResult = null) {
    const normalScores = {};
    const excludeSet = new Set(excludeNumbers || []);
    
    try {
      for (let num = 1; num <= 49; num++) {
        if (excludeSet.has(num)) {
          normalScores[num] = { score: -999999, probability: 0 };
          continue;
        }
        
        let score = 0;
        let probability = 0;
        
        // Âπ≥Á†ÅÈ¢ëÁéá
        if (stats.normalFrequency[num]) {
          const freq = stats.normalFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 150 * weights.w_number_frequency;
        }
        
        // Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ¶ÇÁéá
        if (monteCarloResult && monteCarloResult.normalNumbers) {
          const monteItem = monteCarloResult.normalNumbers.find(item => item.number === num);
          if (monteItem && monteItem.probability) {
            score += monteItem.probability * 250 * weights.w_monte_carlo;
            probability = monteItem.probability;
          }
        }
        
        // ËΩªÂæÆÈöèÊú∫Êâ∞Âä®
        const randomFactor = 0.96 + Math.random() * 0.08;
        score *= randomFactor;
        
        normalScores[num] = { score: score, probability: probability };
      }
      
      const scoreArray = Object.entries(normalScores)
        .filter(([_, data]) => data.score > -999999)
        .map(([num, data]) => ({
          number: Formatter.safeInt(num, 0),
          score: data.score,
          probability: data.probability
        }));
      
      scoreArray.sort((a, b) => b.score - a.score);
      
      return scoreArray.slice(0, 6);
    } catch (error) {
      Logger.error("Stats", "ÁîüÊàêÂπ≥Á†ÅÈ¢ÑÊµãÂ§±Ë¥•", error);
      
      const randomNumbers = [];
      const used = new Set();
      
      while (randomNumbers.length < 6) {
        const num = Math.floor(Math.random() * 49) + 1;
        if (!used.has(num) && !excludeSet.has(num)) {
          used.add(num);
          randomNumbers.push({
            number: num,
            score: Math.random() * 100,
            probability: 0
          });
        }
      }
      
      return randomNumbers;
    }
  }

  static generateStaticFallback() {
    try {
      const date = new Date();
      const day = date.getDate();
      const hour = date.getHours();
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = (day * hour) % allZodiacs.length;
      const colorIndex = (day + hour) % colors.length;
      
      const mainZodiac = allZodiacs[zodiacIndex] || "Èº†";
      const mainColor = colors[colorIndex] || "red";
      
      const candidates = CONFIG.ZODIAC_MAP[mainZodiac] || [1, 13, 25, 37, 49];
      const numIndex = hour % candidates.length;
      const exampleNumber = candidates[numIndex] || 1;
      
      // ÁîüÊàêÂπ≥Á†Å
      let normalNumbers = [];
      const excludeNumbers = [exampleNumber];
      
      for (let i = 0; i < 6; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((excludeNumbers.includes(num) || normalNumbers.find(n => n.number === num)) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        normalNumbers.push({
          number: num,
          zodiac: attr.zodiac,
          color: attr.color,
          score: Math.floor(Math.random() * 100),
          probability: Math.random() * 0.05
        });
        excludeNumbers.push(num);
      }
      
      // ÁîüÊàêÁâπÁ†ÅÊé®Ëçê
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((specialNumbers.find(n => n.number === num) || num === exampleNumber) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 100),
          probability: Math.random() * 0.1,
          zodiac: attr.zodiac,
          color: attr.color
        });
      }
      
      // ÁîüÊàê‰∏ÄËÇñ‰∏ÄÁ†Å
      const zodiacBestNumbers = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        const randomIndex = Math.floor(Math.random() * numbers.length);
        const num = numbers[randomIndex] || numbers[0] || 1;
        zodiacBestNumbers[zodiac] = {
          number: num,
          score: Math.floor(Math.random() * 100),
          color: Formatter.getAttributes(num).color
        };
      });
      
      const isBig = exampleNumber >= 25;
      const isOdd = exampleNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(exampleNumber / 10);
      
      return {
        nextExpect: "2025001",
        zodiac: {
          main: [
            mainZodiac, 
            allZodiacs[(zodiacIndex + 3) % allZodiacs.length] || "ÂÖî",
            allZodiacs[(zodiacIndex + 6) % allZodiacs.length] || "È©¨"
          ],
          guard: [
            allZodiacs[(zodiacIndex + 1) % allZodiacs.length] || "Áâõ",
            allZodiacs[(zodiacIndex + 4) % allZodiacs.length] || "Èæô"
          ],
          scores: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length] || "blue",
          scores: {}
        },
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        zodiacBestNumbers: zodiacBestNumbers,
        confidence: 20,
        analysisBased: false,
        monteCarloUsed: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V11.1-Static"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ÁîüÊàêÈùôÊÄÅÂõûÈÄÄÈ¢ÑÊµãÊó∂Âá∫Èîô", error);
      
      return {
        nextExpect: "2025001",
        zodiac: { main: ["Èº†", "Èæô", "Áå¥"], guard: ["Áâõ", "Ëõá"], scores: {} },
        color: { main: "red", guard: "blue", scores: {} },
        head: "0Â§¥",
        shape: "Â∞èÂçï",
        specialNumbers: [
          { number: 1, score: 50, probability: 0.1, zodiac: "Ëõá", color: "red" },
          { number: 13, score: 45, probability: 0.09, zodiac: "Ëõá", color: "blue" },
          { number: 25, score: 40, probability: 0.08, zodiac: "Ëõá", color: "green" },
          { number: 37, score: 35, probability: 0.07, zodiac: "Ëõá", color: "red" },
          { number: 49, score: 30, probability: 0.06, zodiac: "Ëõá", color: "blue" }
        ],
        normalNumbers: [
          { number: 2, zodiac: "Èæô", color: "red", score: 45, probability: 0.05 },
          { number: 3, zodiac: "ÂÖî", color: "blue", score: 40, probability: 0.04 },
          { number: 4, zodiac: "Ëôé", color: "blue", score: 35, probability: 0.03 },
          { number: 5, zodiac: "Áâõ", color: "green", score: 30, probability: 0.02 },
          { number: 6, zodiac: "Èº†", color: "green", score: 25, probability: 0.01 },
          { number: 7, zodiac: "Áå™", color: "red", score: 20, probability: 0.01 }
        ],
        zodiacBestNumbers: {
          "Èº†": { number: 6, score: 50, color: "green" },
          "Áâõ": { number: 5, score: 45, color: "green" },
          "Ëôé": { number: 4, score: 40, color: "blue" },
          "ÂÖî": { number: 3, score: 35, color: "blue" },
          "Èæô": { number: 2, score: 30, color: "red" },
          "Ëõá": { number: 1, score: 50, color: "red" },
          "È©¨": { number: 12, score: 45, color: "red" },
          "Áæä": { number: 11, score: 40, color: "green" },
          "Áå¥": { number: 10, score: 35, color: "blue" },
          "È∏°": { number: 9, score: 30, color: "blue" },
          "Áãó": { number: 8, score: 25, color: "red" },
          "Áå™": { number: 7, score: 20, color: "red" }
        },
        confidence: 10,
        analysisBased: false,
        monteCarloUsed: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V11.1-Emergency"
      };
    }
  }

  static clearCache() {
    try {
      this.predictionCache.clear();
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  }
}

// ==============================================================================
// 9. ÂÆöÊó∂‰ªªÂä°Ë∞ÉÂ∫¶Âô®
// ==============================================================================

class ScheduleManager {
  static async processPendingTasks(env) {
    try {
      const pendingTasks = await DB.getPendingScheduleTasks(env);
      
      if (pendingTasks.length === 0) {
        Logger.debug("ScheduleManager", "Ê≤°ÊúâÂæÖÂ§ÑÁêÜÁöÑÂÆöÊó∂‰ªªÂä°");
        return { processed: 0, results: [] };
      }
      
      Logger.info("ScheduleManager", `ÂèëÁé∞ ${pendingTasks.length} ‰∏™ÂæÖÂ§ÑÁêÜ‰ªªÂä°`);
      
      const results = [];
      
      for (const task of pendingTasks) {
        try {
          // Ê†áËÆ∞‰ªªÂä°‰∏∫ÂºÄÂßãÊâßË°å
          await DB.updateScheduleTask(env, task.id, { next_run: new Date(Date.now() + 5 * 60000).toISOString() });
          
          // ÊâßË°å‰ªªÂä°
          const result = await this.executeTask(env, task);
          
          // Ê†áËÆ∞‰ªªÂä°‰∏∫Â∑≤ÂÆåÊàê
          await DB.markScheduleTaskAsRun(env, task.id);
          
          results.push({
            taskId: task.id,
            taskName: task.name,
            taskType: task.task_type,
            success: result.success,
            message: result.message
          });
          
          Logger.info("ScheduleManager", `‰ªªÂä°ÊâßË°åÂÆåÊàê: ${task.name} (${task.task_type})`, {
            success: result.success,
            taskId: task.id
          });
          
        } catch (taskError) {
          Logger.error("ScheduleManager", `ÊâßË°å‰ªªÂä°Â§±Ë¥•: ${task.name}`, taskError);
          
          results.push({
            taskId: task.id,
            taskName: task.name,
            taskType: task.task_type,
            success: false,
            error: taskError.message
          });
          
          // Ê†áËÆ∞‰ªªÂä°Â§±Ë¥•ÔºåËÆæÁΩÆ‰∏ãÊ¨°ÊâßË°åÊó∂Èó¥Ôºà1Â∞èÊó∂ÂêéÈáçËØïÔºâ
          const retryTime = new Date(Date.now() + 60 * 60000);
          await DB.updateScheduleTask(env, task.id, { 
            next_run: retryTime.toISOString(),
            enabled: 1
          });
        }
      }
      
      return {
        processed: pendingTasks.length,
        results: results
      };
    } catch (error) {
      Logger.error("ScheduleManager", "Â§ÑÁêÜÂÆöÊó∂‰ªªÂä°Â§±Ë¥•", error);
      return { processed: 0, results: [], error: error.message };
    }
  }
  
  static async executeTask(env, task) {
    try {
      const taskType = task.task_type;
      const params = task.params ? JSON.parse(task.params) : {};
      
      Logger.info("ScheduleManager", `ÂºÄÂßãÊâßË°å‰ªªÂä°: ${task.name} (${taskType})`, params);
      
      switch (taskType) {
        case CONFIG.SCHEDULE_TYPES.SYNC:
          return await this.executeSyncTask(env, params);
          
        case CONFIG.SCHEDULE_TYPES.PREDICT:
          return await this.executePredictTask(env, params);
          
        case CONFIG.SCHEDULE_TYPES.PUSH:
          return await this.executePushTask(env, params);
          
        case CONFIG.SCHEDULE_TYPES.CLEANUP:
          return await this.executeCleanupTask(env, params);
          
        case CONFIG.SCHEDULE_TYPES.MONTE:
          return await this.executeMonteTask(env, params);
          
        default:
          return {
            success: false,
            message: `Êú™Áü•ÁöÑ‰ªªÂä°Á±ªÂûã: ${taskType}`
          };
      }
    } catch (error) {
      Logger.error("ScheduleManager", `ÊâßË°å‰ªªÂä°Â§±Ë¥•: ${task.name}`, error);
      return {
        success: false,
        message: `‰ªªÂä°ÊâßË°åÂºÇÂ∏∏: ${error.message}`
      };
    }
  }
  
  static async executeSyncTask(env, params) {
    try {
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      return {
        success: result.success,
        message: `Êï∞ÊçÆÂêåÊ≠•ÂÆåÊàê: Êñ∞Â¢û${result.added}Êù°ÔºåË∑≥Ëøá${result.skipped}Êù°`
      };
    } catch (error) {
      Logger.error("ScheduleManager", "ÊâßË°åÂêåÊ≠•‰ªªÂä°Â§±Ë¥•", error);
      return {
        success: false,
        message: `ÂêåÊ≠•Â§±Ë¥•: ${error.message}`
      };
    }
  }
  
  static async executePredictTask(env, params) {
    try {
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        return {
          success: false,
          message: "Êó†ÂéÜÂè≤Êï∞ÊçÆÔºåÊó†Ê≥ïÁîüÊàêÈ¢ÑÊµã"
        };
      }
      
      const weights = await DB.getWeights(env);
      const useMonteCarlo = params.useMonteCarlo !== false;
      
      const prediction = await AdvancedPredictionEngine.generate(env, history, weights, useMonteCarlo);
      
      return {
        success: true,
        message: `È¢ÑÊµãÁîüÊàêÂÆåÊàê: Á¨¨${prediction.nextExpect}ÊúüÔºåÁΩÆ‰ø°Â∫¶${prediction.confidence}%`,
        data: {
          expect: prediction.nextExpect,
          confidence: prediction.confidence
        }
      };
    } catch (error) {
      Logger.error("ScheduleManager", "ÊâßË°åÈ¢ÑÊµã‰ªªÂä°Â§±Ë¥•", error);
      return {
        success: false,
        message: `È¢ÑÊµãÁîüÊàêÂ§±Ë¥•: ${error.message}`
      };
    }
  }
  
  static async executePushTask(env, params) {
    try {
      if (!env.TG_CHANNEL_ID) {
        return {
          success: false,
          message: "È¢ëÈÅìIDÊú™ÈÖçÁΩÆÔºåÊó†Ê≥ïÊé®ÈÄÅ"
        };
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        return {
          success: false,
          message: "Êó†ÂéÜÂè≤Êï∞ÊçÆÔºåÊó†Ê≥ïÁîüÊàêÊé®ÈÄÅ"
        };
      }
      
      const weights = await DB.getWeights(env);
      const useMonteCarlo = params.useMonteCarlo !== false;
      
      const prediction = await AdvancedPredictionEngine.generate(env, history, weights, useMonteCarlo);
      const message = MessageRenderer.renderPrediction(prediction);
      
      await ExternalService.sendMessage(env, env.TG_CHANNEL_ID, message);
      
      return {
        success: true,
        message: `È¢ÑÊµãÂ∑≤Êé®ÈÄÅÂà∞È¢ëÈÅì: Á¨¨${prediction.nextExpect}Êúü`,
        data: {
          expect: prediction.nextExpect,
          channelId: env.TG_CHANNEL_ID
        }
      };
    } catch (error) {
      Logger.error("ScheduleManager", "ÊâßË°åÊé®ÈÄÅ‰ªªÂä°Â§±Ë¥•", error);
      return {
        success: false,
        message: `Êé®ÈÄÅÂ§±Ë¥•: ${error.message}`
      };
    }
  }
  
  static async executeCleanupTask(env, params) {
    try {
      // Ê∏ÖÁêÜÁºìÂ≠ò
      CacheManager.clear();
      AdvancedStatsEngine.clearCache();
      AdvancedPredictionEngine.clearCache();
      EnhancedMonteCarloEngine.clearCache();
      
      // Ê∏ÖÁêÜÊ∂àÊÅØÁÆ°ÁêÜÂô®‰∏≠ÁöÑÊóßÊ∂àÊÅØ
      let totalCleaned = 0;
      for (const [chatId, _] of MessageManager.userMessages) {
        totalCleaned += MessageManager.cleanupOldMessages(chatId, 5);
      }
      
      // Ê∏ÖÁêÜÊóßÁöÑËíôÁâπÂç°Ê¥õËøõÂ∫¶ËÆ∞ÂΩï
      const cleanupResult = await DB.cleanupOldMonteCarloProgress(env, 24);
      
      return {
        success: true,
        message: `Á≥ªÁªüÊ∏ÖÁêÜÂÆåÊàê: Ê∏ÖÁêÜ‰∫Ü${totalCleaned}Êù°ÊóßÊ∂àÊÅØÔºå${cleanupResult.deleted || 0}Êù°ËøõÂ∫¶ËÆ∞ÂΩïÔºåÊ∏ÖÈô§‰∫ÜÊâÄÊúâÁºìÂ≠ò`
      };
    } catch (error) {
      Logger.error("ScheduleManager", "ÊâßË°åÊ∏ÖÁêÜ‰ªªÂä°Â§±Ë¥•", error);
      return {
        success: false,
        message: `Ê∏ÖÁêÜÂ§±Ë¥•: ${error.message}`
      };
    }
  }
  
  static async executeMonteTask(env, params) {
    try {
      const simulations = params.simulations || CONFIG.SYSTEM.MONTECARLO_SIMULATIONS;
      const sampleType = params.sampleType || "full_history";
      
      const result = await EnhancedMonteCarloEngine.runSimulation(env, simulations, sampleType);
      
      return {
        success: true,
        message: `Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂÆåÊàê: ${result.total_simulations}Ê¨°Ê®°ÊãüÔºåÁΩÆ‰ø°Â∫¶${result.confidence}%`,
        data: {
          simulations: result.total_simulations,
          confidence: result.confidence,
          duration: result.duration_ms,
          sampleType: sampleType
        }
      };
    } catch (error) {
      Logger.error("ScheduleManager", "ÊâßË°åËíôÁâπÂç°Ê¥õ‰ªªÂä°Â§±Ë¥•", error);
      return {
        success: false,
        message: `ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•: ${error.message}`
      };
    }
  }
}

// ==============================================================================
// 10. Ê∂àÊÅØÊ∏≤ÊüìÂô®
// ==============================================================================

class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME} - ÂëΩ‰ª§Ê®°Êùø</b>\n`;
      message += `ÁâàÊú¨: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `${CONFIG.EMOJI.refresh} <i>Èò≤Âà∑Â±èÊ®°ÂºèÔºåÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞Ê∂àÊÅØ</i>\n\n`;
      
      message += `<b>üìã ‰∏ªË¶ÅÂëΩ‰ª§Ôºö</b>\n`;
      message += `<code>/predict</code> - ÁîüÊàê/Êõ¥Êñ∞È¢ÑÊµãÁªìÊûú\n`;
      message += `<code>/monte [Ê¨°Êï∞]</code> - Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü\n`;
      message += `<code>/monte async [Ê¨°Êï∞]</code> - ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°Êãü\n`;
      message += `<code>/monte progress [ID]</code> - Êü•ÁúãÊ®°ÊãüËøõÂ∫¶\n`;
      message += `<code>/monte complete [ID]</code> - ÂÆåÊàêÂºÇÊ≠•Ê®°Êãü\n`;
      message += `<code>/history [È°µÁ†Å]</code> - Êü•ÁúãÂéÜÂè≤ËÆ∞ÂΩï\n`;
      message += `<code>/stats</code> - Êü•ÁúãÁ≥ªÁªüÁªüËÆ°\n`;
      message += `<code>/ccc</code> - ÊòæÁ§∫Ê≠§ÂëΩ‰ª§Ê®°Êùø\n`;
      
      if (isAdmin) {
        message += `\n<b>üîß ÁÆ°ÁêÜÂëòÂëΩ‰ª§Ôºö</b>\n`;
        message += `<code>/sync</code> - ÂêåÊ≠•ÂéÜÂè≤Êï∞ÊçÆ\n`;
        message += `<code>/push</code> - Êé®ÈÄÅÈ¢ÑÊµãÂà∞È¢ëÈÅì\n`;
        message += `<code>/delete [ÊúüÂè∑]</code> - Âà†Èô§ÂçïÊúüËÆ∞ÂΩï\n`;
        message += `<code>/schedule list</code> - ÂàóÂá∫ÂÆöÊó∂‰ªªÂä°\n`;
        message += `<code>/schedule add [Á±ªÂûã] [Êó∂Èó¥] [ÂèÇÊï∞]</code> - Ê∑ªÂä†ÂÆöÊó∂‰ªªÂä°\n`;
        message += `<code>/schedule remove [ID]</code> - Âà†Èô§ÂÆöÊó∂‰ªªÂä°\n`;
        message += `<code>/schedule test [Á±ªÂûã]</code> - ÊµãËØïÂÆöÊó∂‰ªªÂä°\n`;
      }
      
      message += `\n<b>üí° ‰ΩøÁî®Á§∫‰æãÔºö</b>\n`;
      message += `<code>/predict</code> - ÁîüÊàêÊñ∞È¢ÑÊµã\n`;
      message += `<code>/monte 20000</code> - ËøêË°å20000Ê¨°Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü\n`;
      message += `<code>/monte async 50000</code> - ÂºÇÊ≠•ËøêË°å50000Ê¨°Ê®°Êãü\n`;
      message += `<code>/monte progress monte_async_1234567890</code> - Êü•ÁúãËøõÂ∫¶\n`;
      message += `<code>/history 1</code> - Êü•ÁúãÁ¨¨1È°µÂéÜÂè≤\n`;
      message += `<code>/schedule add sync "0 9 * * *"</code> - ÊØèÂ§©9ÁÇπÂêåÊ≠•\n`;
      message += `<code>/schedule add push "18:00" '{"useMonteCarlo": true}'</code>\n`;
      
      message += `\n<b>üìÖ ÂÆöÊó∂‰ªªÂä°Êó∂Èó¥Ê†ºÂºèÔºö</b>\n`;
      message += `‚Ä¢ ÊØèÊó•Êó∂Èó¥: "HH:MM" (Â¶Ç "09:00")\n`;
      message += `‚Ä¢ CronË°®ËææÂºè: "0 9 * * *" (ÊØèÂ§©9ÁÇπ)\n`;
      message += `‚Ä¢ ÂÖ∑‰ΩìÊó∂Èó¥: "2024-01-01 09:00"\n`;
      message += `‚Ä¢ ÊòéÂ§©Êó∂Èó¥: "tomorrow 09:00"\n`;
      message += `‚Ä¢ Áõ∏ÂØπÊó∂Èó¥: "in 30 minutes"\n`;
      
      message += `\n${CONFIG.EMOJI.refresh} <b>Èò≤Âà∑Â±èÁâπÊÄßÔºö</b>\n`;
      message += `‚Ä¢ ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞‰∏ÄÊù°Ê∂àÊÅØ\n`;
      message += `‚Ä¢ ÂèëÈÄÅÁõ∏ÂêåÂëΩ‰ª§Ëá™Âä®Âà†Èô§ÊóßÊ∂àÊÅØ\n`;
      message += `‚Ä¢ ‰øùÊåÅËÅäÂ§©ÁïåÈù¢Êï¥Ê¥Å\n`;
      message += `‚Ä¢ Èò≤Ê≠¢Ê∂àÊÅØÂ†ÜÁßØ\n`;
      
      message += `\n${CONFIG.EMOJI.dice} <b>Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÔºö</b>\n`;
      message += `‚Ä¢ Âü∫‰∫éÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÊ®°Êãü\n`;
      message += `‚Ä¢ ÊîØÊåÅÂàÜÊâπÂ§ÑÁêÜÔºåÈÅøÂÖçË∂ÖÊó∂\n`;
      message += `‚Ä¢ Êèê‰æõÊ¶ÇÁéáÁªüËÆ°ÂíåËøõÂ∫¶Ë∑üË∏™\n`;
      message += `‚Ä¢ ÊîØÊåÅÂºÇÊ≠•ÈïøÊó∂Èó¥Ê®°Êãü\n`;
      
      message += `\n${CONFIG.EMOJI.calendar} <b>ÂÆöÊó∂‰ªªÂä°Ôºö</b>\n`;
      message += `‚Ä¢ ÊîØÊåÅÂ§öÁßçÊó∂Èó¥Ê†ºÂºè\n`;
      message += `‚Ä¢ Ëá™Âä®ÊâßË°åÂêåÊ≠•„ÄÅÈ¢ÑÊµã„ÄÅÊé®ÈÄÅ\n`;
      message += `‚Ä¢ ÂèØÈÖçÁΩÆ‰ªªÂä°ÂèÇÊï∞\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂëΩ‰ª§Ê®°ÊùøÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME}</b>\n\n‰ΩøÁî® /ccc Êü•ÁúãÂÆåÊï¥ÂëΩ‰ª§ÂàóË°®„ÄÇ`;
    }
  }

  static renderWelcomeMessage(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.home} <b>Ê¨¢Ëøé‰ΩøÁî® ${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ÁâàÊú¨: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `${CONFIG.EMOJI.refresh} <b>Èò≤Âà∑Â±èÊ®°ÂºèÂ∑≤ÂêØÁî®</b>\n\n`;
      message += `ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞‰∏ÄÊù°Ê∂àÊÅØ\n`;
      message += `ÂèëÈÄÅÁõ∏ÂêåÂëΩ‰ª§‰ºöËá™Âä®Âà†Èô§ÊóßÊ∂àÊÅØ\n`;
      message += `\n‰ΩøÁî® <code>/ccc</code> Êü•ÁúãÂÆåÊï¥ÂëΩ‰ª§ÂàóË°®\n`;
      message += `‰ΩøÁî® <code>/predict</code> ÁîüÊàêÊñ∞È¢ÑÊµã\n`;
      message += `‰ΩøÁî® <code>/monte</code> ËøêË°åÂ¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü\n`;
      message += `\n${CONFIG.EMOJI.check} <b>‰øùÊåÅËÅäÂ§©ÁïåÈù¢Êï¥Ê¥Å</b>\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊ¨¢ËøéÊ∂àÊÅØÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.home} <b>${CONFIG.SYSTEM.NAME}</b>\n\nÁ≥ªÁªüËøêË°åÊ≠£Â∏∏„ÄÇ`;
    }
  }

  static renderStats(historyCount = 0, lastSync = "", deletionStats = null, monteStats = null, scheduleStats = null, cacheStats = null) {
    try {
      let message = `${CONFIG.EMOJI.chart} <b>Á≥ªÁªüÁªüËÆ°</b>\n\n`;
      message += `üìä <b>Êï∞ÊçÆÁªüËÆ°:</b>\n`;
      message += `‚Ä¢ ÂéÜÂè≤ËÆ∞ÂΩï: ${historyCount} Êúü\n`;
      
      if (lastSync) {
        message += `‚Ä¢ ÊúÄÂêéÂêåÊ≠•: ${lastSync}\n`;
      }
      
      if (deletionStats) {
        message += `‚Ä¢ Âà†Èô§Êìç‰Ωú: ${deletionStats.totalDeletions || 0} Ê¨°\n`;
        message += `‚Ä¢ Âà†Èô§ËÆ∞ÂΩï: ${deletionStats.totalRecordsDeleted || 0} Êù°\n`;
      }
      
      if (monteStats) {
        message += `\nüé≤ <b>Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÁªüËÆ°:</b>\n`;
        message += `‚Ä¢ Ê®°ÊãüÊ¨°Êï∞: ${monteStats.total || 0} Ê¨°\n`;
        message += `‚Ä¢ Âπ≥ÂùáÊ®°Êãü: ${monteStats.avgSimulations || 0} Ê¨°/Ê¨°\n`;
        message += `‚Ä¢ Âπ≥ÂùáÁΩÆ‰ø°Â∫¶: ${monteStats.avgConfidence || 0}%\n`;
        message += `‚Ä¢ Âπ≥ÂùáËÄóÊó∂: ${Formatter.formatDuration(monteStats.avgDuration || 0)}\n`;
        message += `‚Ä¢ ÊúÄÂêéÁ±ªÂûã: ${monteStats.lastSampleType || "Êú™Áü•"}\n`;
        
        if (monteStats.sampleTypes && monteStats.sampleTypes.length > 0) {
          message += `‚Ä¢ Ê†∑Êú¨Á±ªÂûã: `;
          message += monteStats.sampleTypes.map(st => `${st.sample_type}:${st.count}`).join(", ");
          message += `\n`;
        }
      }
      
      if (scheduleStats) {
        message += `\n${CONFIG.EMOJI.calendar} <b>ÂÆöÊó∂‰ªªÂä°ÁªüËÆ°:</b>\n`;
        message += `‚Ä¢ ÊÄª‰ªªÂä°Êï∞: ${scheduleStats.total || 0}\n`;
        message += `‚Ä¢ ÂêØÁî®‰ªªÂä°: ${scheduleStats.enabled || 0}\n`;
        message += `‚Ä¢ ÂæÖÊâßË°å‰ªªÂä°: ${scheduleStats.pending || 0}\n`;
      }
      
      if (cacheStats) {
        message += `\n${CONFIG.EMOJI.database} <b>ÁºìÂ≠òÁªüËÆ°:</b>\n`;
        message += `‚Ä¢ ÁºìÂ≠òÊÄªÊï∞: ${cacheStats.total || 0}\n`;
        message += `‚Ä¢ ÊúâÊïàÁºìÂ≠ò: ${cacheStats.valid || 0}\n`;
        message += `‚Ä¢ ËøáÊúüÁºìÂ≠ò: ${cacheStats.expired || 0}\n`;
      }
      
      // ËíôÁâπÂç°Ê¥õ‰ºöËØùÁªüËÆ°
      const activeSessions = EnhancedMonteCarloEngine.activeSessions.size;
      if (activeSessions > 0) {
        message += `\n${CONFIG.EMOJI.progress} <b>ËíôÁâπÂç°Ê¥õ‰ºöËØù:</b>\n`;
        message += `‚Ä¢ Ê¥ªÂä®‰ºöËØù: ${activeSessions}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.check} <b>Á≥ªÁªüÁä∂ÊÄÅÔºöÊ≠£Â∏∏</b>\n`;
      message += `ÁÆóÊ≥ïÁâàÊú¨: V11.1\n`;
      message += `Èò≤Âà∑Â±èÊ®°Âºè: Â∑≤ÂêØÁî®\n`;
      message += `Ê∂àÊÅØÁÆ°ÁêÜ: ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞Ê∂àÊÅØ\n`;
      message += `ËíôÁâπÂç°Ê¥õ: ‰ΩøÁî®ÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÔºåÂàÜÊâπÂ§ÑÁêÜ\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÁªüËÆ°Â§±Ë¥•", error);
      return `${CONFIG.EMOJI.chart} <b>Á≥ªÁªüÁªüËÆ°</b>\n\nÊó†Ê≥ïËé∑ÂèñÁªüËÆ°‰ø°ÊÅØ„ÄÇ`;
    }
  }

  static renderPrediction(prediction) {
    try {
      if (!prediction) {
        return `${CONFIG.EMOJI.warning} È¢ÑÊµãÊï∞ÊçÆ‰∏∫Á©∫ÔºåËØ∑ÈáçËØï„ÄÇ`;
      }
      
      const nextExpect = Formatter.safeString(prediction.nextExpect, "Êú™Áü•");
      const confidence = Formatter.safeInt(prediction.confidence, 0);
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const basedOnLastRecord = prediction.basedOnLastRecord || {};
      const analysisBased = prediction.analysisBased || false;
      const monteCarloUsed = prediction.monteCarloUsed || false;
      const monteCarloEnhanced = prediction.monteCarloEnhanced || false;
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      const zodiac = prediction.zodiac || { main: [], guard: [], scores: {} };
      const color = prediction.color || { main: "red", guard: "blue", scores: {} };
      const head = Formatter.safeString(prediction.head, "Êú™Áü•");
      const shape = Formatter.safeString(prediction.shape, "Êú™Áü•");
      
      // ÁÆóÊ≥ïÊ†áËØÜ
      let algorithmInfo = "";
      if (monteCarloUsed && monteCarloEnhanced) {
        algorithmInfo = `${CONFIG.EMOJI.science} <b>Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÁÆóÊ≥ïÈ¢ÑÊµã</b>\n`;
      } else if (monteCarloUsed) {
        algorithmInfo = `${CONFIG.EMOJI.dice} <b>ËíôÁâπÂç°Ê¥õÁÆóÊ≥ïÈ¢ÑÊµã</b>\n`;
      } else {
        algorithmInfo = `${CONFIG.EMOJI.brain} <b>‰º†ÁªüÁÆóÊ≥ïÈ¢ÑÊµã</b>\n`;
      }
      
      let dataSource = "";
      if (analysisBased && totalHistoryRecords > 0) {
        dataSource = `üìä Âü∫‰∫é ${totalHistoryRecords} ÊúüÂéÜÂè≤Êï∞ÊçÆÂàÜÊûê\n`;
      } else {
        dataSource = `‚ö†Ô∏è Âü∫‰∫éÈùôÊÄÅÁÆóÊ≥ïÁîüÊàê\n`;
      }
      
      let basedOnInfo = "";
      if (basedOnLastRecord.expect) {
        const { expect, special } = basedOnLastRecord;
        const attr = Formatter.getAttributes(special);
        basedOnInfo = `üìù Âü∫‰∫é: Á¨¨ ${expect} Êúü (ÁâπÁ†Å${special} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]})\n`;
      }
      
      // Ê†ºÂºèÂåñÂπ≥Á†ÅÊòæÁ§∫
      let normalDisplay = "ÊöÇÊó†Êï∞ÊçÆ";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // Ê†ºÂºèÂåñÁâπÁ†ÅÊòæÁ§∫ÔºàÂ∏¶Ê¶ÇÁéáÔºâ
      let specialDisplay = "ÊöÇÊó†Êï∞ÊçÆ";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.slice(0, 5).map(num => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.probability ? `(${(num.probability * 100).toFixed(1)}%)` : "";
          
          return `${numStr}(${zodiacStr}${colorEmoji})${prob}`;
        }).join("  ");
      }
      
      const zodiacMain = Array.isArray(zodiac.main) ? zodiac.main : [];
      const zodiacGuard = Array.isArray(zodiac.guard) ? zodiac.guard : [];
      
      const content = `
${CONFIG.EMOJI.fire} <b>${CONFIG.SYSTEM.NAME} - Â¢ûÂº∫È¢ÑÊµã</b>
${algorithmInfo}Á¨¨ <b>${nextExpect}</b> Êúü
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
${dataSource}${basedOnInfo}
${CONFIG.EMOJI.star} <b>ÁîüËÇñÊé®Ëçê</b>
‰∏ªÊé®: ${zodiacMain.join(" ") || "ÊöÇÊó†"}
Èò≤ÂÆà: ${zodiacGuard.join(" ") || "ÊöÇÊó†"}

${CONFIG.EMOJI.diamond} <b>Ê≥¢Ëâ≤ÂèÇËÄÉ</b>
‰∏ª${CONFIG.EMOJI[color.main] || ""} / Èò≤${CONFIG.EMOJI[color.guard] || ""}

${CONFIG.EMOJI.rocket} <b>ÁâπÁ†ÅÂèÇËÄÉ</b>
Â§¥Êï∞: ${head} | ÂΩ¢ÊÄÅ: ${shape}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
<b>Á≤æÈÄâÂπ≥Á†Å</b>
${normalDisplay}

<b>ÁâπÁ†ÅÊé®Ëçê (Ê¶ÇÁéá)</b>
${specialDisplay}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
<b>ÁΩÆ‰ø°Â∫¶</b>: ${confidence}%
<b>ÁîüÊàêÊó∂Èó¥</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ÁÆóÊ≥ïÁâàÊú¨</b>: ${prediction.algorithmVersion || "V11.1"}
<b>ËíôÁâπÂç°Ê¥õ</b>: ${monteCarloUsed ? "Â∑≤‰ΩøÁî®" + (monteCarloEnhanced ? "ÔºàÂ¢ûÂº∫Ôºâ" : "") : "Êú™‰ΩøÁî®"}
<b>Ê∂àÊÅØÊ®°Âºè</b>: ${CONFIG.EMOJI.refresh} ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞Ê∂àÊÅØ
<b>ÂéÜÂè≤Êï∞ÊçÆ</b>: ${totalHistoryRecords} Êúü
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÈ¢ÑÊµãÊó∂Âá∫Èîô", error);
      return `${CONFIG.EMOJI.warning} Ê∏≤ÊüìÈ¢ÑÊµãÊó∂ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ`;
    }
  }

  static renderMonteCarloResult(result) {
    try {
      if (!result) {
        return `${CONFIG.EMOJI.warning} ËíôÁâπÂç°Ê¥õÊ®°ÊãüÁªìÊûú‰∏∫Á©∫ÔºåËØ∑ÈáçËØï„ÄÇ`;
      }
      
      const specialNumbers = Array.isArray(result.specialNumbers) ? result.specialNumbers : [];
      const normalNumbers = Array.isArray(result.normalNumbers) ? result.normalNumbers : [];
      const confidence = Formatter.safeInt(result.confidence, 0);
      const simulationStats = result.simulationStats || {};
      const duration = Formatter.safeInt(result.duration_ms, 0);
      const sampleType = Formatter.safeString(result.sample_type, "Êú™Áü•");
      const historyCount = Formatter.safeInt(result.history_count, 0);
      const hotNumbers = Array.isArray(result.hotNumbers) ? result.hotNumbers : [];
      
      // Ê†ºÂºèÂåñÁâπÁ†ÅÊòæÁ§∫ÔºàÂ∏¶Ê¶ÇÁéáÔºâ
      let specialDisplay = "ÊöÇÊó†Êï∞ÊçÆ";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.slice(0, 5).map((num, index) => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.probability ? `${(num.probability * 100).toFixed(1)}%` : "0%";
          const rank = index + 1;
          
          return `${rank}. ${numStr}(${zodiacStr}${colorEmoji})[${prob}]`;
        }).join("\n");
      }
      
      // Ê†ºÂºèÂåñÂπ≥Á†ÅÊòæÁ§∫
      let normalDisplay = "ÊöÇÊó†Êï∞ÊçÆ";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      const content = `
${CONFIG.EMOJI.science} <b>Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÁªìÊûú</b>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
<b>Ê®°ÊãüÁªüËÆ°</b>
‚Ä¢ Ê®°ÊãüÊ¨°Êï∞: ${simulationStats.totalSimulations || 0}
‚Ä¢ ÂéÜÂè≤Êï∞ÊçÆ: ${historyCount} Êúü
‚Ä¢ Ê†∑Êú¨Á±ªÂûã: ${sampleType}
‚Ä¢ ÊúÄÈ´òÊ¶ÇÁéá: ${((simulationStats.maxProbability || 0) * 100).toFixed(2)}%
‚Ä¢ Âπ≥ÂùáÊ¶ÇÁéá: ${((simulationStats.avgProbability || 0) * 100).toFixed(2)}%
‚Ä¢ ËÆ°ÁÆóËÄóÊó∂: ${Formatter.formatDuration(duration)}

<b>ÁâπÁ†ÅÊé®Ëçê (Ê¶ÇÁéáÊéíÂêç)</b>
${specialDisplay}

<b>Âπ≥Á†ÅÊé®Ëçê</b>
${normalDisplay}

<b>ÁîüËÇñÊé®Ëçê</b>
‰∏ªÊé®: ${Array.isArray(result.zodiac?.main) ? result.zodiac.main.join(" ") : "ÊöÇÊó†"}
Èò≤ÂÆà: ${Array.isArray(result.zodiac?.guard) ? result.zodiac.guard.join(" ") : "ÊöÇÊó†"}

<b>Ê≥¢Ëâ≤Êé®Ëçê</b>
‰∏ª${CONFIG.EMOJI[result.color?.main] || ""} / Èò≤${CONFIG.EMOJI[result.color?.guard] || ""}

${hotNumbers.length > 0 ? `<b>${CONFIG.EMOJI.fire} ÁÉ≠Â∫¶Âè∑Á†Å</b>\n${hotNumbers.join(", ")}\n` : ''}

<b>ÂΩ¢ÊÄÅÂàÜÊûê</b>
${result.head || "Êú™Áü•"} | ${result.shape || "Êú™Áü•"}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
<b>ÁΩÆ‰ø°Â∫¶</b>: ${confidence}%
<b>ÁîüÊàêÊó∂Èó¥</b>: ${new Date(result.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ÁÆóÊ≥ïÁâàÊú¨</b>: ${result.algorithmVersion || "V11.1-EnhancedMonteCarlo"}
<b>Ê≥®ÊÑè‰∫ãÈ°π</b>: Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂü∫‰∫éÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÂàÜÊâπÂ§ÑÁêÜÔºåÁªìÊûúÊõ¥Âä†ÁßëÂ≠¶ÂèØÈù†
      `.trim();
      
      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìËíôÁâπÂç°Ê¥õÁªìÊûúÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.warning} Ê∏≤ÊüìËíôÁâπÂç°Ê¥õÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderMonteCarloProgress(progress) {
    try {
      if (!progress.success) {
        return `${CONFIG.EMOJI.warning} <b>Ëé∑ÂèñËøõÂ∫¶Â§±Ë¥•</b>\n\nÈîôËØØ: ${progress.error || "Êú™Áü•ÈîôËØØ"}`;
      }
      
      const {
        sessionId,
        active,
        status,
        completed,
        total,
        progress: progressPercent,
        elapsedTime,
        batchesCompleted,
        totalBatches,
        estimatedRemaining,
        lastUpdated
      } = progress;
      
      let message = `${CONFIG.EMOJI.progress} <b>ËíôÁâπÂç°Ê¥õÊ®°ÊãüËøõÂ∫¶</b>\n\n`;
      message += `‰ºöËØùID: ${sessionId}\n`;
      message += `Áä∂ÊÄÅ: ${status || (active ? "ËøõË°å‰∏≠" : "Â∑≤ÊöÇÂÅú")}\n`;
      message += `ËøõÂ∫¶: ${progressPercent}%\n`;
      message += `Ê®°Êãü: ${completed} / ${total}\n`;
      message += `ÊâπÊ¨°: ${batchesCompleted} / ${totalBatches}\n`;
      
      if (active) {
        message += `Â∑≤ËøêË°å: ${Formatter.formatDuration(elapsedTime)}\n`;
        message += `È¢ÑËÆ°Ââ©‰Ωô: ${estimatedRemaining}\n`;
      } else if (lastUpdated) {
        message += `ÊúÄÂêéÊõ¥Êñ∞: ${new Date(lastUpdated).toLocaleString('zh-CN')}\n`;
        message += `Ë∑ùÁ¶ªÁé∞Âú®: ${Formatter.formatDuration(elapsedTime)}\n`;
      }
      
      const progressBar = Formatter.formatProgress(completed, total);
      message += `\n${progressBar}\n`;
      
      if (status === "running" || active) {
        message += `\nÊ®°ÊãüÊ≠£Âú®ËøõË°å‰∏≠...\n`;
        message += `‰ΩøÁî® <code>/monte progress ${sessionId}</code> Êü•ÁúãÊúÄÊñ∞ËøõÂ∫¶\n`;
      } else if (status === "completed") {
        message += `\nÊ®°ÊãüÂ∑≤ÂÆåÊàê\n`;
        message += `‰ΩøÁî® <code>/monte complete ${sessionId}</code> Ëé∑ÂèñÁªìÊûú\n`;
      } else if (status === "failed" || status === "error") {
        message += `\nÊ®°ÊãüÂ§±Ë¥•\n`;
        message += `ËØ∑Ê£ÄÊü•Á≥ªÁªüÁä∂ÊÄÅÊàñÈáçÊñ∞ÂêØÂä®Ê®°Êãü\n`;
      } else {
        message += `\nÊ®°ÊãüÂ∑≤ÊöÇÂÅúÊàñÂÆåÊàê\n`;
        message += `ÂèØ‰ª•‰ΩøÁî® <code>/monte complete ${sessionId}</code> ÂÆåÊàêÊ®°Êãü\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìËíôÁâπÂç°Ê¥õËøõÂ∫¶Â§±Ë¥•", error);
      return `${CONFIG.EMOJI.warning} Ê∏≤ÊüìËøõÂ∫¶‰ø°ÊÅØÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderMonteCarloAsyncStart(result) {
    try {
      if (!result.success) {
        return `${CONFIG.EMOJI.warning} <b>ÂêØÂä®ÂºÇÊ≠•Ê®°ÊãüÂ§±Ë¥•</b>\n\nÈîôËØØ: ${result.error || "Êú™Áü•ÈîôËØØ"}`;
      }
      
      const {
        sessionId,
        totalSimulations,
        totalBatches,
        batchSize,
        historyCount
      } = result;
      
      let message = `${CONFIG.EMOJI.progress} <b>ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ∑≤ÂêØÂä®</b>\n\n`;
      message += `‰ºöËØùID: <code>${sessionId}</code>\n`;
      message += `ÊÄªÊ®°ÊãüÊ¨°Êï∞: ${totalSimulations}\n`;
      message += `ÊÄªÊâπÊ¨°Êï∞: ${totalBatches}\n`;
      message += `ÊâπÊ¨°Â§ßÂ∞è: ${batchSize}\n`;
      message += `ÂéÜÂè≤Êï∞ÊçÆ: ${historyCount} Êúü\n`;
      message += `Ê†∑Êú¨Á±ªÂûã: ÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩï\n\n`;
      
      message += `Ê®°ÊãüÂ∞ÜÂú®ÂêéÂè∞Ëá™Âä®ËøõË°å\n`;
      message += `‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Êü•ÁúãËøõÂ∫¶:\n`;
      message += `<code>/monte progress ${sessionId}</code>\n\n`;
      
      message += `ÂÆåÊàêÊ®°ÊãüÂêéÔºå‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ëé∑ÂèñÁªìÊûú:\n`;
      message += `<code>/monte complete ${sessionId}</code>\n\n`;
      
      message += `Ê≥®ÊÑè: ‰ºöËØùÂ∞ÜÂú®24Â∞èÊó∂ÂêéËá™Âä®Ê∏ÖÁêÜ\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂºÇÊ≠•Ê®°ÊãüÂêØÂä®Â§±Ë¥•", error);
      return `${CONFIG.EMOJI.warning} Ê∏≤ÊüìÂêØÂä®‰ø°ÊÅØÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderMonteCarloComplete(result) {
    try {
      if (!result.success) {
        return `${CONFIG.EMOJI.warning} <b>ÂÆåÊàêÊ®°ÊãüÂ§±Ë¥•</b>\n\nÈîôËØØ: ${result.error || "Êú™Áü•ÈîôËØØ"}`;
      }
      
      const {
        sessionId,
        duration,
        simulations
      } = result;
      
      let message = `${CONFIG.EMOJI.check} <b>ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ∑≤ÂÆåÊàê</b>\n\n`;
      message += `‰ºöËØùID: ${sessionId}\n`;
      message += `ÊÄªÊ®°ÊãüÊ¨°Êï∞: ${simulations}\n`;
      message += `ÊÄªËÄóÊó∂: ${Formatter.formatDuration(duration)}\n\n`;
      
      // Ê∏≤ÊüìÁªìÊûú
      if (result.result) {
        const resultMessage = this.renderMonteCarloResult(result.result);
        message += resultMessage;
      } else {
        message += `ÁªìÊûúÂ§ÑÁêÜ‰∏≠ÔºåËØ∑Á®çÂêéÊü•Áúã...\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊ®°ÊãüÂÆåÊàêÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.warning} Ê∏≤ÊüìÂÆåÊàê‰ø°ÊÅØÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderScheduleList(tasks) {
    try {
      if (!tasks || tasks.length === 0) {
        return `${CONFIG.EMOJI.calendar} <b>ÂÆöÊó∂‰ªªÂä°ÂàóË°®</b>\n\nÊöÇÊó†ÂÆöÊó∂‰ªªÂä°„ÄÇ`;
      }
      
      let message = `${CONFIG.EMOJI.calendar} <b>ÂÆöÊó∂‰ªªÂä°ÂàóË°®</b>\n\n`;
      
      tasks.forEach((task, index) => {
        const status = task.enabled ? "‚úÖ" : "‚ùå";
        const taskType = task.task_type || "Êú™Áü•";
        const nextRun = task.next_run ? new Date(task.next_run).toLocaleString('zh-CN') : "Êú™ËÆæÁΩÆ";
        const lastRun = task.last_run ? new Date(task.last_run).toLocaleString('zh-CN') : "‰ªéÊú™ËøêË°å";
        const scheduleDesc = task.schedule ? Formatter.formatCronDescription(task.schedule) : "Êú™Áü•";
        
        message += `<b>${index + 1}. ${task.name}</b> ${status}\n`;
        message += `Á±ªÂûã: ${taskType}\n`;
        message += `ÂÆöÊó∂: ${scheduleDesc}\n`;
        message += `‰∏ãÊ¨°ËøêË°å: ${nextRun}\n`;
        message += `‰∏äÊ¨°ËøêË°å: ${lastRun}\n`;
        message += `ËøêË°åÊ¨°Êï∞: ${task.run_count || 0}\n`;
        message += `ID: ${task.id}\n`;
        
        if (task.params) {
          try {
            const params = JSON.parse(task.params);
            if (Object.keys(params).length > 0) {
              message += `ÂèÇÊï∞: ${JSON.stringify(params)}\n`;
            }
          } catch (e) {
            // ÂøΩÁï•ÂèÇÊï∞Ëß£ÊûêÈîôËØØ
          }
        }
        
        message += `\n`;
      });
      
      message += `‰ΩøÁî® <code>/schedule remove [ID]</code> Âà†Èô§‰ªªÂä°\n`;
      message += `‰ΩøÁî® <code>/schedule add [Á±ªÂûã] [Êó∂Èó¥] [ÂèÇÊï∞]</code> Ê∑ªÂä†Êñ∞‰ªªÂä°\n`;
      message += `\n<b>Êó∂Èó¥Ê†ºÂºèÁ§∫‰æãÔºö</b>\n`;
      message += `‚Ä¢ ÊØèÊó•Êó∂Èó¥: "09:00"\n`;
      message += `‚Ä¢ CronË°®ËææÂºè: "0 9 * * *" (ÊØèÂ§©9ÁÇπ)\n`;
      message += `‚Ä¢ ÂÖ∑‰ΩìÊó∂Èó¥: "2024-01-01 09:00"\n`;
      message += `‚Ä¢ ÊòéÂ§©Êó∂Èó¥: "tomorrow 09:00"\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂÆöÊó∂‰ªªÂä°ÂàóË°®Â§±Ë¥•", error);
      return `${CONFIG.EMOJI.calendar} <b>ÂÆöÊó∂‰ªªÂä°ÂàóË°®</b>\n\nËé∑ÂèñÂÆöÊó∂‰ªªÂä°ÂàóË°®Â§±Ë¥•„ÄÇ`;
    }
  }

  static renderScheduleAddResult(result, taskType, schedule, params) {
    try {
      if (!result.success) {
        return `${CONFIG.EMOJI.warning} <b>Ê∑ªÂä†ÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ: ${result.error || "Êú™Áü•ÈîôËØØ"}`;
      }
      
      let message = `${CONFIG.EMOJI.check} <b>ÂÆöÊó∂‰ªªÂä°Ê∑ªÂä†ÊàêÂäü</b>\n\n`;
      message += `‰ªªÂä°ÂêçÁß∞: ${result.name}\n`;
      message += `‰ªªÂä°Á±ªÂûã: ${taskType}\n`;
      message += `ÂÆöÊó∂ËÆæÁΩÆ: ${schedule}\n`;
      message += `Êó∂Èó¥ÊèèËø∞: ${Formatter.formatCronDescription(schedule)}\n`;
      
      if (params && params.trim() !== '') {
        try {
          const paramsObj = JSON.parse(params);
          if (Object.keys(paramsObj).length > 0) {
            message += `‰ªªÂä°ÂèÇÊï∞: ${params}\n`;
          }
        } catch (e) {
          message += `‰ªªÂä°ÂèÇÊï∞: ${params}\n`;
        }
      }
      
      const nextRun = result.nextRun ? new Date(result.nextRun).toLocaleString('zh-CN') : "Êú™Áü•";
      message += `‰∏ãÊ¨°ËøêË°å: ${nextRun}\n`;
      message += `‰ªªÂä°ID: ${result.id}\n\n`;
      
      message += `‰ªªÂä°Â∞ÜËá™Âä®Âú®ÊåáÂÆöÊó∂Èó¥ÊâßË°å„ÄÇ\n`;
      message += `‰ΩøÁî® <code>/schedule list</code> Êü•ÁúãÊâÄÊúâ‰ªªÂä°„ÄÇ`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊ∑ªÂä†ÂÆöÊó∂‰ªªÂä°ÁªìÊûúÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.check} <b>ÂÆöÊó∂‰ªªÂä°Ê∑ªÂä†ÊàêÂäü</b>\n\n‰ΩÜÊó†Ê≥ïÊòæÁ§∫ËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ`;
    }
  }

  static renderScheduleRemoveResult(result, taskId) {
    try {
      if (!result.success) {
        return `${CONFIG.EMOJI.warning} <b>Âà†Èô§ÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ: ${result.error || "Êú™Áü•ÈîôËØØ"}`;
      }
      
      let message = `${CONFIG.EMOJI.trash} <b>ÂÆöÊó∂‰ªªÂä°Âà†Èô§ÊàêÂäü</b>\n\n`;
      message += `‰ªªÂä°ID: ${taskId}\n`;
      message += `Âà†Èô§Êï∞Èáè: ${result.deleted || 0} ‰∏™\n\n`;
      message += `‰ΩøÁî® <code>/schedule list</code> Êü•ÁúãÂâ©‰Ωô‰ªªÂä°„ÄÇ`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂà†Èô§ÂÆöÊó∂‰ªªÂä°ÁªìÊûúÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.trash} <b>ÂÆöÊó∂‰ªªÂä°Âà†Èô§ÊàêÂäü</b>\n\n‰ΩÜÊó†Ê≥ïÊòæÁ§∫ËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ`;
    }
  }

  static renderScheduleTestResult(result, taskType) {
    try {
      if (!result.success) {
        return `${CONFIG.EMOJI.warning} <b>ÊµãËØïÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ: ${result.error || "Êú™Áü•ÈîôËØØ"}`;
      }
      
      let message = `${CONFIG.EMOJI.check} <b>ÂÆöÊó∂‰ªªÂä°ÊµãËØïÊàêÂäü</b>\n\n`;
      message += `‰ªªÂä°Á±ªÂûã: ${taskType}\n`;
      message += `ÊâßË°åÁªìÊûú: ${result.message || "ÊàêÂäü"}\n`;
      
      if (result.data) {
        message += `\n<b>ÊâßË°åËØ¶ÊÉÖ:</b>\n`;
        for (const [key, value] of Object.entries(result.data)) {
          message += `${key}: ${value}\n`;
        }
      }
      
      message += `\nÊµãËØïÂÆåÊàêÔºå‰ªªÂä°ÂèØ‰ª•Ê≠£Â∏∏ÊâßË°å„ÄÇ`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊµãËØïÂÆöÊó∂‰ªªÂä°ÁªìÊûúÂ§±Ë¥•", error);
      return `${CONFIG.EMOJI.check} <b>ÂÆöÊó∂‰ªªÂä°ÊµãËØïÊàêÂäü</b>\n\n‰ΩÜÊó†Ê≥ïÊòæÁ§∫ËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.database} ÂéÜÂè≤ÂºÄÂ•ñËÆ∞ÂΩï</b>\n`;
      message += `Á¨¨ ${page}/${totalPages} È°µ | ÂÖ± ${totalRecords} Êúü\n`;
      message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "ÊöÇÊó†ÂºÄÂ•ñËÆ∞ÂΩï\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `Á¨¨ <b>${r.expect}</b> Êúü: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      message += `\n‰ΩøÁî® <code>/history ${page + 1}</code> Êü•Áúã‰∏ã‰∏ÄÈ°µ`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>ÂÜçÊ¨°ÂèëÈÄÅ /history Â∞ÜÂà†Èô§Ê≠§Ê∂àÊÅØÂπ∂ÂàõÂª∫Êñ∞Ê∂àÊÅØ</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂéÜÂè≤ËÆ∞ÂΩïÊó∂Âá∫Èîô", error);
      return `${CONFIG.EMOJI.warning} Ëé∑ÂèñÂéÜÂè≤ËÆ∞ÂΩïÊó∂ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.database} <b>Êï∞ÊçÆÂêåÊ≠•ÁªìÊûú</b>\n\n`;
      
      if (result?.success) {
        message += `‚úÖ <b>ÂêåÊ≠•ÊàêÂäü</b>\n`;
        message += `Êï∞ÊçÆÊ∫êÊÄªÊï∞: ${result.total || 0} Êù°\n`;
        message += `ÊàêÂäüÊñ∞Â¢û: ${result.added || 0} Êù°\n`;
        message += `Ë∑≥ËøáÈáçÂ§ç: ${result.skipped || 0} Êù°\n`;
        
        if (result.newCount > 0) {
          message += `\nüìù <b>ÂèëÁé∞ ${result.newCount} Êù°Êñ∞ÂºÄÂ•ñËÆ∞ÂΩï</b>\n`;
        }
      } else {
        message += `‚ùå <b>ÂêåÊ≠•Â§±Ë¥•</b>\n`;
        message += `ÈîôËØØ‰ø°ÊÅØ: ${result?.error || 'Êú™Áü•ÈîôËØØ'}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>ÂÜçÊ¨°ÂèëÈÄÅ /sync Â∞ÜÂà†Èô§Ê≠§Ê∂àÊÅØÂπ∂ÂàõÂª∫Êñ∞Ê∂àÊÅØ</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂêåÊ≠•ÁªìÊûúÊó∂Âá∫Èîô", error);
      return `${CONFIG.EMOJI.warning} Â§ÑÁêÜÂêåÊ≠•ÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderPushResult(success, prediction, channelPushSuccess = false) {
    try {
      let message = `${CONFIG.EMOJI.fire} <b>È¢ÑÊµãÊé®ÈÄÅÁªìÊûú</b>\n\n`;
      
      if (success) {
        message += `‚úÖ <b>Êé®ÈÄÅÊàêÂäü</b>\n`;
        message += `ÊúüÂè∑: ${prediction?.nextExpect || "Êú™Áü•"}\n`;
        message += `ÁΩÆ‰ø°Â∫¶: ${prediction?.confidence || 0}%\n`;
        
        if (channelPushSuccess) {
          message += `È¢ëÈÅìÊé®ÈÄÅ: ÊàêÂäü ‚úÖ\n`;
        } else {
          message += `È¢ëÈÅìÊé®ÈÄÅ: Â§±Ë¥• ‚ùå\n`;
        }
      } else {
        message += `‚ùå <b>Êé®ÈÄÅÂ§±Ë¥•</b>\n`;
        message += `ËØ∑Ê£ÄÊü•Á≥ªÁªüÁä∂ÊÄÅÂíåÈÖçÁΩÆ\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>ÂÜçÊ¨°ÂèëÈÄÅ /push Â∞ÜÂà†Èô§Ê≠§Ê∂àÊÅØÂπ∂ÂàõÂª∫Êñ∞Ê∂àÊÅØ</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊé®ÈÄÅÁªìÊûúÊó∂Âá∫Èîô", error);
      return `${CONFIG.EMOJI.warning} Â§ÑÁêÜÊé®ÈÄÅÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderDeleteConfirmation(expectRange, impactInfo) {
    try {
      const { toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `${CONFIG.EMOJI.warning} <b>Âà†Èô§Á°ÆËÆ§</b>\n\n`;
      
      if (expectRange.includes('-')) {
        const [start, end] = expectRange.split('-');
        message += `ÊÇ®Âç≥Â∞ÜÂà†Èô§Á¨¨ <b>${Formatter.safeString(start)}</b> ÊúüÂà∞Á¨¨ <b>${Formatter.safeString(end)}</b> ÊúüÁöÑËÆ∞ÂΩï\n`;
      } else {
        message += `ÊÇ®Âç≥Â∞ÜÂà†Èô§Á¨¨ <b>${Formatter.safeString(expectRange)}</b> ÊúüÁöÑËÆ∞ÂΩï\n`;
      }
      
      message += `Ê∂âÂèä <b>${toDeleteCount || 0}</b> Êù°ÂéÜÂè≤ËÆ∞ÂΩï\n\n`;
      
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        message += `Âà†Èô§ÂêéÔºåÊúÄÊñ∞ËÆ∞ÂΩï‰∏∫:\n`;
        message += `Á¨¨ <b>${latestAfterDelete.expect || "Êú™Áü•"}</b> Êúü | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
      } else {
        message += `Âà†Èô§ÂêéÂ∞ÜÊó†ÂéÜÂè≤ËÆ∞ÂΩï\n`;
      }
      
      message += `\n${CONFIG.EMOJI.warning} <b>Ë≠¶ÂëäÔºöÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§çÔºÅ</b>\n\n`;
      message += `ËØ∑ÂõûÂ§ç <code>Á°ÆËÆ§Âà†Èô§ ${Formatter.safeString(expectRange)}</code> ‰ª•Á°ÆËÆ§Âà†Èô§„ÄÇ`;
      
      message += `\n\n${CONFIG.EMOJI.refresh} <i>ÂÜçÊ¨°ÂèëÈÄÅ /delete Â∞ÜÂà†Èô§Ê≠§Ê∂àÊÅØÂπ∂ÂàõÂª∫Êñ∞Á°ÆËÆ§</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂà†Èô§Á°ÆËÆ§Â§±Ë¥•", error);
      return `${CONFIG.EMOJI.warning} <b>Âà†Èô§Á°ÆËÆ§Â§±Ë¥•</b>\n\nÊó†Ê≥ïÁîüÊàêÁ°ÆËÆ§‰ø°ÊÅØÔºåËØ∑ÈáçËØï„ÄÇ`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `${CONFIG.EMOJI.trash} <b>Âà†Èô§Êìç‰ΩúÁªìÊûú</b>\n\n`;
      
      if (result?.success) {
        message += `‚úÖ <b>Âà†Èô§ÊàêÂäü</b>\n`;
        message += `Âà†Èô§ËåÉÂõ¥: ${Formatter.safeString(expectRange)}\n`;
        message += `Âà†Èô§ËÆ∞ÂΩïÊï∞: ${result.deleted || 0} Êù°\n`;
        
        if (result.total !== undefined) {
          message += `ËåÉÂõ¥ÂÜÖËÆ∞ÂΩïÊï∞: ${result.total} Êù°\n`;
        }
        
        // ÊòæÁ§∫Âà†Èô§ÂêéÁöÑÊúÄÊñ∞ËÆ∞ÂΩï
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          message += `\n${CONFIG.EMOJI.check} <b>Âà†Èô§ÂêéÊúÄÊñ∞ËÆ∞ÂΩï</b>\n`;
          message += `Á¨¨ ${latestAfterDelete.expect} Êúü | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `‚ùå <b>Âà†Èô§Â§±Ë¥•</b>\n`;
        message += `ÈîôËØØ‰ø°ÊÅØ: ${result?.error || 'Êú™Áü•ÈîôËØØ'}\n`;
      }
      
      message += `\nÊìç‰ΩúÊó∂Èó¥: ${Formatter.formatDateTime()}`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>ÂÜçÊ¨°ÂèëÈÄÅ /delete Â∞ÜÂà†Èô§Ê≠§Ê∂àÊÅØÂπ∂ÂàõÂª∫Êñ∞Á°ÆËÆ§</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂà†Èô§ÁªìÊûúÊó∂Âá∫Èîô", error);
      return `${CONFIG.EMOJI.trash} <b>Âà†Èô§Êìç‰ΩúÁªìÊûú</b>\n\nÂ§ÑÁêÜÂà†Èô§ÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }
}

// ==============================================================================
// 11. Â§ñÈÉ®Êé•Âè£Â∞ÅË£Ö
// ==============================================================================

class ExternalService {
  static async sendMessage(env, chatId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN Êú™ÈÖçÁΩÆ");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  static async editMessage(env, chatId, messageId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN Êú™ÈÖçÁΩÆ");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  static async deleteMessage(env, chatId, messageId) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN Êú™ÈÖçÁΩÆ");
        return null;
      }
      
      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage?chat_id=${chatId}&message_id=${messageId}`;

      const response = await fetch(url, {
        method: "POST"
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.warn("Telegram", `deleteMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "deleteMessage network error", error);
      return null;
    }
  }

  static async sendAndDeleteOldMessage(env, chatId, messageType, text) {
    try {
      const oldMessageId = MessageManager.getUserMessage(chatId, messageType);
      
      if (oldMessageId) {
        this.deleteMessage(env, chatId, oldMessageId).then(result => {
          if (result && result.ok) {
            Logger.info("Telegram", `Âà†Èô§ÊóßÊ∂àÊÅØÊàêÂäü: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          } else {
            Logger.warn("Telegram", `Âà†Èô§ÊóßÊ∂àÊÅØÂ§±Ë¥•ÊàñÊ∂àÊÅØÂ∑≤‰∏çÂ≠òÂú®: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          }
        }).catch(error => {
          Logger.error("Telegram", `Âà†Èô§ÊóßÊ∂àÊÅØÂºÇÂ∏∏: chatId=${chatId}, type=${messageType}`, error);
        });
      }
      
      const sendResult = await this.sendMessage(env, chatId, text);
      
      if (sendResult && sendResult.ok && sendResult.result) {
        const newMessageId = sendResult.result.message_id;
        
        MessageManager.setUserMessage(chatId, messageType, newMessageId);
        
        MessageManager.cleanupOldMessages(chatId, 10);
        
        Logger.info("Telegram", `ÂèëÈÄÅÊñ∞Ê∂àÊÅØÊàêÂäü: chatId=${chatId}, type=${messageType}, messageId=${newMessageId}, ÊóßÊ∂àÊÅØID=${oldMessageId || 'Êó†'}`);
        
        return { 
          success: true, 
          messageId: newMessageId, 
          oldMessageId: oldMessageId,
          message: oldMessageId ? "Â∑≤Âà†Èô§ÊóßÊ∂àÊÅØÂπ∂ÂèëÈÄÅÊñ∞Ê∂àÊÅØ" : "ÂèëÈÄÅÊñ∞Ê∂àÊÅØ"
        };
      }
      
      return { 
        success: false, 
        error: "Ê∂àÊÅØÂèëÈÄÅÂ§±Ë¥•",
        oldMessageId: oldMessageId
      };
    } catch (error) {
      Logger.error("Telegram", "sendAndDeleteOldMessageÂ§±Ë¥•", error);
      return { 
        success: false, 
        error: error.message,
        method: "error"
      };
    }
  }

  static async sendTemporaryMessage(env, chatId, text, parseMode = "HTML") {
    return await this.sendMessage(env, chatId, text, parseMode);
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'Êú™ÈÖçÁΩÆ LOTTERY_DATA_URL ÁéØÂ¢ÉÂèòÈáè' };
    }

    try {
      Logger.info("Sync", `ÂºÄÂßã‰ªé ${env.LOTTERY_DATA_URL} ÂêåÊ≠•Êï∞ÊçÆ`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/11.1',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('ÂìçÂ∫î‰∏çÊòØÊúâÊïàÁöÑJSONÊ†ºÂºè');
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('‰∏çÊîØÊåÅÁöÑJSONÊ†ºÂºè');
      }

      if (records.length === 0) {
        return { success: false, error: 'Êú™Ëß£ÊûêÂà∞ÊúâÊïàÂºÄÂ•ñËÆ∞ÂΩï' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `Êï∞ÊçÆÂ∫ìÊúÄÊñ∞ÊúüÂè∑: ${latestInDB}, ÂèëÁé∞ ${newRecords.length} Êù°Êñ∞ËÆ∞ÂΩï`);
      } else {
        newRecords = records;
        Logger.info("Sync", `Êï∞ÊçÆÂ∫ì‰∏∫Á©∫ÔºåÊâÄÊúâ ${records.length} Êù°ËÆ∞ÂΩïÈÉΩÊòØÊñ∞ÁöÑ`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'Ê≤°ÊúâÂèëÁé∞Êñ∞ËÆ∞ÂΩïÔºåÊï∞ÊçÆÂ∑≤ÊòØÊúÄÊñ∞' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
        
        // Ê∏ÖÈô§ÁºìÂ≠ò
        CacheManager.clear();
        AdvancedStatsEngine.clearCache();
        AdvancedPredictionEngine.clearCache();
        EnhancedMonteCarloEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "ÂêåÊ≠•ÂéÜÂè≤Êï∞ÊçÆÂ§±Ë¥•", error);
      return { 
        success: false, 
        error: error.message || 'Êú™Áü•ÈîôËØØ'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `Ëß£ÊûêËÆ∞ÂΩïÂ§±Ë¥•`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `Ëß£ÊûêËÆ∞ÂΩïÂ§±Ë¥•`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 12. ‰∏öÂä°ÈÄªËæëÊéßÂà∂Âô®Ôºà‰øÆÂ§çÂÆöÊó∂‰ªªÂä°ÂíåËíôÁâπÂç°Ê¥õÈóÆÈ¢òÔºâ
// ==============================================================================

class Controller {
  static pendingDeletions = new Map();

  // Â§ÑÁêÜÂºÄÂßãÂëΩ‰ª§
  static async handleStart(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜstartÂëΩ‰ª§Â§±Ë¥•", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "‚ùå <b>Á≥ªÁªüÈîôËØØ</b>\n\nÊó†Ê≥ïÊòæÁ§∫Ê¨¢Ëøé‰ø°ÊÅØÔºåËØ∑ÈáçËØï„ÄÇ"
      );
    }
  }

  // Â§ÑÁêÜÂëΩ‰ª§Ê®°Êùø
  static async handleCommandTemplate(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜcccÂëΩ‰ª§Â§±Ë¥•", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "‚ùå <b>Á≥ªÁªüÈîôËØØ</b>\n\nÊó†Ê≥ïÊòæÁ§∫ÂëΩ‰ª§Ê®°ÊùøÔºåËØ∑ÈáçËØï„ÄÇ"
      );
    }
  }

  // Â§ÑÁêÜÁªüËÆ°
  static async handleStats(env, chatId) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const lastSync = await DB.getSetting(env, "LAST_SYNC", "");
      const deletionStats = await DB.getDeletionStats(env);
      const monteStats = await DB.getMonteCarloStats(env);
      
      const scheduleTasks = await DB.getScheduleTasks(env, false);
      const pendingTasks = await DB.getPendingScheduleTasks(env);
      
      const scheduleStats = {
        total: scheduleTasks.length,
        enabled: scheduleTasks.filter(t => t.enabled).length,
        pending: pendingTasks.length
      };
      
      const cacheStats = CacheManager.getStats();
      
      const message = MessageRenderer.renderStats(
        historyCount, 
        lastSync, 
        deletionStats, 
        monteStats, 
        scheduleStats,
        cacheStats
      );
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATS, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜstatsÂëΩ‰ª§Â§±Ë¥•", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "‚ùå <b>Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØÂ§±Ë¥•</b>\n\nËØ∑Á®çÂêéÈáçËØï„ÄÇ"
      );
    }
  }

  // Â§ÑÁêÜÈ¢ÑÊµã
  static async handlePredict(env, chatId, useMonteCarlo = false) {
    try {
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "‚ùå <b>Êó†ÂéÜÂè≤Êï∞ÊçÆ</b>\n\nÊó†Ê≥ïÁîüÊàêÈ¢ÑÊµã„ÄÇËØ∑ÂÖà‰ΩøÁî® /sync ÂëΩ‰ª§ÂêåÊ≠•Êï∞ÊçÆ„ÄÇ";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await AdvancedPredictionEngine.generate(env, history, weights, useMonteCarlo);
      
      const message = MessageRenderer.renderPrediction(prediction);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜpredictÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>ÁîüÊàêÈ¢ÑÊµãÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // Â§ÑÁêÜÂ¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü
  static async handleMonteCarlo(env, chatId, commandText) {
    try {
      const parts = commandText.trim().split(/\s+/);
      
      // Ëß£ÊûêÂèÇÊï∞
      let mode = "sync"; // ÂêåÊ≠•Ê®°Âºè
      let simulations = null;
      
      if (parts.length > 1) {
        const secondArg = parts[1].toLowerCase();
        
        if (secondArg === "async") {
          mode = "async";
          if (parts.length > 2) {
            const simCount = Formatter.safeInt(parts[2], 0);
            if (simCount >= CONFIG.SYSTEM.MIN_SIMULATIONS && simCount <= CONFIG.SYSTEM.MAX_SIMULATIONS) {
              simulations = simCount;
            }
          }
        } else if (secondArg === "progress") {
          mode = "progress";
        } else if (secondArg === "complete") {
          mode = "complete";
        } else {
          // ÈªòËÆ§‰∏∫ÂêåÊ≠•Ê®°ÂºèÔºåÁ¨¨‰∫å‰∏™ÂèÇÊï∞ÊòØÊ®°ÊãüÊ¨°Êï∞
          const simCount = Formatter.safeInt(parts[1], 0);
          if (simCount >= CONFIG.SYSTEM.MIN_SIMULATIONS && simCount <= CONFIG.SYSTEM.MAX_SIMULATIONS) {
            simulations = simCount;
          }
        }
      }
      
      // Ê†πÊçÆÊ®°ÂºèÂ§ÑÁêÜ
      if (mode === "async") {
        await this.handleMonteCarloAsync(env, chatId, simulations, parts);
      } else if (mode === "progress") {
        await this.handleMonteCarloProgress(env, chatId, parts);
      } else if (mode === "complete") {
        await this.handleMonteCarloComplete(env, chatId, parts);
      } else {
        await this.handleMonteCarloSync(env, chatId, simulations);
      }
      
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜËíôÁâπÂç°Ê¥õÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  // ÂêåÊ≠•ËíôÁâπÂç°Ê¥õÊ®°Êãü
  static async handleMonteCarloSync(env, chatId, simulations) {
    try {
      // ÂèëÈÄÅÂ§ÑÁêÜ‰∏≠Ê∂àÊÅØ
      const processingMessage = `${CONFIG.EMOJI.hourglass} <b>Ê≠£Âú®ËøêË°åÂ¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü...</b>\n\nÊ®°ÊãüÊ¨°Êï∞: ${simulations || CONFIG.SYSTEM.MONTECARLO_SIMULATIONS}\nÊ†∑Êú¨Á±ªÂûã: ÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩï\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      // ËøêË°åÂ¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü
      const result = await EnhancedMonteCarloEngine.runSimulation(env, simulations, "full_history");
      
      // Ê∏≤ÊüìÁªìÊûú
      const message = MessageRenderer.renderMonteCarloResult(result);
      
      // Êõ¥Êñ∞‰∏∫ÊúÄÁªàÁªìÊûú
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO, message
      );
      
    } catch (error) {
      Logger.error("Controller", "ÂêåÊ≠•ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•", error);
      const errorMessage = `‚ùå <b>ÂêåÊ≠•ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  // ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°Êãü
  static async handleMonteCarloAsync(env, chatId, simulations, parts) {
    try {
      // Ëß£ÊûêÂèØËÉΩÁöÑ‰ºöËØùID
      let sessionId = null;
      if (parts.length > 3 && parts[3]) {
        sessionId = parts[3];
      }
      
      if (sessionId && parts.length > 4 && parts[4] === "batch") {
        // Â§ÑÁêÜÊâπÊ¨°
        const batchResult = await EnhancedMonteCarloEngine.processBatch(env, sessionId);
        
        if (batchResult.success) {
          const message = `${CONFIG.EMOJI.progress} <b>ÊâπÊ¨°Â§ÑÁêÜÂÆåÊàê</b>\n\nÊâπÊ¨°: ${batchResult.batch}/${batchResult.totalBatches}\nËøõÂ∫¶: ${batchResult.progress}%\nËÄóÊó∂: ${batchResult.duration}ms`;
          
          await ExternalService.sendAndDeleteOldMessage(
            env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, message
          );
        } else {
          const errorMessage = `‚ùå <b>ÊâπÊ¨°Â§ÑÁêÜÂ§±Ë¥•</b>\n\nÈîôËØØ: ${batchResult.error}`;
          await ExternalService.sendAndDeleteOldMessage(
            env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, errorMessage
          );
        }
        
        return;
      }
      
      // ÂêØÂä®Êñ∞ÁöÑÂºÇÊ≠•Ê®°Êãü
      const result = await EnhancedMonteCarloEngine.runAsyncSimulation(env, chatId, simulations);
      
      const message = MessageRenderer.renderMonteCarloAsyncStart(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, message
      );
      
    } catch (error) {
      Logger.error("Controller", "ÂêØÂä®ÂºÇÊ≠•ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•", error);
      const errorMessage = `‚ùå <b>ÂêØÂä®ÂºÇÊ≠•Ê®°ÊãüÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  // Êü•ÁúãËíôÁâπÂç°Ê¥õËøõÂ∫¶
  static async handleMonteCarloProgress(env, chatId, parts) {
    try {
      if (parts.length < 3) {
        const message = `‚ùå <b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®: <code>/monte progress [‰ºöËØùID]</code>\n\n‰ΩøÁî® <code>/monte async</code> ÂêØÂä®ÂºÇÊ≠•Ê®°ÊãüËé∑Âèñ‰ºöËØùID`;
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, message
        );
        return;
      }
      
      const sessionId = parts[2];
      const progress = await EnhancedMonteCarloEngine.getSessionProgress(env, sessionId, chatId);
      
      const message = MessageRenderer.renderMonteCarloProgress(progress);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, message
      );
      
    } catch (error) {
      Logger.error("Controller", "Êü•ÁúãËíôÁâπÂç°Ê¥õËøõÂ∫¶Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Êü•ÁúãËøõÂ∫¶Â§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  // ÂÆåÊàêËíôÁâπÂç°Ê¥õÊ®°Êãü
  static async handleMonteCarloComplete(env, chatId, parts) {
    try {
      if (parts.length < 3) {
        const message = `‚ùå <b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®: <code>/monte complete [‰ºöËØùID]</code>`;
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, message
        );
        return;
      }
      
      const sessionId = parts[2];
      
      // ÂèëÈÄÅÂ§ÑÁêÜ‰∏≠Ê∂àÊÅØ
      const processingMessage = `${CONFIG.EMOJI.hourglass} <b>Ê≠£Âú®ÂÆåÊàêËíôÁâπÂç°Ê¥õÊ®°Êãü...</b>\n\n‰ºöËØùID: ${sessionId}\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      // ÂÆåÊàêÊ®°Êãü
      const result = await EnhancedMonteCarloEngine.completeAsyncSimulation(env, sessionId);
      
      const message = MessageRenderer.renderMonteCarloComplete(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, message
      );
      
    } catch (error) {
      Logger.error("Controller", "ÂÆåÊàêËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•", error);
      const errorMessage = `‚ùå <b>ÂÆåÊàêÊ®°ÊãüÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.MONTECARLO_PROGRESS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // Â§ÑÁêÜÂéÜÂè≤ËÆ∞ÂΩï
  static async handleHistory(env, chatId, pageStr = "1") {
    try {
      const page = Math.max(1, Formatter.safeInt(pageStr, 1));
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜhistoryÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = "‚ùå <b>Ëé∑ÂèñÂéÜÂè≤ËÆ∞ÂΩïÂ§±Ë¥•</b>\n\nËØ∑Á®çÂêéÈáçËØï„ÄÇ";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // Â§ÑÁêÜÂêåÊ≠•
  static async handleSync(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•ÂêåÊ≠•Êï∞ÊçÆ„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.database} <b>Ê≠£Âú®ÂêåÊ≠•ÂéÜÂè≤Êï∞ÊçÆ...</b>\n\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      const message = MessageRenderer.renderSyncResult(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
    } catch (error) {
      Logger.error("Sync", "ÂêåÊ≠•Â§ÑÁêÜÂ§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Êï∞ÊçÆÂêåÊ≠•ÂºÇÂ∏∏</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // Â§ÑÁêÜÊé®ÈÄÅ
  static async handlePush(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Êé®ÈÄÅÈ¢ÑÊµã„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    if (!env.TG_CHANNEL_ID) {
      const message = "‚ùå <b>È¢ëÈÅìIDÊú™ÈÖçÁΩÆ</b>\n\nÊó†Ê≥ïÊé®ÈÄÅÂà∞È¢ëÈÅì„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.fire} <b>Ê≠£Âú®ÁîüÊàêÂπ∂Êé®ÈÄÅÈ¢ÑÊµã...</b>\n\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "‚ùå <b>Êó†ÂéÜÂè≤Êï∞ÊçÆ</b>\n\nÊó†Ê≥ïÁîüÊàêÊé®ÈÄÅ„ÄÇ";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await AdvancedPredictionEngine.generate(env, history, weights, true);
      
      let channelPushSuccess = false;
      try {
        const channelMessage = MessageRenderer.renderPrediction(prediction);
        await ExternalService.sendTemporaryMessage(env, env.TG_CHANNEL_ID, channelMessage);
        channelPushSuccess = true;
        Logger.info("Push", `È¢ÑÊµãÂ∑≤Êé®ÈÄÅÂà∞È¢ëÈÅì: ${env.TG_CHANNEL_ID}, ÊúüÂè∑: ${prediction.nextExpect}`);
      } catch (error) {
        Logger.error("Push", "Êé®ÈÄÅÂà∞È¢ëÈÅìÂ§±Ë¥•", error);
        channelPushSuccess = false;
      }
      
      const message = MessageRenderer.renderPushResult(true, prediction, channelPushSuccess);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
    } catch (error) {
      Logger.error("Push", "Êé®ÈÄÅÂ§ÑÁêÜÂ§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Êé®ÈÄÅÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // Â§ÑÁêÜÂà†Èô§
  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Âà†Èô§ËÆ∞ÂΩï„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        const message = `‚ùå <b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºèÔºö\n<code>/delete 2025001</code> ÔºàÂà†Èô§Âçï‰∏™ÊúüÂè∑Ôºâ\n<code>/delete 2025001-2025010</code> ÔºàÂà†Èô§ÊúüÂè∑ËåÉÂõ¥Ôºâ`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        const message = "‚ùå <b>ÊúüÂè∑Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®Ê≠£Á°ÆÊ†ºÂºèÔºö\n<code>/delete 2025001</code> Êàñ <code>/delete 2025001-2025010</code>";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        const message = `‚ö†Ô∏è <b>Êú™ÊâæÂà∞ËÆ∞ÂΩï</b>\n\nÂú® ${expectRange} ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊâæÂà∞‰ªª‰ΩïÂéÜÂè≤ËÆ∞ÂΩï„ÄÇ`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, confirmMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, confirmMessage);
      }
      
    } catch (error) {
      Logger.error("Delete", "Â§ÑÁêÜÂà†Èô§ÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Â§ÑÁêÜÂà†Èô§ÂëΩ‰ª§Â§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // Á°ÆËÆ§Âà†Èô§
  static async confirmDelete(env, chatId, userId, confirmText) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const pendingDeletion = this.pendingDeletions.get(deletionKey);
      
      if (!pendingDeletion) {
        const message = "‚ùå <b>Âà†Èô§Êìç‰ΩúÂ∑≤ËøáÊúüÊàñÊó†Êïà</b>\n\nËØ∑ÈáçÊñ∞ÂèëËµ∑Âà†Èô§ÂëΩ‰ª§„ÄÇ";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectedConfirm = `Á°ÆËÆ§Âà†Èô§ ${pendingDeletion.expectRange}`;
      if (confirmText !== expectedConfirm) {
        const message = `‚ùå <b>Á°ÆËÆ§ÊñáÊú¨‰∏çÊ≠£Á°Æ</b>\n\nËØ∑ÂõûÂ§ç: <code>${expectedConfirm}</code>`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      this.pendingDeletions.delete(deletionKey);
      
      const processingMessage = `${CONFIG.EMOJI.trash} <b>Ê≠£Âú®Âà†Èô§ËÆ∞ÂΩï...</b>\n\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await DB.deleteHistoryByRange(
        env, 
        pendingDeletion.start, 
        pendingDeletion.end,
        Formatter.safeString(userId),
        "ÊâãÂä®Âà†Èô§"
      );
      
      if (!result.success) {
        const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange);
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        return;
      }
      
      CacheManager.clear();
      AdvancedStatsEngine.clearCache();
      AdvancedPredictionEngine.clearCache();
      EnhancedMonteCarloEngine.clearCache();
      
      const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange, pendingDeletion.impactInfo);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      Logger.info("Delete", `Âà†Èô§Êìç‰ΩúÂÆåÊàê: ${pendingDeletion.expectRange}, Âà†Èô§ËÆ∞ÂΩïÊï∞: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "Á°ÆËÆ§Âà†Èô§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Âà†Èô§Êìç‰ΩúÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // ============== ÂÆöÊó∂‰ªªÂä°Áõ∏ÂÖ≥Â§ÑÁêÜÊñπÊ≥ïÔºà‰øÆÂ§çÔºâ ==============
  
  static async handleScheduleList(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Êü•ÁúãÂÆöÊó∂‰ªªÂä°„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_LIST, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const tasks = await DB.getScheduleTasks(env, false);
      const message = MessageRenderer.renderScheduleList(tasks);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_LIST, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜschedule listÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = "‚ùå <b>Ëé∑ÂèñÂÆöÊó∂‰ªªÂä°ÂàóË°®Â§±Ë¥•</b>\n\nËØ∑Á®çÂêéÈáçËØï„ÄÇ";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_LIST, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  static async handleScheduleAdd(env, chatId, isAdmin, commandText) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Ê∑ªÂä†ÂÆöÊó∂‰ªªÂä°„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      
      if (parts.length < 4) {
        const message = `‚ùå <b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºèÔºö\n<code>/schedule add [Á±ªÂûã] [Êó∂Èó¥] [ÂèÇÊï∞(ÂèØÈÄâ)]</code>\n\nÂèØÁî®Á±ªÂûã: sync, predict, push, cleanup, monte\nÊó∂Èó¥Ê†ºÂºè: "HH:MM", "YYYY-MM-DD HH:MM", cronË°®ËææÂºè\nÁ§∫‰æã:\n<code>/schedule add sync "0 9 * * *"</code>\n<code>/schedule add push "18:00" '{"useMonteCarlo": true}'</code>\n<code>/schedule add sync "tomorrow 09:00"</code>`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const taskType = parts[2].toLowerCase();
      
      // ÊèêÂèñÊó∂Èó¥ÈÉ®ÂàÜÔºàÂèØËÉΩÂåÖÂê´Á©∫Ê†ºÔºâ
      let timeStartIndex = commandText.indexOf(parts[2]) + parts[2].length + 1;
      let scheduleEndIndex = commandText.length;
      let paramsStartIndex = -1;
      
      // Êü•ÊâæÂèÇÊï∞ÂºÄÂßã‰ΩçÁΩÆÔºàÂ¶ÇÊûúÊúâÔºâ
      for (let i = timeStartIndex; i < commandText.length; i++) {
        if (commandText[i] === '{') {
          scheduleEndIndex = i;
          paramsStartIndex = i;
          break;
        }
      }
      
      let schedule = commandText.substring(timeStartIndex, scheduleEndIndex).trim();
      
      // Â§ÑÁêÜÂºïÂè∑
      if ((schedule.startsWith('"') && schedule.endsWith('"')) || 
          (schedule.startsWith("'") && schedule.endsWith("'"))) {
        schedule = schedule.substring(1, schedule.length - 1);
      }
      
      let params = "";
      if (paramsStartIndex > 0) {
        params = commandText.substring(paramsStartIndex).trim();
      }
      
      const validTaskTypes = Object.values(CONFIG.SCHEDULE_TYPES);
      if (!validTaskTypes.includes(taskType)) {
        const message = `‚ùå <b>Êó†ÊïàÁöÑ‰ªªÂä°Á±ªÂûã</b>\n\nÂèØÁî®Á±ªÂûã: ${validTaskTypes.join(", ")}`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      Logger.debug("Controller", "Ëß£ÊûêÂÆöÊó∂‰ªªÂä°ÂèÇÊï∞", { taskType, schedule, params });
      
      const timeInfo = Formatter.parseTimeString(schedule);
      if (!timeInfo) {
        const message = `‚ùå <b>Êó†ÊïàÁöÑÊó∂Èó¥Ê†ºÂºè</b>\n\nËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºè:\n1. ÊØèÊó•Êó∂Èó¥: "HH:MM" (Â¶Ç "09:00")\n2. ÂÖ∑‰ΩìÊó∂Èó¥: "YYYY-MM-DD HH:MM" (Â¶Ç "2024-01-01 09:00")\n3. CronË°®ËææÂºè: "0 9 * * *" (ÊØèÂ§©9ÁÇπ)\n4. ÊòéÂ§©Êó∂Èó¥: "tomorrow HH:MM" (Â¶Ç "tomorrow 09:00")\n5. Áõ∏ÂØπÊó∂Èó¥: "in X minutes" (Â¶Ç "in 30 minutes")`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const taskName = `${taskType}_${Date.now()}`;
      
      const result = await DB.addScheduleTask(env, taskName, taskType, schedule, params);
      
      if (!result.success) {
        const message = `‚ùå <b>Ê∑ªÂä†ÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ: ${result.error}`;
        const sendResult = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, message
        );
        
        if (!sendResult.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const message = MessageRenderer.renderScheduleAddResult(result, taskType, schedule, params);
      const sendResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, message
      );
      
      if (!sendResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜschedule addÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Ê∑ªÂä†ÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_ADD, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  static async handleScheduleRemove(env, chatId, isAdmin, commandText) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Âà†Èô§ÂÆöÊó∂‰ªªÂä°„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_REMOVE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      
      if (parts.length < 3) {
        const message = `‚ùå <b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºèÔºö\n<code>/schedule remove [‰ªªÂä°ID]</code>\n\n‰ΩøÁî® <code>/schedule list</code> Êü•Áúã‰ªªÂä°ID„ÄÇ`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_REMOVE, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const taskId = Formatter.safeInt(parts[2], 0);
      
      if (taskId <= 0) {
        const message = "‚ùå <b>Êó†ÊïàÁöÑ‰ªªÂä°ID</b>\n\n‰ªªÂä°IDÂøÖÈ°ªÊòØÊ≠£Êï¥Êï∞„ÄÇ";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_REMOVE, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const result = await DB.deleteScheduleTask(env, taskId);
      
      if (!result.success) {
        const message = `‚ùå <b>Âà†Èô§ÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ: ${result.error}`;
        const sendResult = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_REMOVE, message
        );
        
        if (!sendResult.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const message = MessageRenderer.renderScheduleRemoveResult(result, taskId);
      const sendResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_REMOVE, message
      );
      
      if (!sendResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜschedule removeÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>Âà†Èô§ÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_REMOVE, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
  
  static async handleScheduleTest(env, chatId, isAdmin, commandText) {
    if (!isAdmin) {
      const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•ÊµãËØïÂÆöÊó∂‰ªªÂä°„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_TEST, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      
      if (parts.length < 3) {
        const message = `‚ùå <b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºèÔºö\n<code>/schedule test [Á±ªÂûã] [ÂèÇÊï∞(ÂèØÈÄâ)]</code>\n\nÂèØÁî®Á±ªÂûã: sync, predict, push, cleanup, monte\nÁ§∫‰æã:\n<code>/schedule test sync</code>\n<code>/schedule test monte '{"simulations": 1000}'</code>`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_TEST, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const taskType = parts[2].toLowerCase();
      
      let params = {};
      if (parts.length > 3) {
        try {
          const paramsStr = commandText.substring(commandText.indexOf(parts[2]) + parts[2].length).trim();
          if (paramsStr) {
            params = JSON.parse(paramsStr);
          }
        } catch (parseError) {
          Logger.warn("Controller", "Ëß£Êûê‰ªªÂä°ÂèÇÊï∞Â§±Ë¥•", parseError);
        }
      }
      
      const mockTask = {
        name: `test_${taskType}_${Date.now()}`,
        task_type: taskType,
        params: JSON.stringify(params)
      };
      
      const processingMessage = `${CONFIG.EMOJI.alarm} <b>Ê≠£Âú®ÊµãËØïÂÆöÊó∂‰ªªÂä°...</b>\n\n‰ªªÂä°Á±ªÂûã: ${taskType}\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_TEST, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ScheduleManager.executeTask(env, mockTask);
      
      const message = MessageRenderer.renderScheduleTestResult(result, taskType);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_TEST, message
      );
      
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜschedule testÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `‚ùå <b>ÊµãËØïÂÆöÊó∂‰ªªÂä°Â§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SCHEDULE_TEST, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
}

// ==============================================================================
// 13. ‰∫ã‰ª∂Â§ÑÁêÜÂô®
// ==============================================================================

async function handleUpdate(env, payload) {
  try {
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `Êî∂Âà∞Ê∂àÊÅØ: ${text}`, { chatId, userId, isAdmin });
    
    // Â§ÑÁêÜÁ°ÆËÆ§Âà†Èô§
    if (text.startsWith('Á°ÆËÆ§Âà†Èô§ ')) {
      if (isAdmin) {
        await Controller.confirmDelete(env, chatId, userId, text);
      } else {
        const message = "‚ùå <b>ÊùÉÈôê‰∏çË∂≥</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, "permission_error", message
        );
      }
      return;
    }
    
    // Â§ÑÁêÜÂëΩ‰ª§
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
          
        case '/stats':
          await Controller.handleStats(env, chatId);
          break;
          
        case '/predict':
        case '/p':
          await Controller.handlePredict(env, chatId, false);
          break;
          
        case '/monte':
        case '/montecarlo':
          await Controller.handleMonteCarlo(env, chatId, text);
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        case '/schedule':
          if (text.toLowerCase().startsWith('/schedule list')) {
            await Controller.handleScheduleList(env, chatId, isAdmin);
          } else if (text.toLowerCase().startsWith('/schedule add')) {
            await Controller.handleScheduleAdd(env, chatId, isAdmin, text);
          } else if (text.toLowerCase().startsWith('/schedule remove')) {
            await Controller.handleScheduleRemove(env, chatId, isAdmin, text);
          } else if (text.toLowerCase().startsWith('/schedule test')) {
            await Controller.handleScheduleTest(env, chatId, isAdmin, text);
          } else {
            await Controller.handleScheduleList(env, chatId, isAdmin);
          }
          break;
          
        default:
          // Êú™Áü•ÂëΩ‰ª§ÔºåÊòæÁ§∫ÂëΩ‰ª§Ê®°Êùø
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
      }
    } else {
      // ÈùûÂëΩ‰ª§Ê∂àÊÅØÔºåÊòæÁ§∫ÂëΩ‰ª§Ê®°Êùø
      await Controller.handleCommandTemplate(env, chatId, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "Â§ÑÁêÜÊõ¥Êñ∞Â§±Ë¥•", error);
  }
}

// ==============================================================================
// 14. Worker ÂÖ•Âè£ÁÇπ
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `Êî∂Âà∞ËØ∑Ê±Ç: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `Áº∫Â∞ëÂøÖË¶ÅÁéØÂ¢ÉÂèòÈáè: ${missingVars.join(', ')}`);
        return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "YOUR_CHANNEL_ID_HERE";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "YOUR_ADMIN_ID_HERE";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response("Database Initialization Failed. Please check D1 binding.", { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      // ÂÆöÊó∂‰ªªÂä°Ëß¶ÂèëÂô®
      if (url.pathname === "/cron" || url.pathname === "/schedule") {
        try {
          const result = await ScheduleManager.processPendingTasks(env);
          
          return new Response(JSON.stringify({
            status: "OK",
            processed: result.processed || 0,
            results: result.results || [],
            timestamp: new Date().toISOString()
          }, null, 2), {
            headers: { 
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
        } catch (error) {
          Logger.error("Cron", "ÂÆöÊó∂‰ªªÂä°ÊâßË°åÂ§±Ë¥•", error);
          return new Response(JSON.stringify({
            status: "ERROR",
            error: error.message,
            timestamp: new Date().toISOString()
          }, null, 2), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
      
      // ËíôÁâπÂç°Ê¥õÊâπÊ¨°Â§ÑÁêÜÂô®
      if (url.pathname === "/monte-batch" && request.method === "POST") {
        try {
          const data = await request.json();
          const { sessionId } = data;
          
          if (!sessionId) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: "Áº∫Â∞ësessionIdÂèÇÊï∞"
            }), { status: 400 });
          }
          
          const result = await EnhancedMonteCarloEngine.processBatch(env, sessionId);
          
          return new Response(JSON.stringify({
            status: result.success ? "OK" : "ERROR",
            ...result,
            timestamp: new Date().toISOString()
          }, null, 2), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          Logger.error("Worker", "Â§ÑÁêÜËíôÁâπÂç°Ê¥õÊâπÊ¨°Â§±Ë¥•", error);
          return new Response(JSON.stringify({
            status: "ERROR",
            error: error.message
          }, null, 2), { status: 500 });
        }
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const deletionStats = await DB.getDeletionStats(env);
            const monteStats = await DB.getMonteCarloStats(env);
            
            const scheduleTasks = await DB.getScheduleTasks(env, true);
            const pendingTasks = await DB.getPendingScheduleTasks(env);
            
            const cacheStats = CacheManager.getStats();
            
            const messageManagerStats = {
              totalUsers: MessageManager.userMessages.size,
              sampleUser: Array.from(MessageManager.userMessages.keys())[0] || null
            };
            
            const monteSessions = EnhancedMonteCarloEngine.activeSessions.size;
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              database: {
                historyCount: historyCount,
                deletionStats: deletionStats,
                monteCarloStats: monteStats
              },
              schedule: {
                totalTasks: scheduleTasks.length,
                enabledTasks: scheduleTasks.filter(t => t.enabled).length,
                pendingTasks: pendingTasks.length
              },
              cache: cacheStats,
              messageManager: messageManagerStats,
              monteCarlo: {
                activeSessions: monteSessions,
                batchSize: CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE,
                maxSimulations: CONFIG.SYSTEM.MAX_SIMULATIONS
              },
              environment: {
                hasChannel: !!env.TG_CHANNEL_ID,
                hasLotteryUrl: !!env.LOTTERY_DATA_URL
              },
              config: {
                monteCarloSimulations: CONFIG.SYSTEM.MONTECARLO_SIMULATIONS,
                maxSimulations: CONFIG.SYSTEM.MAX_SIMULATIONS,
                historyLimit: CONFIG.SYSTEM.HISTORY_LIMIT,
                maxRuntimeMs: CONFIG.SYSTEM.MAX_RUNTIME_MS
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            AdvancedStatsEngine.clearCache();
            AdvancedPredictionEngine.clearCache();
            EnhancedMonteCarloEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "ÊâÄÊúâÁºìÂ≠òÂ∑≤Ê∏ÖÈô§"
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/test-monte") {
          try {
            const startTime = Date.now();
            const result = await EnhancedMonteCarloEngine.runSimulation(env, 2000, "full_history");
            const duration = Date.now() - startTime;
            
            return new Response(JSON.stringify({
              status: "OK",
              duration: `${duration}ms`,
              confidence: result.confidence,
              specialNumbers: result.specialNumbers?.slice(0, 5) || [],
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/schedule-info") {
          try {
            const tasks = await DB.getScheduleTasks(env, false);
            const pending = await DB.getPendingScheduleTasks(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              totalTasks: tasks.length,
              enabledTasks: tasks.filter(t => t.enabled).length,
              pendingTasks: pending.length,
              tasks: tasks.map(t => ({
                id: t.id,
                name: t.name,
                type: t.task_type,
                schedule: t.schedule,
                enabled: t.enabled,
                nextRun: t.next_run,
                lastRun: t.last_run
              })),
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/monte-sessions") {
          try {
            const sessions = Array.from(EnhancedMonteCarloEngine.activeSessions.entries()).map(([id, session]) => ({
              id: id,
              chatId: session.chatId,
              startTime: new Date(session.startTime).toISOString(),
              completedSimulations: session.completedSimulations,
              totalSimulations: session.totalSimulations,
              progress: ((session.completedSimulations / session.totalSimulations) * 100).toFixed(1),
              status: session.status || "running"
            }));
            
            return new Response(JSON.stringify({
              status: "OK",
              totalSessions: sessions.length,
              sessions: sessions,
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // ‰∏ªÈ°µÊòæÁ§∫
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .feature-list {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .feature-item {
                  margin-bottom: 10px;
                  color: #2d3748;
                }
                .feature-item:before {
                  content: "‚úÖ ";
                  margin-right: 8px;
                }
                .command-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .command {
                  margin-bottom: 8px;
                  color: #276749;
                  font-family: monospace;
                  background: #e6fffa;
                  padding: 5px 10px;
                  border-radius: 5px;
                  display: inline-block;
                }
                .monte-info {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .schedule-info {
                  background: #fffaf0;
                  border: 1px solid #ed8936;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #dd6b20;
                }
                .anti-spam {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .api-endpoints {
                  background: #f7fafc;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #2d3748;
                }
                .api-endpoint {
                  font-family: monospace;
                  background: #edf2f7;
                  padding: 3px 8px;
                  border-radius: 3px;
                  margin: 2px 0;
                  display: inline-block;
                }
                .enhanced {
                  background: linear-gradient(45deg, #667eea, #764ba2);
                  color: white;
                  padding: 5px 10px;
                  border-radius: 5px;
                  font-weight: bold;
                  display: inline-block;
                  margin: 5px 0;
                }
                .fixed-badge {
                  background: linear-gradient(45deg, #f56565, #ed8936);
                  color: white;
                  padding: 3px 8px;
                  border-radius: 4px;
                  font-size: 0.8em;
                  margin-left: 5px;
                  display: inline-block;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION} <span class="fixed-badge">‰øÆÂ§çÁâà</span></div>
                
                <div class="feature-list">
                  <h3>Á≥ªÁªüÁâπÊÄß</h3>
                  <div class="feature-item">Èò≤Âà∑Â±èÊ®°ÂºèÔºöÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞Ê∂àÊÅØ</div>
                  <div class="feature-item"><span class="enhanced">Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü</span>ÔºöÂü∫‰∫éÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÈ¢ÑÊµã <span class="fixed-badge">Â∑≤‰øÆÂ§ç</span></div>
                  <div class="feature-item">ÂàÜÊâπÂ§ÑÁêÜÔºöÈÅøÂÖçWorkerË∂ÖÊó∂ÔºåÊîØÊåÅÈïøÊó∂Èó¥Ê®°Êãü</div>
                  <div class="feature-item">ËøõÂ∫¶Ë∑üË∏™ÔºöÂÆûÊó∂Êü•ÁúãÊ®°ÊãüËøõÂ∫¶ÔºåÊîØÊåÅÊñ≠ÁÇπÁª≠‰º† <span class="fixed-badge">Â∑≤‰øÆÂ§ç</span></div>
                  <div class="feature-item">ÂÆöÊó∂‰ªªÂä°Á≥ªÁªüÔºöÊîØÊåÅÂ§öÁßçÊó∂Èó¥Ê†ºÂºè <span class="fixed-badge">Â∑≤‰øÆÂ§ç</span></div>
                  <div class="feature-item">Ëá™Âä®Âà†Èô§ÊóßÊ∂àÊÅØÔºå‰øùÊåÅÁïåÈù¢Êï¥Ê¥Å</div>
                  <div class="feature-item">Âç≥Êó∂È¢ÑÊµãÔºåÊó†ÈúÄÁ≠âÂæÖ</div>
                  <div class="feature-item">Á∫ØÊñáÊú¨ÂëΩ‰ª§‰∫§‰∫í</div>
                  <div class="feature-item">Âü∫‰∫éÂÖ®ÈÉ®ÂéÜÂè≤Êï∞ÊçÆÂàÜÊûê <span class="fixed-badge">Â∑≤‰ºòÂåñ</span></div>
                  <div class="feature-item">ÁîüËÇñ„ÄÅÊ≥¢Ëâ≤„ÄÅÂ∞æÊï∞Â§öÁª¥Â∫¶È¢ÑÊµã</div>
                </div>
                
                <div class="command-list">
                  <h3>‰∏ªË¶ÅÂëΩ‰ª§</h3>
                  <div class="command">/start - Ê¨¢Ëøé‰ø°ÊÅØ</div>
                  <div class="command">/ccc - ÊòæÁ§∫ÂëΩ‰ª§Ê®°Êùø</div>
                  <div class="command">/predict - ÁîüÊàêÈ¢ÑÊµã</div>
                  <div class="command">/monte [Ê¨°Êï∞] - Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°Êãü</div>
                  <div class="command">/monte async [Ê¨°Êï∞] - ÂºÇÊ≠•Ê®°Êãü <span class="fixed-badge">Â∑≤‰øÆÂ§ç</span></div>
                  <div class="command">/monte progress [ID] - Êü•ÁúãËøõÂ∫¶</div>
                  <div class="command">/monte complete [ID] - ÂÆåÊàêÊ®°Êãü</div>
                  <div class="command">/history [È°µÁ†Å] - Êü•ÁúãÂéÜÂè≤</div>
                  <div class="command">/stats - Êü•Áúã/Êõ¥Êñ∞ÁªüËÆ°</div>
                  <div class="command">/sync - ÂêåÊ≠•Êï∞ÊçÆ(ÁÆ°ÁêÜÂëò)</div>
                  <div class="command">/schedule list - ÂÆöÊó∂‰ªªÂä°(ÁÆ°ÁêÜÂëò)</div>
                  <div class="command">/delete [ÊúüÂè∑] - Âà†Èô§ËÆ∞ÂΩï(ÁÆ°ÁêÜÂëò)</div>
                </div>
                
                <div class="monte-info">
                  <strong>${CONFIG.EMOJI.science} Â¢ûÂº∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÔºö</strong><br>
                  ‚Ä¢ Âü∫‰∫éÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÔºàÁ∫¶300Â§öÊúüÔºâ<br>
                  ‚Ä¢ ÂàÜÊâπÂ§ÑÁêÜÔºåÈÅøÂÖçWorkerË∂ÖÊó∂<br>
                  ‚Ä¢ ÊîØÊåÅÂºÇÊ≠•ÈïøÊó∂Èó¥Ê®°ÊãüÔºà10‰∏áÊ¨°‰ª•‰∏äÔºâ<span class="fixed-badge">Â∑≤‰øÆÂ§ç</span><br>
                  ‚Ä¢ ÂÆûÊó∂ËøõÂ∫¶Ë∑üË∏™ÂíåÊñ≠ÁÇπÁª≠‰º†<br>
                  ‚Ä¢ Êõ¥ÁßëÂ≠¶ÁöÑÊ¶ÇÁéáÁªüËÆ°ÂíåÁΩÆ‰ø°Â∫¶<br>
                  ‚Ä¢ ÂëΩ‰ª§: <code>/monte 20000</code> (ÂêåÊ≠•2‰∏áÊ¨°Ê®°Êãü)<br>
                  ‚Ä¢ ÂëΩ‰ª§: <code>/monte async 50000</code> (ÂºÇÊ≠•5‰∏áÊ¨°Ê®°Êãü)
                </div>
                
                <div class="schedule-info">
                  <strong>${CONFIG.EMOJI.calendar} ÂÆöÊó∂‰ªªÂä°Á≥ªÁªüÔºö</strong><br>
                  ‚Ä¢ ÊîØÊåÅÂ§öÁßçÊó∂Èó¥Ê†ºÂºè <span class="fixed-badge">Â∑≤‰øÆÂ§ç</span><br>
                  ‚Ä¢ Ëá™Âä®ÊâßË°åÂêåÊ≠•„ÄÅÈ¢ÑÊµã„ÄÅÊé®ÈÄÅ<br>
                  ‚Ä¢ ÂèØÈÖçÁΩÆ‰ªªÂä°ÂèÇÊï∞<br>
                  ‚Ä¢ Á§∫‰æã: <code>/schedule add push "18:00"</code><br>
                  ‚Ä¢ Á§∫‰æã: <code>/schedule add sync "0 9 * * *"</code><br>
                  ‚Ä¢ Á§∫‰æã: <code>/schedule add predict "tomorrow 09:00"</code><br>
                  ‚Ä¢ Á§∫‰æã: <code>/schedule add monte "in 30 minutes"</code>
                </div>
                
                <div class="anti-spam">
                  <strong>${CONFIG.EMOJI.refresh} Èò≤Âà∑Â±èÁâπÊÄßÔºö</strong><br>
                  ‚Ä¢ ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞‰∏ÄÊù°Ê∂àÊÅØ<br>
                  ‚Ä¢ ÂèëÈÄÅÁõ∏ÂêåÂëΩ‰ª§Ëá™Âä®Âà†Èô§ÊóßÊ∂àÊÅØ<br>
                  ‚Ä¢ ‰øùÊåÅËÅäÂ§©ÁïåÈù¢Êï¥Ê¥ÅÔºåÈò≤Ê≠¢Ê∂àÊÅØÂ†ÜÁßØ<br>
                  ‚Ä¢ Áî®Êà∑ÊØè‰∏™ÂëΩ‰ª§Á±ªÂûãÊúÄÂ§ö‰øùÁïô10Êù°ÊúÄÊñ∞Ê∂àÊÅØ
                </div>
                
                <div class="api-endpoints">
                  <strong>APIÁ´ØÁÇπÔºö</strong><br>
                  <div class="api-endpoint">GET /health - Á≥ªÁªüÂÅ•Â∫∑Ê£ÄÊü•</div>
                  <div class="api-endpoint">GET /reset-cache - ÈáçÁΩÆÁºìÂ≠ò</div>
                  <div class="api-endpoint">GET /test-monte - ÊµãËØïÂ¢ûÂº∫ËíôÁâπÂç°Ê¥õ</div>
                  <div class="api-endpoint">GET /schedule-info - ÂÆöÊó∂‰ªªÂä°‰ø°ÊÅØ</div>
                  <div class="api-endpoint">GET /monte-sessions - ËíôÁâπÂç°Ê¥õ‰ºöËØù</div>
                  <div class="api-endpoint">POST /monte-batch - Â§ÑÁêÜËíôÁâπÂç°Ê¥õÊâπÊ¨°</div>
                  <div class="api-endpoint">GET /cron - Ëß¶ÂèëÂÆöÊó∂‰ªªÂä°</div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 8px;">
                  <strong>‰øÆÂ§çÂÜÖÂÆπÔºö</strong><br>
                  ‚Ä¢ ‰øÆÂ§çÂÆöÊó∂‰ªªÂä°Êó∂Èó¥Ê†ºÂºèËØÜÂà´ÈóÆÈ¢ò<br>
                  ‚Ä¢ ‰øÆÂ§çËíôÁâπÂç°Ê¥õÂºÇÊ≠•Ê®°ÊãüÊöÇÂÅúÈóÆÈ¢ò<br>
                  ‚Ä¢ ‰ºòÂåñÂéÜÂè≤ËÆ∞ÂΩï‰ΩøÁî®Á≠ñÁï•‰∏∫ÂÖ®ÈÉ®ËÆ∞ÂΩï<br>
                  ‚Ä¢ ÊîπËøõÈîôËØØÂ§ÑÁêÜÂíåÁ®≥ÂÆöÊÄß
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "Â§ÑÁêÜPOSTËØ∑Ê±ÇÂá∫Èîô", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "Â§ÑÁêÜËØ∑Ê±ÇÂ§±Ë¥•", error);
      return new Response("Internal Server Error", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};
