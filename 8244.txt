const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ¾³å…­é¢„æµ‹",
    VERSION: "V13.1 å®šæ—¶è‡ªåŠ¨åŒæ­¥å¢å¼ºç‰ˆ",
    TIMEZONE_OFFSET: 8,
    HISTORY_LIMIT: 2000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    MONTECARLO_SIMULATIONS: 10000,
    MONTECARLO_BATCH_SIZE: 2000,
    MONTECARLO_MAX_BATCHES: 5,
    MAX_SIMULATIONS: 50000,
    MIN_SIMULATIONS: 2000,
    MAX_RUNTIME_MS: 10000,
    ASYNC_BATCH_DELAY: 20,
    MAX_SPECIAL_PREDICTIONS: 15,
    MAX_NORMAL_PREDICTIONS: 12,
    MONTE_CACHE_TTL: 5 * 60 * 1000,
    KNN_K_VALUE: 10,
    STATS_WINDOW_SIZE: 100,
    PREDICTION_TIMEOUT: 8000,
    ALGORITHM_TIMEOUTS: {
      traditional: 3000,
      knn: 4000,
      stats: 5000,
      advanced: 8000,
      omission: 6000,
      association: 7000,
      math: 5000,
      zone: 5000
    },
    MIN_HISTORY_FOR_ALGORITHMS: {
      traditional: 2,
      knn: 10,
      stats: 20,
      advanced: 5,
      omission: 30,
      association: 50,
      math: 10,
      zone: 20
    },
    MESSAGE_MANAGER_MAX_USERS: 1000,
    MESSAGE_MANAGER_MAX_MESSAGES_PER_USER: 20,
    AUTO_CLEANUP_INTERVAL: 10 * 60 * 1000,
    USER_INACTIVITY_THRESHOLD: 30 * 60 * 1000,
    OMISSION_RATIO_THRESHOLDS: {
      extreme_cold: 2.5,
      cold: 1.5,
      normal: 0.8,
      hot: 0.2
    },
    ASSOCIATION_MIN_SUPPORT: 0.1,
    GOLDEN_RATIO: 0.6180339887,
    ZONE_CONFIGS: {
      seven_zone: [
        [1, 7],    // 1åŒº: 1-7
        [8, 14],   // 2åŒº: 8-14
        [15, 21],  // 3åŒº: 15-21
        [22, 28],  // 4åŒº: 22-28
        [29, 35],  // 5åŒº: 29-35
        [36, 42],  // 6åŒº: 36-42
        [43, 49]   // 7åŒº: 43-49
      ],
      five_zone: [
        [1, 10],   // 1åŒº: 1-10
        [11, 20],  // 2åŒº: 11-20
        [21, 30],  // 3åŒº: 21-30
        [31, 40],  // 4åŒº: 31-40
        [41, 49]   // 5åŒº: 41-49
      ]
    },
    MODULO_ANALYSIS: {
      mod3: [0, 1, 2],
      mod5: [0, 1, 2, 3, 4],
      mod7: [0, 1, 2, 3, 4, 5, 6]
    },
    // æ–°å¢ï¼šè‡ªåŠ¨åŒæ­¥é…ç½®
    AUTO_SYNC_CONFIG: {
      ENABLED_BY_DEFAULT: true,
      BEIJING_HOUR: 5,
      CHECK_INTERVAL: 60 * 60 * 1000,
      LAST_CHECK_KEY: "LAST_AUTO_SYNC_CHECK",
      AUTO_SYNC_ENABLED_KEY: "AUTO_SYNC_ENABLED",
      NEXT_SYNC_KEY: "NEXT_AUTO_SYNC_TIME",
      SYNC_WINDOW_START: 0,    // çª—å£å¼€å§‹åˆ†é’Ÿ
      SYNC_WINDOW_END: 30,     // çª—å£ç»“æŸåˆ†é’Ÿ
      PRE_WINDOW_START: 45,    // é¢„å¤‡çª—å£å¼€å§‹åˆ†é’Ÿ
      PRE_WINDOW_END: 59       // é¢„å¤‡çª—å£ç»“æŸåˆ†é’Ÿ
    }
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.5,
    w_zodiac_relation: 2.0,
    w_color_transfer: 1.8,
    w_tail_correlation: 1.5,
    w_number_frequency: 1.3,
    w_monte_carlo: 2.5,
    w_number_pattern: 1.2,
    w_hot_cold: 1.1,
    w_knn_similarity: 2.0,
    w_statistics_analysis: 2.8,
    w_tail_pattern: 1.8,
    w_head_pattern: 1.5,
    w_size_pattern: 1.4,
    w_odd_even_pattern: 1.4,
    
    // æ–°å¢ä¸“å®¶ç®—æ³•æƒé‡
    w_omission_balancing: 3.0,
    w_association_rules: 2.5,
    w_math_logic: 2.2,
    w_zone_balance: 2.8,
    
    _version: "13.0"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  NUMBER_PATTERNS: {
    prime: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47],
    composite: [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49],
    multiples_of_7: [7, 14, 21, 28, 35, 42, 49],
    multiples_of_8: [8, 16, 24, 32, 40, 48],
    consecutive_pairs: [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,26],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,37],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,46],[46,47],[47,48],[48,49]]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    PREDICT: "prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_CONFIRM: "delete_confirm",
    DELETE_RESULT: "delete_result",
    AUTO_SYNC_STATUS: "auto_sync_status",
    AUTO_SYNC_ON: "auto_sync_on",
    AUTO_SYNC_OFF: "auto_sync_off"
  },

  ALGORITHM_NAMES: {
    traditional: "ä¼ ç»Ÿç®—æ³•",
    knn: "KNNç®—æ³•",
    stats: "ç»Ÿè®¡ç®—æ³•",
    advanced: "å¢å¼ºç®—æ³•",
    omission: "é—æ¼å›è¡¥ä¸“å®¶",
    association: "å…³è”è§„åˆ™ä¸“å®¶",
    math: "é»„é‡‘åˆ†å‰²ä¸“å®¶",
    zone: "åŒºé—´å¹³è¡¡ä¸“å®¶"
  }
};
class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
  
  static debug(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [DEBUG] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.debug] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
      }
      
      let zodiac = "æœªçŸ¥";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "æœªçŸ¥";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(2) + 'äº¿';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }

  static getRandomElement(array) {
    try {
      if (!array || !Array.isArray(array) || array.length === 0) return null;
      return array[Math.floor(Math.random() * array.length)];
    } catch (error) {
      return null;
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static formatDuration(ms) {
    try {
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms/1000).toFixed(2)}ç§’`;
      if (ms < 3600000) return `${Math.floor(ms/60000)}åˆ†${Math.floor((ms%60000)/1000)}ç§’`;
      return `${Math.floor(ms/3600000)}å°æ—¶${Math.floor((ms%3600000)/60000)}åˆ†`;
    } catch (error) {
      return `${ms}ms`;
    }
  }

  static formatProgress(current, total) {
    try {
      const percent = total > 0 ? ((current / total) * 100).toFixed(1) : 0;
      const progressBarLength = 20;
      const filled = Math.round((current / total) * progressBarLength);
      const empty = progressBarLength - filled;
      const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
      return `${bar} ${percent}% (${current}/${total})`;
    } catch (error) {
      return `${current}/${total}`;
    }
  }

  static isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    
    for (let i = 5; i * i <= num; i += 6) {
      if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
  }

  static calculateNumberPattern(num) {
    try {
      const patterns = [];
      
      if (this.isPrime(num)) {
        patterns.push("è´¨æ•°");
      } else {
        patterns.push("åˆæ•°");
      }
      
      if (num % 7 === 0) {
        patterns.push("7å€æ•°");
      }
      
      if (num % 8 === 0) {
        patterns.push("8å€æ•°");
      }
      
      return patterns;
    } catch (error) {
      return [];
    }
  }

  static calculateHotColdStatus(numbers, history) {
    try {
      if (!Array.isArray(numbers) || !Array.isArray(history) || history.length < 10) {
        return {};
      }
      
      const frequency = {};
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }
      
      const recentHistory = history.slice(0, Math.min(100, history.length));
      for (const record of recentHistory) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => this.safeInt(n, 0));
          for (const num of nums) {
            if (num >= 1 && num <= 49) {
              frequency[num]++;
            }
          }
        }
      }
      
      const status = {};
      const maxFrequency = Math.max(...Object.values(frequency));
      const avgFrequency = Object.values(frequency).reduce((a, b) => a + b, 0) / 49;
      
      for (const num of numbers) {
        if (num >= 1 && num <= 49) {
          const freq = frequency[num] || 0;
          if (freq >= maxFrequency * 0.8) {
            status[num] = "çƒ­é—¨";
          } else if (freq <= avgFrequency * 0.5) {
            status[num] = "å†·é—¨";
          } else if (freq <= avgFrequency * 0.8) {
            status[num] = "æ¸©ç ";
          } else {
            status[num] = "æ´»è·ƒ";
          }
        }
      }
      
      return status;
    } catch (error) {
      return {};
    }
  }

  static calculateFeatures(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return null;
      }
      
      const attr = this.getAttributes(num);
      
      return {
        number: num,
        zodiac: attr.zodiac,
        color: attr.color,
        tail: num % 10,
        head: Math.floor(num / 10),
        isBig: num >= 25,
        isOdd: num % 2 !== 0,
        isPrime: this.isPrime(num)
      };
    } catch (error) {
      return null;
    }
  }

  static isAlgorithmSupported(algorithm, historyLength) {
    try {
      const minHistory = CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS[algorithm] || 2;
      return historyLength >= minHistory;
    } catch (error) {
      return historyLength >= 2;
    }
  }

  static getAlgorithmTimeout(algorithm) {
    try {
      return CONFIG.SYSTEM.ALGORITHM_TIMEOUTS[algorithm] || CONFIG.SYSTEM.PREDICTION_TIMEOUT;
    } catch (error) {
      return CONFIG.SYSTEM.PREDICTION_TIMEOUT;
    }
  }

  static normalizeScores(scoresMap, algorithmName) {
    try {
      const scores = Array.from(scoresMap.entries()).map(([number, score]) => ({ number, score }));
      
      if (scores.length === 0) {
        return scores;
      }
      
      const maxScore = Math.max(...scores.map(s => s.score));
      const minScore = Math.min(...scores.map(s => s.score));
      const range = maxScore - minScore;
      
      if (range === 0) {
        return scores.map(s => ({ number: s.number, score: 50 }));
      }
      
      return scores.map(s => ({
        number: s.number,
        score: Math.round(((s.score - minScore) / range) * 100),
        rawScore: s.score,
        algorithm: algorithmName
      }));
    } catch (error) {
      Logger.error("Formatter", "å½’ä¸€åŒ–åˆ†æ•°å¤±è´¥", error);
      return Array.from(scoresMap.entries()).map(([number, score]) => ({ 
        number, 
        score: Math.min(100, Math.max(0, score)),
        rawScore: score,
        algorithm: algorithmName
      }));
    }
  }

  static getZoneForNumber(number, zoneType = 'seven_zone') {
    try {
      const zones = CONFIG.SYSTEM.ZONE_CONFIGS[zoneType];
      if (!zones) return -1;
      
      for (let i = 0; i < zones.length; i++) {
        const [start, end] = zones[i];
        if (number >= start && number <= end) {
          return i + 1;
        }
      }
      return -1;
    } catch (error) {
      return -1;
    }
  }

  static getNumbersInZone(zoneId, zoneType = 'seven_zone') {
    try {
      const zones = CONFIG.SYSTEM.ZONE_CONFIGS[zoneType];
      if (!zones || zoneId < 1 || zoneId > zones.length) {
        return [];
      }
      
      const [start, end] = zones[zoneId - 1];
      const numbers = [];
      for (let i = start; i <= end; i++) {
        numbers.push(i);
      }
      return numbers;
    } catch (error) {
      return [];
    }
  }

  // æ–°å¢ï¼šæ—¶é—´ç›¸å…³å‡½æ•°
  static getBeijingTime() {
    try {
      const now = new Date();
      // è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´ï¼ˆUTC+8ï¼‰
      const beijingTime = new Date(now.getTime() + (CONFIG.SYSTEM.TIMEZONE_OFFSET * 60 * 60 * 1000));
      return beijingTime;
    } catch (error) {
      return new Date();
    }
  }

  static getBeijingHour() {
    try {
      const beijingTime = this.getBeijingTime();
      return beijingTime.getHours();
    } catch (error) {
      return new Date().getHours();
    }
  }

  static getBeijingMinute() {
    try {
      const beijingTime = this.getBeijingTime();
      return beijingTime.getMinutes();
    } catch (error) {
      return new Date().getMinutes();
    }
  }

  static isSyncTime() {
    try {
      const beijingHour = this.getBeijingHour();
      const beijingMinute = this.getBeijingMinute();
      const targetHour = CONFIG.SYSTEM.AUTO_SYNC_CONFIG.BEIJING_HOUR;
      
      // æ£€æŸ¥æ˜¯å¦åœ¨ç›®æ ‡æ—¶é—´çª—å£å†…ï¼ˆç›®æ ‡å°æ—¶çš„0-30åˆ†é’Ÿï¼‰
      if (beijingHour === targetHour && 
          beijingMinute >= CONFIG.SYSTEM.AUTO_SYNC_CONFIG.SYNC_WINDOW_START && 
          beijingMinute <= CONFIG.SYSTEM.AUTO_SYNC_CONFIG.SYNC_WINDOW_END) {
        return true;
      }
      
      // æ£€æŸ¥æ˜¯å¦åœ¨é¢„å¤‡çª—å£å†…ï¼ˆå‰ä¸€å¤©çš„45-59åˆ†é’Ÿï¼‰
      if (beijingHour === (targetHour - 1 + 24) % 24 && 
          beijingMinute >= CONFIG.SYSTEM.AUTO_SYNC_CONFIG.PRE_WINDOW_START && 
          beijingMinute <= CONFIG.SYSTEM.AUTO_SYNC_CONFIG.PRE_WINDOW_END) {
        return true;
      }
      
      return false;
    } catch (error) {
      return false;
    }
  }

  static getNextSyncTime() {
    try {
      const now = new Date();
      const beijingTime = this.getBeijingTime();
      const targetHour = CONFIG.SYSTEM.AUTO_SYNC_CONFIG.BEIJING_HOUR;
      
      // è®¡ç®—ä¸‹ä¸€ä¸ªç›®æ ‡æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´çš„5:00ï¼‰
      let nextSync = new Date(beijingTime);
      nextSync.setHours(targetHour, 0, 0, 0);
      
      // å¦‚æœå½“å‰æ—¶é—´å·²ç»è¿‡äº†ä»Šå¤©çš„ç›®æ ‡æ—¶é—´ï¼Œè®¾ç½®ä¸ºæ˜å¤©çš„ç›®æ ‡æ—¶é—´
      if (nextSync.getTime() <= beijingTime.getTime()) {
        nextSync.setDate(nextSync.getDate() + 1);
      }
      
      // è½¬æ¢å›UTCæ—¶é—´
      const utcNextSync = new Date(nextSync.getTime() - (CONFIG.SYSTEM.TIMEZONE_OFFSET * 60 * 60 * 1000));
      
      return {
        beijingTime: nextSync,
        utcTime: utcNextSync,
        timestamp: utcNextSync.getTime(),
        formatted: this.formatDateTime(nextSync)
      };
    } catch (error) {
      const fallback = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24å°æ—¶å
      return {
        beijingTime: fallback,
        utcTime: fallback,
        timestamp: fallback.getTime(),
        formatted: this.formatDateTime(fallback)
      };
    }
  }

  static formatTimeRemaining(targetTime) {
    try {
      const now = new Date();
      const diff = targetTime - now.getTime();
      
      if (diff <= 0) {
        return "ç«‹å³";
      }
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      
      if (hours > 0) {
        return `${hours}å°æ—¶${minutes}åˆ†é’Ÿå`;
      } else {
        return `${minutes}åˆ†é’Ÿå`;
      }
    } catch (error) {
      return "æœªçŸ¥";
    }
  }
}
class MessageManager {
  static userMessages = new Map();
  static lastCleanupTime = Date.now();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static deleteUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.delete(messageType);
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
  
  static cleanupOldMessages(chatId, keepCount = 10) {
    try {
      this.initUser(chatId);
      const userMap = this.userMessages.get(chatId);
      
      if (userMap.size <= keepCount) {
        return 0;
      }
      
      const entries = Array.from(userMap.entries());
      const toRemove = entries.slice(0, entries.length - keepCount);
      
      let removed = 0;
      for (const [key, _] of toRemove) {
        if (userMap.delete(key)) {
          removed++;
        }
      }
      
      return removed;
    } catch (error) {
      Logger.error("MessageManager", "æ¸…ç†æ—§æ¶ˆæ¯å¤±è´¥", error);
      return 0;
    }
  }
  
  static autoCleanup() {
    try {
      const now = Date.now();
      if (now - this.lastCleanupTime < CONFIG.SYSTEM.AUTO_CLEANUP_INTERVAL) {
        return;
      }
      
      Logger.info("MessageManager", "å¼€å§‹è‡ªåŠ¨æ¸…ç†ç”¨æˆ·æ¶ˆæ¯ç¼“å­˜");
      
      let totalCleaned = 0;
      
      for (const [chatId, userMap] of this.userMessages.entries()) {
        if (userMap.size > CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_MESSAGES_PER_USER) {
          const cleaned = this.cleanupOldMessages(chatId, 10);
          totalCleaned += cleaned;
        }
      }
      
      this.lastCleanupTime = now;
      
      if (totalCleaned > 0) {
        Logger.info("MessageManager", `è‡ªåŠ¨æ¸…ç†å®Œæˆï¼Œæ¸…ç†äº† ${totalCleaned} æ¡æ¶ˆæ¯`);
      }
      
      if (this.userMessages.size > CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_USERS) {
        const keysToDelete = Array.from(this.userMessages.keys())
          .slice(0, this.userMessages.size - CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_USERS);
        
        keysToDelete.forEach(key => this.userMessages.delete(key));
        Logger.info("MessageManager", `æ¸…ç†äº† ${keysToDelete.length} ä¸ªä¸æ´»è·ƒç”¨æˆ·`);
      }
      
    } catch (error) {
      Logger.error("MessageManager", "è‡ªåŠ¨æ¸…ç†å¤±è´¥", error);
    }
  }
}
class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "è®¾ç½®ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
  
  static getStats() {
    try {
      const now = Date.now();
      let validCount = 0;
      let expiredCount = 0;
      
      for (const [_, item] of this.cache) {
        if (now > item.expireAt) {
          expiredCount++;
        } else {
          validCount++;
        }
      }
      
      return {
        total: this.cache.size,
        valid: validCount,
        expired: expiredCount
      };
    } catch (error) {
      return { total: 0, valid: 0, expired: 0 };
    }
  }
}
const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE INDEX IF NOT EXISTS idx_history_created_at ON lottery_history (created_at DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_deletion_log_created_at ON deletion_log (created_at DESC)`,
        `CREATE TABLE IF NOT EXISTS montecarlo_results (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          simulation_id TEXT,
          simulations INTEGER,
          sample_type TEXT,
          special_numbers TEXT,
          normal_numbers TEXT,
          confidence REAL,
          duration_ms INTEGER,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_montecarlo_created_at ON montecarlo_results (created_at DESC)`,
        `CREATE INDEX IF NOT EXISTS idx_montecarlo_simulation_id ON montecarlo_results (simulation_id)`,
        `CREATE TABLE IF NOT EXISTS algorithm_weights (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          algorithm_name TEXT,
          weight REAL,
          performance REAL,
          last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_algorithm_weights_name ON algorithm_weights (algorithm_name)`,
        `CREATE TABLE IF NOT EXISTS auto_sync_logs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          success BOOLEAN,
          added INTEGER,
          skipped INTEGER,
          total INTEGER,
          new_count INTEGER,
          prediction_generated BOOLEAN,
          channel_push_success BOOLEAN,
          error_message TEXT,
          executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_auto_sync_logs_executed_at ON auto_sync_logs (executed_at DESC)`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  checkExpectExists: async function(env, expect) {
    try {
      if (!expect) return false;
      
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(Formatter.safeString(expect)).first();
      
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      // éªŒè¯è®°å½•æ ¼å¼
      const validRecords = records.filter(record => {
        if (!record || !record.expect || !record.open_code) return false;
        
        // éªŒè¯æœŸå·æ ¼å¼
        if (!Formatter.isValidExpect(record.expect.toString())) {
          Logger.warn("DB", `æœŸå·æ ¼å¼æ— æ•ˆ: ${record.expect}`);
          return false;
        }
        
        // éªŒè¯å¼€å¥–å·ç æ ¼å¼
        const numbers = record.open_code.split(',');
        if (numbers.length !== 7) {
          Logger.warn("DB", `å¼€å¥–å·ç æ•°é‡ä¸æ­£ç¡®: ${record.open_code}`);
          return false;
        }
        
        // éªŒè¯æ¯ä¸ªå·ç éƒ½åœ¨1-49èŒƒå›´å†…
        for (const numStr of numbers) {
          const num = parseInt(numStr);
          if (isNaN(num) || num < 1 || num > 49) {
            Logger.warn("DB", `å·ç è¶…å‡ºèŒƒå›´: ${numStr}ï¼Œè®°å½•: ${record.expect}`);
            return false;
          }
        }
        
        return true;
      });

      Logger.info("DB", `æœ‰æ•ˆè®°å½•: ${validRecords.length}/${records.length}`);

      for (let i = 0; i < validRecords.length; i += CHUNK_SIZE) {
        const chunk = validRecords.slice(i, i + CHUNK_SIZE);
        
        if (chunk.length === 0) continue;
        
        const batch = env.DB.batch(
          chunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (chunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of chunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { 
        success: true, 
        added: totalAdded, 
        skipped: totalSkipped,
        validRecords: validRecords.length,
        invalidRecords: records.length - validRecords.length
      };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { 
        success: false, 
        error: e.message,
        added: 0,
        skipped: 0
      };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          
          weights = { ...defaultWeights, ...parsed };
          
          // ç¡®ä¿æ‰€æœ‰æƒé‡éƒ½å­˜åœ¨
          for (const key of Object.keys(defaultWeights)) {
            if (!weights.hasOwnProperty(key)) {
              weights[key] = defaultWeights[key];
            }
          }
          
          weights._version = weights._version || "13.0";
        } catch (parseError) {
          Logger.error("DB", "è§£ææƒé‡è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤", parseError);
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0",
        "TOTAL_MONTE": "0",
        "MONTE_SAMPLE_TYPE": "full_history",
        "AUTO_SYNC_ENABLED": CONFIG.SYSTEM.AUTO_SYNC_CONFIG.ENABLED_BY_DEFAULT ? "1" : "0",
        "LAST_AUTO_SYNC": "",
        "LAST_AUTO_SYNC_RESULT": "",
        "AUTO_SYNC_NEXT_TIME": "",
        "AUTO_SYNC_STATS": JSON.stringify({
          total_auto_syncs: 0,
          successful_auto_syncs: 0,
          failed_auto_syncs: 0,
          total_new_records: 0,
          total_predictions_generated: 0,
          total_channel_pushes: 0,
          last_auto_predict_result: "",
          last_execution_time: ""
        })
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  getDeletionStats: async function(env) {
    try {
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM deletion_log"
      ).first();
      
      const recordsResult = await env.DB.prepare(
        "SELECT SUM(deleted_count) as total FROM deletion_log"
      ).first();
      
      const recentResult = await env.DB.prepare(
        "SELECT created_at FROM deletion_log ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalDeletions: totalResult ? totalResult.count : 0,
        totalRecordsDeleted: recordsResult ? (recordsResult.total || 0) : 0,
        lastDeletion: recentResult ? recentResult.created_at : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionStats failed", e);
      return {
        totalDeletions: 0,
        totalRecordsDeleted: 0,
        lastDeletion: null
      };
    }
  },

  // æ–°å¢ï¼šè‡ªåŠ¨åŒæ­¥ç›¸å…³å‡½æ•°
  getAutoSyncStatus: async function(env) {
    try {
      const enabled = await this.getSetting(env, "AUTO_SYNC_ENABLED", "0");
      const lastAutoSync = await this.getSetting(env, "LAST_AUTO_SYNC", "");
      const lastResult = await this.getSetting(env, "LAST_AUTO_SYNC_RESULT", "");
      const nextTime = await this.getSetting(env, "AUTO_SYNC_NEXT_TIME", "");
      const statsStr = await this.getSetting(env, "AUTO_SYNC_STATS", "{}");
      
      let stats = {
        total_auto_syncs: 0,
        successful_auto_syncs: 0,
        failed_auto_syncs: 0,
        total_new_records: 0,
        total_predictions_generated: 0,
        total_channel_pushes: 0,
        last_auto_predict_result: "",
        last_execution_time: ""
      };
      
      try {
        stats = JSON.parse(statsStr);
      } catch (e) {
        // ä½¿ç”¨é»˜è®¤å€¼
      }
      
      return {
        enabled: enabled === "1",
        lastAutoSync: lastAutoSync || "ä»æœªæ‰§è¡Œ",
        lastResult: lastResult || "æ— ",
        nextTime: nextTime || Formatter.getNextSyncTime().formatted,
        stats: stats
      };
    } catch (error) {
      Logger.error("DB", "è·å–è‡ªåŠ¨åŒæ­¥çŠ¶æ€å¤±è´¥", error);
      return {
        enabled: CONFIG.SYSTEM.AUTO_SYNC_CONFIG.ENABLED_BY_DEFAULT,
        lastAutoSync: "æœªçŸ¥",
        lastResult: "æœªçŸ¥",
        nextTime: Formatter.getNextSyncTime().formatted,
        stats: {
          total_auto_syncs: 0,
          successful_auto_syncs: 0,
          failed_auto_syncs: 0,
          total_new_records: 0,
          total_predictions_generated: 0,
          total_channel_pushes: 0,
          last_auto_predict_result: "",
          last_execution_time: ""
        }
      };
    }
  },

  setAutoSyncEnabled: async function(env, enabled) {
    try {
      await this.saveSetting(env, "AUTO_SYNC_ENABLED", enabled ? "1" : "0");
      
      // å¦‚æœå¯ç”¨ï¼Œè®¡ç®—å¹¶ä¿å­˜ä¸‹æ¬¡åŒæ­¥æ—¶é—´
      if (enabled) {
        const nextSync = Formatter.getNextSyncTime();
        await this.saveSetting(env, "AUTO_SYNC_NEXT_TIME", nextSync.formatted);
      } else {
        await this.saveSetting(env, "AUTO_SYNC_NEXT_TIME", "");
      }
      
      CacheManager.set(`setting_AUTO_SYNC_ENABLED`, enabled ? "1" : "0", 60000);
      
      Logger.info("DB", `è‡ªåŠ¨åŒæ­¥çŠ¶æ€å·²æ›´æ–°: ${enabled ? "å¯ç”¨" : "ç¦ç”¨"}`);
      return true;
    } catch (error) {
      Logger.error("DB", "è®¾ç½®è‡ªåŠ¨åŒæ­¥çŠ¶æ€å¤±è´¥", error);
      return false;
    }
  },

  updateAutoSyncStats: async function(env, syncResult) {
    try {
      const statsStr = await this.getSetting(env, "AUTO_SYNC_STATS", "{}");
      let stats = {
        total_auto_syncs: 0,
        successful_auto_syncs: 0,
        failed_auto_syncs: 0,
        total_new_records: 0,
        total_predictions_generated: 0,
        total_channel_pushes: 0,
        last_auto_predict_result: "",
        last_execution_time: Formatter.formatDateTime()
      };
      
      try {
        stats = JSON.parse(statsStr);
      } catch (e) {
        // ä½¿ç”¨é»˜è®¤å€¼
      }
      
      stats.total_auto_syncs = (stats.total_auto_syncs || 0) + 1;
      stats.last_execution_time = Formatter.formatDateTime();
      
      if (syncResult.success) {
        stats.successful_auto_syncs = (stats.successful_auto_syncs || 0) + 1;
        if (syncResult.added && syncResult.added > 0) {
          stats.total_new_records = (stats.total_new_records || 0) + syncResult.added;
        }
        
        if (syncResult.predictionResult && syncResult.predictionResult.success) {
          stats.total_predictions_generated = (stats.total_predictions_generated || 0) + 1;
          
          if (syncResult.predictionResult.channelPushSuccess) {
            stats.total_channel_pushes = (stats.total_channel_pushes || 0) + 1;
          }
        }
      } else {
        stats.failed_auto_syncs = (stats.failed_auto_syncs || 0) + 1;
      }
      
      // è®°å½•è‡ªåŠ¨é¢„æµ‹ç»“æœ
      if (syncResult.predictionResult) {
        if (syncResult.predictionResult.success) {
          stats.last_auto_predict_result = `ç¬¬ ${syncResult.predictionResult.nextExpect} æœŸé¢„æµ‹${syncResult.predictionResult.channelPushSuccess ? "å·²æ¨é€" : "ç”Ÿæˆä½†æœªæ¨é€"}`;
        } else {
          stats.last_auto_predict_result = `é¢„æµ‹ç”Ÿæˆå¤±è´¥: ${syncResult.predictionResult.error || "æœªçŸ¥é”™è¯¯"}`;
        }
      } else if (syncResult.success && syncResult.added === 0) {
        stats.last_auto_predict_result = "åŒæ­¥æˆåŠŸä½†æ— æ–°è®°å½•ï¼Œæ— éœ€ç”Ÿæˆé¢„æµ‹";
      }
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await this.saveSetting(env, "AUTO_SYNC_STATS", JSON.stringify(stats));
      
      // æ›´æ–°æœ€ååŒæ­¥æ—¶é—´å’Œç»“æœ
      await this.saveSetting(env, "LAST_AUTO_SYNC", Formatter.formatDateTime());
      await this.saveSetting(env, "LAST_AUTO_SYNC_RESULT", syncResult.success ? 
        `æˆåŠŸï¼Œæ–°å¢ ${syncResult.added || 0} æ¡è®°å½•` : 
        `å¤±è´¥: ${syncResult.error || "æœªçŸ¥é”™è¯¯"}`);
      
      // æ›´æ–°ä¸‹æ¬¡åŒæ­¥æ—¶é—´
      if (syncResult.success) {
        const nextSync = Formatter.getNextSyncTime();
        await this.saveSetting(env, "AUTO_SYNC_NEXT_TIME", nextSync.formatted);
      }
      
      // è®°å½•åˆ°æ—¥å¿—è¡¨
      await env.DB.prepare(
        `INSERT INTO auto_sync_logs (
          success, added, skipped, total, new_count, 
          prediction_generated, channel_push_success, error_message
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
      ).bind(
        syncResult.success ? 1 : 0,
        syncResult.added || 0,
        syncResult.skipped || 0,
        syncResult.total || 0,
        syncResult.newCount || 0,
        syncResult.predictionResult ? (syncResult.predictionResult.success ? 1 : 0) : 0,
        syncResult.predictionResult ? (syncResult.predictionResult.channelPushSuccess ? 1 : 0) : 0,
        syncResult.error || ""
      ).run();
      
      CacheManager.set(`setting_AUTO_SYNC_STATS`, JSON.stringify(stats), 60000);
      
      Logger.info("DB", "è‡ªåŠ¨åŒæ­¥ç»Ÿè®¡å·²æ›´æ–°", stats);
      return true;
    } catch (error) {
      Logger.error("DB", "æ›´æ–°è‡ªåŠ¨åŒæ­¥ç»Ÿè®¡å¤±è´¥", error);
      return false;
    }
  },

  shouldRunAutoSync: async function(env) {
    try {
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨åŒæ­¥
      const enabled = await this.getSetting(env, "AUTO_SYNC_ENABLED", "0");
      if (enabled !== "1") {
        return { shouldRun: false, reason: "è‡ªåŠ¨åŒæ­¥æœªå¯ç”¨" };
      }
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯åŒæ­¥æ—¶é—´
      if (!Formatter.isSyncTime()) {
        return { shouldRun: false, reason: "ä¸æ˜¯åŒæ­¥æ—¶é—´" };
      }
      
      // æ£€æŸ¥ä¸Šæ¬¡åŒæ­¥æ—¶é—´ï¼Œé¿å…é‡å¤æ‰§è¡Œ
      const lastAutoSync = await this.getSetting(env, "LAST_AUTO_SYNC", "");
      if (lastAutoSync) {
        const lastSyncTime = new Date(lastAutoSync);
        const now = new Date();
        const diffMinutes = (now.getTime() - lastSyncTime.getTime()) / (1000 * 60);
        
        // å¦‚æœä¸Šæ¬¡åŒæ­¥åœ¨30åˆ†é’Ÿå†…ï¼Œè·³è¿‡
        if (diffMinutes < 30) {
          return { 
            shouldRun: false, 
            reason: `ä¸Šæ¬¡åŒæ­¥åœ¨ ${Math.floor(diffMinutes)} åˆ†é’Ÿå‰ï¼Œè·³è¿‡` 
          };
        }
      }
      
      return { shouldRun: true, reason: "å¯ä»¥æ‰§è¡Œè‡ªåŠ¨åŒæ­¥" };
    } catch (error) {
      Logger.error("DB", "æ£€æŸ¥æ˜¯å¦åº”è¿è¡Œè‡ªåŠ¨åŒæ­¥å¤±è´¥", error);
      return { shouldRun: false, reason: "æ£€æŸ¥å¤±è´¥: " + error.message };
    }
  },

  getAutoSyncLogs: async function(env, limit = 10) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM auto_sync_logs ORDER BY executed_at DESC LIMIT ?"
      ).bind(limit).all();
      
      return results || [];
    } catch (error) {
      Logger.error("DB", "è·å–è‡ªåŠ¨åŒæ­¥æ—¥å¿—å¤±è´¥", error);
      return [];
    }
  }
};
class KNNAlgorithm {
  static findSimilarRecords(history, targetRecord, k = 10) {
    try {
      if (!history || !Array.isArray(history) || history.length === 0 || !targetRecord) {
        return [];
      }
      
      const targetNumbers = targetRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      const targetFeatures = this.extractFeatures(targetNumbers);
      
      // è®¡ç®—æ‰€æœ‰å†å²è®°å½•ä¸ç›®æ ‡è®°å½•çš„ç›¸ä¼¼åº¦
      const distances = [];
      const currentDate = new Date();
      
      for (let i = 0; i < Math.min(history.length, 200); i++) {
        const record = history[i];
        if (!record || record.expect === targetRecord.expect) {
          continue;
        }
        
        const recordNumbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const recordFeatures = this.extractFeatures(recordNumbers);
        
        // è®¡ç®—ç‰¹å¾è·ç¦»
        const distance = this.calculateDistance(targetFeatures, recordFeatures);
        
        // è€ƒè™‘æ—¶é—´è¡°å‡å› å­ï¼ˆè¶Šè¿‘çš„è®°å½•æƒé‡è¶Šé«˜ï¼‰
        const timeDecay = this.calculateTimeDecay(record, currentDate);
        
        distances.push({
          record: record,
          distance: distance * timeDecay,
          rawDistance: distance,
          timeDecay: timeDecay
        });
      }
      
      // æŒ‰è·ç¦»æ’åºï¼Œå–å‰kä¸ª
      distances.sort((a, b) => a.distance - b.distance);
      return distances.slice(0, k);
    } catch (error) {
      Logger.error("KNNAlgorithm", "å¯»æ‰¾ç›¸ä¼¼è®°å½•å¤±è´¥", error);
      return [];
    }
  }

  static extractFeatures(numbers) {
    try {
      if (!Array.isArray(numbers) || numbers.length !== 7) {
        return {};
      }
      
      // æå–ç‰¹å¾
      const special = numbers[6];
      const normal = numbers.slice(0, 6);
      
      // ç”Ÿè‚–åˆ†å¸ƒ
      const zodiacCount = {};
      // æ³¢è‰²åˆ†å¸ƒ
      const colorCount = { red: 0, blue: 0, green: 0 };
      // å°¾æ•°åˆ†å¸ƒ
      const tailCount = {};
      // å¤´æ•°åˆ†å¸ƒ
      const headCount = {};
      // å¤§å°åˆ†å¸ƒ
      let bigCount = 0;
      // å•åŒåˆ†å¸ƒ
      let oddCount = 0;
      
      for (const num of numbers) {
        const attributes = Formatter.getAttributes(num);
        
        // ç”Ÿè‚–
        zodiacCount[attributes.zodiac] = (zodiacCount[attributes.zodiac] || 0) + 1;
        
        // æ³¢è‰²
        if (CONFIG.COLORS.red.includes(num)) colorCount.red++;
        else if (CONFIG.COLORS.blue.includes(num)) colorCount.blue++;
        else if (CONFIG.COLORS.green.includes(num)) colorCount.green++;
        
        // å°¾æ•°
        const tail = num % 10;
        tailCount[tail] = (tailCount[tail] || 0) + 1;
        
        // å¤´æ•°
        const head = Math.floor(num / 10);
        headCount[head] = (headCount[head] || 0) + 1;
        
        // å¤§å°
        if (num >= 25) bigCount++;
        
        // å•åŒ
        if (num % 2 !== 0) oddCount++;
      }
      
      // è®¡ç®—ç»Ÿè®¡ç‰¹å¾
      const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
      const variance = numbers.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numbers.length;
      
      return {
        special: special,
        normal: normal,
        zodiacCount: zodiacCount,
        colorCount: colorCount,
        tailCount: tailCount,
        headCount: headCount,
        bigCount: bigCount,
        oddCount: oddCount,
        mean: mean,
        variance: variance,
        sum: numbers.reduce((a, b) => a + b, 0)
      };
    } catch (error) {
      Logger.error("KNNAlgorithm", "æå–ç‰¹å¾å¤±è´¥", error);
      return {};
    }
  }

  static calculateDistance(features1, features2) {
    try {
      let distance = 0;
      
      // ç‰¹æ®Šå·ç è·ç¦»
      distance += Math.abs(features1.special - features2.special) * 0.5;
      
      // ç”Ÿè‚–åˆ†å¸ƒè·ç¦»
      const allZodiacs = new Set([...Object.keys(features1.zodiacCount), ...Object.keys(features2.zodiacCount)]);
      for (const zodiac of allZodiacs) {
        const count1 = features1.zodiacCount[zodiac] || 0;
        const count2 = features2.zodiacCount[zodiac] || 0;
        distance += Math.abs(count1 - count2) * 0.3;
      }
      
      // æ³¢è‰²åˆ†å¸ƒè·ç¦»
      for (const color of ['red', 'blue', 'green']) {
        const count1 = features1.colorCount[color] || 0;
        const count2 = features2.colorCount[color] || 0;
        distance += Math.abs(count1 - count2) * 0.2;
      }
      
      // å°¾æ•°åˆ†å¸ƒè·ç¦»
      const allTails = new Set([...Object.keys(features1.tailCount), ...Object.keys(features2.tailCount)]);
      for (const tail of allTails) {
        const count1 = features1.tailCount[tail] || 0;
        const count2 = features2.tailCount[tail] || 0;
        distance += Math.abs(count1 - count2) * 0.1;
      }
      
      // å…¶ä»–ç‰¹å¾è·ç¦»
      distance += Math.abs(features1.bigCount - features2.bigCount) * 0.2;
      distance += Math.abs(features1.oddCount - features2.oddCount) * 0.2;
      distance += Math.abs(features1.mean - features2.mean) * 0.05;
      distance += Math.abs(features1.sum - features2.sum) * 0.01;
      
      return distance;
    } catch (error) {
      Logger.error("KNNAlgorithm", "è®¡ç®—è·ç¦»å¤±è´¥", error);
      return 1000; // è¿”å›å¤§è·ç¦»è¡¨ç¤ºä¸ç›¸ä¼¼
    }
  }

  static calculateTimeDecay(record, currentDate) {
    try {
      // æ ¹æ®è®°å½•æ—¶é—´è®¡ç®—è¡°å‡å› å­
      const recordDate = new Date(record.created_at || currentDate);
      const diffDays = (currentDate - recordDate) / (1000 * 60 * 60 * 24);
      
      // ä½¿ç”¨æŒ‡æ•°è¡°å‡
      return Math.exp(-diffDays / 30); // 30å¤©åŠè¡°æœŸ
    } catch (error) {
      return 1.0;
    }
  }

  static predictFromSimilar(similarRecords, weights) {
    try {
      if (!similarRecords || similarRecords.length === 0) {
        return { specialNumbers: [], normalNumbers: [], confidence: 0 };
      }
      
      // åˆ†æç›¸ä¼¼è®°å½•çš„æ¨¡å¼
      const specialNumbers = new Map();
      const normalNumbers = new Map();
      
      for (const item of similarRecords) {
        const record = item.record;
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        // ç»Ÿè®¡ç‰¹æ®Šå·ç 
        const special = numbers[6];
        specialNumbers.set(special, (specialNumbers.get(special) || 0) + 1);
        
        // ç»Ÿè®¡å¹³ç 
        for (let i = 0; i < 6; i++) {
          const num = numbers[i];
          normalNumbers.set(num, (normalNumbers.get(num) || 0) + 1);
        }
      }
      
      // æ ¹æ®å‡ºç°é¢‘ç‡æ’åº
      const sortedSpecial = Array.from(specialNumbers.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      const sortedNormal = Array.from(normalNumbers.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 12);
      
      // è®¡ç®—ç½®ä¿¡åº¦
      const maxFrequency = Math.max(...sortedSpecial.map(s => s[1]), ...sortedNormal.map(n => n[1]));
      const totalRecords = similarRecords.length;
      const confidence = Math.min(100, (maxFrequency / totalRecords) * 100);
      
      return {
        specialNumbers: sortedSpecial.map(([number, freq]) => ({
          number,
          frequency: freq,
          probability: freq / totalRecords
        })),
        normalNumbers: sortedNormal.map(([number, freq]) => ({
          number,
          frequency: freq,
          probability: freq / totalRecords
        })),
        confidence: Math.round(confidence),
        algorithm: "knn",
        sampleSize: similarRecords.length
      };
    } catch (error) {
      Logger.error("KNNAlgorithm", "åŸºäºç›¸ä¼¼è®°å½•é¢„æµ‹å¤±è´¥", error);
      return { specialNumbers: [], normalNumbers: [], confidence: 0 };
    }
  }
}
class EnhancedStatistics {
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length === 0) {
        return null;
      }
      
      const stats = {
        totalRecords: history.length,
        zodiacStats: {},
        colorStats: {},
        tailStats: {},
        headStats: {},
        sizeStats: { big: 0, small: 0 },
        oddEvenStats: { odd: 0, even: 0 },
        patternStats: {},
        transferProbabilities: {},
        correlations: {},
        recentTrends: {}
      };
      
      // åˆå§‹åŒ–ç»Ÿè®¡
      this.initializeStats(stats);
      
      // åˆ†æå†å²è®°å½•
      for (let i = 0; i < Math.min(history.length, CONFIG.SYSTEM.STATS_WINDOW_SIZE); i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        this.analyzeRecord(numbers, stats, i);
      }
      
      // è®¡ç®—è½¬ç§»æ¦‚ç‡
      this.calculateTransferProbabilities(history, stats);
      
      // è®¡ç®—ç›¸å…³æ€§
      this.calculateCorrelations(stats);
      
      // è¯†åˆ«è¶‹åŠ¿
      this.identifyTrends(history, stats);
      
      // è®¡ç®—æœ€ç»ˆç»Ÿè®¡
      this.finalizeStatistics(stats);
      
      return stats;
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå†å²ç»Ÿè®¡å¤±è´¥", error);
      return null;
    }
  }

  static initializeStats(stats) {
    // åˆå§‹åŒ–ç”Ÿè‚–ç»Ÿè®¡
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      stats.zodiacStats[zodiac] = {
        count: 0,
        asSpecial: 0,
        asNormal: 0,
        frequency: 0,
        lastAppearance: -1,
        omission: 0
      };
    }
    
    // åˆå§‹åŒ–æ³¢è‰²ç»Ÿè®¡
    for (const color of Object.keys(CONFIG.COLORS)) {
      stats.colorStats[color] = {
        count: 0,
        frequency: 0,
        lastAppearance: -1,
        omission: 0
      };
    }
    
    // åˆå§‹åŒ–å°¾æ•°ç»Ÿè®¡ï¼ˆ0-9ï¼‰
    for (let i = 0; i <= 9; i++) {
      stats.tailStats[i] = {
        count: 0,
        frequency: 0,
        lastAppearance: -1,
        omission: 0
      };
    }
    
    // åˆå§‹åŒ–å¤´æ•°ç»Ÿè®¡ï¼ˆ0-4ï¼‰
    for (let i = 0; i <= 4; i++) {
      stats.headStats[i] = {
        count: 0,
        frequency: 0,
        lastAppearance: -1,
        omission: 0
      };
    }
  }

  static analyzeRecord(numbers, stats, index) {
    const special = numbers[6];
    const normalNumbers = numbers.slice(0, 6);
    
    // åˆ†ææ¯ä¸ªå·ç 
    for (let i = 0; i < numbers.length; i++) {
      const num = numbers[i];
      const isSpecial = (i === 6);
      
      // ç”Ÿè‚–ç»Ÿè®¡
      const zodiac = Formatter.getAttributes(num).zodiac;
      if (stats.zodiacStats[zodiac]) {
        stats.zodiacStats[zodiac].count++;
        if (isSpecial) {
          stats.zodiacStats[zodiac].asSpecial++;
        } else {
          stats.zodiacStats[zodiac].asNormal++;
        }
        stats.zodiacStats[zodiac].lastAppearance = index;
      }
      
      // æ³¢è‰²ç»Ÿè®¡
      for (const [color, colorNumbers] of Object.entries(CONFIG.COLORS)) {
        if (colorNumbers.includes(num)) {
          stats.colorStats[color].count++;
          stats.colorStats[color].lastAppearance = index;
          break;
        }
      }
      
      // å°¾æ•°ç»Ÿè®¡
      const tail = num % 10;
      if (stats.tailStats[tail]) {
        stats.tailStats[tail].count++;
        stats.tailStats[tail].lastAppearance = index;
      }
      
      // å¤´æ•°ç»Ÿè®¡
      const head = Math.floor(num / 10);
      if (head <= 4 && stats.headStats[head]) {
        stats.headStats[head].count++;
        stats.headStats[head].lastAppearance = index;
      }
      
      // å¤§å°ç»Ÿè®¡
      if (num >= 25) {
        stats.sizeStats.big++;
      } else {
        stats.sizeStats.small++;
      }
      
      // å•åŒç»Ÿè®¡
      if (num % 2 !== 0) {
        stats.oddEvenStats.odd++;
      } else {
        stats.oddEvenStats.even++;
      }
    }
    
    // æ¨¡å¼ç»Ÿè®¡
    this.analyzePatterns(numbers, stats, index);
  }

  static analyzePatterns(numbers, stats, index) {
    // åˆ†æè¿å·æ¨¡å¼
    const sortedNumbers = [...numbers].sort((a, b) => a - b);
    let consecutiveCount = 1;
    let maxConsecutive = 1;
    
    for (let i = 1; i < sortedNumbers.length; i++) {
      if (sortedNumbers[i] === sortedNumbers[i-1] + 1) {
        consecutiveCount++;
        maxConsecutive = Math.max(maxConsecutive, consecutiveCount);
      } else {
        consecutiveCount = 1;
      }
    }
    
    if (!stats.patternStats.consecutive) {
      stats.patternStats.consecutive = { max: 0, average: 0, total: 0, count: 0 };
    }
    stats.patternStats.consecutive.max = Math.max(stats.patternStats.consecutive.max, maxConsecutive);
    stats.patternStats.consecutive.total += maxConsecutive;
    stats.patternStats.consecutive.count++;
    
    // åˆ†æå’Œå€¼
    const sum = numbers.reduce((a, b) => a + b, 0);
    if (!stats.patternStats.sum) {
      stats.patternStats.sum = { min: Infinity, max: -Infinity, total: 0, count: 0 };
    }
    stats.patternStats.sum.min = Math.min(stats.patternStats.sum.min, sum);
    stats.patternStats.sum.max = Math.max(stats.patternStats.sum.max, sum);
    stats.patternStats.sum.total += sum;
    stats.patternStats.sum.count++;
    
    // åˆ†æACå€¼
    const acValue = this.calculateACValue(numbers);
    if (!stats.patternStats.acValue) {
      stats.patternStats.acValue = { min: Infinity, max: -Infinity, total: 0, count: 0 };
    }
    stats.patternStats.acValue.min = Math.min(stats.patternStats.acValue.min, acValue);
    stats.patternStats.acValue.max = Math.max(stats.patternStats.acValue.max, acValue);
    stats.patternStats.acValue.total += acValue;
    stats.patternStats.acValue.count++;
  }

  static calculateACValue(numbers) {
    // ACå€¼ = ä¸åŒæ­£æ•°å·®å€¼çš„ä¸ªæ•° - (é€‰å·ä¸ªæ•° - 1)
    const differences = new Set();
    const sortedNumbers = [...numbers].sort((a, b) => a - b);
    
    for (let i = 0; i < sortedNumbers.length; i++) {
      for (let j = i + 1; j < sortedNumbers.length; j++) {
        differences.add(sortedNumbers[j] - sortedNumbers[i]);
      }
    }
    
    return differences.size - (numbers.length - 1);
  }

  static calculateTransferProbabilities(history, stats) {
    if (history.length < 2) return;
    
    // ç”Ÿè‚–è½¬ç§»æ¦‚ç‡
    stats.transferProbabilities.zodiac = {};
    for (const zodiac1 of Object.keys(CONFIG.ZODIAC_MAP)) {
      stats.transferProbabilities.zodiac[zodiac1] = {};
      for (const zodiac2 of Object.keys(CONFIG.ZODIAC_MAP)) {
        stats.transferProbabilities.zodiac[zodiac1][zodiac2] = 0;
      }
    }
    
    // æ³¢è‰²è½¬ç§»æ¦‚ç‡
    stats.transferProbabilities.color = {};
    for (const color1 of Object.keys(CONFIG.COLORS)) {
      stats.transferProbabilities.color[color1] = {};
      for (const color2 of Object.keys(CONFIG.COLORS)) {
        stats.transferProbabilities.color[color1][color2] = 0;
      }
    }
    
    // å°¾æ•°è½¬ç§»æ¦‚ç‡
    stats.transferProbabilities.tail = {};
    for (let i = 0; i <= 9; i++) {
      stats.transferProbabilities.tail[i] = {};
      for (let j = 0; j <= 9; j++) {
        stats.transferProbabilities.tail[i][j] = 0;
      }
    }
    
    // è®¡ç®—è½¬ç§»æ¬¡æ•°
    let totalTransfers = 0;
    for (let i = 1; i < Math.min(history.length, 100); i++) {
      const prevRecord = history[i-1];
      const currRecord = history[i];
      
      if (!prevRecord || !currRecord) continue;
      
      const prevNumbers = prevRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      const currNumbers = currRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      
      // ç”Ÿè‚–è½¬ç§»
      const prevZodiac = Formatter.getAttributes(prevNumbers[6]).zodiac;
      const currZodiac = Formatter.getAttributes(currNumbers[6]).zodiac;
      if (stats.transferProbabilities.zodiac[prevZodiac] && 
          stats.transferProbabilities.zodiac[prevZodiac][currZodiac] !== undefined) {
        stats.transferProbabilities.zodiac[prevZodiac][currZodiac]++;
      }
      
      // æ³¢è‰²è½¬ç§»
      const prevColor = this.getColorForNumber(prevNumbers[6]);
      const currColor = this.getColorForNumber(currNumbers[6]);
      if (stats.transferProbabilities.color[prevColor] && 
          stats.transferProbabilities.color[prevColor][currColor] !== undefined) {
        stats.transferProbabilities.color[prevColor][currColor]++;
      }
      
      // å°¾æ•°è½¬ç§»
      const prevTail = prevNumbers[6] % 10;
      const currTail = currNumbers[6] % 10;
      if (stats.transferProbabilities.tail[prevTail] && 
          stats.transferProbabilities.tail[prevTail][currTail] !== undefined) {
        stats.transferProbabilities.tail[prevTail][currTail]++;
      }
      
      totalTransfers++;
    }
    
    // è½¬æ¢ä¸ºæ¦‚ç‡
    if (totalTransfers > 0) {
      for (const zodiac1 of Object.keys(CONFIG.ZODIAC_MAP)) {
        const total = Object.values(stats.transferProbabilities.zodiac[zodiac1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          for (const zodiac2 of Object.keys(CONFIG.ZODIAC_MAP)) {
            stats.transferProbabilities.zodiac[zodiac1][zodiac2] /= total;
          }
        }
      }
      
      for (const color1 of Object.keys(CONFIG.COLORS)) {
        const total = Object.values(stats.transferProbabilities.color[color1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          for (const color2 of Object.keys(CONFIG.COLORS)) {
            stats.transferProbabilities.color[color1][color2] /= total;
          }
        }
      }
      
      for (let i = 0; i <= 9; i++) {
        const total = Object.values(stats.transferProbabilities.tail[i]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          for (let j = 0; j <= 9; j++) {
            stats.transferProbabilities.tail[i][j] /= total;
          }
        }
      }
    }
  }

  static getColorForNumber(num) {
    for (const [color, numbers] of Object.entries(CONFIG.COLORS)) {
      if (numbers.includes(num)) {
        return color;
      }
    }
    return "unknown";
  }

  static calculateCorrelations(stats) {
    // è®¡ç®—ç”Ÿè‚–ç›¸å…³æ€§
    stats.correlations.zodiac = {};
    const zodiacs = Object.keys(CONFIG.ZODIAC_MAP);
    
    for (let i = 0; i < zodiacs.length; i++) {
      for (let j = i + 1; j < zodiacs.length; j++) {
        const zodiac1 = zodiacs[i];
        const zodiac2 = zodiacs[j];
        
        // ç®€å•ç›¸å…³æ€§è®¡ç®—
        const freq1 = stats.zodiacStats[zodiac1].frequency || 0;
        const freq2 = stats.zodiacStats[zodiac2].frequency || 0;
        const correlation = 1 - Math.abs(freq1 - freq2);
        
        stats.correlations.zodiac[`${zodiac1}-${zodiac2}`] = correlation;
      }
    }
    
    // è®¡ç®—æ³¢è‰²ç›¸å…³æ€§
    stats.correlations.color = {};
    const colors = Object.keys(CONFIG.COLORS);
    
    for (let i = 0; i < colors.length; i++) {
      for (let j = i + 1; j < colors.length; j++) {
        const color1 = colors[i];
        const color2 = colors[j];
        
        const freq1 = stats.colorStats[color1].frequency || 0;
        const freq2 = stats.colorStats[color2].frequency || 0;
        const correlation = 1 - Math.abs(freq1 - freq2);
        
        stats.correlations.color[`${color1}-${color2}`] = correlation;
      }
    }
  }

  static identifyTrends(history, stats) {
    if (history.length < 10) return;
    
    // åˆ†æè¿‘æœŸè¶‹åŠ¿
    const recentRecords = history.slice(0, Math.min(20, history.length));
    
    // ç”Ÿè‚–è¶‹åŠ¿
    const recentZodiacs = [];
    for (const record of recentRecords) {
      if (record && record.open_code) {
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const zodiac = Formatter.getAttributes(numbers[6]).zodiac;
        recentZodiacs.push(zodiac);
      }
    }
    
    // è®¡ç®—ç”Ÿè‚–å‡ºç°é¢‘ç‡è¶‹åŠ¿
    const zodiacTrends = {};
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const count = recentZodiacs.filter(z => z === zodiac).length;
      zodiacTrends[zodiac] = count / recentZodiacs.length;
    }
    
    stats.recentTrends.zodiac = zodiacTrends;
    
    // æ³¢è‰²è¶‹åŠ¿
    const recentColors = [];
    for (const record of recentRecords) {
      if (record && record.open_code) {
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const color = this.getColorForNumber(numbers[6]);
        recentColors.push(color);
      }
    }
    
    const colorTrends = {};
    for (const color of Object.keys(CONFIG.COLORS)) {
      const count = recentColors.filter(c => c === color).length;
      colorTrends[color] = count / recentColors.length;
    }
    
    stats.recentTrends.color = colorTrends;
    
    // å°¾æ•°è¶‹åŠ¿
    const recentTails = [];
    for (const record of recentRecords) {
      if (record && record.open_code) {
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const tail = numbers[6] % 10;
        recentTails.push(tail);
      }
    }
    
    const tailTrends = {};
    for (let i = 0; i <= 9; i++) {
      const count = recentTails.filter(t => t === i).length;
      tailTrends[i] = count / recentTails.length;
    }
    
    stats.recentTrends.tail = tailTrends;
  }

  static finalizeStatistics(stats) {
    const totalAnalyzed = Math.min(stats.totalRecords, CONFIG.SYSTEM.STATS_WINDOW_SIZE);
    
    // è®¡ç®—é¢‘ç‡å’Œé—æ¼
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const zodiacStat = stats.zodiacStats[zodiac];
      zodiacStat.frequency = zodiacStat.count / (totalAnalyzed * 7); // æ¯ä¸ªè®°å½•7ä¸ªå·ç 
      zodiacStat.omission = totalAnalyzed - zodiacStat.lastAppearance;
    }
    
    for (const color of Object.keys(CONFIG.COLORS)) {
      const colorStat = stats.colorStats[color];
      colorStat.frequency = colorStat.count / (totalAnalyzed * 7);
      colorStat.omission = totalAnalyzed - colorStat.lastAppearance;
    }
    
    for (let i = 0; i <= 9; i++) {
      const tailStat = stats.tailStats[i];
      tailStat.frequency = tailStat.count / (totalAnalyzed * 7);
      tailStat.omission = totalAnalyzed - tailStat.lastAppearance;
    }
    
    for (let i = 0; i <= 4; i++) {
      const headStat = stats.headStats[i];
      if (headStat) {
        headStat.frequency = headStat.count / (totalAnalyzed * 7);
        headStat.omission = totalAnalyzed - headStat.lastAppearance;
      }
    }
    
    // è®¡ç®—å¹³å‡å€¼
    if (stats.patternStats.consecutive && stats.patternStats.consecutive.count > 0) {
      stats.patternStats.consecutive.average = 
        stats.patternStats.consecutive.total / stats.patternStats.consecutive.count;
    }
    
    if (stats.patternStats.sum && stats.patternStats.sum.count > 0) {
      stats.patternStats.sum.average = 
        stats.patternStats.sum.total / stats.patternStats.sum.count;
    }
    
    if (stats.patternStats.acValue && stats.patternStats.acValue.count > 0) {
      stats.patternStats.acValue.average = 
        stats.patternStats.acValue.total / stats.patternStats.acValue.count;
    }
  }

  static generatePrediction(stats, weights) {
    try {
      if (!stats) {
        return { specialNumbers: [], normalNumbers: [], confidence: 0 };
      }
      
      const prediction = {
        specialNumbers: [],
        normalNumbers: [],
        zodiac: { main: [], guard: [], scores: {} },
        color: { main: "", guard: "", scores: {} },
        head: "",
        shape: "",
        confidence: 0,
        algorithm: "stats"
      };
      
      // ç”Ÿæˆç”Ÿè‚–æ¨è
      this.generateZodiacPrediction(stats, prediction, weights);
      
      // ç”Ÿæˆæ³¢è‰²æ¨è
      this.generateColorPrediction(stats, prediction, weights);
      
      // ç”Ÿæˆå·ç é¢„æµ‹
      this.generateNumberPrediction(stats, prediction, weights);
      
      // è®¡ç®—å½¢æ€åˆ†æ
      this.calculateShape(stats, prediction);
      
      // è®¡ç®—ç½®ä¿¡åº¦
      prediction.confidence = this.calculateConfidence(stats, prediction);
      
      return prediction;
    } catch (error) {
      Logger.error("EnhancedStatistics", "ç”Ÿæˆé¢„æµ‹å¤±è´¥", error);
      return { specialNumbers: [], normalNumbers: [], confidence: 0 };
    }
  }

  static generateZodiacPrediction(stats, prediction, weights) {
    // æ ¹æ®é—æ¼ã€é¢‘ç‡ã€è¿‘æœŸè¶‹åŠ¿ç»¼åˆè¯„åˆ†
    const zodiacScores = new Map();
    
    for (const [zodiac, zodiacStat] of Object.entries(stats.zodiacStats)) {
      let score = 0;
      
      // é—æ¼åŠ åˆ†ï¼ˆé—æ¼è¶Šä¹…ï¼Œåˆ†æ•°è¶Šé«˜ï¼‰
      score += zodiacStat.omission * 0.5 * weights.w_zodiac_transfer;
      
      // è¿‘æœŸè¶‹åŠ¿åŠ åˆ†
      const recentTrend = stats.recentTrends.zodiac[zodiac] || 0;
      score += (1 - recentTrend) * 100 * weights.w_zodiac_relation;
      
      // ä½œä¸ºç‰¹æ®Šå·ç çš„é¢‘ç‡
      const specialRate = zodiacStat.asSpecial / (zodiacStat.count || 1);
      score += specialRate * 50 * weights.w_zodiac_transfer;
      
      zodiacScores.set(zodiac, score);
    }
    
    // æ’åºå¹¶é€‰æ‹©
    const sortedZodiacs = Array.from(zodiacScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    prediction.zodiac.scores = Object.fromEntries(zodiacScores);
    
    // ä¸»æ¨ç”Ÿè‚–ï¼ˆå‰3ä¸ªï¼‰
    prediction.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    
    // é˜²å®ˆç”Ÿè‚–ï¼ˆ4-6ä¸ªï¼‰
    prediction.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
  }

  static generateColorPrediction(stats, prediction, weights) {
    const colorScores = new Map();
    
    for (const [color, colorStat] of Object.entries(stats.colorStats)) {
      let score = 0;
      
      // é—æ¼åŠ åˆ†
      score += colorStat.omission * 0.3 * weights.w_color_transfer;
      
      // è¿‘æœŸè¶‹åŠ¿
      const recentTrend = stats.recentTrends.color[color] || 0;
      score += (1 - recentTrend) * 80 * weights.w_color_transfer;
      
      // è½¬ç§»æ¦‚ç‡
      if (stats.transferProbabilities.color) {
        const lastColor = this.getLastColor(stats);
        if (lastColor && stats.transferProbabilities.color[lastColor]) {
          const transferProb = stats.transferProbabilities.color[lastColor][color] || 0;
          score += transferProb * 100 * weights.w_color_transfer;
        }
      }
      
      colorScores.set(color, score);
    }
    
    const sortedColors = Array.from(colorScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    prediction.color.scores = Object.fromEntries(colorScores);
    
    if (sortedColors.length > 0) {
      prediction.color.main = sortedColors[0][0];
    }
    if (sortedColors.length > 1) {
      prediction.color.guard = sortedColors[1][0];
    }
  }

  static getLastColor(stats) {
    // æ‰¾åˆ°æœ€è¿‘å‡ºç°çš„æ³¢è‰²
    let lastColor = null;
    let minOmission = Infinity;
    
    for (const [color, colorStat] of Object.entries(stats.colorStats)) {
      if (colorStat.omission < minOmission) {
        minOmission = colorStat.omission;
        lastColor = color;
      }
    }
    
    return lastColor;
  }

  static generateNumberPrediction(stats, prediction, weights) {
    const specialScores = new Map();
    const normalScores = new Map();
    
    // ä¸ºæ¯ä¸ªå·ç è¯„åˆ†
    for (let num = 1; num <= 49; num++) {
      let specialScore = 0;
      let normalScore = 0;
      
      const attributes = Formatter.getAttributes(num);
      const zodiac = attributes.zodiac;
      const color = attributes.color;
      const tail = num % 10;
      const head = Math.floor(num / 10);
      
      // ç”Ÿè‚–åˆ†æ•°
      const zodiacScore = prediction.zodiac.scores[zodiac] || 0;
      specialScore += zodiacScore * 0.3;
      normalScore += zodiacScore * 0.2;
      
      // æ³¢è‰²åˆ†æ•°
      const colorScore = prediction.color.scores[color] || 0;
      specialScore += colorScore * 0.4;
      normalScore += colorScore * 0.3;
      
      // å°¾æ•°åˆ†æ•°
      const tailStat = stats.tailStats[tail];
      if (tailStat) {
        specialScore += tailStat.omission * 0.2 * weights.w_tail_correlation;
        normalScore += tailStat.omission * 0.15 * weights.w_tail_correlation;
      }
      
      // å¤´æ•°åˆ†æ•°
      if (head <= 4) {
        const headStat = stats.headStats[head];
        if (headStat) {
          specialScore += headStat.omission * 0.1;
          normalScore += headStat.omission * 0.1;
        }
      }
      
      // çƒ­é—¨å†·é—¨åˆ†æ
      const hotCold = this.analyzeHotCold(num, stats);
      specialScore += hotCold * 20 * weights.w_hot_cold;
      normalScore += hotCold * 15 * weights.w_hot_cold;
      
      specialScores.set(num, specialScore);
      normalScores.set(num, normalScore);
    }
    
    // é€‰æ‹©ç‰¹æ®Šå·ç 
    const sortedSpecial = Array.from(specialScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 100,
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    // é€‰æ‹©å¹³ç 
    const sortedNormal = Array.from(normalScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 100,
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    prediction.specialNumbers = sortedSpecial;
    prediction.normalNumbers = sortedNormal;
  }

  static analyzeHotCold(number, stats) {
    // åˆ†æå·ç å†·çƒ­çŠ¶æ€
    // æ­£æ•°è¡¨ç¤ºçƒ­é—¨ï¼Œè´Ÿæ•°è¡¨ç¤ºå†·é—¨
    const zodiac = Formatter.getAttributes(number).zodiac;
    const zodiacStat = stats.zodiacStats[zodiac];
    const color = Formatter.getAttributes(number).color;
    const colorStat = stats.colorStats[color];
    
    let hotColdScore = 0;
    
    // ç”Ÿè‚–é—æ¼åˆ†æ
    if (zodiacStat) {
      const avgOmission = this.calculateAverageOmission(stats.zodiacStats);
      if (zodiacStat.omission > avgOmission * 1.5) {
        hotColdScore -= 1; // å†·é—¨
      } else if (zodiacStat.omission < avgOmission * 0.5) {
        hotColdScore += 1; // çƒ­é—¨
      }
    }
    
    // æ³¢è‰²é—æ¼åˆ†æ
    if (colorStat) {
      const avgOmission = this.calculateAverageOmission(stats.colorStats);
      if (colorStat.omission > avgOmission * 1.5) {
        hotColdScore -= 0.5;
      } else if (colorStat.omission < avgOmission * 0.5) {
        hotColdScore += 0.5;
      }
    }
    
    return hotColdScore;
  }

  static calculateAverageOmission(stats) {
    const omissions = Object.values(stats).map(stat => stat.omission || 0);
    const validOmissions = omissions.filter(omission => omission > 0);
    
    if (validOmissions.length === 0) return 0;
    
    return validOmissions.reduce((a, b) => a + b, 0) / validOmissions.length;
  }

  static calculateShape(stats, prediction) {
    // è®¡ç®—å¤´æ•°å½¢æ€
    const headCounts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
    
    for (const num of prediction.normalNumbers.slice(0, 6)) {
      const head = Math.floor(num.number / 10);
      if (head <= 4) {
        headCounts[head] = (headCounts[head] || 0) + 1;
      }
    }
    
    // æ‰¾å‡ºæœ€å¤šçš„å¤´æ•°
    let maxHead = 0;
    let maxCount = 0;
    
    for (const [head, count] of Object.entries(headCounts)) {
      if (count > maxCount) {
        maxCount = count;
        maxHead = parseInt(head);
      }
    }
    
    prediction.head = `${maxHead}å¤´`;
    
    // è®¡ç®—å½¢æ€
    const bigCount = prediction.normalNumbers
      .slice(0, 6)
      .filter(num => num.number >= 25)
      .length;
    
    const oddCount = prediction.normalNumbers
      .slice(0, 6)
      .filter(num => num.number % 2 !== 0)
      .length;
    
    let shape = "";
    if (bigCount >= 4) shape += "å¤§";
    else if (bigCount <= 2) shape += "å°";
    else shape += "å‡è¡¡";
    
    shape += "/";
    
    if (oddCount >= 4) shape += "å•";
    else if (oddCount <= 2) shape += "åŒ";
    else shape += "å‡è¡¡";
    
    prediction.shape = shape;
  }

  static calculateConfidence(stats, prediction) {
    let confidence = 0;
    
    // åŸºäºç»Ÿè®¡æ•°æ®çš„ç½®ä¿¡åº¦
    if (stats.totalRecords >= 100) {
      confidence += 30;
    } else if (stats.totalRecords >= 50) {
      confidence += 20;
    } else if (stats.totalRecords >= 20) {
      confidence += 10;
    }
    
    // åŸºäºæ¨¡å¼ç¨³å®šæ€§çš„ç½®ä¿¡åº¦
    if (stats.patternStats && stats.patternStats.sum) {
      const sumRange = stats.patternStats.sum.max - stats.patternStats.sum.min;
      if (sumRange < 100) confidence += 20;
      else if (sumRange < 150) confidence += 10;
    }
    
    // åŸºäºç”Ÿè‚–é—æ¼çš„ç½®ä¿¡åº¦
    const zodiacOmissions = Object.values(stats.zodiacStats)
      .map(stat => stat.omission)
      .filter(omission => omission > 0);
    
    if (zodiacOmissions.length > 0) {
      const avgOmission = zodiacOmissions.reduce((a, b) => a + b, 0) / zodiacOmissions.length;
      if (avgOmission < 10) confidence += 20;
      else if (avgOmission < 20) confidence += 10;
    }
    
    return Math.min(100, confidence);
  }
}
class OmissionExpert {
  static async runOmission(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.omission) {
        Logger.warn("OmissionExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡é—æ¼åˆ†æ");
        return { success: false, error: "å†å²æ•°æ®ä¸è¶³" };
      }
      
      const startTime = Date.now();
      Logger.info("OmissionExpert", "å¼€å§‹é—æ¼å›è¡¥åˆ†æ", {
        historyLength: history.length,
        weight: weights.w_omission_balancing
      });
      
      const analysis = this.analyzeOmissions(history);
      const predictions = this.generateOmissionPredictions(analysis, weights);
      
      const duration = Date.now() - startTime;
      Logger.info("OmissionExpert", "é—æ¼å›è¡¥åˆ†æå®Œæˆ", {
        duration,
        extremeColdCount: analysis.summary.extremeColdCount,
        hotCount: analysis.summary.hotCount
      });
      
      return {
        success: true,
        algorithm: "omission",
        analysis: analysis,
        predictions: predictions,
        duration: duration,
        confidence: this.calculateConfidence(analysis)
      };
    } catch (error) {
      Logger.error("OmissionExpert", "é—æ¼å›è¡¥åˆ†æå¤±è´¥", error);
      return {
        success: false,
        error: error.message,
        algorithm: "omission"
      };
    }
  }

  static analyzeOmissions(history) {
    const analysis = {
      numberOmissions: {},
      zodiacOmissions: {},
      colorOmissions: {},
      tailOmissions: {},
      headOmissions: {},
      summary: {
        totalRecords: history.length,
        analyzedRecords: Math.min(history.length, 100)
      }
    };
    
    // åˆå§‹åŒ–é—æ¼æ•°æ®
    this.initializeOmissions(analysis);
    
    // åˆ†æå†å²è®°å½•
    const analyzedHistory = history.slice(0, analysis.summary.analyzedRecords);
    
    for (let i = 0; i < analyzedHistory.length; i++) {
      const record = analyzedHistory[i];
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      this.updateOmissions(analysis, numbers, i);
    }
    
    // è®¡ç®—æœ€ç»ˆé—æ¼æœŸæ•°
    this.finalizeOmissions(analysis, analyzedHistory.length);
    
    // è¯†åˆ«å†·çƒ­å·ç 
    this.identifyHotCold(analysis);
    
    // è®¡ç®—å‡å€¼å›å½’æŒ‡æ ‡
    this.calculateMeanReversion(analysis);
    
    return analysis;
  }

  static initializeOmissions(analysis) {
    // åˆå§‹åŒ–å·ç é—æ¼ï¼ˆ1-49ï¼‰
    for (let i = 1; i <= 49; i++) {
      analysis.numberOmissions[i] = {
        lastAppearance: -1,
        omission: 0,
        appearanceCount: 0,
        averageInterval: 0,
        maxOmission: 0
      };
    }
    
    // åˆå§‹åŒ–ç”Ÿè‚–é—æ¼
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      analysis.zodiacOmissions[zodiac] = {
        lastAppearance: -1,
        omission: 0,
        appearanceCount: 0,
        averageInterval: 0,
        maxOmission: 0
      };
    }
    
    // åˆå§‹åŒ–æ³¢è‰²é—æ¼
    for (const color of Object.keys(CONFIG.COLORS)) {
      analysis.colorOmissions[color] = {
        lastAppearance: -1,
        omission: 0,
        appearanceCount: 0,
        averageInterval: 0,
        maxOmission: 0
      };
    }
    
    // åˆå§‹åŒ–å°¾æ•°é—æ¼ï¼ˆ0-9ï¼‰
    for (let i = 0; i <= 9; i++) {
      analysis.tailOmissions[i] = {
        lastAppearance: -1,
        omission: 0,
        appearanceCount: 0,
        averageInterval: 0,
        maxOmission: 0
      };
    }
    
    // åˆå§‹åŒ–å¤´æ•°é—æ¼ï¼ˆ0-4ï¼‰
    for (let i = 0; i <= 4; i++) {
      analysis.headOmissions[i] = {
        lastAppearance: -1,
        omission: 0,
        appearanceCount: 0,
        averageInterval: 0,
        maxOmission: 0
      };
    }
  }

  static updateOmissions(analysis, numbers, index) {
    // æ›´æ–°æ‰€æœ‰å·ç çš„é—æ¼
    for (let i = 1; i <= 49; i++) {
      if (numbers.includes(i)) {
        const omissionData = analysis.numberOmissions[i];
        const lastInterval = index - omissionData.lastAppearance;
        
        if (omissionData.lastAppearance >= 0) {
          omissionData.averageInterval = (
            omissionData.averageInterval * omissionData.appearanceCount + lastInterval
          ) / (omissionData.appearanceCount + 1);
        }
        
        omissionData.lastAppearance = index;
        omissionData.appearanceCount++;
        omissionData.omission = 0;
        omissionData.maxOmission = Math.max(omissionData.maxOmission, lastInterval);
      } else if (analysis.numberOmissions[i].lastAppearance >= 0) {
        analysis.numberOmissions[i].omission++;
      }
    }
    
    // æ›´æ–°ç”Ÿè‚–é—æ¼
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const zodiacNumbers = CONFIG.ZODIAC_MAP[zodiac];
      const hasZodiac = numbers.some(num => zodiacNumbers.includes(num));
      
      if (hasZodiac) {
        const omissionData = analysis.zodiacOmissions[zodiac];
        const lastInterval = index - omissionData.lastAppearance;
        
        if (omissionData.lastAppearance >= 0) {
          omissionData.averageInterval = (
            omissionData.averageInterval * omissionData.appearanceCount + lastInterval
          ) / (omissionData.appearanceCount + 1);
        }
        
        omissionData.lastAppearance = index;
        omissionData.appearanceCount++;
        omissionData.omission = 0;
        omissionData.maxOmission = Math.max(omissionData.maxOmission, lastInterval);
      } else if (analysis.zodiacOmissions[zodiac].lastAppearance >= 0) {
        analysis.zodiacOmissions[zodiac].omission++;
      }
    }
    
    // æ›´æ–°æ³¢è‰²é—æ¼
    for (const color of Object.keys(CONFIG.COLORS)) {
      const colorNumbers = CONFIG.COLORS[color];
      const hasColor = numbers.some(num => colorNumbers.includes(num));
      
      if (hasColor) {
        const omissionData = analysis.colorOmissions[color];
        const lastInterval = index - omissionData.lastAppearance;
        
        if (omissionData.lastAppearance >= 0) {
          omissionData.averageInterval = (
            omissionData.averageInterval * omissionData.appearanceCount + lastInterval
          ) / (omissionData.appearanceCount + 1);
        }
        
        omissionData.lastAppearance = index;
        omissionData.appearanceCount++;
        omissionData.omission = 0;
        omissionData.maxOmission = Math.max(omissionData.maxOmission, lastInterval);
      } else if (analysis.colorOmissions[color].lastAppearance >= 0) {
        analysis.colorOmissions[color].omission++;
      }
    }
    
    // æ›´æ–°å°¾æ•°é—æ¼
    for (let tail = 0; tail <= 9; tail++) {
      const hasTail = numbers.some(num => num % 10 === tail);
      
      if (hasTail) {
        const omissionData = analysis.tailOmissions[tail];
        const lastInterval = index - omissionData.lastAppearance;
        
        if (omissionData.lastAppearance >= 0) {
          omissionData.averageInterval = (
            omissionData.averageInterval * omissionData.appearanceCount + lastInterval
          ) / (omissionData.appearanceCount + 1);
        }
        
        omissionData.lastAppearance = index;
        omissionData.appearanceCount++;
        omissionData.omission = 0;
        omissionData.maxOmission = Math.max(omissionData.maxOmission, lastInterval);
      } else if (analysis.tailOmissions[tail].lastAppearance >= 0) {
        analysis.tailOmissions[tail].omission++;
      }
    }
    
    // æ›´æ–°å¤´æ•°é—æ¼
    for (let head = 0; head <= 4; head++) {
      const hasHead = numbers.some(num => Math.floor(num / 10) === head);
      
      if (hasHead) {
        const omissionData = analysis.headOmissions[head];
        const lastInterval = index - omissionData.lastAppearance;
        
        if (omissionData.lastAppearance >= 0) {
          omissionData.averageInterval = (
            omissionData.averageInterval * omissionData.appearanceCount + lastInterval
          ) / (omissionData.appearanceCount + 1);
        }
        
        omissionData.lastAppearance = index;
        omissionData.appearanceCount++;
        omissionData.omission = 0;
        omissionData.maxOmission = Math.max(omissionData.maxOmission, lastInterval);
      } else if (analysis.headOmissions[head].lastAppearance >= 0) {
        analysis.headOmissions[head].omission++;
      }
    }
  }

  static finalizeOmissions(analysis, totalRecords) {
    // è®¡ç®—æœ€ç»ˆé—æ¼æœŸæ•°
    for (let i = 1; i <= 49; i++) {
      const omissionData = analysis.numberOmissions[i];
      if (omissionData.lastAppearance >= 0) {
        omissionData.omission = totalRecords - omissionData.lastAppearance - 1;
      } else {
        omissionData.omission = totalRecords;
        omissionData.averageInterval = totalRecords;
      }
    }
    
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const omissionData = analysis.zodiacOmissions[zodiac];
      if (omissionData.lastAppearance >= 0) {
        omissionData.omission = totalRecords - omissionData.lastAppearance - 1;
      } else {
        omissionData.omission = totalRecords;
        omissionData.averageInterval = totalRecords;
      }
    }
    
    for (const color of Object.keys(CONFIG.COLORS)) {
      const omissionData = analysis.colorOmissions[color];
      if (omissionData.lastAppearance >= 0) {
        omissionData.omission = totalRecords - omissionData.lastAppearance - 1;
      } else {
        omissionData.omission = totalRecords;
        omissionData.averageInterval = totalRecords;
      }
    }
    
    for (let tail = 0; tail <= 9; tail++) {
      const omissionData = analysis.tailOmissions[tail];
      if (omissionData.lastAppearance >= 0) {
        omissionData.omission = totalRecords - omissionData.lastAppearance - 1;
      } else {
        omissionData.omission = totalRecords;
        omissionData.averageInterval = totalRecords;
      }
    }
    
    for (let head = 0; head <= 4; head++) {
      const omissionData = analysis.headOmissions[head];
      if (omissionData.lastAppearance >= 0) {
        omissionData.omission = totalRecords - omissionData.lastAppearance - 1;
      } else {
        omissionData.omission = totalRecords;
        omissionData.averageInterval = totalRecords;
      }
    }
  }

  static identifyHotCold(analysis) {
    const numberStatus = {};
    const zodiacStatus = {};
    const colorStatus = {};
    
    // åˆ†æå·ç å†·çƒ­çŠ¶æ€
    for (let i = 1; i <= 49; i++) {
      const omissionData = analysis.numberOmissions[i];
      const ratio = omissionData.omission / (omissionData.averageInterval || 1);
      
      if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.extreme_cold) {
        numberStatus[i] = "extreme_cold";
      } else if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.cold) {
        numberStatus[i] = "cold";
      } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.hot) {
        numberStatus[i] = "hot";
      } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.normal) {
        numberStatus[i] = "normal";
      } else {
        numberStatus[i] = "warm";
      }
    }
    
    // åˆ†æç”Ÿè‚–å†·çƒ­çŠ¶æ€
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const omissionData = analysis.zodiacOmissions[zodiac];
      const ratio = omissionData.omission / (omissionData.averageInterval || 1);
      
      if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.extreme_cold) {
        zodiacStatus[zodiac] = "extreme_cold";
      } else if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.cold) {
        zodiacStatus[zodiac] = "cold";
      } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.hot) {
        zodiacStatus[zodiac] = "hot";
      } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.normal) {
        zodiacStatus[zodiac] = "normal";
      } else {
        zodiacStatus[zodiac] = "warm";
      }
    }
    
    // åˆ†ææ³¢è‰²å†·çƒ­çŠ¶æ€
    for (const color of Object.keys(CONFIG.COLORS)) {
      const omissionData = analysis.colorOmissions[color];
      const ratio = omissionData.omission / (omissionData.averageInterval || 1);
      
      if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.extreme_cold) {
        colorStatus[color] = "extreme_cold";
      } else if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.cold) {
        colorStatus[color] = "cold";
      } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.hot) {
        colorStatus[color] = "hot";
      } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.normal) {
        colorStatus[color] = "normal";
      } else {
        colorStatus[color] = "warm";
      }
    }
    
    analysis.numberStatus = numberStatus;
    analysis.zodiacStatus = zodiacStatus;
    analysis.colorStatus = colorStatus;
    
    // ç»Ÿè®¡æ‘˜è¦
    analysis.summary.extremeColdCount = Object.values(numberStatus).filter(s => s === "extreme_cold").length;
    analysis.summary.coldCount = Object.values(numberStatus).filter(s => s === "cold").length;
    analysis.summary.hotCount = Object.values(numberStatus).filter(s => s === "hot").length;
    analysis.summary.normalCount = Object.values(numberStatus).filter(s => s === "normal").length;
    analysis.summary.warmCount = Object.values(numberStatus).filter(s => s === "warm").length;
  }

  static calculateMeanReversion(analysis) {
    // è®¡ç®—å‡å€¼å›å½’æŒ‡æ ‡
    const meanReversion = {
      numbers: {},
      zodiacs: {},
      colors: {},
      overall: 0
    };
    
    let totalPressure = 0;
    let totalItems = 0;
    
    // å·ç çš„å‡å€¼å›å½’å‹åŠ›
    for (let i = 1; i <= 49; i++) {
      const omissionData = analysis.numberOmissions[i];
      const expectedInterval = omissionData.averageInterval || analysis.summary.analyzedRecords;
      const currentOmission = omissionData.omission;
      
      if (expectedInterval > 0) {
        const pressure = currentOmission / expectedInterval;
        meanReversion.numbers[i] = pressure;
        totalPressure += pressure;
        totalItems++;
      }
    }
    
    // ç”Ÿè‚–çš„å‡å€¼å›å½’å‹åŠ›
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const omissionData = analysis.zodiacOmissions[zodiac];
      const expectedInterval = omissionData.averageInterval || analysis.summary.analyzedRecords;
      const currentOmission = omissionData.omission;
      
      if (expectedInterval > 0) {
        const pressure = currentOmission / expectedInterval;
        meanReversion.zodiacs[zodiac] = pressure;
        totalPressure += pressure;
        totalItems++;
      }
    }
    
    // æ³¢è‰²çš„å‡å€¼å›å½’å‹åŠ›
    for (const color of Object.keys(CONFIG.COLORS)) {
      const omissionData = analysis.colorOmissions[color];
      const expectedInterval = omissionData.averageInterval || analysis.summary.analyzedRecords;
      const currentOmission = omissionData.omission;
      
      if (expectedInterval > 0) {
        const pressure = currentOmission / expectedInterval;
        meanReversion.colors[color] = pressure;
        totalPressure += pressure;
        totalItems++;
      }
    }
    
    if (totalItems > 0) {
      meanReversion.overall = totalPressure / totalItems;
    }
    
    analysis.meanReversion = meanReversion;
  }

  static generateOmissionPredictions(analysis, weights) {
    const predictions = {
      specialNumbers: [],
      normalNumbers: [],
      zodiac: { main: [], guard: [], scores: {} },
      color: { main: "", guard: "", scores: {} },
      confidence: 0
    };
    
    // åŸºäºé—æ¼è¯„åˆ†
    const specialScores = new Map();
    const normalScores = new Map();
    const zodiacScores = new Map();
    const colorScores = new Map();
    
    // è¯„åˆ†å‡½æ•°
    for (let i = 1; i <= 49; i++) {
      const omissionData = analysis.numberOmissions[i];
      const status = analysis.numberStatus[i];
      const pressure = analysis.meanReversion.numbers[i] || 0;
      
      let score = 0;
      
      // é—æ¼æœŸæ•°åŠ åˆ†ï¼ˆé—æ¼è¶Šä¹…ï¼Œåˆ†æ•°è¶Šé«˜ï¼‰
      score += omissionData.omission * 2 * weights.w_omission_balancing;
      
      // å‡å€¼å›å½’å‹åŠ›åŠ åˆ†
      score += pressure * 100 * weights.w_omission_balancing;
      
      // å†·çƒ­çŠ¶æ€åŠ åˆ†
      switch (status) {
        case "extreme_cold":
          score += 80;
          break;
        case "cold":
          score += 40;
          break;
        case "normal":
          score += 10;
          break;
        case "hot":
          score -= 20;
          break;
        case "warm":
          score += 5;
          break;
      }
      
      // å†å²æœ€å¤§é—æ¼åŠ åˆ†
      const maxOmissionRatio = omissionData.omission / (omissionData.maxOmission || 1);
      score += Math.min(maxOmissionRatio * 50, 50);
      
      specialScores.set(i, score);
      normalScores.set(i, score * 0.8); // å¹³ç æƒé‡ç•¥ä½
    }
    
    // ç”Ÿè‚–è¯„åˆ†
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      const omissionData = analysis.zodiacOmissions[zodiac];
      const status = analysis.zodiacStatus[zodiac];
      const pressure = analysis.meanReversion.zodiacs[zodiac] || 0;
      
      let score = 0;
      
      score += omissionData.omission * 1.5 * weights.w_omission_balancing;
      score += pressure * 80 * weights.w_omission_balancing;
      
      switch (status) {
        case "extreme_cold":
          score += 60;
          break;
        case "cold":
          score += 30;
          break;
        case "normal":
          score += 8;
          break;
        case "hot":
          score -= 15;
          break;
        case "warm":
          score += 4;
          break;
      }
      
      zodiacScores.set(zodiac, score);
    }
    
    // æ³¢è‰²è¯„åˆ†
    for (const color of Object.keys(CONFIG.COLORS)) {
      const omissionData = analysis.colorOmissions[color];
      const status = analysis.colorStatus[color];
      const pressure = analysis.meanReversion.colors[color] || 0;
      
      let score = 0;
      
      score += omissionData.omission * 1.2 * weights.w_omission_balancing;
      score += pressure * 60 * weights.w_omission_balancing;
      
      switch (status) {
        case "extreme_cold":
          score += 50;
          break;
        case "cold":
          score += 25;
          break;
        case "normal":
          score += 6;
          break;
        case "hot":
          score -= 12;
          break;
        case "warm":
          score += 3;
          break;
      }
      
      colorScores.set(color, score);
    }
    
    // é€‰æ‹©å·ç 
    const sortedSpecial = Array.from(specialScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 200, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color,
        omission: analysis.numberOmissions[number].omission,
        status: analysis.numberStatus[number]
      }));
    
    const sortedNormal = Array.from(normalScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 160, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color,
        omission: analysis.numberOmissions[number].omission,
        status: analysis.numberStatus[number]
      }));
    
    // é€‰æ‹©ç”Ÿè‚–
    const sortedZodiacs = Array.from(zodiacScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.zodiac.scores = Object.fromEntries(zodiacScores);
    predictions.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    predictions.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
    
    // é€‰æ‹©æ³¢è‰²
    const sortedColors = Array.from(colorScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.color.scores = Object.fromEntries(colorScores);
    predictions.color.main = sortedColors[0] ? sortedColors[0][0] : "";
    predictions.color.guard = sortedColors[1] ? sortedColors[1][0] : "";
    
    predictions.specialNumbers = sortedSpecial;
    predictions.normalNumbers = sortedNormal;
    
    // è®¡ç®—ç½®ä¿¡åº¦
    predictions.confidence = this.calculateConfidence(analysis);
    
    return predictions;
  }

  static calculateConfidence(analysis) {
    let confidence = 0;
    
    // åŸºäºæ•°æ®åˆ†ææ·±åº¦
    if (analysis.summary.analyzedRecords >= 100) {
      confidence += 40;
    } else if (analysis.summary.analyzedRecords >= 50) {
      confidence += 25;
    } else if (analysis.summary.analyzedRecords >= 30) {
      confidence += 15;
    }
    
    // åŸºäºæå†·å·ç æ•°é‡ï¼ˆè¶Šå¤šè¯´æ˜è¶Šå¯èƒ½å‡ºç°å›è¡¥ï¼‰
    const extremeColdRatio = analysis.summary.extremeColdCount / 49;
    confidence += Math.min(extremeColdRatio * 100, 30);
    
    // åŸºäºå‡å€¼å›å½’å‹åŠ›
    const pressure = analysis.meanReversion.overall;
    if (pressure > 2) {
      confidence += 30;
    } else if (pressure > 1.5) {
      confidence += 20;
    } else if (pressure > 1) {
      confidence += 10;
    }
    
    return Math.min(95, confidence);
  }
}
class AssociationExpert {
  static async runAssociation(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.association) {
        Logger.warn("AssociationExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡å…³è”åˆ†æ");
        return { success: false, error: "å†å²æ•°æ®ä¸è¶³" };
      }
      
      const startTime = Date.now();
      Logger.info("AssociationExpert", "å¼€å§‹å…³è”è§„åˆ™åˆ†æ", {
        historyLength: history.length,
        weight: weights.w_association_rules
      });
      
      const analysis = this.analyzeAssociations(history);
      const predictions = this.generateAssociationPredictions(analysis, weights);
      
      const duration = Date.now() - startTime;
      Logger.info("AssociationExpert", "å…³è”è§„åˆ™åˆ†æå®Œæˆ", {
        duration,
        strongRules: analysis.summary.strongRulesCount,
        frequentItemsets: analysis.summary.frequentItemsetsCount
      });
      
      return {
        success: true,
        algorithm: "association",
        analysis: analysis,
        predictions: predictions,
        duration: duration,
        confidence: this.calculateConfidence(analysis)
      };
    } catch (error) {
      Logger.error("AssociationExpert", "å…³è”è§„åˆ™åˆ†æå¤±è´¥", error);
      return {
        success: false,
        error: error.message,
        algorithm: "association"
      };
    }
  }

  static analyzeAssociations(history) {
    const analysis = {
      transactions: [],
      itemsets: {},
      rules: {},
      summary: {
        totalTransactions: 0,
        minSupport: CONFIG.SYSTEM.ASSOCIATION_MIN_SUPPORT
      }
    };
    
    // å‡†å¤‡äº‹åŠ¡æ•°æ®
    const analyzedHistory = history.slice(0, Math.min(history.length, 200));
    analysis.summary.totalTransactions = analyzedHistory.length;
    
    for (const record of analyzedHistory) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      const transaction = this.createTransaction(numbers);
      analysis.transactions.push(transaction);
    }
    
    // Aprioriç®—æ³•æŒ–æ˜é¢‘ç¹é¡¹é›†
    this.apriori(analysis);
    
    // ç”Ÿæˆå…³è”è§„åˆ™
    this.generateRules(analysis);
    
    // åˆ†æè§„åˆ™å¼ºåº¦
    this.analyzeRuleStrength(analysis);
    
    return analysis;
  }

  static createTransaction(numbers) {
    const transaction = new Set();
    
    // æ·»åŠ åŸå§‹å·ç 
    for (const num of numbers) {
      transaction.add(`N${num}`);
    }
    
    // æ·»åŠ ç”Ÿè‚–
    for (const num of numbers) {
      const zodiac = Formatter.getAttributes(num).zodiac;
      transaction.add(`Z${zodiac}`);
    }
    
    // æ·»åŠ æ³¢è‰²
    for (const num of numbers) {
      const color = Formatter.getAttributes(num).color;
      transaction.add(`C${color}`);
    }
    
    // æ·»åŠ å°¾æ•°
    for (const num of numbers) {
      const tail = num % 10;
      transaction.add(`T${tail}`);
    }
    
    // æ·»åŠ å¤´æ•°
    for (const num of numbers) {
      const head = Math.floor(num / 10);
      if (head <= 4) {
        transaction.add(`H${head}`);
      }
    }
    
    // æ·»åŠ å¤§å°
    for (const num of numbers) {
      const size = num >= 25 ? 'B' : 'S';
      transaction.add(`S${size}`);
    }
    
    // æ·»åŠ å•åŒ
    for (const num of numbers) {
      const parity = num % 2 === 0 ? 'E' : 'O';
      transaction.add(`P${parity}`);
    }
    
    return Array.from(transaction);
  }

  static apriori(analysis) {
    const transactions = analysis.transactions;
    const minSupport = analysis.summary.minSupport;
    const minSupportCount = Math.ceil(transactions.length * minSupport);
    
    // ç¬¬ä¸€æ­¥ï¼šç”Ÿæˆ1-é¡¹é›†
    let itemsets = this.generateOneItemsets(transactions, minSupportCount);
    analysis.itemsets[1] = itemsets;
    
    // è¿­ä»£ç”Ÿæˆk-é¡¹é›†
    let k = 2;
    while (true) {
      const candidateItemsets = this.generateCandidateItemsets(itemsets, k);
      const frequentItemsets = this.filterFrequentItemsets(candidateItemsets, transactions, minSupportCount);
      
      if (frequentItemsets.size === 0) {
        break;
      }
      
      analysis.itemsets[k] = frequentItemsets;
      itemsets = frequentItemsets;
      k++;
    }
    
    analysis.summary.maxItemsetSize = k - 1;
    analysis.summary.frequentItemsetsCount = Object.values(analysis.itemsets)
      .reduce((total, itemset) => total + itemset.size, 0);
  }

  static generateOneItemsets(transactions, minSupportCount) {
    const itemCounts = new Map();
    
    for (const transaction of transactions) {
      for (const item of transaction) {
        itemCounts.set(item, (itemCounts.get(item) || 0) + 1);
      }
    }
    
    // è¿‡æ»¤æ‰æ”¯æŒåº¦ä¸è¶³çš„é¡¹
    const frequentItemsets = new Map();
    for (const [item, count] of itemCounts.entries()) {
      if (count >= minSupportCount) {
        frequentItemsets.set(item, count);
      }
    }
    
    return frequentItemsets;
  }

  static generateCandidateItemsets(itemsets, k) {
    const candidates = new Map();
    const itemsArray = Array.from(itemsets.keys());
    
    // ç”Ÿæˆå€™é€‰k-é¡¹é›†
    for (let i = 0; i < itemsArray.length; i++) {
      for (let j = i + 1; j < itemsArray.length; j++) {
        const item1 = itemsArray[i];
        const item2 = itemsArray[j];
        
        // å¯¹äºk=2ï¼Œç›´æ¥ç»„åˆ
        if (k === 2) {
          const candidate = [item1, item2].sort();
          candidates.set(candidate.join(','), candidate);
        } else {
          // å¯¹äºk>2ï¼Œæ£€æŸ¥å‰k-1é¡¹æ˜¯å¦ç›¸åŒ
          const prefix1 = item1.split(',').slice(0, k-2);
          const prefix2 = item2.split(',').slice(0, k-2);
          
          if (JSON.stringify(prefix1) === JSON.stringify(prefix2)) {
            const candidate = Array.from(new Set([...item1.split(','), item2])).sort();
            if (candidate.length === k) {
              candidates.set(candidate.join(','), candidate);
            }
          }
        }
      }
    }
    
    return candidates;
  }

  static filterFrequentItemsets(candidates, transactions, minSupportCount) {
    const frequentItemsets = new Map();
    
    for (const [key, candidate] of candidates.entries()) {
      let count = 0;
      
      for (const transaction of transactions) {
        if (candidate.every(item => transaction.includes(item))) {
          count++;
        }
      }
      
      if (count >= minSupportCount) {
        frequentItemsets.set(key, { items: candidate, support: count / transactions.length });
      }
    }
    
    return frequentItemsets;
  }

  static generateRules(analysis) {
    const rules = [];
    
    // ä»2-é¡¹é›†å¼€å§‹ç”Ÿæˆè§„åˆ™
    for (let k = 2; k <= analysis.summary.maxItemsetSize; k++) {
      const itemsets = analysis.itemsets[k];
      
      if (!itemsets) continue;
      
      for (const [_, itemsetData] of itemsets.entries()) {
        const items = itemsetData.items;
        const support = itemsetData.support;
        
        // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§„åˆ™
        for (let i = 1; i < items.length; i++) {
          const antecedent = items.slice(0, i);
          const consequent = items.slice(i);
          
          // è®¡ç®—ç½®ä¿¡åº¦
          const confidence = this.calculateConfidence(antecedent, consequent, analysis);
          
          if (confidence > 0.5) { // åªä¿ç•™ç½®ä¿¡åº¦å¤§äº50%çš„è§„åˆ™
            rules.push({
              antecedent,
              consequent,
              support,
              confidence,
              lift: this.calculateLift(antecedent, consequent, analysis)
            });
          }
        }
      }
    }
    
    // æŒ‰ç½®ä¿¡åº¦æ’åº
    rules.sort((a, b) => b.confidence - a.confidence);
    analysis.rules.list = rules;
    analysis.summary.strongRulesCount = rules.length;
  }

  static calculateConfidence(antecedent, consequent, analysis) {
    // ç½®ä¿¡åº¦ = P(consequent | antecedent) = support(antecedent âˆª consequent) / support(antecedent)
    const transactions = analysis.transactions;
    
    let antecedentCount = 0;
    let unionCount = 0;
    
    for (const transaction of transactions) {
      if (antecedent.every(item => transaction.includes(item))) {
        antecedentCount++;
        if (consequent.every(item => transaction.includes(item))) {
          unionCount++;
        }
      }
    }
    
    return antecedentCount > 0 ? unionCount / antecedentCount : 0;
  }

  static calculateLift(antecedent, consequent, analysis) {
    // æå‡åº¦ = P(antecedent âˆ© consequent) / (P(antecedent) * P(consequent))
    const transactions = analysis.transactions;
    
    let antecedentCount = 0;
    let consequentCount = 0;
    let unionCount = 0;
    
    for (const transaction of transactions) {
      const hasAntecedent = antecedent.every(item => transaction.includes(item));
      const hasConsequent = consequent.every(item => transaction.includes(item));
      
      if (hasAntecedent) antecedentCount++;
      if (hasConsequent) consequentCount++;
      if (hasAntecedent && hasConsequent) unionCount++;
    }
    
    const pAntecedent = antecedentCount / transactions.length;
    const pConsequent = consequentCount / transactions.length;
    const pUnion = unionCount / transactions.length;
    
    return pAntecedent * pConsequent > 0 ? pUnion / (pAntecedent * pConsequent) : 0;
  }

  static analyzeRuleStrength(analysis) {
    const strongRules = [];
    const veryStrongRules = [];
    
    for (const rule of analysis.rules.list) {
      // å¼ºè§„åˆ™ï¼šç½®ä¿¡åº¦>70%ä¸”æå‡åº¦>1.5
      if (rule.confidence > 0.7 && rule.lift > 1.5) {
        strongRules.push(rule);
        
        // éå¸¸å¼ºè§„åˆ™ï¼šç½®ä¿¡åº¦>85%ä¸”æå‡åº¦>2.0
        if (rule.confidence > 0.85 && rule.lift > 2.0) {
          veryStrongRules.push(rule);
        }
      }
    }
    
    analysis.rules.strong = strongRules;
    analysis.rules.veryStrong = veryStrongRules;
    analysis.summary.strongRulesCount = strongRules.length;
    analysis.summary.veryStrongRulesCount = veryStrongRules.length;
  }

  static generateAssociationPredictions(analysis, weights) {
    const predictions = {
      specialNumbers: [],
      normalNumbers: [],
      zodiac: { main: [], guard: [], scores: {} },
      color: { main: "", guard: "", scores: {} },
      confidence: 0,
      strongRules: []
    };
    
    // æå–å¼ºè§„åˆ™ç”¨äºé¢„æµ‹
    const rulesForPrediction = analysis.rules.strong || [];
    predictions.strongRules = rulesForPrediction.slice(0, 5);
    
    // åŸºäºè§„åˆ™è¯„åˆ†
    const specialScores = new Map();
    const normalScores = new Map();
    const zodiacScores = new Map();
    const colorScores = new Map();
    
    // åˆå§‹åŒ–æ‰€æœ‰å·ç 
    for (let i = 1; i <= 49; i++) {
      specialScores.set(i, 0);
      normalScores.set(i, 0);
    }
    
    // åˆå§‹åŒ–ç”Ÿè‚–
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      zodiacScores.set(zodiac, 0);
    }
    
    // åˆå§‹åŒ–æ³¢è‰²
    for (const color of Object.keys(CONFIG.COLORS)) {
      colorScores.set(color, 0);
    }
    
    // åº”ç”¨è§„åˆ™è¯„åˆ†
    for (const rule of rulesForPrediction) {
      const ruleWeight = rule.confidence * rule.lift * weights.w_association_rules;
      
      // åˆ†æè§„åˆ™åä»¶
      for (const item of rule.consequent) {
        if (item.startsWith('N')) {
          // å·ç è§„åˆ™
          const num = parseInt(item.substring(1));
          if (num >= 1 && num <= 49) {
            specialScores.set(num, specialScores.get(num) + ruleWeight);
            normalScores.set(num, normalScores.get(num) + ruleWeight * 0.8);
          }
        } else if (item.startsWith('Z')) {
          // ç”Ÿè‚–è§„åˆ™
          const zodiac = item.substring(1);
          zodiacScores.set(zodiac, zodiacScores.get(zodiac) + ruleWeight);
        } else if (item.startsWith('C')) {
          // æ³¢è‰²è§„åˆ™
          const color = item.substring(1);
          colorScores.set(color, colorScores.get(color) + ruleWeight);
        }
      }
    }
    
    // ä¸ºæ¯ä¸ªå·ç æ·»åŠ å…³è”ç”Ÿè‚–å’Œæ³¢è‰²çš„åˆ†æ•°
    for (let i = 1; i <= 49; i++) {
      const zodiac = Formatter.getAttributes(i).zodiac;
      const color = Formatter.getAttributes(i).color;
      
      specialScores.set(i, specialScores.get(i) + zodiacScores.get(zodiac) * 0.3);
      specialScores.set(i, specialScores.get(i) + colorScores.get(color) * 0.2);
      
      normalScores.set(i, normalScores.get(i) + zodiacScores.get(zodiac) * 0.2);
      normalScores.set(i, normalScores.get(i) + colorScores.get(color) * 0.1);
    }
    
    // é€‰æ‹©å·ç 
    const sortedSpecial = Array.from(specialScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 10, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    const sortedNormal = Array.from(normalScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 8, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    // é€‰æ‹©ç”Ÿè‚–
    const sortedZodiacs = Array.from(zodiacScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.zodiac.scores = Object.fromEntries(zodiacScores);
    predictions.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    predictions.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
    
    // é€‰æ‹©æ³¢è‰²
    const sortedColors = Array.from(colorScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.color.scores = Object.fromEntries(colorScores);
    predictions.color.main = sortedColors[0] ? sortedColors[0][0] : "";
    predictions.color.guard = sortedColors[1] ? sortedColors[1][0] : "";
    
    predictions.specialNumbers = sortedSpecial;
    predictions.normalNumbers = sortedNormal;
    
    // è®¡ç®—ç½®ä¿¡åº¦
    predictions.confidence = this.calculateConfidence(analysis);
    
    return predictions;
  }

  static calculateConfidence(analysis) {
    let confidence = 0;
    
    // åŸºäºæ•°æ®åˆ†ææ·±åº¦
    if (analysis.summary.totalTransactions >= 150) {
      confidence += 35;
    } else if (analysis.summary.totalTransactions >= 100) {
      confidence += 25;
    } else if (analysis.summary.totalTransactions >= 50) {
      confidence += 15;
    }
    
    // åŸºäºå¼ºè§„åˆ™æ•°é‡
    if (analysis.summary.strongRulesCount >= 20) {
      confidence += 40;
    } else if (analysis.summary.strongRulesCount >= 10) {
      confidence += 25;
    } else if (analysis.summary.strongRulesCount >= 5) {
      confidence += 15;
    }
    
    // åŸºäºéå¸¸å¼ºè§„åˆ™æ•°é‡
    if (analysis.summary.veryStrongRulesCount >= 5) {
      confidence += 25;
    } else if (analysis.summary.veryStrongRulesCount >= 3) {
      confidence += 15;
    } else if (analysis.summary.veryStrongRulesCount >= 1) {
      confidence += 5;
    }
    
    return Math.min(95, confidence);
  }
}
class MathLogicExpert {
  static async runMathLogic(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.math) {
        Logger.warn("MathLogicExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡æ•°å­¦é€»è¾‘åˆ†æ");
        return { success: false, error: "å†å²æ•°æ®ä¸è¶³" };
      }
      
      const startTime = Date.now();
      Logger.info("MathLogicExpert", "å¼€å§‹æ•°å­¦é€»è¾‘åˆ†æ", {
        historyLength: history.length,
        weight: weights.w_math_logic
      });
      
      const analysis = this.analyzeMathPatterns(history);
      const predictions = this.generateMathPredictions(analysis, weights);
      
      const duration = Date.now() - startTime;
      Logger.info("MathLogicExpert", "æ•°å­¦é€»è¾‘åˆ†æå®Œæˆ", {
        duration,
        goldenRatioPoints: analysis.summary.goldenRatioPoints,
        sumTrend: analysis.summary.sumTrend
      });
      
      return {
        success: true,
        algorithm: "math",
        analysis: analysis,
        predictions: predictions,
        duration: duration,
        confidence: this.calculateConfidence(analysis)
      };
    } catch (error) {
      Logger.error("MathLogicExpert", "æ•°å­¦é€»è¾‘åˆ†æå¤±è´¥", error);
      return {
        success: false,
        error: error.message,
        algorithm: "math"
      };
    }
  }

  static analyzeMathPatterns(history) {
    const analysis = {
      sumAnalysis: {},
      moduloAnalysis: {},
      sequenceAnalysis: {},
      goldenRatioAnalysis: {},
      trendAnalysis: {},
      summary: {
        totalRecords: Math.min(history.length, 100),
        goldenRatio: CONFIG.SYSTEM.GOLDEN_RATIO
      }
    };
    
    const analyzedHistory = history.slice(0, analysis.summary.totalRecords);
    
    // åˆ†æå’Œå€¼
    this.analyzeSums(analyzedHistory, analysis);
    
    // åˆ†ææ¨¡è¿ç®—
    this.analyzeModulo(analyzedHistory, analysis);
    
    // åˆ†ææ•°åˆ—æ¨¡å¼
    this.analyzeSequences(analyzedHistory, analysis);
    
    // åˆ†æé»„é‡‘åˆ†å‰²
    this.analyzeGoldenRatio(analyzedHistory, analysis);
    
    // åˆ†æè¶‹åŠ¿
    this.analyzeTrends(analyzedHistory, analysis);
    
    return analysis;
  }

  static analyzeSums(history, analysis) {
    const sums = [];
    
    for (const record of history) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      const sum = numbers.reduce((a, b) => a + b, 0);
      sums.push(sum);
    }
    
    if (sums.length === 0) return;
    
    // åŸºç¡€ç»Ÿè®¡
    analysis.sumAnalysis = {
      values: sums,
      min: Math.min(...sums),
      max: Math.max(...sums),
      average: sums.reduce((a, b) => a + b, 0) / sums.length,
      median: this.calculateMedian(sums),
      standardDeviation: this.calculateStandardDeviation(sums)
    };
    
    // åˆ†å¸ƒåˆ†æ
    const sumRanges = {
      veryLow: { min: 0, max: 100, count: 0 },
      low: { min: 101, max: 150, count: 0 },
      medium: { min: 151, max: 200, count: 0 },
      high: { min: 201, max: 250, count: 0 },
      veryHigh: { min: 251, max: 400, count: 0 }
    };
    
    for (const sum of sums) {
      for (const [rangeName, range] of Object.entries(sumRanges)) {
        if (sum >= range.min && sum <= range.max) {
          range.count++;
          break;
        }
      }
    }
    
    analysis.sumAnalysis.distribution = sumRanges;
    
    // è¶‹åŠ¿åˆ†æ
    const recentSums = sums.slice(0, Math.min(20, sums.length));
    const trend = this.calculateTrend(recentSums);
    analysis.sumAnalysis.trend = trend;
    analysis.summary.sumTrend = trend;
  }

  static analyzeModulo(history, analysis) {
    const mod3Analysis = { 0: 0, 1: 0, 2: 0 };
    const mod5Analysis = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
    const mod7Analysis = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
    
    let totalNumbers = 0;
    
    for (const record of history) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      
      for (const num of numbers) {
        mod3Analysis[num % 3]++;
        mod5Analysis[num % 5]++;
        mod7Analysis[num % 7]++;
        totalNumbers++;
      }
    }
    
    // è®¡ç®—é¢‘ç‡
    for (const key of Object.keys(mod3Analysis)) {
      mod3Analysis[key] = mod3Analysis[key] / totalNumbers;
    }
    
    for (const key of Object.keys(mod5Analysis)) {
      mod5Analysis[key] = mod5Analysis[key] / totalNumbers;
    }
    
    for (const key of Object.keys(mod7Analysis)) {
      mod7Analysis[key] = mod7Analysis[key] / totalNumbers;
    }
    
    analysis.moduloAnalysis = {
      mod3: mod3Analysis,
      mod5: mod5Analysis,
      mod7: mod7Analysis
    };
    
    // è¯†åˆ«æ¨¡è¿ç®—æ¨¡å¼
    analysis.moduloAnalysis.patterns = this.identifyModuloPatterns(mod3Analysis, mod5Analysis, mod7Analysis);
  }

  static analyzeSequences(history, analysis) {
    const sequences = {
      arithmetic: [],
      geometric: [],
      fibonacci: [],
      primeSequences: []
    };
    
    // æå–æ‰€æœ‰ç‰¹æ®Šå·ç 
    const specialNumbers = [];
    for (const record of history) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      specialNumbers.push(numbers[6]);
    }
    
    // åˆ†æç­‰å·®æ•°åˆ—
    sequences.arithmetic = this.findArithmeticSequences(specialNumbers);
    
    // åˆ†æç­‰æ¯”æ•°åˆ—
    sequences.geometric = this.findGeometricSequences(specialNumbers);
    
    // åˆ†ææ–æ³¢é‚£å¥‘å…³ç³»
    sequences.fibonacci = this.findFibonacciRelations(specialNumbers);
    
    // åˆ†æè´¨æ•°åºåˆ—
    sequences.primeSequences = this.findPrimeSequences(specialNumbers);
    
    analysis.sequenceAnalysis = sequences;
    analysis.summary.sequencePatterns = Object.values(sequences)
      .reduce((total, seq) => total + seq.length, 0);
  }

  static analyzeGoldenRatio(history, analysis) {
    const goldenRatio = CONFIG.SYSTEM.GOLDEN_RATIO;
    const goldenRatioPoints = [];
    
    // è®¡ç®—é»„é‡‘åˆ†å‰²ç‚¹
    for (let i = 1; i <= 49; i++) {
      const position = i / 49;
      
      // æ£€æŸ¥æ˜¯å¦æ¥è¿‘é»„é‡‘åˆ†å‰²ç‚¹æˆ–å…¶å€’æ•°
      const distance1 = Math.abs(position - goldenRatio);
      const distance2 = Math.abs(position - (1 - goldenRatio));
      const distance3 = Math.abs(position - goldenRatio * goldenRatio);
      
      if (distance1 < 0.05 || distance2 < 0.05 || distance3 < 0.05) {
        goldenRatioPoints.push({
          number: i,
          position,
          distance: Math.min(distance1, distance2, distance3)
        });
      }
    }
    
    // æŒ‰è·ç¦»æ’åº
    goldenRatioPoints.sort((a, b) => a.distance - b.distance);
    
    // åˆ†æå†å²å‘½ä¸­æƒ…å†µ
    let hitCount = 0;
    for (const record of history) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      const hasGoldenRatioNumber = numbers.some(num => 
        goldenRatioPoints.some(point => point.number === num)
      );
      
      if (hasGoldenRatioNumber) hitCount++;
    }
    
    analysis.goldenRatioAnalysis = {
      points: goldenRatioPoints,
      hitRate: hitCount / history.length,
      goldenRatio: goldenRatio
    };
    
    analysis.summary.goldenRatioPoints = goldenRatioPoints.length;
    analysis.summary.goldenRatioHitRate = analysis.goldenRatioAnalysis.hitRate;
  }

  static analyzeTrends(history, analysis) {
    const trends = {
      sumTrend: analysis.sumAnalysis.trend || "stable",
      moduloTrend: {},
      sequenceTrend: {}
    };
    
    // åˆ†ææ¨¡è¿ç®—è¶‹åŠ¿
    const recentHistory = history.slice(0, Math.min(20, history.length));
    const recentMod3 = { 0: 0, 1: 0, 2: 0 };
    let recentTotal = 0;
    
    for (const record of recentHistory) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      
      for (const num of numbers) {
        recentMod3[num % 3]++;
        recentTotal++;
      }
    }
    
    // è®¡ç®—è¶‹åŠ¿
    for (const key of Object.keys(recentMod3)) {
      recentMod3[key] = recentMod3[key] / recentTotal;
      const historical = analysis.moduloAnalysis.mod3[key] || 0;
      trends.moduloTrend[`mod3_${key}`] = recentMod3[key] > historical ? "rising" : 
                                        recentMod3[key] < historical ? "falling" : "stable";
    }
    
    analysis.trendAnalysis = trends;
  }

  static calculateMedian(arr) {
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    } else {
      return sorted[mid];
    }
  }

  static calculateStandardDeviation(arr) {
    const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
    const squareDiffs = arr.map(value => Math.pow(value - avg, 2));
    const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
    return Math.sqrt(avgSquareDiff);
  }

  static calculateTrend(values) {
    if (values.length < 2) return "insufficient_data";
    
    const recentAvg = values.slice(0, Math.floor(values.length / 2))
      .reduce((a, b) => a + b, 0) / Math.floor(values.length / 2);
    
    const olderAvg = values.slice(Math.floor(values.length / 2))
      .reduce((a, b) => a + b, 0) / Math.ceil(values.length / 2);
    
    const diff = recentAvg - olderAvg;
    const diffPercent = Math.abs(diff) / olderAvg;
    
    if (diffPercent < 0.05) return "stable";
    else if (diff > 0) return "rising";
    else return "falling";
  }

  static identifyModuloPatterns(mod3, mod5, mod7) {
    const patterns = [];
    
    // å¯»æ‰¾æ˜¾è‘—åç¦»å¹³å‡å€¼çš„æ¨¡è¿ç®—ç»“æœ
    const avgMod3 = 1 / 3;
    for (const [key, value] of Object.entries(mod3)) {
      if (Math.abs(value - avgMod3) > 0.1) {
        patterns.push({
          type: "mod3",
          remainder: key,
          frequency: value,
          deviation: (value - avgMod3) / avgMod3
        });
      }
    }
    
    const avgMod5 = 1 / 5;
    for (const [key, value] of Object.entries(mod5)) {
      if (Math.abs(value - avgMod5) > 0.08) {
        patterns.push({
          type: "mod5",
          remainder: key,
          frequency: value,
          deviation: (value - avgMod5) / avgMod5
        });
      }
    }
    
    const avgMod7 = 1 / 7;
    for (const [key, value] of Object.entries(mod7)) {
      if (Math.abs(value - avgMod7) > 0.06) {
        patterns.push({
          type: "mod7",
          remainder: key,
          frequency: value,
          deviation: (value - avgMod7) / avgMod7
        });
      }
    }
    
    return patterns;
  }

  static findArithmeticSequences(numbers) {
    const sequences = [];
    
    for (let i = 0; i < numbers.length - 2; i++) {
      const diff1 = numbers[i + 1] - numbers[i];
      const diff2 = numbers[i + 2] - numbers[i + 1];
      
      if (Math.abs(diff1 - diff2) <= 2 && Math.abs(diff1) > 0) {
        sequences.push({
          start: i,
          numbers: [numbers[i], numbers[i + 1], numbers[i + 2]],
          difference: (diff1 + diff2) / 2
        });
      }
    }
    
    return sequences;
  }

  static findGeometricSequences(numbers) {
    const sequences = [];
    
    for (let i = 0; i < numbers.length - 2; i++) {
      if (numbers[i] === 0 || numbers[i + 1] === 0) continue;
      
      const ratio1 = numbers[i + 1] / numbers[i];
      const ratio2 = numbers[i + 2] / numbers[i + 1];
      
      if (Math.abs(ratio1 - ratio2) < 0.2 && Math.abs(ratio1 - 1) > 0.1) {
        sequences.push({
          start: i,
          numbers: [numbers[i], numbers[i + 1], numbers[i + 2]],
          ratio: (ratio1 + ratio2) / 2
        });
      }
    }
    
    return sequences;
  }

  static findFibonacciRelations(numbers) {
    const relations = [];
    const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21, 34];
    
    for (let i = 0; i < numbers.length - 1; i++) {
      const sum = numbers[i] + numbers[i + 1];
      
      if (fibonacciNumbers.includes(sum) || this.isFibonacciLike(sum)) {
        relations.push({
          position: i,
          numbers: [numbers[i], numbers[i + 1]],
          sum: sum,
          isFibonacci: fibonacciNumbers.includes(sum)
        });
      }
    }
    
    return relations;
  }

  static isFibonacciLike(num) {
    // æ£€æŸ¥æ•°å­—æ˜¯å¦æ¥è¿‘æ–æ³¢é‚£å¥‘æ•°åˆ—
    const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21, 34];
    return fibonacciNumbers.some(fib => Math.abs(fib - num) <= 3);
  }

  static findPrimeSequences(numbers) {
    const sequences = [];
    
    for (let i = 0; i < numbers.length - 1; i++) {
      if (Formatter.isPrime(numbers[i]) && Formatter.isPrime(numbers[i + 1])) {
        sequences.push({
          position: i,
          numbers: [numbers[i], numbers[i + 1]],
          length: 2
        });
      }
    }
    
    // æŸ¥æ‰¾æ›´é•¿çš„è´¨æ•°åºåˆ—
    for (const seq of sequences) {
      let extended = true;
      let length = 2;
      
      while (extended && seq.position + length < numbers.length) {
        if (Formatter.isPrime(numbers[seq.position + length])) {
          seq.numbers.push(numbers[seq.position + length]);
          seq.length++;
          length++;
        } else {
          extended = false;
        }
      }
    }
    
    return sequences;
  }

  static generateMathPredictions(analysis, weights) {
    const predictions = {
      specialNumbers: [],
      normalNumbers: [],
      zodiac: { main: [], guard: [], scores: {} },
      color: { main: "", guard: "", scores: {} },
      confidence: 0,
      mathPatterns: analysis.summary
    };
    
    // åŸºäºæ•°å­¦åˆ†æè¯„åˆ†
    const specialScores = new Map();
    const normalScores = new Map();
    const zodiacScores = new Map();
    const colorScores = new Map();
    
    // åˆå§‹åŒ–è¯„åˆ†
    for (let i = 1; i <= 49; i++) {
      specialScores.set(i, 0);
      normalScores.set(i, 0);
    }
    
    for (const zodiac of Object.keys(CONFIG.ZODIAC_MAP)) {
      zodiacScores.set(zodiac, 0);
    }
    
    for (const color of Object.keys(CONFIG.COLORS)) {
      colorScores.set(color, 0);
    }
    
    // é»„é‡‘åˆ†å‰²ç‚¹åŠ åˆ†
    for (const point of analysis.goldenRatioAnalysis.points) {
      const score = (1 - point.distance) * 100 * weights.w_math_logic;
      specialScores.set(point.number, specialScores.get(point.number) + score);
      normalScores.set(point.number, normalScores.get(point.number) + score * 0.7);
    }
    
    // å’Œå€¼åˆ†æåŠ åˆ†
    const targetSum = this.calculateTargetSum(analysis);
    for (let i = 1; i <= 49; i++) {
      // æ¨¡æ‹Ÿä¸å…¶ä»–å·ç ç»„åˆçš„å’Œå€¼
      for (let j = 1; j <= 49; j++) {
        if (i === j) continue;
        
        const simulatedSum = i + j * 6; // ç®€å•æ¨¡æ‹Ÿ
        const sumDistance = Math.abs(simulatedSum - targetSum);
        const sumScore = (1 - sumDistance / 200) * 50 * weights.w_math_logic;
        
        specialScores.set(i, specialScores.get(i) + sumScore / 48);
      }
    }
    
    // æ¨¡è¿ç®—æ¨¡å¼åŠ åˆ†
    for (let i = 1; i <= 49; i++) {
      const mod3 = i % 3;
      const mod5 = i % 5;
      const mod7 = i % 7;
      
      const mod3Freq = analysis.moduloAnalysis.mod3[mod3] || 0;
      const mod5Freq = analysis.moduloAnalysis.mod5[mod5] || 0;
      const mod7Freq = analysis.moduloAnalysis.mod7[mod7] || 0;
      
      // é¢‘ç‡é«˜çš„æ¨¡è¿ç®—ç»“æœåŠ åˆ†
      specialScores.set(i, specialScores.get(i) + mod3Freq * 30 * weights.w_math_logic);
      specialScores.set(i, specialScores.get(i) + mod5Freq * 20 * weights.w_math_logic);
      specialScores.set(i, specialScores.get(i) + mod7Freq * 15 * weights.w_math_logic);
    }
    
    // æ•°åˆ—æ¨¡å¼åŠ åˆ†
    for (const seq of analysis.sequenceAnalysis.arithmetic) {
      const nextNumber = seq.numbers[seq.numbers.length - 1] + seq.difference;
      if (nextNumber >= 1 && nextNumber <= 49) {
        specialScores.set(nextNumber, specialScores.get(nextNumber) + 40 * weights.w_math_logic);
      }
    }
    
    for (const seq of analysis.sequenceAnalysis.geometric) {
      const nextNumber = Math.round(seq.numbers[seq.numbers.length - 1] * seq.ratio);
      if (nextNumber >= 1 && nextNumber <= 49) {
        specialScores.set(nextNumber, specialScores.get(nextNumber) + 35 * weights.w_math_logic);
      }
    }
    
    // è´¨æ•°åºåˆ—åŠ åˆ†
    if (analysis.sequenceAnalysis.primeSequences.length > 0) {
      const lastPrime = analysis.sequenceAnalysis.primeSequences[0].numbers[0];
      if (Formatter.isPrime(lastPrime)) {
        // å¯»æ‰¾ä¸‹ä¸€ä¸ªè´¨æ•°
        for (let i = lastPrime + 1; i <= 49; i++) {
          if (Formatter.isPrime(i)) {
            specialScores.set(i, specialScores.get(i) + 25 * weights.w_math_logic);
            break;
          }
        }
      }
    }
    
    // è¶‹åŠ¿åˆ†æåŠ åˆ†
    if (analysis.trendAnalysis.sumTrend === "rising") {
      // å’Œå€¼ä¸Šå‡è¶‹åŠ¿ï¼Œå¤§å·ç åŠ åˆ†
      for (let i = 25; i <= 49; i++) {
        specialScores.set(i, specialScores.get(i) + 15 * weights.w_math_logic);
      }
    } else if (analysis.trendAnalysis.sumTrend === "falling") {
      // å’Œå€¼ä¸‹é™è¶‹åŠ¿ï¼Œå°å·ç åŠ åˆ†
      for (let i = 1; i <= 24; i++) {
        specialScores.set(i, specialScores.get(i) + 15 * weights.w_math_logic);
      }
    }
    
    // å¹³ç æƒé‡ç•¥ä½
    for (let i = 1; i <= 49; i++) {
      normalScores.set(i, normalScores.get(i) + specialScores.get(i) * 0.8);
    }
    
    // é€‰æ‹©å·ç 
    const sortedSpecial = Array.from(specialScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 200, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color,
        mathScore: score
      }));
    
    const sortedNormal = Array.from(normalScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 160, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color,
        mathScore: score
      }));
    
    // æ ¹æ®å·ç é€‰æ‹©ç”Ÿè‚–å’Œæ³¢è‰²
    const zodiacFrequency = new Map();
    const colorFrequency = new Map();
    
    for (const item of [...sortedSpecial, ...sortedNormal]) {
      const zodiac = Formatter.getAttributes(item.number).zodiac;
      const color = Formatter.getAttributes(item.number).color;
      
      zodiacFrequency.set(zodiac, (zodiacFrequency.get(zodiac) || 0) + 1);
      colorFrequency.set(color, (colorFrequency.get(color) || 0) + 1);
    }
    
    // é€‰æ‹©ç”Ÿè‚–
    const sortedZodiacs = Array.from(zodiacFrequency.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    predictions.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
    
    // é€‰æ‹©æ³¢è‰²
    const sortedColors = Array.from(colorFrequency.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.color.main = sortedColors[0] ? sortedColors[0][0] : "";
    predictions.color.guard = sortedColors[1] ? sortedColors[1][0] : "";
    
    predictions.specialNumbers = sortedSpecial;
    predictions.normalNumbers = sortedNormal;
    
    // è®¡ç®—ç½®ä¿¡åº¦
    predictions.confidence = this.calculateConfidence(analysis);
    
    return predictions;
  }

  static calculateTargetSum(analysis) {
    // åŸºäºå†å²åˆ†æå’Œè¶‹åŠ¿è®¡ç®—ç›®æ ‡å’Œå€¼
    const sumAnalysis = analysis.sumAnalysis;
    
    if (analysis.trendAnalysis.sumTrend === "rising") {
      return Math.min(sumAnalysis.max, sumAnalysis.average * 1.1);
    } else if (analysis.trendAnalysis.sumTrend === "falling") {
      return Math.max(sumAnalysis.min, sumAnalysis.average * 0.9);
    } else {
      return sumAnalysis.average;
    }
  }

  static calculateConfidence(analysis) {
    let confidence = 0;
    
    // åŸºäºæ•°æ®åˆ†ææ·±åº¦
    if (analysis.summary.totalRecords >= 80) {
      confidence += 30;
    } else if (analysis.summary.totalRecords >= 50) {
      confidence += 20;
    } else if (analysis.summary.totalRecords >= 30) {
      confidence += 10;
    }
    
    // åŸºäºé»„é‡‘åˆ†å‰²ç‚¹å‘½ä¸­ç‡
    if (analysis.summary.goldenRatioHitRate > 0.7) {
      confidence += 25;
    } else if (analysis.summary.goldenRatioHitRate > 0.5) {
      confidence += 15;
    } else if (analysis.summary.goldenRatioHitRate > 0.3) {
      confidence += 5;
    }
    
    // åŸºäºæ•°åˆ—æ¨¡å¼æ•°é‡
    if (analysis.summary.sequencePatterns >= 10) {
      confidence += 25;
    } else if (analysis.summary.sequencePatterns >= 5) {
      confidence += 15;
    } else if (analysis.summary.sequencePatterns >= 2) {
      confidence += 5;
    }
    
    // åŸºäºæ¨¡è¿ç®—æ¨¡å¼æ˜¾è‘—æ€§
    const moduloPatterns = analysis.moduloAnalysis.patterns || [];
    if (moduloPatterns.length >= 5) {
      confidence += 20;
    } else if (moduloPatterns.length >= 3) {
      confidence += 10;
    } else if (moduloPatterns.length >= 1) {
      confidence += 5;
    }
    
    return Math.min(95, confidence);
  }
}
class ZoneBalanceExpert {
  static async runZoneBalance(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.zone) {
        Logger.warn("ZoneBalanceExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡åŒºé—´å¹³è¡¡åˆ†æ");
        return { success: false, error: "å†å²æ•°æ®ä¸è¶³" };
      }
      
      const startTime = Date.now();
      Logger.info("ZoneBalanceExpert", "å¼€å§‹åŒºé—´å¹³è¡¡åˆ†æ", {
        historyLength: history.length,
        weight: weights.w_zone_balance
      });
      
      const analysis = this.analyzeZoneDistribution(history);
      const predictions = this.generateZonePredictions(analysis, weights);
      
      const duration = Date.now() - startTime;
      Logger.info("ZoneBalanceExpert", "åŒºé—´å¹³è¡¡åˆ†æå®Œæˆ", {
        duration,
        brokenZones: analysis.summary.brokenZonesCount,
        balancedZones: analysis.summary.balancedZonesCount
      });
      
      return {
        success: true,
        algorithm: "zone",
        analysis: analysis,
        predictions: predictions,
        duration: duration,
        confidence: this.calculateConfidence(analysis)
      };
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "åŒºé—´å¹³è¡¡åˆ†æå¤±è´¥", error);
      return {
        success: false,
        error: error.message,
        algorithm: "zone"
      };
    }
  }

  static analyzeZoneDistribution(history) {
    const analysis = {
      sevenZone: {},
      fiveZone: {},
      recentTrends: {},
      brokenZones: {},
      summary: {
        totalRecords: Math.min(history.length, 100),
        analyzedRecords: Math.min(history.length, 50)
      }
    };
    
    // åˆ†æä¸ƒåŒºåˆ†å¸ƒ
    this.analyzeZone(history, analysis, 'seven_zone');
    
    // åˆ†æäº”åŒºåˆ†å¸ƒ
    this.analyzeZone(history, analysis, 'five_zone');
    
    // åˆ†æè¿‘æœŸè¶‹åŠ¿
    this.analyzeRecentTrends(history, analysis);
    
    // è¯†åˆ«æ–­åŒº
    this.identifyBrokenZones(analysis);
    
    // åˆ†æå¹³è¡¡éœ€æ±‚
    this.analyzeBalanceNeeds(analysis);
    
    return analysis;
  }

  static analyzeZone(history, analysis, zoneType) {
    const zoneConfig = CONFIG.SYSTEM.ZONE_CONFIGS[zoneType];
    const zoneStats = {};
    
    // åˆå§‹åŒ–åŒºç»Ÿè®¡
    for (let i = 0; i < zoneConfig.length; i++) {
      zoneStats[i + 1] = {
        count: 0,
        frequency: 0,
        lastAppearance: -1,
        omission: 0,
        numbers: Formatter.getNumbersInZone(i + 1, zoneType),
        expectedFrequency: 1 / zoneConfig.length
      };
    }
    
    // åˆ†æå†å²è®°å½•
    const analyzedHistory = history.slice(0, analysis.summary.analyzedRecords);
    
    for (let index = 0; index < analyzedHistory.length; index++) {
      const record = analyzedHistory[index];
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      const zonesInRecord = new Set();
      
      for (const num of numbers) {
        const zoneId = Formatter.getZoneForNumber(num, zoneType);
        if (zoneId > 0) {
          zoneStats[zoneId].count++;
          zoneStats[zoneId].lastAppearance = index;
          zonesInRecord.add(zoneId);
        }
      }
      
      // æ›´æ–°æœªå‡ºç°åŒºçš„é—æ¼
      for (const zoneId of Object.keys(zoneStats)) {
        if (!zonesInRecord.has(parseInt(zoneId))) {
          if (zoneStats[zoneId].lastAppearance >= 0) {
            zoneStats[zoneId].omission++;
          }
        } else {
          zoneStats[zoneId].omission = 0;
        }
      }
    }
    
    // è®¡ç®—é¢‘ç‡å’Œæœ€ç»ˆé—æ¼
    for (const zoneId of Object.keys(zoneStats)) {
      const zone = zoneStats[zoneId];
      zone.frequency = zone.count / (analyzedHistory.length * 7); // æ¯ä¸ªè®°å½•7ä¸ªå·ç 
      
      if (zone.lastAppearance >= 0) {
        zone.omission = analyzedHistory.length - zone.lastAppearance - 1;
      } else {
        zone.omission = analyzedHistory.length;
      }
      
      // è®¡ç®—åç¦»åº¦
      zone.deviation = (zone.frequency - zone.expectedFrequency) / zone.expectedFrequency;
    }
    
    analysis[zoneType] = zoneStats;
  }

  static analyzeRecentTrends(history, analysis) {
    const recentHistory = history.slice(0, Math.min(20, history.length));
    const recentSevenZone = {};
    const recentFiveZone = {};
    
    // åˆå§‹åŒ–è¿‘æœŸç»Ÿè®¡
    for (let i = 1; i <= 7; i++) {
      recentSevenZone[i] = 0;
    }
    
    for (let i = 1; i <= 5; i++) {
      recentFiveZone[i] = 0;
    }
    
    // ç»Ÿè®¡è¿‘æœŸåˆ†å¸ƒ
    for (const record of recentHistory) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      
      for (const num of numbers) {
        const sevenZone = Formatter.getZoneForNumber(num, 'seven_zone');
        const fiveZone = Formatter.getZoneForNumber(num, 'five_zone');
        
        if (sevenZone > 0) recentSevenZone[sevenZone]++;
        if (fiveZone > 0) recentFiveZone[fiveZone]++;
      }
    }
    
    // åˆ†æè¶‹åŠ¿
    analysis.recentTrends = {
      sevenZone: this.analyzeZoneTrend(recentSevenZone, analysis.sevenZone),
      fiveZone: this.analyzeZoneTrend(recentFiveZone, analysis.fiveZone)
    };
  }

  static analyzeZoneTrend(recentStats, historicalStats) {
    const trends = {};
    
    for (const zoneId of Object.keys(recentStats)) {
      const recentFreq = recentStats[zoneId] / (Object.values(recentStats).reduce((a, b) => a + b, 0) || 1);
      const historicalFreq = historicalStats[zoneId] ? historicalStats[zoneId].frequency : 0;
      
      if (historicalFreq > 0) {
        const trend = recentFreq / historicalFreq;
        
        if (trend > 1.3) trends[zoneId] = "hot";
        else if (trend > 1.1) trends[zoneId] = "warming";
        else if (trend < 0.7) trends[zoneId] = "cold";
        else if (trend < 0.9) trends[zoneId] = "cooling";
        else trends[zoneId] = "stable";
      } else {
        trends[zoneId] = "insufficient_data";
      }
    }
    
    return trends;
  }

  static identifyBrokenZones(analysis) {
    const brokenZones = {
      sevenZone: [],
      fiveZone: []
    };
    
    // è¯†åˆ«ä¸ƒåŒºæ–­åŒºï¼ˆé—æ¼æœŸæ•°è¶…è¿‡é˜ˆå€¼ï¼‰
    const sevenZoneThreshold = analysis.summary.analyzedRecords * 0.3; // 30%çš„æœŸæ•°
    
    for (const [zoneId, zoneData] of Object.entries(analysis.sevenZone)) {
      if (zoneData.omission >= sevenZoneThreshold) {
        brokenZones.sevenZone.push({
          zoneId: parseInt(zoneId),
          omission: zoneData.omission,
          threshold: sevenZoneThreshold,
          numbers: zoneData.numbers
        });
      }
    }
    
    // è¯†åˆ«äº”åŒºæ–­åŒº
    const fiveZoneThreshold = analysis.summary.analyzedRecords * 0.4; // 40%çš„æœŸæ•°
    
    for (const [zoneId, zoneData] of Object.entries(analysis.fiveZone)) {
      if (zoneData.omission >= fiveZoneThreshold) {
        brokenZones.fiveZone.push({
          zoneId: parseInt(zoneId),
          omission: zoneData.omission,
          threshold: fiveZoneThreshold,
          numbers: zoneData.numbers
        });
      }
    }
    
    analysis.brokenZones = brokenZones;
    analysis.summary.brokenZonesCount = brokenZones.sevenZone.length + brokenZones.fiveZone.length;
  }

  static analyzeBalanceNeeds(analysis) {
    const balanceNeeds = {
      sevenZone: [],
      fiveZone: []
    };
    
    // åˆ†æä¸ƒåŒºå¹³è¡¡éœ€æ±‚
    const sevenZoneAvg = Object.values(analysis.sevenZone)
      .reduce((sum, zone) => sum + zone.frequency, 0) / 7;
    
    for (const [zoneId, zoneData] of Object.entries(analysis.sevenZone)) {
      const deviation = (zoneData.frequency - sevenZoneAvg) / sevenZoneAvg;
      
      if (deviation < -0.3) { // é¢‘ç‡ä½äºå¹³å‡æ°´å¹³30%ä»¥ä¸Š
        balanceNeeds.sevenZone.push({
          zoneId: parseInt(zoneId),
          deviation: deviation,
          need: "high", // éœ€è¦è¡¥å……
          numbers: zoneData.numbers
        });
      } else if (deviation > 0.3) { // é¢‘ç‡é«˜äºå¹³å‡æ°´å¹³30%ä»¥ä¸Š
        balanceNeeds.sevenZone.push({
          zoneId: parseInt(zoneId),
          deviation: deviation,
          need: "low", // å¯èƒ½éœ€è¦å‡å°‘
          numbers: zoneData.numbers
        });
      }
    }
    
    // åˆ†æäº”åŒºå¹³è¡¡éœ€æ±‚
    const fiveZoneAvg = Object.values(analysis.fiveZone)
      .reduce((sum, zone) => sum + zone.frequency, 0) / 5;
    
    for (const [zoneId, zoneData] of Object.entries(analysis.fiveZone)) {
      const deviation = (zoneData.frequency - fiveZoneAvg) / fiveZoneAvg;
      
      if (deviation < -0.25) { // é¢‘ç‡ä½äºå¹³å‡æ°´å¹³25%ä»¥ä¸Š
        balanceNeeds.fiveZone.push({
          zoneId: parseInt(zoneId),
          deviation: deviation,
          need: "high",
          numbers: zoneData.numbers
        });
      } else if (deviation > 0.25) { // é¢‘ç‡é«˜äºå¹³å‡æ°´å¹³25%ä»¥ä¸Š
        balanceNeeds.fiveZone.push({
          zoneId: parseInt(zoneId),
          deviation: deviation,
          need: "low",
          numbers: zoneData.numbers
        });
      }
    }
    
    analysis.balanceNeeds = balanceNeeds;
    analysis.summary.balancedZonesCount = 
      (7 - balanceNeeds.sevenZone.filter(z => z.need === "high").length) +
      (5 - balanceNeeds.fiveZone.filter(z => z.need === "high").length);
  }

  static generateZonePredictions(analysis, weights) {
    const predictions = {
      specialNumbers: [],
      normalNumbers: [],
      zodiac: { main: [], guard: [], scores: {} },
      color: { main: "", guard: "", scores: {} },
      confidence: 0,
      zoneRecommendations: {
        focusZones: [],
        avoidZones: []
      }
    };
    
    // åŸºäºåŒºé—´åˆ†æè¯„åˆ†
    const specialScores = new Map();
    const normalScores = new Map();
    
    // åˆå§‹åŒ–è¯„åˆ†
    for (let i = 1; i <= 49; i++) {
      specialScores.set(i, 0);
      normalScores.set(i, 0);
    }
    
    // æ–­åŒºå·ç åŠ åˆ†ï¼ˆæ–­åŒºå›è¡¥éœ€æ±‚ï¼‰
    for (const brokenZone of analysis.brokenZones.sevenZone) {
      for (const num of brokenZone.numbers) {
        const score = brokenZone.omission * 3 * weights.w_zone_balance;
        specialScores.set(num, specialScores.get(num) + score);
        normalScores.set(num, normalScores.get(num) + score * 0.8);
      }
      
      predictions.zoneRecommendations.focusZones.push({
        zoneType: "seven_zone",
        zoneId: brokenZone.zoneId,
        reason: `æ–­åŒº ${brokenZone.omission} æœŸæœªå‡º`
      });
    }
    
    for (const brokenZone of analysis.brokenZones.fiveZone) {
      for (const num of brokenZone.numbers) {
        const score = brokenZone.omission * 2 * weights.w_zone_balance;
        specialScores.set(num, specialScores.get(num) + score);
        normalScores.set(num, normalScores.get(num) + score * 0.8);
      }
    }
    
    // å¹³è¡¡éœ€æ±‚åŠ åˆ†ï¼ˆé¢‘ç‡ä½çš„åŒºï¼‰
    for (const balanceNeed of analysis.balanceNeeds.sevenZone) {
      if (balanceNeed.need === "high") {
        for (const num of balanceNeed.numbers) {
          const score = Math.abs(balanceNeed.deviation) * 100 * weights.w_zone_balance;
          specialScores.set(num, specialScores.get(num) + score);
          normalScores.set(num, normalScores.get(num) + score * 0.7);
        }
      } else if (balanceNeed.need === "low") {
        // é¢‘ç‡é«˜çš„åŒºï¼Œç›¸åº”å·ç å‡åˆ†
        for (const num of balanceNeed.numbers) {
          const score = Math.abs(balanceNeed.deviation) * -50 * weights.w_zone_balance;
          specialScores.set(num, specialScores.get(num) + score);
          normalScores.set(num, normalScores.get(num) + score * 0.7);
        }
        
        predictions.zoneRecommendations.avoidZones.push({
          zoneType: "seven_zone",
          zoneId: balanceNeed.zoneId,
          reason: `å‡ºç°é¢‘ç‡è¿‡é«˜ (åå·®: ${(balanceNeed.deviation * 100).toFixed(1)}%)`
        });
      }
    }
    
    // è¿‘æœŸè¶‹åŠ¿åŠ åˆ†
    for (const [zoneId, trend] of Object.entries(analysis.recentTrends.sevenZone)) {
      const zoneNumbers = Formatter.getNumbersInZone(parseInt(zoneId), 'seven_zone');
      
      if (trend === "cold" || trend === "cooling") {
        // è¿‘æœŸå†·çš„åŒºåŠ åˆ†ï¼ˆå¯èƒ½å›æš–ï¼‰
        for (const num of zoneNumbers) {
          const score = 30 * weights.w_zone_balance;
          specialScores.set(num, specialScores.get(num) + score);
          normalScores.set(num, normalScores.get(num) + score * 0.6);
        }
      }
    }
    
    // åŒºé—´åˆ†å¸ƒå‡åŒ€æ€§åŠ åˆ†
    const zoneDistributionScore = this.calculateDistributionScore(analysis);
    for (let i = 1; i <= 49; i++) {
      specialScores.set(i, specialScores.get(i) + zoneDistributionScore * 20 * weights.w_zone_balance);
      normalScores.set(i, normalScores.get(i) + zoneDistributionScore * 15 * weights.w_zone_balance);
    }
    
    // é€‰æ‹©å·ç 
    const sortedSpecial = Array.from(specialScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 200, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color,
        sevenZone: Formatter.getZoneForNumber(number, 'seven_zone'),
        fiveZone: Formatter.getZoneForNumber(number, 'five_zone')
      }));
    
    const sortedNormal = Array.from(normalScores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: score / 160, // å½’ä¸€åŒ–
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color,
        sevenZone: Formatter.getZoneForNumber(number, 'seven_zone'),
        fiveZone: Formatter.getZoneForNumber(number, 'five_zone')
      }));
    
    // æ ¹æ®å·ç é€‰æ‹©ç”Ÿè‚–å’Œæ³¢è‰²
    const zodiacFrequency = new Map();
    const colorFrequency = new Map();
    
    for (const item of [...sortedSpecial, ...sortedNormal]) {
      const zodiac = Formatter.getAttributes(item.number).zodiac;
      const color = Formatter.getAttributes(item.number).color;
      
      zodiacFrequency.set(zodiac, (zodiacFrequency.get(zodiac) || 0) + 1);
      colorFrequency.set(color, (colorFrequency.get(color) || 0) + 1);
    }
    
    // é€‰æ‹©ç”Ÿè‚–
    const sortedZodiacs = Array.from(zodiacFrequency.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    predictions.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
    
    // é€‰æ‹©æ³¢è‰²
    const sortedColors = Array.from(colorFrequency.entries())
      .sort((a, b) => b[1] - a[1]);
    
    predictions.color.main = sortedColors[0] ? sortedColors[0][0] : "";
    predictions.color.guard = sortedColors[1] ? sortedColors[1][0] : "";
    
    predictions.specialNumbers = sortedSpecial;
    predictions.normalNumbers = sortedNormal;
    
    // è®¡ç®—ç½®ä¿¡åº¦
    predictions.confidence = this.calculateConfidence(analysis);
    
    return predictions;
  }

  static calculateDistributionScore(analysis) {
    // è®¡ç®—åˆ†å¸ƒå‡åŒ€æ€§å¾—åˆ†
    let score = 0;
    
    // ä¸ƒåŒºåˆ†å¸ƒå‡åŒ€æ€§
    const sevenZoneFreqs = Object.values(analysis.sevenZone).map(zone => zone.frequency);
    const sevenZoneStdDev = this.calculateStdDev(sevenZoneFreqs);
    score += (1 - sevenZoneStdDev) * 0.5;
    
    // äº”åŒºåˆ†å¸ƒå‡åŒ€æ€§
    const fiveZoneFreqs = Object.values(analysis.fiveZone).map(zone => zone.frequency);
    const fiveZoneStdDev = this.calculateStdDev(fiveZoneFreqs);
    score += (1 - fiveZoneStdDev) * 0.5;
    
    return Math.max(0, score);
  }

  static calculateStdDev(arr) {
    if (arr.length === 0) return 0;
    
    const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
    const squareDiffs = arr.map(value => Math.pow(value - avg, 2));
    const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
    return Math.sqrt(avgSquareDiff);
  }

  static calculateConfidence(analysis) {
    let confidence = 0;
    
    // åŸºäºæ•°æ®åˆ†ææ·±åº¦
    if (analysis.summary.analyzedRecords >= 80) {
      confidence += 30;
    } else if (analysis.summary.analyzedRecords >= 50) {
      confidence += 20;
    } else if (analysis.summary.analyzedRecords >= 30) {
      confidence += 10;
    }
    
    // åŸºäºæ–­åŒºæ•°é‡ï¼ˆæ–­åŒºè¶Šå¤šï¼Œé¢„æµ‹è¶Šæœ‰ä¿¡å¿ƒï¼‰
    if (analysis.summary.brokenZonesCount >= 4) {
      confidence += 35;
    } else if (analysis.summary.brokenZonesCount >= 2) {
      confidence += 20;
    } else if (analysis.summary.brokenZonesCount >= 1) {
      confidence += 10;
    }
    
    // åŸºäºå¹³è¡¡éœ€æ±‚
    const highBalanceNeeds = [
      ...(analysis.balanceNeeds?.sevenZone?.filter(z => z.need === "high") || []),
      ...(analysis.balanceNeeds?.fiveZone?.filter(z => z.need === "high") || [])
    ].length;
    
    if (highBalanceNeeds >= 4) {
      confidence += 25;
    } else if (highBalanceNeeds >= 2) {
      confidence += 15;
    } else if (highBalanceNeeds >= 1) {
      confidence += 5;
    }
    
    // åŸºäºåˆ†å¸ƒå‡åŒ€æ€§
    const distributionScore = this.calculateDistributionScore(analysis);
    confidence += distributionScore * 20;
    
    return Math.min(95, confidence);
  }
}
class OptimizedMonteCarloEngine {
  static cache = new Map();
  
  static clearCache() {
    this.cache.clear();
    Logger.info("OptimizedMonteCarloEngine", "è’™ç‰¹å¡æ´›ç¼“å­˜å·²æ¸…é™¤");
  }

  static async runMonteCarlo(history, weights, sampleType = "full_history") {
    try {
      if (!history || history.length < 10) {
        Logger.warn("OptimizedMonteCarloEngine", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ");
        return { success: false, error: "å†å²æ•°æ®ä¸è¶³" };
      }
      
      const startTime = Date.now();
      
      // æ£€æŸ¥ç¼“å­˜
      const cacheKey = this.getCacheKey(history, sampleType);
      const cached = this.cache.get(cacheKey);
      
      if (cached && (Date.now() - cached.timestamp < CONFIG.SYSTEM.MONTE_CACHE_TTL)) {
        Logger.info("OptimizedMonteCarloEngine", "ä½¿ç”¨ç¼“å­˜çš„è’™ç‰¹å¡æ´›ç»“æœ");
        return {
          success: true,
          ...cached.result,
          cached: true,
          duration: Date.now() - startTime
        };
      }
      
      Logger.info("OptimizedMonteCarloEngine", "å¼€å§‹è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ", {
        historyLength: history.length,
        sampleType,
        weight: weights.w_monte_carlo
      });
      
      // å‡†å¤‡æ ·æœ¬æ•°æ®
      const samples = this.prepareSamples(history, sampleType);
      
      if (samples.length === 0) {
        return { success: false, error: "æ— æ³•å‡†å¤‡æ ·æœ¬æ•°æ®" };
      }
      
      // è¿è¡Œæ¨¡æ‹Ÿ
      const simulations = Math.min(
        CONFIG.SYSTEM.MAX_SIMULATIONS,
        Math.max(CONFIG.SYSTEM.MIN_SIMULATIONS, history.length * 10)
      );
      
      Logger.info("OptimizedMonteCarloEngine", `å¼€å§‹ ${simulations} æ¬¡æ¨¡æ‹Ÿ`);
      
      const results = await this.runSimulations(samples, simulations, weights);
      
      const duration = Date.now() - startTime;
      
      // ç¼“å­˜ç»“æœ
      const result = {
        specialNumbers: results.specialNumbers,
        normalNumbers: results.normalNumbers,
        confidence: results.confidence,
        simulations: simulations,
        duration: duration
      };
      
      this.cache.set(cacheKey, {
        result: result,
        timestamp: Date.now()
      });
      
      Logger.info("OptimizedMonteCarloEngine", "è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå®Œæˆ", {
        duration,
        simulations,
        specialNumbers: results.specialNumbers.length,
        normalNumbers: results.normalNumbers.length,
        confidence: results.confidence
      });
      
      return {
        success: true,
        ...result,
        cached: false
      };
    } catch (error) {
      Logger.error("OptimizedMonteCarloEngine", "è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¤±è´¥", error);
      return {
        success: false,
        error: error.message,
        algorithm: "monte_carlo"
      };
    }
  }

  static getCacheKey(history, sampleType) {
    // åŸºäºå†å²æ•°æ®å’Œæ ·æœ¬ç±»å‹ç”Ÿæˆç¼“å­˜é”®
    const recentHistory = history.slice(0, 10);
    const historyHash = recentHistory
      .map(r => `${r.expect}:${r.open_code}`)
      .join('|')
      .hashCode();
    
    return `monte_${sampleType}_${historyHash}`;
  }

  static prepareSamples(history, sampleType) {
    const samples = [];
    
    switch (sampleType) {
      case "full_history":
        // ä½¿ç”¨å…¨éƒ¨å†å²è®°å½•
        for (const record of history) {
          if (record && record.open_code) {
            const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            samples.push(numbers);
          }
        }
        break;
        
      case "recent_100":
        // æœ€è¿‘100æœŸ
        const recentHistory = history.slice(0, Math.min(100, history.length));
        for (const record of recentHistory) {
          if (record && record.open_code) {
            const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            samples.push(numbers);
          }
        }
        break;
        
      case "similar_patterns":
        // åŸºäºæ¨¡å¼ç›¸ä¼¼çš„è®°å½•
        if (history.length >= 10) {
          const lastRecord = history[0];
          if (lastRecord && lastRecord.open_code) {
            const lastNumbers = lastRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            
            // å¯»æ‰¾ç›¸ä¼¼è®°å½•
            for (const record of history.slice(1, Math.min(50, history.length))) {
              if (record && record.open_code) {
                const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
                const similarity = this.calculateSimilarity(lastNumbers, numbers);
                
                if (similarity > 0.6) {
                  samples.push(numbers);
                }
              }
            }
          }
        }
        break;
        
      default:
        // é»˜è®¤ä½¿ç”¨æœ€è¿‘50æœŸ
        const defaultHistory = history.slice(0, Math.min(50, history.length));
        for (const record of defaultHistory) {
          if (record && record.open_code) {
            const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            samples.push(numbers);
          }
        }
    }
    
    return samples;
  }

  static calculateSimilarity(numbers1, numbers2) {
    // è®¡ç®—ä¸¤ç»„å·ç çš„ç›¸ä¼¼åº¦
    let matches = 0;
    
    for (const num1 of numbers1) {
      if (numbers2.includes(num1)) {
        matches++;
      }
    }
    
    return matches / Math.max(numbers1.length, numbers2.length);
  }

  static async runSimulations(samples, totalSimulations, weights) {
    // åˆ†æ‰¹è¿è¡Œæ¨¡æ‹Ÿä»¥é¿å…é˜»å¡
    const batchSize = CONFIG.SYSTEM.MONTECARLO_BATCH_SIZE;
    const batches = Math.min(
      CONFIG.SYSTEM.MONTECARLO_MAX_BATCHES,
      Math.ceil(totalSimulations / batchSize)
    );
    
    const allResults = {
      specialCounts: new Map(),
      normalCounts: new Map(),
      zodiacCounts: new Map(),
      colorCounts: new Map()
    };
    
    let completedSimulations = 0;
    
    for (let batch = 0; batch < batches; batch++) {
      const batchPromises = [];
      const simulationsInBatch = Math.min(batchSize, totalSimulations - completedSimulations);
      
      for (let i = 0; i < simulationsInBatch; i++) {
        batchPromises.push(this.runSingleSimulation(samples, weights));
      }
      
      const batchResults = await Promise.all(batchPromises);
      
      // æ±‡æ€»æ‰¹æ¬¡ç»“æœ
      for (const result of batchResults) {
        this.aggregateResults(result, allResults);
      }
      
      completedSimulations += simulationsInBatch;
      
      // è¿›åº¦æ—¥å¿—
      if (batches > 1) {
        Logger.debug("OptimizedMonteCarloEngine", `æ‰¹æ¬¡ ${batch + 1}/${batches} å®Œæˆ`, {
          progress: Formatter.formatProgress(completedSimulations, totalSimulations)
        });
      }
      
      // çŸ­æš‚å»¶è¿Ÿä»¥é¿å…é˜»å¡
      if (batch < batches - 1) {
        await new Promise(resolve => setTimeout(resolve, CONFIG.SYSTEM.ASYNC_BATCH_DELAY));
      }
    }
    
    // å¤„ç†æœ€ç»ˆç»“æœ
    return this.processResults(allResults, completedSimulations, weights);
  }

  static runSingleSimulation(samples, weights) {
    // å•æ¬¡æ¨¡æ‹Ÿ
    const result = {
      special: 0,
      normal: [],
      zodiac: "",
      color: ""
    };
    
    try {
      // éšæœºé€‰æ‹©ä¸€ä¸ªæ ·æœ¬ä½œä¸ºåŸºç¡€
      const baseSample = Formatter.getRandomElement(samples);
      if (!baseSample) return result;
      
      // åŸºäºæ ·æœ¬ç”Ÿæˆé¢„æµ‹å·ç 
      const predictedNumbers = this.generatePredictionFromSample(baseSample, samples, weights);
      
      if (predictedNumbers.length >= 7) {
        result.special = predictedNumbers[6];
        result.normal = predictedNumbers.slice(0, 6);
        result.zodiac = Formatter.getAttributes(result.special).zodiac;
        result.color = Formatter.getAttributes(result.special).color;
      }
      
      return result;
    } catch (error) {
      Logger.debug("OptimizedMonteCarloEngine", "å•æ¬¡æ¨¡æ‹Ÿå¤±è´¥", error);
      return result;
    }
  }

  static generatePredictionFromSample(baseSample, allSamples, weights) {
    // åŸºäºåŸºç¡€æ ·æœ¬å’Œæƒé‡ç”Ÿæˆé¢„æµ‹
    const prediction = [...baseSample];
    
    // æ·»åŠ éšæœºæ‰°åŠ¨
    for (let i = 0; i < prediction.length; i++) {
      // æ ¹æ®æƒé‡å†³å®šæ˜¯å¦ä¿®æ”¹è¿™ä¸ªå·ç 
      const changeProbability = 0.3 * weights.w_monte_carlo;
      
      if (Math.random() < changeProbability) {
        // ä»ç›¸ä¼¼æ ·æœ¬ä¸­å¯»æ‰¾æ›¿ä»£å·ç 
        const alternative = this.findAlternativeNumber(prediction[i], allSamples, prediction);
        if (alternative && !prediction.includes(alternative)) {
          prediction[i] = alternative;
        }
      }
    }
    
    // ç¡®ä¿å·ç ä¸é‡å¤
    const uniqueNumbers = [...new Set(prediction)];
    
    // å¦‚æœæ•°é‡ä¸è¶³ï¼Œè¡¥å……éšæœºå·ç 
    while (uniqueNumbers.length < 7) {
      const randomNum = Math.floor(Math.random() * 49) + 1;
      if (!uniqueNumbers.includes(randomNum)) {
        uniqueNumbers.push(randomNum);
      }
    }
    
    // éšæœºæ’åºï¼Œä½†ä¿æŒç‰¹æ®Šå·ç åœ¨æœ€å
    const normalNumbers = Formatter.shuffleArray(uniqueNumbers.slice(0, 6));
    const specialNumber = uniqueNumbers[6];
    
    return [...normalNumbers, specialNumber];
  }

  static findAlternativeNumber(currentNum, samples, currentPrediction) {
    // åœ¨æ ·æœ¬ä¸­å¯»æ‰¾ä¸å½“å‰å·ç ç›¸ä¼¼çš„æ›¿ä»£å·ç 
    const alternatives = new Set();
    
    for (const sample of samples) {
      if (sample.includes(currentNum)) {
        // æ‰¾åˆ°åŒ…å«å½“å‰å·ç çš„æ ·æœ¬ï¼Œæå–å…¶ä»–å·ç ä½œä¸ºå€™é€‰
        for (const num of sample) {
          if (num !== currentNum && !currentPrediction.includes(num)) {
            alternatives.add(num);
          }
        }
      }
    }
    
    if (alternatives.size > 0) {
      return Formatter.getRandomElement(Array.from(alternatives));
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ä¸€ä¸ªéšæœºä½†æœªä½¿ç”¨çš„å·ç 
    for (let i = 1; i <= 49; i++) {
      if (!currentPrediction.includes(i)) {
        return i;
      }
    }
    
    return null;
  }

  static aggregateResults(simulationResult, allResults) {
    // ç»Ÿè®¡ç‰¹æ®Šå·ç 
    if (simulationResult.special > 0) {
      allResults.specialCounts.set(
        simulationResult.special,
        (allResults.specialCounts.get(simulationResult.special) || 0) + 1
      );
    }
    
    // ç»Ÿè®¡å¹³ç 
    for (const num of simulationResult.normal) {
      if (num > 0) {
        allResults.normalCounts.set(
          num,
          (allResults.normalCounts.get(num) || 0) + 1
        );
      }
    }
    
    // ç»Ÿè®¡ç”Ÿè‚–
    if (simulationResult.zodiac) {
      allResults.zodiacCounts.set(
        simulationResult.zodiac,
        (allResults.zodiacCounts.get(simulationResult.zodiac) || 0) + 1
      );
    }
    
    // ç»Ÿè®¡æ³¢è‰²
    if (simulationResult.color) {
      allResults.colorCounts.set(
        simulationResult.color,
        (allResults.colorCounts.get(simulationResult.color) || 0) + 1
      );
    }
  }

  static processResults(allResults, totalSimulations, weights) {
    // å¤„ç†ç»Ÿè®¡ç»“æœ
    const result = {
      specialNumbers: [],
      normalNumbers: [],
      zodiac: { main: [], guard: [], scores: {} },
      color: { main: "", guard: "", scores: {} },
      confidence: 0
    };
    
    // å¤„ç†ç‰¹æ®Šå·ç 
    const sortedSpecial = Array.from(allResults.specialCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, count]) => ({
        number,
        count,
        probability: count / totalSimulations,
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    // å¤„ç†å¹³ç 
    const sortedNormal = Array.from(allResults.normalCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, count]) => ({
        number,
        count,
        probability: count / totalSimulations,
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    // å¤„ç†ç”Ÿè‚–
    const zodiacScores = new Map();
    for (const [zodiac, count] of allResults.zodiacCounts.entries()) {
      zodiacScores.set(zodiac, count / totalSimulations);
    }
    
    const sortedZodiacs = Array.from(zodiacScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    result.zodiac.scores = Object.fromEntries(zodiacScores);
    result.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    result.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
    
    // å¤„ç†æ³¢è‰²
    const colorScores = new Map();
    for (const [color, count] of allResults.colorCounts.entries()) {
      colorScores.set(color, count / totalSimulations);
    }
    
    const sortedColors = Array.from(colorScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    result.color.scores = Object.fromEntries(colorScores);
    result.color.main = sortedColors[0] ? sortedColors[0][0] : "";
    result.color.guard = sortedColors[1] ? sortedColors[1][0] : "";
    
    result.specialNumbers = sortedSpecial;
    result.normalNumbers = sortedNormal;
    
    // è®¡ç®—ç½®ä¿¡åº¦
    result.confidence = this.calculateConfidence(sortedSpecial, sortedNormal, totalSimulations, weights);
    
    return result;
  }

  static calculateConfidence(specialNumbers, normalNumbers, totalSimulations, weights) {
    let confidence = 0;
    
    // åŸºäºæ¨¡æ‹Ÿæ¬¡æ•°
    if (totalSimulations >= 20000) {
      confidence += 40;
    } else if (totalSimulations >= 10000) {
      confidence += 30;
    } else if (totalSimulations >= 5000) {
      confidence += 20;
    } else if (totalSimulations >= 2000) {
      confidence += 10;
    }
    
    // åŸºäºæœ€é«˜æ¦‚ç‡
    if (specialNumbers.length > 0) {
      const maxProbability = Math.max(...specialNumbers.map(n => n.probability));
      confidence += Math.min(maxProbability * 100 * 2, 30);
    }
    
    if (normalNumbers.length > 0) {
      const maxProbability = Math.max(...normalNumbers.map(n => n.probability));
      confidence += Math.min(maxProbability * 100 * 1.5, 20);
    }
    
    // åŸºäºæƒé‡
    confidence *= (weights.w_monte_carlo / 2.5); // æ ‡å‡†åŒ–åˆ°é»˜è®¤æƒé‡
    
    return Math.min(95, confidence);
  }
}

// ä¸ºå­—ç¬¦ä¸²æ·»åŠ hashCodeæ–¹æ³•
if (!String.prototype.hashCode) {
  String.prototype.hashCode = function() {
    let hash = 0;
    for (let i = 0; i < this.length; i++) {
      const char = this.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return hash;
  };
}
class PredictionEngine {
  static async generate(env, history, weights, algorithm = "traditional") {
    try {
      const startTime = Date.now();
      
      // æ£€æŸ¥å†å²æ•°æ®
      if (!history || !Array.isArray(history) || history.length === 0) {
        throw new Error("æ²¡æœ‰å†å²æ•°æ®");
      }
      
      // æ£€æŸ¥ç®—æ³•æ”¯æŒ
      if (!Formatter.isAlgorithmSupported(algorithm, history.length)) {
        throw new Error(`å†å²æ•°æ®ä¸è¶³ï¼Œæ— æ³•è¿è¡Œ ${algorithm} ç®—æ³•`);
      }
      
      // è®¾ç½®è¶…æ—¶
      const timeout = Formatter.getAlgorithmTimeout(algorithm);
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error(`ç®—æ³•æ‰§è¡Œè¶…æ—¶ (${timeout}ms)`)), timeout);
      });
      
      Logger.info("PredictionEngine", `å¼€å§‹ç”Ÿæˆé¢„æµ‹`, {
        algorithm,
        historyLength: history.length,
        timeout
      });
      
      // è¿è¡Œç®—æ³•
      let predictionPromise;
      
      switch (algorithm) {
        case "traditional":
          predictionPromise = this.runTraditionalAlgorithm(history, weights);
          break;
          
        case "knn":
          predictionPromise = this.runKNNAgorithm(history, weights);
          break;
          
        case "stats":
          predictionPromise = this.runStatisticsAlgorithm(history, weights);
          break;
          
        case "advanced":
          predictionPromise = this.runAdvancedAlgorithm(env, history, weights);
          break;
          
        case "omission":
          predictionPromise = this.runOmissionAlgorithm(history, weights);
          break;
          
        case "association":
          predictionPromise = this.runAssociationAlgorithm(history, weights);
          break;
          
        case "math":
          predictionPromise = this.runMathAlgorithm(history, weights);
          break;
          
        case "zone":
          predictionPromise = this.runZoneAlgorithm(history, weights);
          break;
          
        default:
          throw new Error(`æœªçŸ¥ç®—æ³•: ${algorithm}`);
      }
      
      // ç«é€Ÿæ‰§è¡Œï¼Œè¶…æ—¶åˆ™æŠ›å‡ºé”™è¯¯
      const prediction = await Promise.race([predictionPromise, timeoutPromise]);
      
      const duration = Date.now() - startTime;
      
      // ç”Ÿæˆä¸‹ä¸€æœŸæœŸå·
      const nextExpect = this.generateNextExpect(history);
      
      // æ„å»ºå®Œæ•´é¢„æµ‹ç»“æœ
      const finalPrediction = {
        ...prediction,
        nextExpect: nextExpect,
        algorithm: algorithm,
        algorithmName: CONFIG.ALGORITHM_NAMES[algorithm] || algorithm,
        historyLength: history.length,
        generatedAt: new Date().toISOString(),
        duration: duration,
        totalHistoryRecords: history.length
      };
      
      Logger.info("PredictionEngine", `é¢„æµ‹ç”Ÿæˆå®Œæˆ`, {
        algorithm,
        duration,
        nextExpect,
        confidence: finalPrediction.confidence || 0
      });
      
      return finalPrediction;
    } catch (error) {
      Logger.error("PredictionEngine", `ç”Ÿæˆé¢„æµ‹å¤±è´¥ [${algorithm}]`, error);
      
      // è¿”å›é”™è¯¯ä¿¡æ¯
      return {
        success: false,
        error: error.message,
        algorithm: algorithm,
        nextExpect: this.generateNextExpect(history),
        specialNumbers: [],
        normalNumbers: [],
        zodiac: { main: [], guard: [], scores: {} },
        color: { main: "", guard: "", scores: {} },
        confidence: 0
      };
    }
  }

  static generateNextExpect(history) {
    try {
      if (!history || history.length === 0) {
        return "2025001"; // é»˜è®¤èµ·å§‹æœŸå·
      }
      
      // è·å–æœ€æ–°æœŸå·
      const latestRecord = history[0];
      if (!latestRecord || !latestRecord.expect) {
        return "2025001";
      }
      
      // æœŸå·åŠ 1
      const currentExpect = Formatter.safeInt(latestRecord.expect, 2025000);
      return (currentExpect + 1).toString();
    } catch (error) {
      return "2025001";
    }
  }

  static async runTraditionalAlgorithm(history, weights) {
    // ä¼ ç»Ÿç®—æ³•ï¼šåŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°è½¬ç§»æ¦‚ç‡
    const stats = EnhancedStatistics.analyzeHistoryStatistics(history);
    const prediction = EnhancedStatistics.generatePrediction(stats, weights);
    
    return {
      ...prediction,
      algorithm: "traditional"
    };
  }

  static async runKNNAgorithm(history, weights) {
    // KNNç®—æ³•
    if (history.length < 10) {
      throw new Error("å†å²æ•°æ®ä¸è¶³ï¼Œè‡³å°‘éœ€è¦10æœŸè®°å½•");
    }
    
    const latestRecord = history[0];
    const similarRecords = KNNAlgorithm.findSimilarRecords(history, latestRecord, CONFIG.SYSTEM.KNN_K_VALUE);
    const prediction = KNNAlgorithm.predictFromSimilar(similarRecords, weights);
    
    return {
      ...prediction,
      algorithm: "knn",
      sampleSize: similarRecords.length
    };
  }

  static async runStatisticsAlgorithm(history, weights) {
    // ç»Ÿè®¡ç®—æ³•
    const stats = EnhancedStatistics.analyzeHistoryStatistics(history);
    const prediction = EnhancedStatistics.generatePrediction(stats, weights);
    
    return {
      ...prediction,
      algorithm: "stats"
    };
  }

  static async runAdvancedAlgorithm(env, history, weights) {
    // å¢å¼ºç®—æ³•ï¼šæ•´åˆæ‰€æœ‰ç®—æ³•
    const startTime = Date.now();
    
    Logger.info("PredictionEngine", "å¼€å§‹è¿è¡Œå¢å¼ºç®—æ³•");
    
    // å¹¶è¡Œè¿è¡Œæ‰€æœ‰ç®—æ³•ï¼ˆé™¤è’™ç‰¹å¡æ´›å¤–ï¼‰
    const algorithms = [
      { name: "traditional", weight: weights.w_zodiac_transfer },
      { name: "knn", weight: weights.w_knn_similarity },
      { name: "stats", weight: weights.w_statistics_analysis },
      { name: "omission", weight: weights.w_omission_balancing },
      { name: "association", weight: weights.w_association_rules },
      { name: "math", weight: weights.w_math_logic },
      { name: "zone", weight: weights.w_zone_balance }
    ];
    
    // è¿‡æ»¤æ”¯æŒçš„å†å²æ•°æ®ä¸è¶³çš„ç®—æ³•
    const validAlgorithms = algorithms.filter(algo => 
      Formatter.isAlgorithmSupported(algo.name, history.length)
    );
    
    Logger.info("PredictionEngine", `å°†è¿è¡Œ ${validAlgorithms.length} ä¸ªå­ç®—æ³•`, {
      algorithms: validAlgorithms.map(a => a.name)
    });
    
    // å¹¶è¡Œè¿è¡Œç®—æ³•
    const algorithmPromises = validAlgorithms.map(async (algo) => {
      try {
        const result = await this.generate(env, history, weights, algo.name);
        return {
          name: algo.name,
          weight: algo.weight,
          result: result,
          success: !result.error
        };
      } catch (error) {
        Logger.error("PredictionEngine", `å­ç®—æ³• ${algo.name} è¿è¡Œå¤±è´¥`, error);
        return {
          name: algo.name,
          weight: algo.weight,
          result: null,
          success: false,
          error: error.message
        };
      }
    });
    
    const algorithmResults = await Promise.all(algorithmPromises);
    
    // è¿è¡Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ
    let monteCarloResult = null;
    try {
      monteCarloResult = await OptimizedMonteCarloEngine.runMonteCarlo(history, weights, "recent_100");
      if (monteCarloResult.success) {
        algorithmResults.push({
          name: "monte_carlo",
          weight: weights.w_monte_carlo,
          result: monteCarloResult,
          success: true
        });
      }
    } catch (error) {
      Logger.error("PredictionEngine", "è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¤±è´¥", error);
    }
    
    // æ•´åˆç»“æœ
    const integratedPrediction = this.integratePredictions(algorithmResults, weights);
    
    const duration = Date.now() - startTime;
    
    Logger.info("PredictionEngine", "å¢å¼ºç®—æ³•å®Œæˆ", {
      duration,
      integratedAlgorithms: algorithmResults.filter(a => a.success).length,
      confidence: integratedPrediction.confidence
    });
    
    return {
      ...integratedPrediction,
      algorithm: "advanced",
      integratedAlgorithms: algorithmResults
        .filter(a => a.success)
        .map(a => ({ name: a.name, weight: a.weight }))
    };
  }

  static async runOmissionAlgorithm(history, weights) {
    // é—æ¼å›è¡¥ä¸“å®¶ç®—æ³•
    const result = await OmissionExpert.runOmission(history, weights);
    
    if (!result.success) {
      throw new Error(result.error || "é—æ¼å›è¡¥åˆ†æå¤±è´¥");
    }
    
    return {
      ...result.predictions,
      algorithm: "omission",
      analysisSummary: result.analysis.summary
    };
  }

  static async runAssociationAlgorithm(history, weights) {
    // å…³è”è§„åˆ™ä¸“å®¶ç®—æ³•
    const result = await AssociationExpert.runAssociation(history, weights);
    
    if (!result.success) {
      throw new Error(result.error || "å…³è”è§„åˆ™åˆ†æå¤±è´¥");
    }
    
    return {
      ...result.predictions,
      algorithm: "association",
      strongRules: result.predictions.strongRules
    };
  }

  static async runMathAlgorithm(history, weights) {
    // æ•°å­¦é€»è¾‘ä¸“å®¶ç®—æ³•
    const result = await MathLogicExpert.runMathLogic(history, weights);
    
    if (!result.success) {
      throw new Error(result.error || "æ•°å­¦é€»è¾‘åˆ†æå¤±è´¥");
    }
    
    return {
      ...result.predictions,
      algorithm: "math",
      mathPatterns: result.predictions.mathPatterns
    };
  }

  static async runZoneAlgorithm(history, weights) {
    // åŒºé—´å¹³è¡¡ä¸“å®¶ç®—æ³•
    const result = await ZoneBalanceExpert.runZoneBalance(history, weights);
    
    if (!result.success) {
      throw new Error(result.error || "åŒºé—´å¹³è¡¡åˆ†æå¤±è´¥");
    }
    
    return {
      ...result.predictions,
      algorithm: "zone",
      zoneRecommendations: result.predictions.zoneRecommendations
    };
  }

  static integratePredictions(algorithmResults, weights) {
    const integrated = {
      specialNumbers: new Map(),
      normalNumbers: new Map(),
      zodiacScores: new Map(),
      colorScores: new Map(),
      algorithmContributions: {}
    };
    
    // æ±‡æ€»æ‰€æœ‰æˆåŠŸç®—æ³•çš„ç»“æœ
    const successfulResults = algorithmResults.filter(r => r.success && r.result);
    
    for (const algoResult of successfulResults) {
      const algoName = algoResult.name;
      const algoWeight = algoResult.weight;
      const prediction = algoResult.result;
      
      integrated.algorithmContributions[algoName] = {
        weight: algoWeight,
        confidence: prediction.confidence || 0
      };
      
      // æ±‡æ€»ç‰¹æ®Šå·ç 
      if (prediction.specialNumbers && Array.isArray(prediction.specialNumbers)) {
        for (const numData of prediction.specialNumbers) {
          const num = numData.number;
          const score = (numData.score || numData.probability || 0) * algoWeight;
          
          integrated.specialNumbers.set(
            num,
            (integrated.specialNumbers.get(num) || 0) + score
          );
        }
      }
      
      // æ±‡æ€»å¹³ç 
      if (prediction.normalNumbers && Array.isArray(prediction.normalNumbers)) {
        for (const numData of prediction.normalNumbers) {
          const num = numData.number;
          const score = (numData.score || numData.probability || 0) * algoWeight * 0.8; // å¹³ç æƒé‡ç•¥ä½
          
          integrated.normalNumbers.set(
            num,
            (integrated.normalNumbers.get(num) || 0) + score
          );
        }
      }
      
      // æ±‡æ€»ç”Ÿè‚–
      if (prediction.zodiac && prediction.zodiac.scores) {
        for (const [zodiac, score] of Object.entries(prediction.zodiac.scores)) {
          const weightedScore = score * algoWeight;
          integrated.zodiacScores.set(
            zodiac,
            (integrated.zodiacScores.get(zodiac) || 0) + weightedScore
          );
        }
      }
      
      // æ±‡æ€»æ³¢è‰²
      if (prediction.color && prediction.color.scores) {
        for (const [color, score] of Object.entries(prediction.color.scores)) {
          const weightedScore = score * algoWeight;
          integrated.colorScores.set(
            color,
            (integrated.colorScores.get(color) || 0) + weightedScore
          );
        }
      }
    }
    
    // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
    return this.generateIntegratedPrediction(integrated, successfulResults.length);
  }

  static generateIntegratedPrediction(integrated, algorithmCount) {
    const prediction = {
      specialNumbers: [],
      normalNumbers: [],
      zodiac: { main: [], guard: [], scores: {} },
      color: { main: "", guard: "", scores: {} },
      confidence: 0,
      integratedFrom: algorithmCount
    };
    
    // å¤„ç†ç‰¹æ®Šå·ç 
    const sortedSpecial = Array.from(integrated.specialNumbers.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_SPECIAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: this.normalizeScore(score, integrated.specialNumbers),
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    // å¤„ç†å¹³ç 
    const sortedNormal = Array.from(integrated.normalNumbers.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, CONFIG.SYSTEM.MAX_NORMAL_PREDICTIONS)
      .map(([number, score]) => ({
        number,
        score,
        probability: this.normalizeScore(score, integrated.normalNumbers),
        zodiac: Formatter.getAttributes(number).zodiac,
        color: Formatter.getAttributes(number).color
      }));
    
    // å¤„ç†ç”Ÿè‚–
    const sortedZodiacs = Array.from(integrated.zodiacScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    prediction.zodiac.scores = Object.fromEntries(integrated.zodiacScores);
    prediction.zodiac.main = sortedZodiacs.slice(0, 3).map(([zodiac]) => zodiac);
    prediction.zodiac.guard = sortedZodiacs.slice(3, 6).map(([zodiac]) => zodiac);
    
    // å¤„ç†æ³¢è‰²
    const sortedColors = Array.from(integrated.colorScores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    prediction.color.scores = Object.fromEntries(integrated.colorScores);
    prediction.color.main = sortedColors[0] ? sortedColors[0][0] : "";
    prediction.color.guard = sortedColors[1] ? sortedColors[1][0] : "";
    
    prediction.specialNumbers = sortedSpecial;
    prediction.normalNumbers = sortedNormal;
    
    // è®¡ç®—å½¢æ€
    prediction.head = this.calculateHead(sortedNormal);
    prediction.shape = this.calculateShape(sortedNormal);
    
    // è®¡ç®—ç½®ä¿¡åº¦
    prediction.confidence = this.calculateIntegratedConfidence(integrated, algorithmCount);
    
    return prediction;
  }

  static normalizeScore(score, scoresMap) {
    const scores = Array.from(scoresMap.values());
    const maxScore = Math.max(...scores);
    const minScore = Math.min(...scores);
    
    if (maxScore === minScore) return 0.5;
    
    return (score - minScore) / (maxScore - minScore);
  }

  static calculateHead(normalNumbers) {
    if (!normalNumbers || normalNumbers.length === 0) return "æœªçŸ¥";
    
    const headCounts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
    
    for (const numData of normalNumbers.slice(0, 6)) {
      const head = Math.floor(numData.number / 10);
      if (head <= 4) {
        headCounts[head] = (headCounts[head] || 0) + 1;
      }
    }
    
    // æ‰¾å‡ºæœ€å¤šçš„å¤´æ•°
    let maxHead = 0;
    let maxCount = 0;
    
    for (const [head, count] of Object.entries(headCounts)) {
      if (count > maxCount) {
        maxCount = count;
        maxHead = parseInt(head);
      }
    }
    
    return `${maxHead}å¤´`;
  }

  static calculateShape(normalNumbers) {
    if (!normalNumbers || normalNumbers.length < 6) return "æœªçŸ¥";
    
    const topSix = normalNumbers.slice(0, 6);
    
    const bigCount = topSix.filter(num => num.number >= 25).length;
    const oddCount = topSix.filter(num => num.number % 2 !== 0).length;
    
    let shape = "";
    
    // å¤§å°å½¢æ€
    if (bigCount >= 4) shape += "å¤§";
    else if (bigCount <= 2) shape += "å°";
    else shape += "å‡è¡¡";
    
    shape += "/";
    
    // å•åŒå½¢æ€
    if (oddCount >= 4) shape += "å•";
    else if (oddCount <= 2) shape += "åŒ";
    else shape += "å‡è¡¡";
    
    return shape;
  }

  static calculateIntegratedConfidence(integrated, algorithmCount) {
    let confidence = 0;
    
    // åŸºäºç®—æ³•æ•°é‡
    if (algorithmCount >= 5) {
      confidence += 40;
    } else if (algorithmCount >= 3) {
      confidence += 25;
    } else if (algorithmCount >= 2) {
      confidence += 15;
    } else if (algorithmCount >= 1) {
      confidence += 5;
    }
    
    // åŸºäºç‰¹æ®Šå·ç çš„é›†ä¸­åº¦
    const specialScores = Array.from(integrated.specialNumbers.values());
    if (specialScores.length > 0) {
      const maxScore = Math.max(...specialScores);
      const avgScore = specialScores.reduce((a, b) => a + b, 0) / specialScores.length;
      const concentration = maxScore / (avgScore || 1);
      
      if (concentration > 2) confidence += 30;
      else if (concentration > 1.5) confidence += 20;
      else if (concentration > 1.2) confidence += 10;
    }
    
    // åŸºäºå¹³ç çš„é›†ä¸­åº¦
    const normalScores = Array.from(integrated.normalNumbers.values());
    if (normalScores.length > 0) {
      const maxScore = Math.max(...normalScores);
      const avgScore = normalScores.reduce((a, b) => a + b, 0) / normalScores.length;
      const concentration = maxScore / (avgScore || 1);
      
      if (concentration > 1.8) confidence += 20;
      else if (concentration > 1.4) confidence += 12;
      else if (concentration > 1.1) confidence += 6;
    }
    
    return Math.min(95, confidence);
  }
}
class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `<b>${CONFIG.SYSTEM.NAME} - å‘½ä»¤æ¨¡æ¿</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `<i>é˜²åˆ·å±æ¨¡å¼ï¼Œæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</i>\n\n`;
      
      message += `<b>ä¸»è¦å‘½ä»¤ï¼š</b>\n`;
      message += `<code>/predict</code> - ä¼ ç»Ÿç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict knn</code> - KNNç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict stats</code> - ç»Ÿè®¡ç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹ï¼ˆæ•´åˆå…¨éƒ¨ç®—æ³•ï¼‰\n`;
      message += `<code>/history [é¡µç ]</code> - æŸ¥çœ‹å†å²è®°å½•\n`;
      message += `<code>/ccc</code> - æ˜¾ç¤ºæ­¤å‘½ä»¤æ¨¡æ¿\n`;
      
      if (isAdmin) {
        message += `\n<b>ç®¡ç†å‘˜å‘½ä»¤ï¼š</b>\n`;
        message += `<code>/sync</code> - åŒæ­¥å†å²æ•°æ®\n`;
        message += `<code>/push</code> - æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
        message += `<code>/delete [æœŸå·]</code> - åˆ é™¤å•æœŸè®°å½•\n`;
        message += `<code>/auto_sync_status</code> - æŸ¥çœ‹è‡ªåŠ¨åŒæ­¥çŠ¶æ€\n`;
        message += `<code>/auto_sync_on</code> - å¼€å¯è‡ªåŠ¨åŒæ­¥\n`;
        message += `<code>/auto_sync_off</code> - å…³é—­è‡ªåŠ¨åŒæ­¥\n`;
      }
      
      message += `\n<b>å¢å¼ºé¢„æµ‹ç®—æ³•ï¼š</b>\n`;
      message += `ä¼ ç»Ÿç®—æ³• - åŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°\n`;
      message += `KNNç®—æ³• - K-è¿‘é‚»ç®—æ³•ï¼Œå¯»æ‰¾ç›¸ä¼¼å†å²\n`;
      message += `ç»Ÿè®¡ç®—æ³• - ç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ã€å¤´æ•°ã€å¤§å°ã€å•åŒå…¨é¢ç»Ÿè®¡\n`;
      message += `å¢å¼ºé¢„æµ‹ - æ•´åˆæ‰€æœ‰ç®—æ³•çš„æœ€å¼ºé¢„æµ‹ï¼ˆåŒ…å«è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿï¼‰\n`;
      message += `æ–°å¢å››å¤§ä¸“å®¶ç®—æ³•ï¼š\n`;
      message += `  â€¢ é—æ¼å›è¡¥ä¸“å®¶ - åŸºäºå‡å€¼å›å½’åŸç†\n`;
      message += `  â€¢ å…³è”è§„åˆ™ä¸“å®¶ - åŸºäºæ•°æ®æŒ–æ˜å…³è”åˆ†æ\n`;
      message += `  â€¢ é»„é‡‘åˆ†å‰²ä¸“å®¶ - åŸºäºæ•°å­¦å¸¸æ•°å’Œæ•°åˆ—\n`;
      message += `  â€¢ åŒºé—´å¹³è¡¡ä¸“å®¶ - åŸºäºç©ºé—´åˆ†å¸ƒå‡åŒ€æ€§\n`;
      
      message += `\n<b>è‡ªåŠ¨åŒæ­¥åŠŸèƒ½ï¼š</b>\n`;
      message += `â€¢ åŒ—äº¬æ—¶é—´æ¯å¤©å‡Œæ™¨5ç‚¹è‡ªåŠ¨åŒæ­¥æ•°æ®\n`;
      message += `â€¢ å‘ç°æ–°å¼€å¥–è®°å½•åè‡ªåŠ¨ç”Ÿæˆé¢„æµ‹å¹¶æ¨é€åˆ°é¢‘é“\n`;
      message += `â€¢ ç®¡ç†å‘˜å¯ä½¿ç”¨ /auto_sync_on å’Œ /auto_sync_off æ§åˆ¶\n`;
      
      message += `\n<b>ä½¿ç”¨ç¤ºä¾‹ï¼š</b>\n`;
      message += `<code>/predict</code> - ä¼ ç»Ÿç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict knn</code> - KNNç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict stats</code> - ç»Ÿè®¡ç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹ï¼ˆæ¨èï¼‰\n`;
      message += `<code>/history 1</code> - æŸ¥çœ‹ç¬¬1é¡µå†å²\n`;
      
      if (isAdmin) {
        message += `<code>/auto_sync_status</code> - æŸ¥çœ‹è‡ªåŠ¨åŒæ­¥çŠ¶æ€\n`;
      }
      
      message += `\n<b>å¢å¼ºç‰¹æ€§ï¼š</b>\n`;
      message += `KNNç®—æ³•ï¼šå¯»æ‰¾ç›¸ä¼¼å†å²æ¨¡å¼\n`;
      message += `ç»Ÿè®¡ç®—æ³•ï¼šå…¨é¢åˆ†æå†å²è§„å¾‹\n`;
      message += `è’™ç‰¹å¡æ´›ï¼šå·²æ•´åˆåˆ°å¢å¼ºé¢„æµ‹ä¸­\n`;
      message += `å››å¤§ä¸“å®¶ï¼šé—æ¼å›è¡¥ã€å…³è”è§„åˆ™ã€é»„é‡‘åˆ†å‰²ã€åŒºé—´å¹³è¡¡\n`;
      message += `å®šæ—¶åŒæ­¥ï¼šæ¯å¤©å‡Œæ™¨5ç‚¹è‡ªåŠ¨åŒæ­¥å¹¶é¢„æµ‹\n`;
      message += `æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ\n`;
      message += `å¤šç»´åº¦åˆ†æ\n`;
      message += `è¶…æ—¶æ§åˆ¶ï¼Œé¿å…Workerè¶…æ—¶\n`;
      
      message += `\n<b>é˜²åˆ·å±ç‰¹æ€§ï¼š</b>\n`;
      message += `æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `ä¿æŒèŠå¤©ç•Œé¢æ•´æ´\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å‘½ä»¤æ¨¡æ¿å¤±è´¥", error);
      return `<b>${CONFIG.SYSTEM.NAME}</b>\n\nä½¿ç”¨ /ccc æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨ã€‚`;
    }
  }

  static renderWelcomeMessage(isAdmin = false) {
    try {
      let message = `<b>æ¬¢è¿ä½¿ç”¨ ${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `<b>å¢å¼ºç»Ÿè®¡ç®—æ³•é¢„æµ‹ç³»ç»Ÿ</b>\n\n`;
      message += `KNNç®—æ³•ï¼šå¯»æ‰¾ç›¸ä¼¼å†å²æ¨¡å¼\n`;
      message += `ç»Ÿè®¡ç®—æ³•ï¼šå…¨é¢åˆ†æç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°è§„å¾‹\n`;
      message += `å¢å¼ºé¢„æµ‹ï¼šæ•´åˆæ‰€æœ‰ç®—æ³•çš„æœ€å¼ºé¢„æµ‹\n`;
      message += `æ–°å¢å››å¤§ä¸“å®¶ç®—æ³•ï¼š\n`;
      message += `â€¢ é—æ¼å›è¡¥ä¸“å®¶\n`;
      message += `â€¢ å…³è”è§„åˆ™ä¸“å®¶\n`;
      message += `â€¢ é»„é‡‘åˆ†å‰²ä¸“å®¶\n`;
      message += `â€¢ åŒºé—´å¹³è¡¡ä¸“å®¶\n`;
      message += `è‡ªåŠ¨åŒæ­¥ï¼šæ¯å¤©å‡Œæ™¨5ç‚¹è‡ªåŠ¨åŒæ­¥å¹¶é¢„æµ‹\n`;
      message += `é˜²åˆ·å±æ¶ˆæ¯ç®¡ç†\n`;
      message += `é¢„æµ‹è¶…æ—¶æ§åˆ¶\n\n`;
      message += `ä½¿ç”¨ <code>/ccc</code> æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨\n`;
      message += `ä½¿ç”¨ <code>/predict advanced</code> ç”Ÿæˆå¢å¼ºé¢„æµ‹\n`;
      message += `ä½¿ç”¨ <code>/predict stats</code> æŸ¥çœ‹ç»Ÿè®¡é¢„æµ‹\n`;
      
      if (isAdmin) {
        message += `\n<b>ç®¡ç†å‘˜åŠŸèƒ½ï¼š</b>\n`;
        message += `ä½¿ç”¨ <code>/auto_sync_status</code> æŸ¥çœ‹è‡ªåŠ¨åŒæ­¥çŠ¶æ€\n`;
        message += `ä½¿ç”¨ <code>/auto_sync_on</code> å¼€å¯è‡ªåŠ¨åŒæ­¥\n`;
        message += `ä½¿ç”¨ <code>/auto_sync_off</code> å…³é—­è‡ªåŠ¨åŒæ­¥\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¬¢è¿æ¶ˆæ¯å¤±è´¥", error);
      return `<b>${CONFIG.SYSTEM.NAME}</b>\n\nç³»ç»Ÿè¿è¡Œæ­£å¸¸ã€‚`;
    }
  }

  static renderPrediction(prediction) {
    try {
      if (!prediction) {
        return `é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚`;
      }
      
      const nextExpect = Formatter.safeString(prediction.nextExpect, "æœªçŸ¥");
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const zodiac = prediction.zodiac || { main: [], guard: [], scores: {} };
      const color = prediction.color || { main: "red", guard: "blue", scores: {} };
      const head = Formatter.safeString(prediction.head, "æœªçŸ¥");
      const shape = Formatter.safeString(prediction.shape, "æœªçŸ¥");
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      const algorithmName = prediction.algorithmName || prediction.algorithm || "æœªçŸ¥";
      const confidence = Formatter.safeInt(prediction.confidence, 0);
      
      let content = `ç¬¬ ${nextExpect} æœŸé¢„æµ‹\n`;
      content += `ç®—æ³•: ${algorithmName}\n`;
      content += `ç½®ä¿¡åº¦: ${confidence}%\n`;
      content += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      content += `ç”Ÿè‚–æ¨è\n`;
      content += `ä¸»æ¨: ${(zodiac.main || []).join(" ")}\n`;
      content += `é˜²å®ˆ: ${(zodiac.guard || []).join(" ")}\n\n`;
      content += `æ³¢è‰²å‚è€ƒ\n`;
      content += `ä¸»${CONFIG.EMOJI[color.main] || ""} / é˜²${CONFIG.EMOJI[color.guard] || ""}\n\n`;
      content += `ç‰¹ç å‚è€ƒ (æ¦‚ç‡)\n`;
      
      if (specialNumbers.length > 0) {
        specialNumbers.slice(0, 5).forEach((num, index) => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.probability ? `(${(num.probability * 100).toFixed(1)}%)` : "";
          const rank = index + 1;
          
          content += `${rank}. ${numStr}(${zodiacStr}${colorEmoji})${prob}\n`;
        });
      } else {
        content += `æš‚æ— æ•°æ®\n`;
      }
      
      content += `\nç²¾é€‰å¹³ç \n`;
      
      if (normalNumbers.length > 0) {
        content += normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      } else {
        content += `æš‚æ— æ•°æ®`;
      }
      
      content += `\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      content += `å½¢æ€åˆ†æ\n`;
      content += `å¤´æ•°: ${head} | å½¢æ€: ${shape}\n`;
      content += `å†å²æ•°æ®: ${totalHistoryRecords} æœŸ`;
      
      // å¦‚æœæ˜¯è‡ªåŠ¨é¢„æµ‹ï¼Œæ·»åŠ æ ‡è®°
      if (prediction.autoGenerated) {
        content += `\n\n<i>ğŸ•’ è‡ªåŠ¨é¢„æµ‹ç”Ÿæˆæ—¶é—´: ${prediction.autoGeneratedTime || Formatter.formatDateTime()}</i>`;
      }
      
      // å¦‚æœæ˜¯å¢å¼ºé¢„æµ‹ï¼Œæ˜¾ç¤ºé›†æˆçš„ç®—æ³•
      if (prediction.algorithm === "advanced" && prediction.integratedAlgorithms) {
        content += `\n\n<i>æ•´åˆç®—æ³•: ${prediction.integratedAlgorithms.map(a => a.name).join(", ")}</i>`;
      }
      
      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„æµ‹æ—¶å‡ºé”™", error);
      return `æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            const colorEmoji = CONFIG.EMOJI[attr.color] || "";
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${colorEmoji}\n`;
          }
        });
      }

      message += `\nä½¿ç”¨ <code>/history ${page + 1}</code> æŸ¥çœ‹ä¸‹ä¸€é¡µ`;
      message += `\n\n<i>å†æ¬¡å‘é€ /history å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return `è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `<b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `<b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\n<b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
      } else {
        message += `<b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\n<i>å†æ¬¡å‘é€ /sync å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return `å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderPushResult(success, prediction, channelPushSuccess = false) {
    try {
      let message = `<b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `<b>æ¨é€æˆåŠŸ</b>\n`;
        message += `æœŸå·: ${prediction?.nextExpect || "æœªçŸ¥"}\n`;
        message += `ç½®ä¿¡åº¦: ${prediction?.confidence || 0}%\n`;
        
        if (channelPushSuccess) {
          message += `é¢‘é“æ¨é€: æˆåŠŸ\n`;
        } else {
          message += `é¢‘é“æ¨é€: å¤±è´¥\n`;
        }
      } else {
        message += `<b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      message += `\n<i>å†æ¬¡å‘é€ /push å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return `å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteConfirmation(expectRange, impactInfo) {
    try {
      const { toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `<b>åˆ é™¤ç¡®è®¤</b>\n\n`;
      
      if (expectRange.includes('-')) {
        const [start, end] = expectRange.split('-');
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(start)}</b> æœŸåˆ°ç¬¬ <b>${Formatter.safeString(end)}</b> æœŸçš„è®°å½•\n`;
      } else {
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(expectRange)}</b> æœŸçš„è®°å½•\n`;
      }
      
      message += `æ¶‰åŠ <b>${toDeleteCount || 0}</b> æ¡å†å²è®°å½•\n\n`;
      
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        const colorEmoji = CONFIG.EMOJI[attr.color] || "";
        message += `<b>åˆ é™¤åï¼Œæœ€æ–°è®°å½•ä¸º:</b>\n`;
        message += `ç¬¬ <b>${latestAfterDelete.expect || "æœªçŸ¥"}</b> æœŸ | ${attr.zodiac}${colorEmoji}\n`;
      } else {
        message += `åˆ é™¤åå°†æ— å†å²è®°å½•\n`;
      }
      
      message += `\n<b>è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼</b>\n\n`;
      message += `è¯·å›å¤ <code>ç¡®è®¤åˆ é™¤ ${Formatter.safeString(expectRange)}</code> ä»¥ç¡®è®¤åˆ é™¤ã€‚`;
      
      message += `\n\n<i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç¡®è®¤å¤±è´¥", error);
      return `<b>åˆ é™¤ç¡®è®¤å¤±è´¥</b>\n\næ— æ³•ç”Ÿæˆç¡®è®¤ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `<b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `<b>åˆ é™¤æˆåŠŸ</b>\n`;
        message += `åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
        message += `åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
        
        if (result.total !== undefined) {
          message += `èŒƒå›´å†…è®°å½•æ•°: ${result.total} æ¡\n`;
        }
        
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          const colorEmoji = CONFIG.EMOJI[attr.color] || "";
          message += `\n<b>åˆ é™¤åæœ€æ–°è®°å½•</b>\n`;
          message += `ç¬¬ ${latestAfterDelete.expect} æœŸ | ${attr.zodiac}${colorEmoji}\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `<b>åˆ é™¤å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\næ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
      message += `\n\n<i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç»“æœæ—¶å‡ºé”™", error);
      return `<b>åˆ é™¤æ“ä½œç»“æœ</b>\n\nå¤„ç†åˆ é™¤ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderAutoSyncStatus(status) {
    try {
      let message = `<b>è‡ªåŠ¨åŒæ­¥çŠ¶æ€</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
      
      message += `<b>çŠ¶æ€:</b> ${status.enabled ? "âœ… å·²å¯ç”¨" : "âŒ å·²ç¦ç”¨"}\n`;
      message += `<b>æœ€åæ‰§è¡Œ:</b> ${status.lastAutoSync}\n`;
      message += `<b>æœ€åç»“æœ:</b> ${status.lastResult}\n`;
      message += `<b>ä¸‹æ¬¡æ‰§è¡Œ:</b> ${status.nextTime}\n`;
      
      const nextSyncTime = new Date(status.nextTime);
      if (!isNaN(nextSyncTime.getTime())) {
        const timeRemaining = Formatter.formatTimeRemaining(nextSyncTime.getTime());
        message += `<b>å‰©ä½™æ—¶é—´:</b> ${timeRemaining}\n`;
      }
      
      message += `\n<b>ç»Ÿè®¡ä¿¡æ¯:</b>\n`;
      message += `æ€»æ‰§è¡Œæ¬¡æ•°: ${status.stats.total_auto_syncs || 0}\n`;
      message += `æˆåŠŸæ¬¡æ•°: ${status.stats.successful_auto_syncs || 0}\n`;
      message += `å¤±è´¥æ¬¡æ•°: ${status.stats.failed_auto_syncs || 0}\n`;
      message += `æ–°å¢è®°å½•æ€»æ•°: ${status.stats.total_new_records || 0}\n`;
      message += `è‡ªåŠ¨é¢„æµ‹ç”Ÿæˆæ¬¡æ•°: ${status.stats.total_predictions_generated || 0}\n`;
      message += `é¢‘é“æ¨é€æˆåŠŸæ¬¡æ•°: ${status.stats.total_channel_pushes || 0}\n`;
      
      if (status.stats.last_auto_predict_result) {
        message += `\n<b>æœ€åè‡ªåŠ¨é¢„æµ‹:</b> ${status.stats.last_auto_predict_result}\n`;
      }
      
      if (status.stats.last_execution_time) {
        message += `\n<b>æœ€åæ‰§è¡Œæ—¶é—´:</b> ${status.stats.last_execution_time}\n`;
      }
      
      message += `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      message += `<b>é…ç½®ä¿¡æ¯:</b>\n`;
      message += `åŒæ­¥æ—¶é—´: åŒ—äº¬æ—¶é—´æ¯å¤© ${CONFIG.SYSTEM.AUTO_SYNC_CONFIG.BEIJING_HOUR}:00\n`;
      message += `çª—å£æœŸ: ${CONFIG.SYSTEM.AUTO_SYNC_CONFIG.SYNC_WINDOW_START}:00-${CONFIG.SYSTEM.AUTO_SYNC_CONFIG.SYNC_WINDOW_END}:59\n`;
      message += `å½“å‰åŒ—äº¬æ—¶é—´: ${Formatter.formatDateTime(Formatter.getBeijingTime())}\n`;
      
      message += `\n<b>ç®¡ç†å‘˜å‘½ä»¤:</b>\n`;
      message += `<code>/auto_sync_on</code> - å¼€å¯è‡ªåŠ¨åŒæ­¥\n`;
      message += `<code>/auto_sync_off</code> - å…³é—­è‡ªåŠ¨åŒæ­¥\n`;
      message += `<code>/sync</code> - æ‰‹åŠ¨ç«‹å³åŒæ­¥\n`;
      
      message += `\n<i>æ³¨æ„: è‡ªåŠ¨åŒæ­¥ä»…åœ¨å‘ç°æ–°å¼€å¥–è®°å½•æ—¶æ‰ç”Ÿæˆé¢„æµ‹å¹¶æ¨é€åˆ°é¢‘é“</i>`;
      message += `\n<i>å†æ¬¡å‘é€ /auto_sync_status å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“è‡ªåŠ¨åŒæ­¥çŠ¶æ€å¤±è´¥", error);
      return `<b>è‡ªåŠ¨åŒæ­¥çŠ¶æ€</b>\n\næ— æ³•è·å–çŠ¶æ€ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderAutoSyncOperationResult(operation, success, enabled) {
    try {
      let message = `<b>è‡ªåŠ¨åŒæ­¥æ“ä½œç»“æœ</b>\n\n`;
      
      if (success) {
        message += `<b>æ“ä½œæˆåŠŸ</b>\n`;
        message += `æ“ä½œ: ${operation}\n`;
        message += `å½“å‰çŠ¶æ€: ${enabled ? "âœ… å·²å¯ç”¨" : "âŒ å·²ç¦ç”¨"}\n`;
        
        if (enabled) {
          const nextSync = Formatter.getNextSyncTime();
          message += `ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´: ${nextSync.formatted}\n`;
          message += `å‰©ä½™æ—¶é—´: ${Formatter.formatTimeRemaining(nextSync.timestamp)}\n`;
        }
      } else {
        message += `<b>æ“ä½œå¤±è´¥</b>\n`;
        message += `æ“ä½œ: ${operation}\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      message += `\nä½¿ç”¨ <code>/auto_sync_status</code> æŸ¥çœ‹è¯¦ç»†çŠ¶æ€`;
      message += `\n\n<i>å†æ¬¡å‘é€ç›¸åŒå‘½ä»¤å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“è‡ªåŠ¨åŒæ­¥æ“ä½œç»“æœå¤±è´¥", error);
      return `<b>è‡ªåŠ¨åŒæ­¥æ“ä½œç»“æœ</b>\n\nå¤„ç†æ“ä½œç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderAutoSyncExecutionResult(result, predictionResult = null) {
    try {
      let message = `<b>è‡ªåŠ¨åŒæ­¥æ‰§è¡Œç»“æœ</b>\n`;
      message += `æ‰§è¡Œæ—¶é—´: ${Formatter.formatDateTime()}\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
      
      if (result?.success) {
        message += `<b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\n<b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
          
          if (predictionResult && predictionResult.success) {
            message += `\n<b>è‡ªåŠ¨é¢„æµ‹ç”ŸæˆæˆåŠŸ</b>\n`;
            message += `æœŸå·: ${predictionResult.nextExpect || "æœªçŸ¥"}\n`;
            message += `ç½®ä¿¡åº¦: ${predictionResult.confidence || 0}%\n`;
            message += `é¢‘é“æ¨é€: ${predictionResult.channelPushSuccess ? "âœ… æˆåŠŸ" : "âŒ å¤±è´¥"}\n`;
            
            if (predictionResult.channelPushSuccess) {
              message += `\n<i>é¢„æµ‹å·²è‡ªåŠ¨æ¨é€åˆ°é¢‘é“</i>\n`;
            }
          } else if (predictionResult) {
            message += `\n<b>è‡ªåŠ¨é¢„æµ‹ç”Ÿæˆå¤±è´¥</b>\n`;
            message += `é”™è¯¯: ${predictionResult.error || "æœªçŸ¥é”™è¯¯"}\n`;
          }
        } else {
          message += `\n<b>æœªå‘ç°æ–°å¼€å¥–è®°å½•</b>\n`;
          message += `æ— éœ€ç”Ÿæˆæ–°é¢„æµ‹\n`;
        }
      } else {
        message += `<b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      message += `<b>ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´:</b>\n`;
      const nextSync = Formatter.getNextSyncTime();
      message += `${nextSync.formatted}\n`;
      message += `å‰©ä½™æ—¶é—´: ${Formatter.formatTimeRemaining(nextSync.timestamp)}\n`;
      
      message += `\n<i>æ­¤æ¶ˆæ¯ä»…å‘é€ç»™ç®¡ç†å‘˜ï¼Œæ™®é€šç”¨æˆ·ä¸ä¼šçœ‹åˆ°</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“è‡ªåŠ¨åŒæ­¥æ‰§è¡Œç»“æœå¤±è´¥", error);
      return `<b>è‡ªåŠ¨åŒæ­¥æ‰§è¡Œç»“æœ</b>\n\nå¤„ç†æ‰§è¡Œç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }
}
class ExternalService {
  static async sendMessage(env, chatId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  static async editMessage(env, chatId, messageId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  static async deleteMessage(env, chatId, messageId) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage?chat_id=${chatId}&message_id=${messageId}`;

      const response = await fetch(url, {
        method: "POST"
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.warn("Telegram", `deleteMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "deleteMessage network error", error);
      return null;
    }
  }

  static async sendAndDeleteOldMessage(env, chatId, messageType, text) {
    try {
      const oldMessageId = MessageManager.getUserMessage(chatId, messageType);
      
      if (oldMessageId) {
        this.deleteMessage(env, chatId, oldMessageId).then(result => {
          if (result && result.ok) {
            Logger.info("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          } else {
            Logger.warn("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¤±è´¥æˆ–æ¶ˆæ¯å·²ä¸å­˜åœ¨: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          }
        }).catch(error => {
          Logger.error("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¼‚å¸¸: chatId=${chatId}, type=${messageType}`, error);
        });
      }
      
      const sendResult = await this.sendMessage(env, chatId, text);
      
      if (sendResult && sendResult.ok && sendResult.result) {
        const newMessageId = sendResult.result.message_id;
        
        MessageManager.setUserMessage(chatId, messageType, newMessageId);
        
        MessageManager.cleanupOldMessages(chatId, 10);
        
        Logger.info("Telegram", `å‘é€æ–°æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${newMessageId}, æ—§æ¶ˆæ¯ID=${oldMessageId || 'æ— '}`);
        
        return { 
          success: true, 
          messageId: newMessageId, 
          oldMessageId: oldMessageId,
          message: oldMessageId ? "å·²åˆ é™¤æ—§æ¶ˆæ¯å¹¶å‘é€æ–°æ¶ˆæ¯" : "å‘é€æ–°æ¶ˆæ¯"
        };
      }
      
      return { 
        success: false, 
          error: "æ¶ˆæ¯å‘é€å¤±è´¥",
        oldMessageId: oldMessageId
      };
    } catch (error) {
      Logger.error("Telegram", "sendAndDeleteOldMessageå¤±è´¥", error);
      return { 
        success: false, 
        error: error.message,
        method: "error"
      };
    }
  }

  static async sendTemporaryMessage(env, chatId, text, parseMode = "HTML") {
    return await this.sendMessage(env, chatId, text, parseMode);
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'application/json, text/plain, */*',
          'Referer': 'https://1234kj.com/'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const text = await response.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        Logger.error("Sync", "JSONè§£æå¤±è´¥", { sample: text.substring(0, 50) });
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      let records = [];

      if (data.code === 0 && data.data && typeof data.data === 'object' && !Array.isArray(data.data)) {
        Logger.info("Sync", "è¯†åˆ«åˆ° 1234kj.com (Object) æ¥å£æ ¼å¼");
        const rawArray = Object.values(data.data);
        records = this.parseRecordsFormat2(rawArray);
      }
      else if (data.code === 0 && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      }
      else if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } 
      else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } 
      else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } 
      else {
        Logger.error("Sync", "ä¸æ”¯æŒçš„JSONæ ¼å¼", { keys: Object.keys(data) });
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
        
        CacheManager.clear();
        OptimizedMonteCarloEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }

  static async executeAutoSync(env) {
    try {
      Logger.info("AutoSync", "å¼€å§‹æ‰§è¡Œè‡ªåŠ¨åŒæ­¥");
      
      // æ£€æŸ¥æ˜¯å¦åº”è¯¥è¿è¡Œè‡ªåŠ¨åŒæ­¥
      const shouldRun = await DB.shouldRunAutoSync(env);
      if (!shouldRun.shouldRun) {
        Logger.info("AutoSync", `è·³è¿‡è‡ªåŠ¨åŒæ­¥: ${shouldRun.reason}`);
        return {
          success: true,
          skipped: true,
          reason: shouldRun.reason,
          added: 0,
          newCount: 0
        };
      }
      
      // æ‰§è¡ŒåŒæ­¥
      const syncResult = await this.syncHistoryFromUrl(env);
      
      let predictionResult = null;
      
      // å¦‚æœåŒæ­¥æˆåŠŸå¹¶ä¸”æœ‰æ–°è®°å½•ï¼Œç”Ÿæˆé¢„æµ‹å¹¶æ¨é€åˆ°é¢‘é“
      if (syncResult.success && syncResult.added > 0 && syncResult.newCount > 0) {
        Logger.info("AutoSync", `å‘ç° ${syncResult.added} æ¡æ–°è®°å½•ï¼Œå¼€å§‹ç”Ÿæˆé¢„æµ‹`);
        
        try {
          // è·å–å†å²æ•°æ®å’Œæƒé‡
          const history = await DB.getAllHistory(env);
          const weights = await DB.getWeights(env);
          
          // ç”Ÿæˆå¢å¼ºé¢„æµ‹
          const prediction = await PredictionEngine.generate(env, history, weights, "advanced");
          
          if (prediction && !prediction.error) {
            // æ ‡è®°ä¸ºè‡ªåŠ¨ç”Ÿæˆ
            prediction.autoGenerated = true;
            prediction.autoGeneratedTime = Formatter.formatDateTime();
            
            // å°è¯•æ¨é€åˆ°é¢‘é“
            let channelPushSuccess = false;
            if (env.TG_CHANNEL_ID) {
              try {
                const channelMessage = MessageRenderer.renderPrediction(prediction);
                await this.sendMessage(env, env.TG_CHANNEL_ID, channelMessage);
                channelPushSuccess = true;
                Logger.info("AutoSync", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${prediction.nextExpect}`);
              } catch (channelError) {
                Logger.error("AutoSync", "æ¨é€åˆ°é¢‘é“å¤±è´¥", channelError);
                channelPushSuccess = false;
              }
            } else {
              Logger.warn("AutoSync", "æœªé…ç½®é¢‘é“IDï¼Œæ— æ³•æ¨é€é¢„æµ‹åˆ°é¢‘é“");
            }
            
            predictionResult = {
              success: true,
              nextExpect: prediction.nextExpect,
              confidence: prediction.confidence,
              channelPushSuccess: channelPushSuccess,
              autoGenerated: true
            };
            
            // æ›´æ–°è‡ªåŠ¨åŒæ­¥ç»Ÿè®¡ï¼ŒåŒ…å«é¢„æµ‹ç»“æœ
            syncResult.autoPredictionResult = channelPushSuccess ? 
              `æˆåŠŸç”Ÿæˆç¬¬ ${prediction.nextExpect} æœŸé¢„æµ‹å¹¶æ¨é€åˆ°é¢‘é“` :
              `æˆåŠŸç”Ÿæˆç¬¬ ${prediction.nextExpect} æœŸé¢„æµ‹ä½†é¢‘é“æ¨é€å¤±è´¥`;
          } else {
            Logger.error("AutoSync", "ç”Ÿæˆé¢„æµ‹å¤±è´¥", prediction?.error);
            predictionResult = {
              success: false,
              error: prediction?.error || "ç”Ÿæˆé¢„æµ‹å¤±è´¥"
            };
            syncResult.autoPredictionResult = "ç”Ÿæˆé¢„æµ‹å¤±è´¥";
          }
        } catch (predictionError) {
          Logger.error("AutoSync", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", predictionError);
          predictionResult = {
            success: false,
            error: predictionError.message || "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™"
          };
          syncResult.autoPredictionResult = "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™";
        }
      } else if (syncResult.success) {
        Logger.info("AutoSync", "åŒæ­¥æˆåŠŸä½†æœªå‘ç°æ–°è®°å½•");
        syncResult.autoPredictionResult = "æœªå‘ç°æ–°è®°å½•ï¼Œæ— éœ€ç”Ÿæˆé¢„æµ‹";
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await DB.updateAutoSyncStats(env, {
        ...syncResult,
        predictionResult: predictionResult
      });
      
      // å‘é€æ‰§è¡Œç»“æœç»™ç®¡ç†å‘˜ï¼ˆå¦‚æœé…ç½®äº†ç®¡ç†å‘˜IDï¼‰
      if (env.TG_ADMIN_ID) {
        try {
          const adminMessage = MessageRenderer.renderAutoSyncExecutionResult(syncResult, predictionResult);
          await this.sendMessage(env, env.TG_ADMIN_ID, adminMessage);
          Logger.info("AutoSync", "è‡ªåŠ¨åŒæ­¥æ‰§è¡Œç»“æœå·²å‘é€ç»™ç®¡ç†å‘˜");
        } catch (adminError) {
          Logger.error("AutoSync", "å‘é€æ‰§è¡Œç»“æœç»™ç®¡ç†å‘˜å¤±è´¥", adminError);
        }
      }
      
      return {
        ...syncResult,
        predictionResult: predictionResult,
        autoExecuted: true
      };
      
    } catch (error) {
      Logger.error("AutoSync", "æ‰§è¡Œè‡ªåŠ¨åŒæ­¥å¤±è´¥", error);
      
      // è®°å½•å¤±è´¥ç»Ÿè®¡
      const failedResult = {
        success: false,
        error: error.message || "æœªçŸ¥é”™è¯¯",
        predictionResult: null,
        autoPredictionResult: "æ‰§è¡Œå¤±è´¥"
      };
      
      await DB.updateAutoSyncStats(env, failedResult);
      
      return {
        success: false,
        error: error.message || "æœªçŸ¥é”™è¯¯",
        autoExecuted: true,
        predictionResult: null
      };
    }
  }
}
class Controller {
  static pendingDeletions = new Map();

  static async handleStart(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†startå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "<b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  static async handleCommandTemplate(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†cccå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "<b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  static async handlePredict(env, chatId, algorithm = "traditional") {
    try {
      const algorithmName = CONFIG.ALGORITHM_NAMES[algorithm] || "ä¼ ç»Ÿç®—æ³•";
      
      const processingMessage = `<b>æ­£åœ¨ç”Ÿæˆé¢„æµ‹...</b>\n\nç®—æ³•: ${algorithmName}\næ•°æ®: å…¨éƒ¨å†å²è®°å½•\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      if (history.length === 0) {
        const message = "<b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const prediction = await PredictionEngine.generate(env, history, weights, algorithm);
      
      if (!prediction || prediction.error) {
        const message = `<b>é¢„æµ‹ç”Ÿæˆå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${prediction?.error || "æœªçŸ¥é”™è¯¯"}`;
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const message = MessageRenderer.renderPrediction(prediction);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
      );
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†predictå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `<b>ç”Ÿæˆé¢„æµ‹å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message || "æœªçŸ¥é”™è¯¯"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleHistory(env, chatId, pageStr = "1") {
    try {
      const page = Math.max(1, Formatter.safeInt(pageStr, 1));
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†historyå‘½ä»¤å¤±è´¥", error);
      const errorMessage = "<b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleSync(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åŒæ­¥æ•°æ®ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      const message = MessageRenderer.renderSyncResult(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      const errorMessage = `<b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handlePush(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥æ¨é€é¢„æµ‹ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    if (!env.TG_CHANNEL_ID) {
      const message = "<b>é¢‘é“IDæœªé…ç½®</b>\n\næ— æ³•æ¨é€åˆ°é¢‘é“ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>æ­£åœ¨ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "<b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆæ¨é€ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await PredictionEngine.generate(env, history, weights, "advanced");
      
      if (prediction.error) {
        const message = `<b>é¢„æµ‹ç”Ÿæˆå¤±è´¥</b>\n\né”™è¯¯: ${prediction.error}`;
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      let channelPushSuccess = false;
      try {
        const channelMessage = MessageRenderer.renderPrediction(prediction);
        await ExternalService.sendTemporaryMessage(env, env.TG_CHANNEL_ID, channelMessage);
        channelPushSuccess = true;
        Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${prediction.nextExpect}`);
      } catch (error) {
        Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
        channelPushSuccess = false;
      }
      
      const message = MessageRenderer.renderPushResult(true, prediction, channelPushSuccess);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
    } catch (error) {
      Logger.error("Push", "æ¨é€å¤„ç†å¤±è´¥", error);
      const errorMessage = `<b>æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    if (!isAdmin) {
      const message = "<b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åˆ é™¤è®°å½•ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        const message = `<b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        const message = "<b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        const message = `<b>æœªæ‰¾åˆ°è®°å½•</b>\n\nåœ¨ ${expectRange} èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å†å²è®°å½•ã€‚`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, confirmMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, confirmMessage);
      }
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      const errorMessage = `<b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async confirmDelete(env, chatId, userId, confirmText) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const deletionData = this.pendingDeletions.get(deletionKey);
      
      if (!deletionData) {
        const message = "<b>ç¡®è®¤å·²è¿‡æœŸ</b>\n\nåˆ é™¤ç¡®è®¤å·²è¿‡æœŸï¼Œè¯·é‡æ–°å‘èµ·åˆ é™¤å‘½ä»¤ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        return;
      }
      
      // éªŒè¯ç¡®è®¤æ–‡æœ¬
      const expectedText = `ç¡®è®¤åˆ é™¤ ${deletionData.expectRange}`;
      if (confirmText !== expectedText) {
        const message = `<b>ç¡®è®¤æ–‡æœ¬ä¸åŒ¹é…</b>\n\nè¯·å›å¤: <code>${expectedText}</code>`;
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        return;
      }
      
      // æ‰§è¡Œåˆ é™¤
      const result = await DB.deleteHistoryByRange(
        env, 
        deletionData.start, 
        deletionData.end, 
        userId,
        "ç®¡ç†å‘˜æ‰‹åŠ¨åˆ é™¤"
      );
      
      const message = MessageRenderer.renderDeleteResult(result, deletionData.expectRange, deletionData.impactInfo);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      // æ¸…ç†å¾…åˆ é™¤æ•°æ®
      this.pendingDeletions.delete(deletionKey);
      
    } catch (error) {
      Logger.error("Controller", "ç¡®è®¤åˆ é™¤å¤±è´¥", error);
      const errorMessage = `<b>åˆ é™¤æ“ä½œå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, errorMessage
      );
    }
  }

  static async handleAutoSyncStatus(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹è‡ªåŠ¨åŒæ­¥çŠ¶æ€ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_STATUS, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>æ­£åœ¨è·å–è‡ªåŠ¨åŒæ­¥çŠ¶æ€...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_STATUS, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const status = await DB.getAutoSyncStatus(env);
      const message = MessageRenderer.renderAutoSyncStatus(status);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_STATUS, message
      );
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†è‡ªåŠ¨åŒæ­¥çŠ¶æ€æŸ¥è¯¢å¤±è´¥", error);
      const errorMessage = `<b>è·å–è‡ªåŠ¨åŒæ­¥çŠ¶æ€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_STATUS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleAutoSyncOn(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥å¼€å¯è‡ªåŠ¨åŒæ­¥ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_ON, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>æ­£åœ¨å¼€å¯è‡ªåŠ¨åŒæ­¥...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_ON, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const success = await DB.setAutoSyncEnabled(env, true);
      const message = MessageRenderer.renderAutoSyncOperationResult("å¼€å¯è‡ªåŠ¨åŒæ­¥", success, true);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_ON, message
      );
      
      if (success) {
        Logger.info("Controller", "è‡ªåŠ¨åŒæ­¥å·²å¼€å¯");
      }
      
    } catch (error) {
      Logger.error("Controller", "å¼€å¯è‡ªåŠ¨åŒæ­¥å¤±è´¥", error);
      const errorMessage = `<b>å¼€å¯è‡ªåŠ¨åŒæ­¥å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_ON, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleAutoSyncOff(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥å…³é—­è‡ªåŠ¨åŒæ­¥ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_OFF, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>æ­£åœ¨å…³é—­è‡ªåŠ¨åŒæ­¥...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_OFF, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const success = await DB.setAutoSyncEnabled(env, false);
      const message = MessageRenderer.renderAutoSyncOperationResult("å…³é—­è‡ªåŠ¨åŒæ­¥", success, false);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_OFF, message
      );
      
      if (success) {
        Logger.info("Controller", "è‡ªåŠ¨åŒæ­¥å·²å…³é—­");
      }
      
    } catch (error) {
      Logger.error("Controller", "å…³é—­è‡ªåŠ¨åŒæ­¥å¤±è´¥", error);
      const errorMessage = `<b>å…³é—­è‡ªåŠ¨åŒæ­¥å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.AUTO_SYNC_OFF, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async executeAutoSync(env) {
    try {
      Logger.info("Controller", "å¼€å§‹æ‰§è¡Œå®šæ—¶è‡ªåŠ¨åŒæ­¥");
      
      // åˆå§‹åŒ–æ•°æ®åº“
      await DB.init(env);
      
      // æ‰§è¡Œè‡ªåŠ¨åŒæ­¥
      const result = await ExternalService.executeAutoSync(env);
      
      Logger.info("Controller", `å®šæ—¶è‡ªåŠ¨åŒæ­¥å®Œæˆ: ${result.success ? "æˆåŠŸ" : "å¤±è´¥"}, æ–°å¢è®°å½•: ${result.added || 0}`);
      
      return result;
    } catch (error) {
      Logger.error("Controller", "æ‰§è¡Œå®šæ—¶è‡ªåŠ¨åŒæ­¥å¤±è´¥", error);
      return {
        success: false,
        error: error.message || "æœªçŸ¥é”™è¯¯",
        autoExecuted: true
      };
    }
  }
}
async function handleUpdate(env, payload) {
  try {
    if (Math.random() < 0.01) {
      MessageManager.autoCleanup();
    }
    
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId, isAdmin });
    
    if (text.startsWith('ç¡®è®¤åˆ é™¤ ')) {
      if (isAdmin) {
        await Controller.confirmDelete(env, chatId, userId, text);
      } else {
        const message = "<b>æƒé™ä¸è¶³</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, "permission_error", message
        );
      }
      return;
    }
    
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
          
        case '/predict':
        case '/p':
          const predictMatch = text.match(/\/predict\s+(knn|stats|advanced|omission|association|math|zone)/i);
          if (predictMatch) {
            await Controller.handlePredict(env, chatId, predictMatch[1].toLowerCase());
          } else {
            await Controller.handlePredict(env, chatId, "traditional");
          }
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        case '/auto_sync_status':
          await Controller.handleAutoSyncStatus(env, chatId, isAdmin);
          break;
          
        case '/auto_sync_on':
          await Controller.handleAutoSyncOn(env, chatId, isAdmin);
          break;
          
        case '/auto_sync_off':
          await Controller.handleAutoSyncOff(env, chatId, isAdmin);
          break;
          
        default:
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
      }
    } else {
      await Controller.handleCommandTemplate(env, chatId, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}
export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const optionalEnvVars = ['TG_CHANNEL_ID', 'LOTTERY_DATA_URL'];
      
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(JSON.stringify({
          status: "ERROR",
          message: `Missing required environment variables: ${missingVars.join(', ')}`,
          required: requiredEnvVars,
          optional: optionalEnvVars,
          provided: Object.keys(env).filter(k => requiredEnvVars.includes(k) || optionalEnvVars.includes(k)),
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      const optionalMissing = optionalEnvVars.filter(key => !env[key]);
      if (optionalMissing.length > 0) {
        Logger.warn("Worker", `ç¼ºå°‘å¯é€‰ç¯å¢ƒå˜é‡: ${optionalMissing.join(', ')}`, {
          impact: optionalMissing.includes('TG_CHANNEL_ID') ? 'æ— æ³•æ¨é€åˆ°é¢‘é“' : '',
          impact2: optionalMissing.includes('LOTTERY_DATA_URL') ? 'æ— æ³•åŒæ­¥å¤–éƒ¨æ•°æ®' : ''
        });
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "YOUR_CHANNEL_ID_HERE";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "YOUR_ADMIN_ID_HERE";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response(JSON.stringify({
          status: "ERROR",
          message: "Database Initialization Failed. Please check D1 binding.",
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const deletionStats = await DB.getDeletionStats(env);
            const autoSyncStatus = await DB.getAutoSyncStatus(env);
            const autoSyncLogs = await DB.getAutoSyncLogs(env, 5);
            
            const cacheStats = CacheManager.getStats();
            
            const messageManagerStats = {
              totalUsers: MessageManager.userMessages.size
            };
            
            const algorithms = await DB.getWeights(env);
            
            const nextSync = Formatter.getNextSyncTime();
            const beijingHour = Formatter.getBeijingHour();
            const beijingMinute = Formatter.getBeijingMinute();
            const isSyncTime = Formatter.isSyncTime();
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              beijingTime: Formatter.formatDateTime(Formatter.getBeijingTime()),
              beijingHour: beijingHour,
              beijingMinute: beijingMinute,
              environment: {
                hasChannel: !!env.TG_CHANNEL_ID,
                hasLotteryUrl: !!env.LOTTERY_DATA_URL,
                requiredVars: requiredEnvVars.filter(k => env[k]).length + "/" + requiredEnvVars.length,
                optionalVars: optionalEnvVars.filter(k => env[k]).length + "/" + optionalEnvVars.length
              },
              database: {
                historyCount: historyCount,
                deletionStats: deletionStats
              },
              autoSync: {
                enabled: autoSyncStatus.enabled,
                lastAutoSync: autoSyncStatus.lastAutoSync,
                stats: autoSyncStatus.stats,
                nextSyncTime: autoSyncStatus.nextTime,
                isSyncTime: isSyncTime,
                beijingHour: beijingHour,
                beijingMinute: beijingMinute,
                targetHour: CONFIG.SYSTEM.AUTO_SYNC_CONFIG.BEIJING_HOUR,
                recentLogs: autoSyncLogs
              },
              cache: cacheStats,
              messageManager: messageManagerStats,
              algorithms: {
                weights: algorithms,
                knn: "Enabled",
                statistics: "Enabled",
                monteCarlo: "Integrated in Advanced",
                traditional: "Enabled",
                advanced: "Enabled",
                omission: "Enabled",
                association: "Enabled",
                math: "Enabled",
                zone: "Enabled"
              },
              config: {
                knnKValue: CONFIG.SYSTEM.KNN_K_VALUE,
                statsWindowSize: CONFIG.SYSTEM.STATS_WINDOW_SIZE,
                maxRuntimeMs: CONFIG.SYSTEM.MAX_RUNTIME_MS,
                historyLimit: CONFIG.SYSTEM.HISTORY_LIMIT,
                predictionTimeout: CONFIG.SYSTEM.PREDICTION_TIMEOUT,
                algorithmTimeouts: CONFIG.SYSTEM.ALGORITHM_TIMEOUTS,
                autoSyncTargetHour: CONFIG.SYSTEM.AUTO_SYNC_CONFIG.BEIJING_HOUR,
                autoSyncEnabledByDefault: CONFIG.SYSTEM.AUTO_SYNC_CONFIG.ENABLED_BY_DEFAULT
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            OptimizedMonteCarloEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤",
              cleared: {
                cache: true,
                monteCarlo: true,
                messageManager: true
              }
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/test-algorithms") {
          try {
            const history = await DB.getAllHistory(env);
            let knnTestResult = "æœªæµ‹è¯•";
            if (history.length >= 10) {
              const lastRecord = history[0];
              const similarRecords = KNNAlgorithm.findSimilarRecords(history, lastRecord, 5);
              knnTestResult = `æ‰¾åˆ° ${similarRecords.length} æ¡ç›¸ä¼¼è®°å½•`;
            }
            
            let statsTestResult = "æœªæµ‹è¯•";
            if (history.length >= 10) {
              const stats = EnhancedStatistics.analyzeHistoryStatistics(history);
              statsTestResult = `åˆ†æ ${stats.totalRecords} æœŸå†å²ï¼Œå‘ç° ${stats.summary?.strongPatterns?.length || 0} æ¡å¼ºè§„å¾‹`;
            }
            
            let omissionTestResult = "æœªæµ‹è¯•";
            if (history.length >= 30) {
              const weights = await DB.getWeights(env);
              const omissionResult = await OmissionExpert.runOmission(history.slice(0, 100), weights);
              omissionTestResult = `åˆ†æå®Œæˆï¼Œå‘ç° ${omissionResult?.analysis?.summary?.extremeColdCount || 0} ä¸ªæå†·å·ç `;
            }
            
            const autoSyncStatus = await DB.getAutoSyncStatus(env);
            const nextSync = Formatter.getNextSyncTime();
            
            return new Response(JSON.stringify({
              status: "OK",
              timestamp: new Date().toISOString(),
              beijingTime: Formatter.formatDateTime(Formatter.getBeijingTime()),
              algorithms: {
                knn: knnTestResult,
                statistics: statsTestResult,
                omission: omissionTestResult,
                association: "åŸºäºAprioriç®€åŒ–çš„å…³è”è§„åˆ™",
                math: "é»„é‡‘åˆ†å‰²ã€å’Œå€¼å‡çº¿ã€æ¨¡è¿ç®—åˆ†æ",
                zone: "ä¸ƒåŒº/äº”åŒºé—´å¹³è¡¡åˆ†æ",
                monteCarlo: "å·²æ•´åˆåˆ°å¢å¼ºé¢„æµ‹ä¸­"
              },
              autoSync: {
                enabled: autoSyncStatus.enabled,
                nextSyncTime: nextSync.formatted,
                timeRemaining: Formatter.formatTimeRemaining(nextSync.timestamp),
                beijingHour: Formatter.getBeijingHour(),
                beijingMinute: Formatter.getBeijingMinute(),
                targetHour: CONFIG.SYSTEM.AUTO_SYNC_CONFIG.BEIJING_HOUR,
                stats: autoSyncStatus.stats
              },
              historyCount: history.length,
              commands: {
                traditional: "/predict",
                knn: "/predict knn",
                statistics: "/predict stats",
                advanced: "/predict advanced (æ¨è)",
                omission: "/predict omission",
                association: "/predict association",
                math: "/predict math",
                zone: "/predict zone",
                autoSyncStatus: "/auto_sync_status (ç®¡ç†å‘˜)",
                autoSyncOn: "/auto_sync_on (ç®¡ç†å‘˜)",
                autoSyncOff: "/auto_sync_off (ç®¡ç†å‘˜)",
                note: "æ–°å¢å››å¤§ä¸“å®¶ç®—æ³•å·²æ•´åˆåˆ°å¢å¼ºé¢„æµ‹ä¸­"
              }
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/trigger-auto-sync") {
          try {
            // è§¦å‘ç«‹å³æ‰§è¡Œè‡ªåŠ¨åŒæ­¥ï¼ˆç”¨äºæµ‹è¯•ï¼‰
            if (env.TG_ADMIN_ID) {
              // æ£€æŸ¥æ˜¯å¦æ¥è‡ªç®¡ç†å‘˜
              const authHeader = request.headers.get('Authorization');
              if (authHeader !== `Bearer ${env.TG_ADMIN_ID}`) {
                return new Response(JSON.stringify({ 
                  status: "ERROR",
                  message: "Unauthorized" 
                }, null, 2), {
                  status: 401,
                  headers: { 'Content-Type': 'application/json' }
                });
              }
            }
            
            // åœ¨åå°æ‰§è¡Œè‡ªåŠ¨åŒæ­¥
            ctx.waitUntil(Controller.executeAutoSync(env));
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "è‡ªåŠ¨åŒæ­¥å·²è§¦å‘ï¼Œæ­£åœ¨åå°æ‰§è¡Œ",
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // é»˜è®¤è¿”å›HTMLé¡µé¢
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .feature-list {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .feature-item {
                  margin-bottom: 10px;
                  color: #2d3748;
                }
                .feature-item:before {
                  content: "âœ… ";
                  margin-right: 8px;
                }
                .command-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .command {
                  margin-bottom: 8px;
                  color: #276749;
                  font-family: monospace;
                  background: #e6fffa;
                  padding: 5px 10px;
                  border-radius: 5px;
                  display: inline-block;
                }
                .algorithm-info {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .anti-spam {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .api-endpoints {
                  background: #f7fafc;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #2d3748;
                }
                .api-endpoint {
                  font-family: monospace;
                  background: #edf2f7;
                  padding: 3px 8px;
                  border-radius: 3px;
                  margin: 2px 0;
                  display: inline-block;
                }
                .enhanced {
                  background: linear-gradient(45deg, #667eea, #764ba2);
                  color: white;
                  padding: 5px 10px;
                  border-radius: 5px;
                  font-weight: bold;
                  display: inline-block;
                  margin: 5px 0;
                }
                .algorithm-knn { background: linear-gradient(45deg, #4299e1, #38b2ac); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-stats { background: linear-gradient(45deg, #ed8936, #f56565); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-advanced { background: linear-gradient(45deg, #9f7aea, #d53f8c); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-omission { background: linear-gradient(45deg, #48bb78, #38a169); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-association { background: linear-gradient(45deg, #ed64a6, #d53f8c); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-math { background: linear-gradient(45deg, #f6ad55, #dd6b20); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .algorithm-zone { background: linear-gradient(45deg, #9ae6b4, #68d391); color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; display: inline-block; margin: 2px; }
                .improvement {
                  background: #fff5f5;
                  border: 1px solid #fc8181;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #742a2a;
                }
                .status {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .status-item {
                  margin: 5px 0;
                  padding: 5px;
                  background: rgba(255,255,255,0.7);
                  border-radius: 4px;
                }
                .status-good {
                  color: #276749;
                  font-weight: bold;
                }
                .status-warning {
                  color: #d69e2e;
                  font-weight: bold;
                }
                .status-error {
                  color: #c53030;
                  font-weight: bold;
                }
                .auto-sync-info {
                  background: linear-gradient(45deg, #4299e1, #9f7aea);
                  color: white;
                  padding: 15px;
                  border-radius: 8px;
                  margin-top: 20px;
                }
                .auto-sync-feature {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION} - å®šæ—¶è‡ªåŠ¨åŒæ­¥å¢å¼ºç‰ˆ</div>
                
                <div class="auto-sync-info">
                  <h3 style="color: white; margin-top: 0;">â° å®šæ—¶è‡ªåŠ¨åŒæ­¥åŠŸèƒ½</h3>
                  <p style="color: white; margin-bottom: 10px;"><strong>åŒ—äº¬æ—¶é—´æ¯å¤©å‡Œæ™¨5ç‚¹è‡ªåŠ¨æ‰§è¡Œï¼š</strong></p>
                  <ul style="color: white; padding-left: 20px;">
                    <li>è‡ªåŠ¨åŒæ­¥æœ€æ–°å¼€å¥–æ•°æ®</li>
                    <li>å‘ç°æ–°è®°å½•åè‡ªåŠ¨ç”Ÿæˆå¢å¼ºé¢„æµ‹</li>
                    <li>è‡ªåŠ¨æ¨é€åˆ°Telegramé¢‘é“</li>
                    <li>æ‰§è¡Œç»“æœå‘é€ç»™ç®¡ç†å‘˜</li>
                  </ul>
                  <p style="color: white; margin-top: 10px; font-size: 0.9em;">
                    å½“å‰åŒ—äº¬æ—¶é—´: ${Formatter.formatDateTime(Formatter.getBeijingTime())}<br>
                    ä¸‹æ¬¡åŒæ­¥æ—¶é—´: ${Formatter.getNextSyncTime().formatted}
                  </p>
                </div>
                
                <div class="feature-list">
                  <h3>ç³»ç»Ÿç‰¹æ€§</h3>
                  <div class="feature-item">å®šæ—¶è‡ªåŠ¨åŒæ­¥ï¼šåŒ—äº¬æ—¶é—´æ¯å¤©å‡Œæ™¨5ç‚¹è‡ªåŠ¨æ‰§è¡Œ</div>
                  <div class="feature-item">é˜²åˆ·å±æ¨¡å¼ï¼šæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</div>
                  <div class="feature-item"><span class="algorithm-knn">KNNç®—æ³•</span>ï¼šK-è¿‘é‚»ç®—æ³•ï¼Œå¯»æ‰¾ç›¸ä¼¼å†å²æ¨¡å¼</div>
                  <div class="feature-item"><span class="algorithm-stats">å¢å¼ºç»Ÿè®¡ç®—æ³•</span>ï¼šç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ã€å¤´æ•°ã€å¤§å°ã€å•åŒå…¨é¢ç»Ÿè®¡</div>
                  <div class="feature-item"><span class="algorithm-advanced">å¢å¼ºé¢„æµ‹</span>ï¼šæ•´åˆæ‰€æœ‰ç®—æ³•çš„æœ€å¼ºé¢„æµ‹ï¼ˆåŒ…å«è’™ç‰¹å¡æ´›ï¼‰</div>
                  <div class="feature-item"><span class="algorithm-omission">é—æ¼å›è¡¥ä¸“å®¶</span>ï¼šåŸºäºå‡å€¼å›å½’åŸç†ï¼Œåˆ†æå·ç é—æ¼</div>
                  <div class="feature-item"><span class="algorithm-association">å…³è”è§„åˆ™ä¸“å®¶</span>ï¼šåŸºäºAprioriç®—æ³•ï¼Œå‘ç°å·ç å…³è”</div>
                  <div class="feature-item"><span class="algorithm-math">é»„é‡‘åˆ†å‰²ä¸“å®¶</span>ï¼šåŸºäºæ•°å­¦å¸¸æ•°å’Œæ•°åˆ—åˆ†æ</div>
                  <div class="feature-item"><span class="algorithm-zone">åŒºé—´å¹³è¡¡ä¸“å®¶</span>ï¼šåŸºäºç©ºé—´åˆ†å¸ƒå‡åŒ€æ€§åˆ†æ</div>
                  <div class="feature-item">ä¼˜åŒ–æ€§èƒ½ï¼šé¢„æµ‹è¶…æ—¶æ§åˆ¶ï¼Œé¿å…Workerè¶…æ—¶</div>
                  <div class="feature-item">æ™ºèƒ½ç¼“å­˜ï¼šæé«˜å“åº”é€Ÿåº¦</div>
                  <div class="feature-item">è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯ï¼Œä¿æŒç•Œé¢æ•´æ´</div>
                </div>
                
                <div class="command-list">
                  <h3>ä¸»è¦å‘½ä»¤</h3>
                  <div class="command">/start - æ¬¢è¿ä¿¡æ¯</div>
                  <div class="command">/ccc - æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿</div>
                  <div class="command">/predict - ä¼ ç»Ÿç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict knn - KNNç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict stats - ç»Ÿè®¡ç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict advanced - å¢å¼ºé¢„æµ‹ï¼ˆæ•´åˆå…¨éƒ¨ç®—æ³•ï¼‰</div>
                  <div class="command">/predict omission - é—æ¼å›è¡¥ä¸“å®¶é¢„æµ‹</div>
                  <div class="command">/predict association - å…³è”è§„åˆ™ä¸“å®¶é¢„æµ‹</div>
                  <div class="command">/predict math - é»„é‡‘åˆ†å‰²ä¸“å®¶é¢„æµ‹</div>
                  <div class="command">/predict zone - åŒºé—´å¹³è¡¡ä¸“å®¶é¢„æµ‹</div>
                  <div class="command">/history [é¡µç ] - æŸ¥çœ‹å†å²</div>
                  <div class="command">/sync - åŒæ­¥æ•°æ®(ç®¡ç†å‘˜)</div>
                  <div class="command">/delete [æœŸå·] - åˆ é™¤è®°å½•(ç®¡ç†å‘˜)</div>
                  <div class="command">/auto_sync_status - æŸ¥çœ‹è‡ªåŠ¨åŒæ­¥çŠ¶æ€(ç®¡ç†å‘˜)</div>
                  <div class="command">/auto_sync_on - å¼€å¯è‡ªåŠ¨åŒæ­¥(ç®¡ç†å‘˜)</div>
                  <div class="command">/auto_sync_off - å…³é—­è‡ªåŠ¨åŒæ­¥(ç®¡ç†å‘˜)</div>
                </div>
                
                <div class="auto-sync-feature">
                  <strong>è‡ªåŠ¨åŒæ­¥è¯¦æƒ…ï¼š</strong><br>
                  â€¢ åŒ—äº¬æ—¶é—´æ¯å¤©å‡Œæ™¨5ç‚¹è‡ªåŠ¨æ‰§è¡Œï¼ˆUTCæ—¶é—´21:00ï¼‰<br>
                  â€¢ è‡ªåŠ¨æ£€æµ‹æ˜¯å¦åº”è¯¥æ‰§è¡Œï¼ˆé¿å…é‡å¤æ‰§è¡Œï¼‰<br>
                  â€¢ åŒæ­¥æˆåŠŸåæ£€æŸ¥æ˜¯å¦æœ‰æ–°å¼€å¥–è®°å½•<br>
                  â€¢ å‘ç°æ–°è®°å½•åè‡ªåŠ¨ç”Ÿæˆå¢å¼ºé¢„æµ‹<br>
                  â€¢ è‡ªåŠ¨æ¨é€åˆ°é…ç½®çš„Telegramé¢‘é“<br>
                  â€¢ æ‰§è¡Œç»“æœå‘é€ç»™ç®¡ç†å‘˜<br>
                  â€¢ å®Œæ•´çš„ç»Ÿè®¡ä¿¡æ¯å’Œæ—¥å¿—è®°å½•<br>
                  â€¢ ç®¡ç†å‘˜å¯éšæ—¶å¼€å¯/å…³é—­æ­¤åŠŸèƒ½<br>
                  â€¢ å‘½ä»¤: <code>/auto_sync_status</code> (æŸ¥çœ‹çŠ¶æ€)
                </div>
                
                <div class="algorithm-info">
                  <strong>ç®—æ³•è¯¦æƒ…ï¼š</strong><br>
                  â€¢ <span class="algorithm-knn">KNNç®—æ³•</span> - å¯»æ‰¾ç›¸ä¼¼å†å²è®°å½•ï¼ŒåŸºäºç‰¹å¾è·ç¦»<br>
                  â€¢ <span class="algorithm-stats">ç»Ÿè®¡ç®—æ³•</span> - åˆ†æç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ã€å¤´æ•°ã€å¤§å°ã€å•åŒè½¬ç§»æ¦‚ç‡<br>
                  â€¢ <span class="algorithm-omission">é—æ¼å›è¡¥ä¸“å®¶</span> - åŸºäºå‡å€¼å›å½’ï¼Œåˆ†æå·ç é—æ¼æœŸæ•°<br>
                  â€¢ <span class="algorithm-association">å…³è”è§„åˆ™ä¸“å®¶</span> - åŸºäºAprioriç®—æ³•ï¼Œå‘ç°å·ç é—´å¼ºå…³è”<br>
                  â€¢ <span class="algorithm-math">é»„é‡‘åˆ†å‰²ä¸“å®¶</span> - åŸºäºé»„é‡‘åˆ†å‰²ç‡ã€å’Œå€¼å‡çº¿ã€æ¨¡è¿ç®—<br>
                  â€¢ <span class="algorithm-zone">åŒºé—´å¹³è¡¡ä¸“å®¶</span> - åˆ†æä¸ƒåŒº/äº”åŒºåˆ†å¸ƒï¼Œæ£€æµ‹æ–­åŒº<br>
                  â€¢ <span class="algorithm-advanced">å¢å¼ºé¢„æµ‹</span> - æ•´åˆæ‰€æœ‰ç®—æ³•çš„æœ€å¼ºé¢„æµ‹<br>
                  â€¢ åŸºäºå…¨éƒ¨å†å²è®°å½•ï¼ˆæœ€å¤š2000æœŸï¼‰<br>
                  â€¢ è¶…æ—¶æ§åˆ¶ï¼Œé¿å…Workerè¶…æ—¶<br>
                  â€¢ æ›´ç§‘å­¦çš„æ¦‚ç‡ç»Ÿè®¡å’Œç½®ä¿¡åº¦<br>
                  â€¢ å‘½ä»¤: <code>/predict advanced</code> (å¢å¼ºé¢„æµ‹ - æ¨è)
                </div>
                
                <div class="improvement">
                  <strong>ä¸»è¦æ”¹è¿›ï¼š</strong><br>
                  â€¢ æ·»åŠ å®šæ—¶è‡ªåŠ¨åŒæ­¥åŠŸèƒ½<br>
                  â€¢ åŒæ­¥å‘ç°æ–°è®°å½•åè‡ªåŠ¨ç”Ÿæˆé¢„æµ‹å¹¶æ¨é€<br>
                  â€¢ æ·»åŠ è‡ªåŠ¨åŒæ­¥å¼€å…³å‘½ä»¤<br>
                  â€¢ ä¿ç•™æ‰€æœ‰åŸæœ‰åŠŸèƒ½å’Œé¢„æµ‹é€»è¾‘<br>
                  â€¢ ä¼˜åŒ–ä»£ç ç»“æ„ï¼Œæé«˜å¯ç»´æŠ¤æ€§<br>
                  â€¢ æ”¹è¿›ç¼“å­˜æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–<br>
                  â€¢ å¢å¼ºé”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ<br>
                  â€¢ å®Œå–„çš„ç¯å¢ƒå˜é‡éªŒè¯å’Œé”™è¯¯å¤„ç†
                </div>
                
                <div class="anti-spam">
                  <strong>é˜²åˆ·å±ç‰¹æ€§ï¼š</strong><br>
                  â€¢ æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯<br>
                  â€¢ å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯<br>
                  â€¢ ä¿æŒèŠå¤©ç•Œé¢æ•´æ´ï¼Œé˜²æ­¢æ¶ˆæ¯å †ç§¯<br>
                  â€¢ ç”¨æˆ·æ¯ä¸ªå‘½ä»¤ç±»å‹æœ€å¤šä¿ç•™10æ¡æœ€æ–°æ¶ˆæ¯<br>
                  â€¢ è‡ªåŠ¨æ¸…ç†ä¸æ´»è·ƒç”¨æˆ·çš„æ¶ˆæ¯ç¼“å­˜
                </div>
                
                <div class="api-endpoints">
                  <strong>APIç«¯ç‚¹ï¼š</strong><br>
                  <div class="api-endpoint">GET /health - ç³»ç»Ÿå¥åº·æ£€æŸ¥</div>
                  <div class="api-endpoint">GET /reset-cache - é‡ç½®ç¼“å­˜</div>
                  <div class="api-endpoint">GET /test-algorithms - æµ‹è¯•ç®—æ³•</div>
                  <div class="api-endpoint">GET /trigger-auto-sync - è§¦å‘è‡ªåŠ¨åŒæ­¥(ç®¡ç†å‘˜)</div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 8px;">
                  <strong>ä½¿ç”¨å»ºè®®ï¼š</strong><br>
                  â€¢ é¦–æ¬¡ä½¿ç”¨è¯·å…ˆæ‰§è¡Œ <code>/sync</code> åŒæ­¥å†å²æ•°æ®<br>
                  â€¢ æ¨èä½¿ç”¨ <code>/predict advanced</code> è·å–æœ€å¼ºé¢„æµ‹<br>
                  â€¢ æŸ¥çœ‹å†å²æ•°æ®ä½¿ç”¨ <code>/history 1</code><br>
                  â€¢ ç®¡ç†å‘˜ä½¿ç”¨ <code>/auto_sync_status</code> æŸ¥çœ‹è‡ªåŠ¨åŒæ­¥çŠ¶æ€<br>
                  â€¢ ç®¡ç†å‘˜ä½¿ç”¨ <code>/auto_sync_on</code> å¼€å¯è‡ªåŠ¨åŒæ­¥<br>
                  â€¢ ç¡®ä¿ç¯å¢ƒå˜é‡é…ç½®æ­£ç¡®ï¼ˆTG_BOT_TOKEN, TG_ADMIN_IDç­‰ï¼‰<br>
                  â€¢ å¦‚éœ€è‡ªåŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“ï¼Œè¯·é…ç½® TG_CHANNEL_ID
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response(JSON.stringify({
        status: "ERROR",
        error: "Internal Server Error",
        message: error.message,
        system: CONFIG.SYSTEM.NAME,
        version: CONFIG.SYSTEM.VERSION
      }, null, 2), { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  },
  
  async scheduled(controller, env, ctx) {
    try {
      Logger.info("Scheduled", "å¼€å§‹æ‰§è¡Œå®šæ—¶ä»»åŠ¡");
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯åŒ—äº¬æ—¶é—´å‡Œæ™¨5ç‚¹ï¼ˆå…è®¸çª—å£æœŸï¼‰
      if (!Formatter.isSyncTime()) {
        Logger.info("Scheduled", `ä¸æ˜¯ç›®æ ‡æ—¶é—´çª—å£ï¼Œè·³è¿‡è‡ªåŠ¨åŒæ­¥`);
        return;
      }
      
      Logger.info("Scheduled", `åœ¨æ—¶é—´çª—å£å†…ï¼Œå¼€å§‹æ‰§è¡Œè‡ªåŠ¨åŒæ­¥`);
      
      // æ‰§è¡Œè‡ªåŠ¨åŒæ­¥
      const result = await Controller.executeAutoSync(env);
      
      Logger.info("Scheduled", `å®šæ—¶ä»»åŠ¡å®Œæˆ: ${result.success ? "æˆåŠŸ" : "å¤±è´¥"}, æ–°å¢è®°å½•: ${result.added || 0}`);
      
    } catch (error) {
      Logger.error("Scheduled", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå¤±è´¥", error);
    }
  }
};
