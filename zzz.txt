/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V6.1 å®Œæ•´ç¨³å®šç‰ˆ
 * 
 * ä¿®å¤é‡ç‚¹:
 * 1. å½»åº•ä¿®å¤æ‰€æœ‰ç©ºæŒ‡é’ˆé”™è¯¯
 * 2. ä¿®å¤åˆ é™¤è®°å½•åé¢„æµ‹æœŸå·ä¸æ­£ç¡®çš„é—®é¢˜
 * 3. ä¿®å¤é¢„æµ‹æœªåŸºäºæœ€æ–°å†å²è®°å½•çš„é—®é¢˜
 * 4. å…¨é¢ä¼˜åŒ–é”™è¯¯å¤„ç†å’Œç©ºå€¼æ£€æŸ¥
 * 5. ä¿è¯æ‰€æœ‰åŠŸèƒ½å®Œæ•´å¯ç”¨
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰ - å®Œæ•´ç‰ˆ
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ–°æ¾³å…­åˆå½©Â·å¤©æœº",
    VERSION: "V6.1 å®Œæ•´ç¨³å®šç‰ˆ",
    DEFAULT_DURATION: 5 * 60 * 60 * 1000, // 5å°æ—¶
    TARGET_SIMS: 100000000, // 1äº¿æ¬¡æ¨¡æ‹Ÿ
    BATCH_SIZE: 50000,
    TIMEZONE_OFFSET: 8,
    CHANNEL_ID: null,
    ADMIN_ID: null,
    MIN_SIMS_REQUIRED: 50000000, // æœ€ä½5000ä¸‡æ¬¡æ¨¡æ‹Ÿ
    MIN_TIME_REQUIRED: 4.5 * 60 * 60 * 1000, // æœ€å°‘4.5å°æ—¶
    HISTORY_LIMIT: 100, // åªä½¿ç”¨æœ€è¿‘100æœŸå†å²è®°å½•è¿›è¡Œåˆ†æ
    CACHE_TTL: 60 * 1000 // ç¼“å­˜æœ‰æ•ˆæœŸ1åˆ†é’Ÿ
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.5,
    w_zodiac_relation: 2.0,
    w_color_transfer: 1.8,
    w_tail_correlation: 1.5,
    w_number_frequency: 1.3,
    w_omission_value: 1.2,
    w_shape_pattern: 1.0,
    w_head_tail: 0.8,
    w_normal_correlation: 1.8,
    _version: "6.1"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    },
    
    OPPOSITION: {
      "é¼ ": "é©¬", "é©¬": "é¼ ",
      "ç‰›": "ç¾Š", "ç¾Š": "ç‰›",
      "è™": "çŒ´", "çŒ´": "è™",
      "å…”": "é¸¡", "é¸¡": "å…”",
      "é¾™": "ç‹—", "ç‹—": "é¾™",
      "è›‡": "çŒª", "çŒª": "è›‡"
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    wait: "â³",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    rocket: "ğŸš€",
    sync: "ğŸ”„",
    reset: "â™»ï¸",
    manage: "âš™ï¸",
    history: "ğŸ“œ",
    preview: "ğŸ‘€",
    back: "ğŸ”™",
    gold: "ğŸ’°",
    wood: "ğŸŒ²",
    water: "ğŸ’§",
    fire_element: "ğŸ”¥",
    earth: "â›°ï¸",
    star: "â­",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    bell: "ğŸ””",
    home: "ğŸ ",
    trash: "ğŸ—‘ï¸",
    warning: "âš ï¸",
    cancel: "âŒ",
    confirm: "âœ…",
    reload: "ğŸ”„",
    database: "ğŸ’¾",
    clock: "â°",
    counter: "ğŸ”¢",
    cpu: "ğŸ’»",
    check: "âœ”ï¸",
    hourglass: "âŒ›",
    speed: "âš¡",
    memory: "ğŸ’¾",
    bug: "ğŸ›",
    fix: "ğŸ”§",
    optimize: "ğŸš€"
  }
};

const CALLBACK_DATA = {
  MAIN_MENU: "main_menu",
  PREVIEW: "preview",
  HISTORY: "history",
  SYNC: "sync",
  PUSH: "push",
  DELETE: "delete",
  DELETE_CONFIRM: "delete_confirm",
  DELETE_CANCEL: "delete_cancel",
  HISTORY_PAGE_PREFIX: "history_page_"
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•° - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }

  static debug(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.log(`[${timestamp}] [DEBUG] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.debug] ${context} - ${message}:`, error);
    }
  }

  static perf(context, operation, startTime) {
    try {
      const endTime = Date.now();
      const duration = endTime - startTime;
      if (duration > 100) {
        this.debug(`PERF-${context}`, `${operation} è€—æ—¶: ${duration}ms`);
      }
    } catch (error) {
      // å¿½ç•¥æ€§èƒ½æ—¥å¿—é”™è¯¯
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
      }
      
      // ä½¿ç”¨å®‰å…¨çš„æŸ¥æ‰¾æ–¹å¼
      let zodiac = "æœªçŸ¥";
      let color = "æœªçŸ¥";
      
      // æŸ¥æ‰¾ç”Ÿè‚–
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      // æŸ¥æ‰¾é¢œè‰²
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static generateProgressBar(current, total, length = 10) {
    try {
      const percentage = total > 0 ? (current / total) : 0;
      const filled = Math.floor(length * percentage);
      const empty = length - filled;
      return "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
    } catch (error) {
      return "â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      // å¦‚æœæ˜¯å•ä¸ªæœŸå·
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      // å¦‚æœæ˜¯èŒƒå›´æ ¼å¼ï¼š2025001-2025010
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatTimeInterval(ms) {
    try {
      if (ms < 0) ms = 0;
      
      const hours = Math.floor(ms / (1000 * 60 * 60));
      const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((ms % (1000 * 60)) / 1000);
      
      if (hours > 0) {
        return `${hours}æ—¶${minutes}åˆ†${seconds}ç§’`;
      } else if (minutes > 0) {
        return `${minutes}åˆ†${seconds}ç§’`;
      } else {
        return `${seconds}ç§’`;
      }
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(2) + 'äº¿';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }
}

// ==============================================================================
// 3. ç¼“å­˜ç®¡ç†å™¨ - å®Œæ•´ç‰ˆ
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      // é™åˆ¶ç¼“å­˜å¤§å°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "è®¾ç½®ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥æ¸…é™¤é”™è¯¯
    }
  }
  
  static getStats() {
    try {
      return {
        size: this.cache.size,
        keys: Array.from(this.cache.keys())
      };
    } catch (error) {
      return { size: 0, keys: [] };
    }
  }
}

// ==============================================================================
// 4. æ•°æ®åº“æ“ä½œå±‚ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_tasks (
          id INTEGER PRIMARY KEY DEFAULT 1, 
          data TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS prediction_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          expect TEXT,
          confidence INTEGER,
          total_sims INTEGER,
          total_time_ms INTEGER,
          is_completed INTEGER DEFAULT 0,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const startTime = Date.now();
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      Logger.perf("DB", `getHistoryæŸ¥è¯¢`, startTime);
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  checkExpectExists: async function(env, expect) {
    try {
      if (!expect) return false;
      
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(Formatter.safeString(expect)).first();
      
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        
        // è¿‡æ»¤æ— æ•ˆè®°å½•
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code &&
          Formatter.isValidExpect(record.expect.toString())
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡ ${Math.floor(i/CHUNK_SIZE)+1} æ’å…¥å¤±è´¥`, chunkError);
          
          // é€ä¸ªæ’å…¥
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ€»è®¡æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      // æ¸…é™¤ç›¸å…³ç¼“å­˜
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getTask: async function(env) {
    try {
      const cacheKey = "task";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const r = await env.DB.prepare("SELECT data FROM lottery_tasks WHERE id = 1").first();
      if (!r || !r.data) {
        CacheManager.set(cacheKey, null, 5000);
        return null;
      }
      
      try {
        const task = JSON.parse(r.data);
        CacheManager.set(cacheKey, task, 5000);
        return task;
      } catch (parseError) {
        Logger.error("DB", "è§£æä»»åŠ¡æ•°æ®å¤±è´¥", parseError);
        CacheManager.set(cacheKey, null, 5000);
        return null;
      }
    } catch (e) {
      Logger.error("DB", "getTask failed", e);
      return null;
    }
  },

  saveTask: async function(env, data) {
    try {
      if (!data) {
        Logger.error("DB", "saveTask: æ•°æ®ä¸ºç©º");
        return null;
      }
      
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_tasks (id, data) VALUES (1, ?)"
      ).bind(JSON.stringify(data)).run();
      
      // æ›´æ–°ç¼“å­˜
      CacheManager.set("task", data, 5000);
      
      return result;
    } catch (e) {
      Logger.error("DB", "saveTask failed", e);
      return null;
    }
  },

  resetTask: async function(env) {
    try {
      await env.DB.prepare("DELETE FROM lottery_tasks WHERE id = 1").run();
      
      // æ¸…é™¤ç¼“å­˜
      CacheManager.delete("task");
      
      Logger.info("DB", "ä»»åŠ¡å·²é‡ç½®");
      return { success: true };
    } catch (e) {
      Logger.error("DB", "resetTask failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          weights = { ...defaultWeights, ...parsed };
        } catch (parseError) {
          Logger.error("DB", "è§£ææƒé‡å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼", parseError);
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "DURATION": CONFIG.SYSTEM.DEFAULT_DURATION.toString(),
        "TARGET_SIMS": CONFIG.SYSTEM.TARGET_SIMS.toString(),
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_PUSHES": "0",
        "TOTAL_DELETIONS": "0",
        "TOTAL_PREDICTIONS": "0",
        "TOTAL_SIMULATIONS": "0",
        "TOTAL_PREDICTION_TIME": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    const startTime = Date.now();
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      // å…ˆæ£€æŸ¥èŒƒå›´å†…æœ‰å¤šå°‘æ¡è®°å½•
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•"
        };
      }
      
      // æ‰§è¡Œåˆ é™¤
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      // æ¸…é™¤æ‰€æœ‰ç›¸å…³ç¼“å­˜
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      // è®°å½•åˆ é™¤æ—¥å¿—
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        // æ›´æ–°ç»Ÿè®¡
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      }
      
      const duration = Date.now() - startTime;
      Logger.perf("DB", `deleteHistoryByRangeæ“ä½œ`, startTime);
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      // è·å–è¦åˆ é™¤çš„è®°å½•
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      // è·å–åˆ é™¤åçš„æœ€æ–°è®°å½•
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  getRecentDeletionLogs: async function(env, limit = 5) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM deletion_log ORDER BY created_at DESC LIMIT ?"
      ).bind(limit).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getRecentDeletionLogs failed", e);
      return [];
    }
  },

  getDeletionStats: async function(env) {
    try {
      // æ€»åˆ é™¤æ¬¡æ•°
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM deletion_log"
      ).first();
      
      // æ€»åˆ é™¤è®°å½•æ•°
      const recordsResult = await env.DB.prepare(
        "SELECT SUM(deleted_count) as total FROM deletion_log"
      ).first();
      
      // æœ€è¿‘åˆ é™¤æ—¶é—´
      const recentResult = await env.DB.prepare(
        "SELECT created_at FROM deletion_log ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalDeletions: totalResult ? totalResult.count : 0,
        totalRecordsDeleted: recordsResult ? (recordsResult.total || 0) : 0,
        lastDeletion: recentResult ? recentResult.created_at : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionStats failed", e);
      return {
        totalDeletions: 0,
        totalRecordsDeleted: 0,
        lastDeletion: null
      };
    }
  },

  logPrediction: async function(env, expect, confidence, totalSims, totalTimeMs, isCompleted = true) {
    try {
      await env.DB.prepare(
        "INSERT INTO prediction_log (expect, confidence, total_sims, total_time_ms, is_completed) VALUES (?, ?, ?, ?, ?)"
      ).bind(
        Formatter.safeString(expect),
        Formatter.safeInt(confidence, 0),
        Formatter.safeInt(totalSims, 0),
        Formatter.safeInt(totalTimeMs, 0),
        isCompleted ? 1 : 0
      ).run();
      
      // æ›´æ–°å…¨å±€ç»Ÿè®¡
      if (isCompleted) {
        const totalPredictions = Formatter.safeInt(await this.getSetting(env, "TOTAL_PREDICTIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_PREDICTIONS", totalPredictions.toString());
        
        const totalSimulations = Formatter.safeInt(await this.getSetting(env, "TOTAL_SIMULATIONS", "0"), 0) + totalSims;
        await this.saveSetting(env, "TOTAL_SIMULATIONS", totalSimulations.toString());
        
        const totalPredictionTime = Formatter.safeInt(await this.getSetting(env, "TOTAL_PREDICTION_TIME", "0"), 0) + totalTimeMs;
        await this.saveSetting(env, "TOTAL_PREDICTION_TIME", totalPredictionTime.toString());
      }
      
      return true;
    } catch (e) {
      Logger.error("DB", "logPrediction failed", e);
      return false;
    }
  },

  getRecentPredictionLogs: async function(env, limit = 5) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM prediction_log ORDER BY created_at DESC LIMIT ?"
      ).bind(limit).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getRecentPredictionLogs failed", e);
      return [];
    }
  },

  getPredictionStats: async function(env) {
    try {
      // æ€»é¢„æµ‹æ¬¡æ•°
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // æ€»æ¨¡æ‹Ÿæ¬¡æ•°
      const simsResult = await env.DB.prepare(
        "SELECT SUM(total_sims) as total FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // å¹³å‡ç½®ä¿¡åº¦
      const avgConfidenceResult = await env.DB.prepare(
        "SELECT AVG(confidence) as avg FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // å¹³å‡é¢„æµ‹æ—¶é—´
      const avgTimeResult = await env.DB.prepare(
        "SELECT AVG(total_time_ms) as avg FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // æœ€è¿‘é¢„æµ‹
      const recentResult = await env.DB.prepare(
        "SELECT * FROM prediction_log WHERE is_completed = 1 ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalPredictions: totalResult ? totalResult.count : 0,
        totalSimulations: simsResult ? (simsResult.total || 0) : 0,
        avgConfidence: avgConfidenceResult ? Math.round(avgConfidenceResult.avg) : 0,
        avgTimeMs: avgTimeResult ? Math.round(avgTimeResult.avg) : 0,
        recentPrediction: recentResult || null
      };
    } catch (e) {
      Logger.error("DB", "getPredictionStats failed", e);
      return {
        totalPredictions: 0,
        totalSimulations: 0,
        avgConfidence: 0,
        avgTimeMs: 0,
        recentPrediction: null
      };
    }
  },

  validateAndFixTask: async function(env, task) {
    try {
      if (!task) return null;
      
      // è·å–æœ€æ–°çš„å†å²è®°å½•
      const latestHistory = await this.getLatestHistory(env, 1);
      
      // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰è®°å½•ï¼Œé‡ç½®ä»»åŠ¡
      if (!latestHistory || latestHistory.length === 0) {
        Logger.warn("DB", "æ•°æ®åº“ä¸­æ— å†å²è®°å½•ï¼Œé‡ç½®ä»»åŠ¡");
        await this.resetTask(env);
        return null;
      }
      
      const latestRecord = latestHistory[0];
      const latestExpect = latestRecord?.expect;
      
      // æ£€æŸ¥ä»»åŠ¡ä¸­çš„å†å²è®°å½•æ˜¯å¦æœ‰æ•ˆ
      if (task.history && task.history.length > 0) {
        const taskLatestRecord = task.history[0];
        
        // å¦‚æœä»»åŠ¡ä¸­çš„æœ€æ–°è®°å½•ä¸åœ¨æ•°æ®åº“ä¸­ï¼Œè¯´æ˜è¢«åˆ é™¤äº†ï¼Œéœ€è¦ä¿®å¤ä»»åŠ¡
        if (taskLatestRecord && taskLatestRecord.expect) {
          const exists = await this.checkExpectExists(env, taskLatestRecord.expect);
          if (!exists) {
            Logger.warn("DB", `ä»»åŠ¡ä¸­çš„è®°å½• ${taskLatestRecord.expect} ä¸å­˜åœ¨ï¼Œä¿®å¤ä»»åŠ¡`);
            
            // é‡æ–°è·å–å†å²è®°å½•
            const newHistory = await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT);
            
            // è®¡ç®—ä¸‹ä¸€æœŸæœŸå·
            let nextExpect;
            if (latestExpect && Formatter.isValidExpect(latestExpect)) {
              const latestNum = Formatter.safeInt(latestExpect, 2025000);
              nextExpect = (latestNum + 1).toString();
            } else {
              nextExpect = "2025001";
            }
            
            // ä¿®å¤ä»»åŠ¡
            task.history = newHistory;
            task.expect = nextExpect;
            task.startTime = Date.now();
            task.unlockTime = Date.now() + CONFIG.SYSTEM.DEFAULT_DURATION;
            task.currentSims = 0;
            task.finalPrediction = null;
            task.status = "CALCULATING";
            
            await this.saveTask(env, task);
            Logger.info("DB", `ä»»åŠ¡å·²ä¿®å¤ï¼Œæ–°æœŸå·: ${nextExpect}`);
          }
        }
      }
      
      return task;
    } catch (e) {
      Logger.error("DB", "validateAndFixTask failed", e);
      return task;
    }
  }
};

// ==============================================================================
// 5. é«˜æ€§èƒ½ç»Ÿè®¡å¼•æ“ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class AdvancedStatsEngine {
  static statsCache = new Map();
  
  static analyzeHistoryStatistics(history) {
    const startTime = Date.now();
    
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        Logger.warn("Stats", "å†å²æ•°æ®ä¸è¶³ï¼Œè¿”å›ç©ºç»Ÿè®¡");
        return this.createEmptyStats();
      }

      // ç”Ÿæˆç¼“å­˜é”®
      const cacheKey = `stats_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.statsCache.get(cacheKey);
      if (cached) {
        return cached;
      }

      Logger.info("Stats", `å¼€å§‹åˆ†æ ${history.length} æœŸå†å²æ•°æ®`);

      const stats = this.createEmptyStats();
      
      // é™åˆ¶åˆ†æçš„æ•°æ®é‡ä»¥æå‡æ€§èƒ½
      const maxRecords = Math.min(history.length, 200);
      const historySlice = history.slice(0, maxRecords);
      
      for (let i = 0; i < historySlice.length - 1; i++) {
        const currentRecord = historySlice[i];
        const nextRecord = historySlice[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNums = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNums = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNums.length < 7 || nextNums.length < 7) {
          continue;
        }
        
        const currentSpecial = currentNums[6] || 1;
        const nextSpecial = nextNums[6] || 1;
        const nextNormals = nextNums.slice(0, 6);
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        // 1. ç”Ÿè‚–è½¬ç§»ç»Ÿè®¡
        if (currentAttr.zodiac && nextAttr.zodiac && 
            stats.zodiacTransfer[currentAttr.zodiac] && 
            stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac] !== undefined) {
          stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac]++;
        }
        
        // 2. æ³¢è‰²è½¬ç§»ç»Ÿè®¡
        if (currentAttr.color && nextAttr.color && 
            stats.colorTransfer[currentAttr.color] && 
            stats.colorTransfer[currentAttr.color][nextAttr.color] !== undefined) {
          stats.colorTransfer[currentAttr.color][nextAttr.color]++;
        }
        
        // 3. å°¾æ•°å…³è”ç»Ÿè®¡
        const currentNormalTails = currentNums.slice(0, 6).map(n => n % 10);
        const nextSpecialTail = nextSpecial % 10;
        
        currentNormalTails.forEach(tail => {
          if (tail >= 0 && tail <= 9 && nextSpecialTail >= 0 && nextSpecialTail <= 9 &&
              stats.tailCorrelation[tail] && 
              stats.tailCorrelation[tail][nextSpecialTail] !== undefined) {
            stats.tailCorrelation[tail][nextSpecialTail]++;
          }
        });
        
        // 4. ç‰¹ç é¢‘ç‡ç»Ÿè®¡
        if (nextSpecial >= 1 && nextSpecial <= 49) {
          stats.specialFrequency[nextSpecial] = (stats.specialFrequency[nextSpecial] || 0) + 1;
        }
        
        // 5. å¹³ç é¢‘ç‡ç»Ÿè®¡
        nextNormals.forEach(num => {
          if (num >= 1 && num <= 49) {
            stats.normalFrequency[num] = (stats.normalFrequency[num] || 0) + 1;
          }
        });
      }

      // 6. è®¡ç®—æ¦‚ç‡å’Œå½’ä¸€åŒ–
      this.normalizeStatistics(stats);
      
      stats.totalRecords = historySlice.length;
      
      // ç¼“å­˜ç»“æœ
      this.statsCache.set(cacheKey, stats);
      
      const duration = Date.now() - startTime;
      Logger.perf("Stats", `å†å²æ•°æ®åˆ†æ`, startTime);
      Logger.info("Stats", `å†å²æ•°æ®åˆ†æå®Œæˆï¼Œè€—æ—¶: ${duration}ms`);
      
      return stats;
    } catch (error) {
      Logger.error("Stats", "åˆ†æå†å²æ•°æ®æ—¶å‡ºé”™", error);
      return this.createEmptyStats();
    }
  }

  static createEmptyStats() {
    try {
      const stats = {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: { 
          red: { red: 0, blue: 0, green: 0 }, 
          blue: { red: 0, blue: 0, green: 0 }, 
          green: { red: 0, blue: 0, green: 0 } 
        },
        tailCorrelation: {},
        zodiacRelations: { sixHarmony: {}, threeHarmony: {}, opposition: {} },
        specialFrequency: {},
        normalFrequency: {},
        normalCombination: { zodiacPairs: {}, colorDistribution: {}, tailDistribution: {} },
        omissionStats: {},
        shapeStats: { bigOdd: 0, bigEven: 0, smallOdd: 0, smallEven: 0 }
      };
      
      this.initializeStatsStructure(stats);
      return stats;
    } catch (error) {
      Logger.error("Stats", "åˆ›å»ºç©ºç»Ÿè®¡å¤±è´¥", error);
      return {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: { red: { red: 0, blue: 0, green: 0 }, blue: { red: 0, blue: 0, green: 0 }, green: { red: 0, blue: 0, green: 0 } },
        tailCorrelation: {},
        specialFrequency: {},
        normalFrequency: {}
      };
    }
  }

  static initializeStatsStructure(stats) {
    try {
      // åˆå§‹åŒ–ç”Ÿè‚–è½¬ç§»çŸ©é˜µ
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac1 => {
        if (!stats.zodiacTransfer[zodiac1]) {
          stats.zodiacTransfer[zodiac1] = {};
        }
        if (!stats.zodiacRelations.sixHarmony[zodiac1]) {
          stats.zodiacRelations.sixHarmony[zodiac1] = 0;
        }
        if (!stats.zodiacRelations.threeHarmony[zodiac1]) {
          stats.zodiacRelations.threeHarmony[zodiac1] = 0;
        }
        if (!stats.zodiacRelations.opposition[zodiac1]) {
          stats.zodiacRelations.opposition[zodiac1] = 0;
        }
        
        Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac2 => {
          if (!stats.zodiacTransfer[zodiac1][zodiac2]) {
            stats.zodiacTransfer[zodiac1][zodiac2] = 0;
          }
        });
      });
      
      // åˆå§‹åŒ–å°¾æ•°å…³è”çŸ©é˜µ
      for (let i = 0; i < 10; i++) {
        if (!stats.tailCorrelation[i]) {
          stats.tailCorrelation[i] = {};
        }
        for (let j = 0; j < 10; j++) {
          if (!stats.tailCorrelation[i][j]) {
            stats.tailCorrelation[i][j] = 0;
          }
        }
      }
      
      // åˆå§‹åŒ–é¢‘ç‡ç»Ÿè®¡
      for (let i = 1; i <= 49; i++) {
        if (stats.specialFrequency[i] === undefined) {
          stats.specialFrequency[i] = 0;
        }
        if (stats.normalFrequency[i] === undefined) {
          stats.normalFrequency[i] = 0;
        }
      }
    } catch (error) {
      Logger.error("Stats", "åˆå§‹åŒ–ç»Ÿè®¡ç»“æ„å¤±è´¥", error);
    }
  }

  static normalizeStatistics(stats) {
    try {
      // å½’ä¸€åŒ–ç”Ÿè‚–è½¬ç§»çŸ©é˜µ
      Object.keys(stats.zodiacTransfer).forEach(zodiac1 => {
        const total = Object.values(stats.zodiacTransfer[zodiac1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          Object.keys(stats.zodiacTransfer[zodiac1]).forEach(zodiac2 => {
            stats.zodiacTransfer[zodiac1][zodiac2] = stats.zodiacTransfer[zodiac1][zodiac2] / total;
          });
        }
      });
      
      // å½’ä¸€åŒ–é¢œè‰²è½¬ç§»çŸ©é˜µ
      Object.keys(stats.colorTransfer).forEach(color1 => {
        const total = Object.values(stats.colorTransfer[color1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          Object.keys(stats.colorTransfer[color1]).forEach(color2 => {
            stats.colorTransfer[color1][color2] = stats.colorTransfer[color1][color2] / total;
          });
        }
      });
      
      // å½’ä¸€åŒ–å°¾æ•°å…³è”çŸ©é˜µ
      Object.keys(stats.tailCorrelation).forEach(tail1 => {
        const total = Object.values(stats.tailCorrelation[tail1]).reduce((a, b) => a + b, 0);
        if (total > 0) {
          Object.keys(stats.tailCorrelation[tail1]).forEach(tail2 => {
            stats.tailCorrelation[tail1][tail2] = stats.tailCorrelation[tail1][tail2] / total;
          });
        }
      });
    } catch (error) {
      Logger.error("Stats", "å½’ä¸€åŒ–ç»Ÿè®¡å¤±è´¥", error);
    }
  }

  static generatePredictionScores(lastSpecial, stats, weights) {
    const startTime = Date.now();
    const scores = {};
    
    try {
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      // ä¼˜åŒ–è®¡ç®—ï¼šå‡å°‘å¤æ‚åº¦
      for (let num = 1; num <= 49; num++) {
        const attr = Formatter.getAttributes(num);
        let score = 0;
        
        // ç”Ÿè‚–è½¬ç§» - ç®€åŒ–è®¡ç®—
        if (lastAttr.zodiac && attr.zodiac && 
            stats.zodiacTransfer[lastAttr.zodiac] && 
            stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac]) {
          score += stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac] * 100 * weights.w_zodiac_transfer;
        }
        
        // å…­åˆå…³ç³»
        if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
          const relationCount = stats.zodiacRelations.sixHarmony[attr.zodiac] || 0;
          const relationProbability = relationCount / Math.max(1, stats.totalRecords);
          score += relationProbability * 80 * weights.w_zodiac_relation;
        }
        
        // æ³¢è‰²è½¬ç§»
        if (lastAttr.color && attr.color && 
            stats.colorTransfer[lastAttr.color] && 
            stats.colorTransfer[lastAttr.color][attr.color]) {
          const colorProb = stats.colorTransfer[lastAttr.color][attr.color];
          score += colorProb * 100 * weights.w_color_transfer;
        }
        
        // å°¾æ•°å…³è”
        const lastTail = lastSpecial % 10;
        const currentTail = num % 10;
        
        if (lastTail >= 0 && lastTail <= 9 && currentTail >= 0 && currentTail <= 9 &&
            stats.tailCorrelation[lastTail] && 
            stats.tailCorrelation[lastTail][currentTail]) {
          const tailProb = stats.tailCorrelation[lastTail][currentTail];
          score += tailProb * 80 * weights.w_tail_correlation;
        }
        
        // ç‰¹ç é¢‘ç‡
        if (stats.specialFrequency[num]) {
          const freq = stats.specialFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 60 * weights.w_number_frequency;
        }
        
        // å½¢æ€ç»Ÿè®¡
        const isBig = num >= 25;
        const isOdd = num % 2 !== 0;
        const shapeType = isBig ? (isOdd ? "bigOdd" : "bigEven") : (isOdd ? "smallOdd" : "smallEven");
        const shapeProbability = (stats.shapeStats[shapeType] || 0) / Math.max(1, stats.totalRecords);
        
        score += shapeProbability * 40 * weights.w_shape_pattern;
        
        // è½»å¾®éšæœºæ‰°åŠ¨
        const randomFactor = 0.95 + Math.random() * 0.1;
        score *= randomFactor;
        
        scores[num] = score;
      }
      
      const duration = Date.now() - startTime;
      if (duration > 50) {
        Logger.perf("Stats", "generatePredictionScores", startTime);
      }
      
      return scores;
    } catch (error) {
      Logger.error("Stats", "ç”Ÿæˆé¢„æµ‹åˆ†æ•°å¤±è´¥", error);
      
      // è¿”å›é»˜è®¤åˆ†æ•°
      for (let num = 1; num <= 49; num++) {
        scores[num] = Math.random() * 100;
      }
      
      return scores;
    }
  }

  static generateNormalPredictions(stats, weights, excludeNumbers = []) {
    const startTime = Date.now();
    const normalScores = {};
    const excludeSet = new Set(excludeNumbers || []);
    
    try {
      for (let num = 1; num <= 49; num++) {
        if (excludeSet.has(num)) {
          normalScores[num] = -999999;
          continue;
        }
        
        const attr = Formatter.getAttributes(num);
        let score = 0;
        
        // å¹³ç é¢‘ç‡
        if (stats.normalFrequency[num]) {
          const freq = stats.normalFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 150 * weights.w_number_frequency;
        }
        
        // è½»å¾®éšæœºæ‰°åŠ¨
        const randomFactor = 0.96 + Math.random() * 0.08;
        score *= randomFactor;
        
        normalScores[num] = score;
      }
      
      const scoreArray = Object.entries(normalScores)
        .filter(([num, score]) => score > -999999)
        .map(([num, score]) => ({
          number: Formatter.safeInt(num, 0),
          score: score
        }));
      
      scoreArray.sort((a, b) => b.score - a.score);
      
      const duration = Date.now() - startTime;
      if (duration > 50) {
        Logger.perf("Stats", "generateNormalPredictions", startTime);
      }
      
      return scoreArray.slice(0, 6);
    } catch (error) {
      Logger.error("Stats", "ç”Ÿæˆå¹³ç é¢„æµ‹å¤±è´¥", error);
      
      // è¿”å›éšæœºå¹³ç 
      const randomNumbers = [];
      const used = new Set();
      
      while (randomNumbers.length < 6) {
        const num = Math.floor(Math.random() * 49) + 1;
        if (!used.has(num) && !excludeSet.has(num)) {
          used.add(num);
          randomNumbers.push({
            number: num,
            score: Math.random() * 100
          });
        }
      }
      
      return randomNumbers;
    }
  }

  static getTopSpecialPredictions(scores, topN = 10) {
    try {
      const scoreArray = Object.entries(scores || {})
        .map(([num, score]) => ({
          number: Formatter.safeInt(num, 0),
          score: score
        }))
        .filter(item => item.number >= 1 && item.number <= 49);
      
      scoreArray.sort((a, b) => b.score - a.score);
      return scoreArray.slice(0, topN);
    } catch (error) {
      Logger.error("Stats", "è·å–ç‰¹ç é¢„æµ‹å¤±è´¥", error);
      return [];
    }
  }

  static getZodiacPredictions(scores) {
    try {
      const zodiacScores = {};
      
      for (let num = 1; num <= 49; num++) {
        const zodiac = Formatter.getAttributes(num).zodiac;
        if (!zodiacScores[zodiac]) {
          zodiacScores[zodiac] = { total: 0, count: 0, numbers: [] };
        }
        zodiacScores[zodiac].total += scores[num] || 0;
        zodiacScores[zodiac].count++;
        zodiacScores[zodiac].numbers.push(num);
      }
      
      const zodiacAvgScores = {};
      Object.keys(zodiacScores).forEach(zodiac => {
        const data = zodiacScores[zodiac];
        zodiacAvgScores[zodiac] = {
          average: data.total / Math.max(1, data.count),
          total: data.total,
          count: data.count,
          numbers: data.numbers
        };
      });
      
      const sortedZodiacs = Object.entries(zodiacAvgScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedZodiacs.slice(0, 3),
        guard: sortedZodiacs.slice(3, 6),
        scores: zodiacAvgScores
      };
    } catch (error) {
      Logger.error("Stats", "è·å–ç”Ÿè‚–é¢„æµ‹å¤±è´¥", error);
      return {
        main: [],
        guard: [],
        scores: {}
      };
    }
  }

  static getColorPredictions(scores) {
    try {
      const colorScores = {};
      
      ['red', 'blue', 'green'].forEach(color => {
        const numbers = CONFIG.COLORS[color] || [];
        let total = 0;
        let maxScore = -Infinity;
        let bestNumber = 0;
        
        numbers.forEach(num => {
          const score = scores[num] || 0;
          total += score;
          if (score > maxScore) {
            maxScore = score;
            bestNumber = num;
          }
        });
        
        colorScores[color] = {
          average: total / Math.max(1, numbers.length),
          total: total,
          count: numbers.length,
          bestNumber: bestNumber,
          maxScore: maxScore
        };
      });
      
      const sortedColors = Object.entries(colorScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedColors[0],
        guard: sortedColors[1],
        scores: colorScores
      };
    } catch (error) {
      Logger.error("Stats", "è·å–é¢œè‰²é¢„æµ‹å¤±è´¥", error);
      return {
        main: "red",
        guard: "blue",
        scores: {}
      };
    }
  }

  static getTailPredictions(scores) {
    try {
      const tailScores = {};
      
      for (let tail = 0; tail < 10; tail++) {
        let total = 0;
        let count = 0;
        let maxScore = -Infinity;
        let bestNumber = 0;
        
        for (let num = tail; num <= 49; num += 10) {
          if (num >= 1 && num <= 49) {
            const score = scores[num] || 0;
            total += score;
            count++;
            if (score > maxScore) {
              maxScore = score;
              bestNumber = num;
            }
          }
        }
        
        if (count > 0) {
          tailScores[tail] = {
            average: total / count,
            total: total,
            count: count,
            bestNumber: bestNumber,
            maxScore: maxScore
          };
        }
      }
      
      const sortedTails = Object.entries(tailScores)
        .sort((a, b) => b[1].average - a[1].average)
        .slice(0, 5)
        .map(entry => Formatter.safeInt(entry[0], 0));
      
      return sortedTails;
    } catch (error) {
      Logger.error("Stats", "è·å–å°¾æ•°é¢„æµ‹å¤±è´¥", error);
      return [1, 3, 5, 7, 9];
    }
  }

  static getZodiacBestNumbers(scores) {
    try {
      const zodiacBestNumbers = {};
      
      // ä¸ºæ¯ä¸ªç”Ÿè‚–æ‰¾å‡ºåˆ†æ•°æœ€é«˜çš„å·ç 
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        let bestNumber = numbers[0] || 1;
        let bestScore = -Infinity;
        
        numbers.forEach(num => {
          const score = scores[num] || 0;
          if (score > bestScore) {
            bestScore = score;
            bestNumber = num;
          }
        });
        
        zodiacBestNumbers[zodiac] = {
          number: bestNumber,
          score: bestScore,
          color: Formatter.getAttributes(bestNumber).color
        };
      });
      
      return zodiacBestNumbers;
    } catch (error) {
      Logger.error("Stats", "è·å–ç”Ÿè‚–æœ€ä½³å·ç å¤±è´¥", error);
      
      // è¿”å›é»˜è®¤å€¼
      const defaultBestNumbers = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        defaultBestNumbers[zodiac] = {
          number: numbers[0] || 1,
          score: 50,
          color: Formatter.getAttributes(numbers[0] || 1).color
        };
      });
      
      return defaultBestNumbers;
    }
  }

  static clearCache() {
    try {
      this.statsCache.clear();
      Logger.info("Stats", "ç»Ÿè®¡ç¼“å­˜å·²æ¸…ç©º");
    } catch (error) {
      // å¿½ç•¥æ¸…é™¤é”™è¯¯
    }
  }
}

// ==============================================================================
// 6. é«˜æ€§èƒ½é¢„æµ‹å¼•æ“ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class AdvancedPredictionEngine {
  static predictionCache = new Map();
  
  static generate(task, historyStats, weights) {
    const startTime = Date.now();
    
    try {
      const history = task?.history || [];
      
      if (!history || history.length < 2) {
        return this.generateStaticFallback(task);
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      // å¦‚æœå†å²ç»Ÿè®¡æ•°æ®ä¸ºç©ºï¼Œé‡æ–°åˆ†æ
      if (!historyStats || historyStats.totalRecords === 0) {
        historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(history);
      }
      
      // ç”Ÿæˆç¼“å­˜é”®
      const cacheKey = `prediction_${lastSpecial}_${history.length}_${weights._version || '1.0'}`;
      const cached = this.predictionCache.get(cacheKey);
      
      if (cached) {
        // æ›´æ–°ç¼“å­˜ä¸­çš„ä»»åŠ¡ç›¸å…³ä¿¡æ¯
        cached.nextExpect = task?.expect || cached.nextExpect;
        cached.simulationInfo = {
          iterations: 1000000,
          targetSims: task?.targetSims || CONFIG.SYSTEM.TARGET_SIMS,
          currentSims: task?.currentSims || 0,
          timeElapsed: task?.startTime ? Date.now() - task.startTime : 0,
          totalDuration: task?.unlockTime && task?.startTime ? task.unlockTime - task.startTime : CONFIG.SYSTEM.DEFAULT_DURATION
        };
        return cached;
      }
      
      // æ‰§è¡Œé«˜æ€§èƒ½è®¡ç®—
      const scores = this.optimizedCalculation(lastSpecial, historyStats, weights);
      
      const topSpecialNumbers = AdvancedStatsEngine.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = AdvancedStatsEngine.getZodiacPredictions(scores);
      const colorPrediction = AdvancedStatsEngine.getColorPredictions(scores);
      const tailPrediction = AdvancedStatsEngine.getTailPredictions(scores);
      
      // æ·»åŠ ä¸€è‚–ä¸€ç åŠŸèƒ½
      const zodiacBestNumbers = AdvancedStatsEngine.getZodiacBestNumbers(scores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = AdvancedStatsEngine.generateNormalPredictions(historyStats, weights, excludeSpecials);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const bestAttr = Formatter.getAttributes(bestNumber);
      
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      
      const head = Math.floor(bestNumber / 10);
      
      // è®¡ç®—ç½®ä¿¡åº¦
      const maxScore = topSpecialNumbers[0]?.score || 50;
      const avgScore = topSpecialNumbers.reduce((sum, item) => sum + (item?.score || 0), 0) / Math.max(1, topSpecialNumbers.length);
      const scoreRatio = maxScore / Math.max(1, avgScore);
      
      const simulationFactor = Math.min(1, (task?.currentSims || 0) / Math.max(1, task?.targetSims || CONFIG.SYSTEM.TARGET_SIMS));
      const timeFactor = task?.unlockTime ? Math.min(1, (Date.now() - (task?.startTime || 0)) / Math.max(1, task?.unlockTime - (task?.startTime || 0))) : 0;
      
      let confidence = 30;
      confidence += scoreRatio * 25;
      confidence += simulationFactor * 25;
      confidence += timeFactor * 20;
      
      // é™åˆ¶åœ¨åˆç†èŒƒå›´
      confidence = Math.min(98, Math.max(20, Math.floor(confidence)));

      const formattedNormals = (normalPredictions || []).map(item => {
        const attr = Formatter.getAttributes(item?.number || 1);
        return {
          number: item?.number || 1,
          zodiac: attr.zodiac,
          color: attr.color,
          score: item?.score || 0
        };
      });

      const formattedSpecials = (topSpecialNumbers || []).slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));

      const prediction = {
        nextExpect: task?.expect || "2025001",
        zodiac: zodiacPrediction || { main: [], guard: [], scores: {} },
        color: colorPrediction || { main: "red", guard: "blue", scores: {} },
        tail: tailPrediction || [1, 3, 5, 7, 9],
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        zodiacBestNumbers: zodiacBestNumbers,
        confidence: confidence,
        analysisBased: true,
        totalHistoryRecords: historyStats?.totalRecords || 0,
        basedOnLastRecord: {
          expect: lastRecord.expect || "æœªçŸ¥",
          openCode: lastOpenCode,
          special: lastSpecial,
          zodiac: bestAttr.zodiac,
          color: bestAttr.color
        },
        simulationInfo: {
          iterations: 1000000,
          targetSims: task?.targetSims || CONFIG.SYSTEM.TARGET_SIMS,
          currentSims: task?.currentSims || 0,
          timeElapsed: task?.startTime ? Date.now() - task.startTime : 0,
          totalDuration: task?.unlockTime && task?.startTime ? task.unlockTime - task.startTime : CONFIG.SYSTEM.DEFAULT_DURATION
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V6.1-Optimized"
      };
      
      // ç¼“å­˜é¢„æµ‹ç»“æœ
      this.predictionCache.set(cacheKey, prediction);
      
      const duration = Date.now() - startTime;
      Logger.perf("Prediction", "ç”Ÿæˆé¢„æµ‹", startTime);
      Logger.info("Prediction", `é¢„æµ‹ç”Ÿæˆå®Œæˆï¼Œè€—æ—¶: ${duration}ms`);
      
      return prediction;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback(task);
    }
  }

  static optimizedCalculation(lastSpecial, stats, weights) {
    const startTime = Date.now();
    const scores = {};
    
    try {
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      // é¢„è®¡ç®—å¸¸ç”¨å€¼
      const totalReciprocal = 1 / Math.max(1, stats.totalRecords);
      
      for (let num = 1; num <= 49; num++) {
        const attr = Formatter.getAttributes(num);
        let score = 0;
        
        // ç”Ÿè‚–è½¬ç§»
        if (lastAttr.zodiac && attr.zodiac && 
            stats.zodiacTransfer[lastAttr.zodiac] && 
            stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac]) {
          score += stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac] * 100 * weights.w_zodiac_transfer;
        }
        
        // å…­åˆå…³ç³»
        if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
          const relationCount = stats.zodiacRelations.sixHarmony[attr.zodiac] || 0;
          score += relationCount * totalReciprocal * 80 * weights.w_zodiac_relation;
        }
        
        // æ³¢è‰²è½¬ç§»
        if (lastAttr.color && attr.color && 
            stats.colorTransfer[lastAttr.color] && 
            stats.colorTransfer[lastAttr.color][attr.color]) {
          score += stats.colorTransfer[lastAttr.color][attr.color] * 100 * weights.w_color_transfer;
        }
        
        // å°¾æ•°å…³è”
        const lastTail = lastSpecial % 10;
        const currentTail = num % 10;
        
        if (lastTail >= 0 && lastTail <= 9 && currentTail >= 0 && currentTail <= 9 &&
            stats.tailCorrelation[lastTail] && 
            stats.tailCorrelation[lastTail][currentTail]) {
          score += stats.tailCorrelation[lastTail][currentTail] * 80 * weights.w_tail_correlation;
        }
        
        // ç‰¹ç é¢‘ç‡
        if (stats.specialFrequency[num]) {
          score += stats.specialFrequency[num] * totalReciprocal * 60 * weights.w_number_frequency;
        }
        
        // å½¢æ€ç»Ÿè®¡
        const isBig = num >= 25;
        const isOdd = num % 2 !== 0;
        const shapeType = isBig ? (isOdd ? "bigOdd" : "bigEven") : (isOdd ? "smallOdd" : "smallEven");
        const shapeCount = stats.shapeStats[shapeType] || 0;
        
        score += shapeCount * totalReciprocal * 40 * weights.w_shape_pattern;
        
        // è½»å¾®éšæœºæ‰°åŠ¨
        score *= 0.98 + Math.random() * 0.04;
        
        scores[num] = score;
      }
      
      const duration = Date.now() - startTime;
      if (duration > 50) {
        Logger.perf("Prediction", "optimizedCalculation", startTime);
      }
      
      return scores;
    } catch (error) {
      Logger.error("Prediction", "ä¼˜åŒ–è®¡ç®—å¤±è´¥", error);
      
      // è¿”å›é»˜è®¤åˆ†æ•°
      for (let num = 1; num <= 49; num++) {
        scores[num] = Math.random() * 100;
      }
      
      return scores;
    }
  }

  static generateStaticFallback(task) {
    try {
      const date = new Date();
      const day = date.getDate();
      const hour = date.getHours();
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = (day * hour) % allZodiacs.length;
      const colorIndex = (day + hour) % colors.length;
      
      const mainZodiac = allZodiacs[zodiacIndex] || "é¼ ";
      const mainColor = colors[colorIndex] || "red";
      
      const candidates = CONFIG.ZODIAC_MAP[mainZodiac] || [1, 13, 25, 37, 49];
      const numIndex = hour % candidates.length;
      const exampleNumber = candidates[numIndex] || 1;
      
      // ç”Ÿæˆå¹³ç 
      let normalNumbers = [];
      const excludeNumbers = [exampleNumber];
      
      for (let i = 0; i < 6; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((excludeNumbers.includes(num) || normalNumbers.find(n => n.number === num)) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        normalNumbers.push({
          number: num,
          zodiac: attr.zodiac,
          color: attr.color,
          score: Math.floor(Math.random() * 100)
        });
        excludeNumbers.push(num);
      }
      
      // ç”Ÿæˆç‰¹ç æ¨è
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((specialNumbers.find(n => n.number === num) || num === exampleNumber) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 100),
          zodiac: attr.zodiac,
          color: attr.color
        });
      }
      
      // ç”Ÿæˆä¸€è‚–ä¸€ç 
      const zodiacBestNumbers = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        const randomIndex = Math.floor(Math.random() * numbers.length);
        const num = numbers[randomIndex] || numbers[0] || 1;
        zodiacBestNumbers[zodiac] = {
          number: num,
          score: Math.floor(Math.random() * 100),
          color: Formatter.getAttributes(num).color
        };
      });
      
      const isBig = exampleNumber >= 25;
      const isOdd = exampleNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(exampleNumber / 10);
      
      return {
        nextExpect: task?.expect || "2025001",
        zodiac: {
          main: [
            mainZodiac, 
            allZodiacs[(zodiacIndex + 3) % allZodiacs.length] || "å…”",
            allZodiacs[(zodiacIndex + 6) % allZodiacs.length] || "é©¬"
          ],
          guard: [
            allZodiacs[(zodiacIndex + 1) % allZodiacs.length] || "ç‰›",
            allZodiacs[(zodiacIndex + 4) % allZodiacs.length] || "é¾™"
          ],
          scores: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length] || "blue",
          scores: {}
        },
        tail: [1, 3, 5, 7, 9],
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        zodiacBestNumbers: zodiacBestNumbers,
        confidence: 20,
        analysisBased: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V6.1-Static"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé™æ€å›é€€é¢„æµ‹æ—¶å‡ºé”™", error);
      
      // ç»ˆæå›é€€
      return {
        nextExpect: task?.expect || "2025001",
        zodiac: { main: ["é¼ ", "é¾™", "çŒ´"], guard: ["ç‰›", "è›‡"], scores: {} },
        color: { main: "red", guard: "blue", scores: {} },
        tail: [1, 3, 5, 7, 9],
        head: "0å¤´",
        shape: "å°å•",
        specialNumbers: [
          { number: 1, score: 50, zodiac: "è›‡", color: "red" },
          { number: 13, score: 45, zodiac: "è›‡", color: "blue" },
          { number: 25, score: 40, zodiac: "è›‡", color: "green" },
          { number: 37, score: 35, zodiac: "è›‡", color: "red" },
          { number: 49, score: 30, zodiac: "è›‡", color: "blue" }
        ],
        normalNumbers: [
          { number: 2, zodiac: "é¾™", color: "red", score: 45 },
          { number: 3, zodiac: "å…”", color: "blue", score: 40 },
          { number: 4, zodiac: "è™", color: "blue", score: 35 },
          { number: 5, zodiac: "ç‰›", color: "green", score: 30 },
          { number: 6, zodiac: "é¼ ", color: "green", score: 25 },
          { number: 7, zodiac: "çŒª", color: "red", score: 20 }
        ],
        zodiacBestNumbers: {
          "é¼ ": { number: 6, score: 50, color: "green" },
          "ç‰›": { number: 5, score: 45, color: "green" },
          "è™": { number: 4, score: 40, color: "blue" },
          "å…”": { number: 3, score: 35, color: "blue" },
          "é¾™": { number: 2, score: 30, color: "red" },
          "è›‡": { number: 1, score: 50, color: "red" },
          "é©¬": { number: 12, score: 45, color: "red" },
          "ç¾Š": { number: 11, score: 40, color: "green" },
          "çŒ´": { number: 10, score: 35, color: "blue" },
          "é¸¡": { number: 9, score: 30, color: "blue" },
          "ç‹—": { number: 8, score: 25, color: "red" },
          "çŒª": { number: 7, score: 20, color: "red" }
        },
        confidence: 10,
        analysisBased: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V6.1-Emergency"
      };
    }
  }

  static clearCache() {
    try {
      this.predictionCache.clear();
      Logger.info("Prediction", "é¢„æµ‹ç¼“å­˜å·²æ¸…ç©º");
    } catch (error) {
      // å¿½ç•¥æ¸…é™¤é”™è¯¯
    }
  }
}

// ==============================================================================
// 7. æ¶ˆæ¯æ¸²æŸ“å™¨ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class MessageRenderer {
  static generateMainMenuKeyboard(isAdmin = false) {
    try {
      const keyboard = {
        inline_keyboard: [
          [
            { text: `${CONFIG.EMOJI.preview} é¢„è§ˆé¢„æµ‹`, callback_data: CALLBACK_DATA.PREVIEW },
            { text: `${CONFIG.EMOJI.history} å†å²è®°å½•`, callback_data: CALLBACK_DATA.HISTORY }
          ]
        ]
      };
      
      if (isAdmin) {
        keyboard.inline_keyboard.push([
          { text: `${CONFIG.EMOJI.sync} åŒæ­¥æ•°æ®`, callback_data: CALLBACK_DATA.SYNC },
          { text: `${CONFIG.EMOJI.rocket} æ¨é€é¢„æµ‹`, callback_data: CALLBACK_DATA.PUSH }
        ]);
        keyboard.inline_keyboard.push([
          { text: `${CONFIG.EMOJI.trash} åˆ é™¤è®°å½•`, callback_data: CALLBACK_DATA.DELETE }
        ]);
      }
      
      return keyboard;
    } catch (error) {
      Logger.error("MessageRenderer", "ç”Ÿæˆä¸»èœå•é”®ç›˜å¤±è´¥", error);
      return { inline_keyboard: [[{ text: "è¿”å›", callback_data: CALLBACK_DATA.MAIN_MENU }]] };
    }
  }

  static generateHistoryKeyboard(page, totalPages) {
    try {
      const keyboard = { inline_keyboard: [] };
      const navRow = [];
      
      if (page > 1) {
        navRow.push({ text: "â—€ï¸ ä¸Šä¸€é¡µ", callback_data: `${CALLBACK_DATA.HISTORY_PAGE_PREFIX}${page - 1}` });
      }
      
      navRow.push({ text: `ğŸ“„ ${page}/${totalPages}`, callback_data: "current_page" });
      
      if (page < totalPages) {
        navRow.push({ text: "ä¸‹ä¸€é¡µ â–¶ï¸", callback_data: `${CALLBACK_DATA.HISTORY_PAGE_PREFIX}${page + 1}` });
      }
      
      if (navRow.length > 0) {
        keyboard.inline_keyboard.push(navRow);
      }
      
      keyboard.inline_keyboard.push([{ text: "ğŸ”™ è¿”å›ä¸»èœå•", callback_data: CALLBACK_DATA.MAIN_MENU }]);
      
      return keyboard;
    } catch (error) {
      Logger.error("MessageRenderer", "ç”Ÿæˆå†å²é”®ç›˜å¤±è´¥", error);
      return { inline_keyboard: [[{ text: "è¿”å›", callback_data: CALLBACK_DATA.MAIN_MENU }]] };
    }
  }

  static generateDeleteConfirmationKeyboard(expectRange) {
    try {
      return {
        inline_keyboard: [
          [
            { 
              text: `${CONFIG.EMOJI.confirm} ç¡®è®¤åˆ é™¤`, 
              callback_data: `${CALLBACK_DATA.DELETE_CONFIRM}_${Formatter.safeString(expectRange)}` 
            },
            { 
              text: `${CONFIG.EMOJI.cancel} å–æ¶ˆåˆ é™¤`, 
              callback_data: CALLBACK_DATA.DELETE_CANCEL 
            }
          ],
          [
            { text: "ğŸ”™ è¿”å›ä¸»èœå•", callback_data: CALLBACK_DATA.MAIN_MENU }
          ]
        ]
      };
    } catch (error) {
      Logger.error("MessageRenderer", "ç”Ÿæˆåˆ é™¤ç¡®è®¤é”®ç›˜å¤±è´¥", error);
      return { inline_keyboard: [[{ text: "è¿”å›", callback_data: CALLBACK_DATA.MAIN_MENU }]] };
    }
  }

  static renderDeletionImpact(impactInfo, expectRange) {
    try {
      const { toDelete, afterDelete, toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤å½±å“åˆ†æ</b>\n\n`;
      message += `åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
      message += `å°†åˆ é™¤è®°å½•: ${toDeleteCount || 0} æ¡\n\n`;
      
      if (toDeleteCount > 0 && toDelete && toDelete.length > 0) {
        message += `<b>å°†è¢«åˆ é™¤çš„è®°å½•:</b>\n`;
        const latestToDelete = toDelete.slice(0, 3);
        latestToDelete.forEach(record => {
          if (record && record.open_code) {
            const special = Formatter.safeInt(record.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ ${record.expect || "æœªçŸ¥"} æœŸ: ${Formatter.formatOpenCode(record.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
        
        if (toDeleteCount > 3) {
          message += `... ç­‰ ${toDeleteCount} æ¡è®°å½•\n`;
        }
      }
      
      message += `\n<b>åˆ é™¤åçš„æœ€æ–°è®°å½•:</b>\n`;
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        message += `ç¬¬ ${latestAfterDelete.expect || "æœªçŸ¥"} æœŸ: ${Formatter.formatOpenCode(latestAfterDelete.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
        message += `\nâš ï¸ <b>é¢„æµ‹å°†åŸºäºæ­¤è®°å½•é‡æ–°è®¡ç®—</b>\n`;
      } else {
        message += `æ— è®°å½• (å°†ä½¿ç”¨é™æ€é¢„æµ‹)\n`;
        message += `\nâš ï¸ <b>é¢„æµ‹å°†ä½¿ç”¨é™æ€ç®—æ³•</b>\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤å½±å“å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} <b>åˆ é™¤å½±å“åˆ†æå¤±è´¥</b>\n\næ— æ³•åˆ†æåˆ é™¤å½±å“ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderDeleteConfirmation(expectRange, impactInfo) {
    try {
      const { toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤</b>\n\n`;
      
      if (expectRange.includes('-')) {
        const [start, end] = expectRange.split('-');
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(start)}</b> æœŸåˆ°ç¬¬ <b>${Formatter.safeString(end)}</b> æœŸçš„è®°å½•\n`;
      } else {
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(expectRange)}</b> æœŸçš„è®°å½•\n`;
      }
      
      message += `æ¶‰åŠ <b>${toDeleteCount || 0}</b> æ¡å†å²è®°å½•\n\n`;
      
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        message += `åˆ é™¤åï¼Œæœ€æ–°è®°å½•ä¸º:\n`;
        message += `ç¬¬ <b>${latestAfterDelete.expect || "æœªçŸ¥"}</b> æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
        message += `é¢„æµ‹å°†åŸºäºæ­¤è®°å½•é‡æ–°è®¡ç®—\n`;
      } else {
        message += `åˆ é™¤åå°†æ— å†å²è®°å½•\n`;
        message += `é¢„æµ‹å°†ä½¿ç”¨é™æ€ç®—æ³•ç”Ÿæˆ\n`;
      }
      
      message += `\n${CONFIG.EMOJI.warning} <b>è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼</b>\n\n`;
      message += `è¯·ç¡®è®¤æ˜¯å¦ç»§ç»­åˆ é™¤ï¼Ÿ`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç¡®è®¤å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤å¤±è´¥</b>\n\næ— æ³•ç”Ÿæˆç¡®è®¤ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderDeleteInfo() {
    try {
      return `
${CONFIG.EMOJI.trash} <b>åˆ é™¤è®°å½•åŠŸèƒ½è¯´æ˜</b>

æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ ¼å¼åˆ é™¤å†å²è®°å½•ï¼š

<b>å•ä¸ªæœŸå·åˆ é™¤</b>
<code>/delete 2025001</code>

<b>æœŸå·èŒƒå›´åˆ é™¤</b>
<code>/delete 2025001-2025010</code>

<b>æ³¨æ„äº‹é¡¹ï¼š</b>
1. åˆ é™¤æ“ä½œä¸å¯æ¢å¤ï¼Œè¯·è°¨æ…æ“ä½œ
2. åˆ é™¤åé¢„æµ‹æ¨¡å‹ä¼šé‡æ–°è®­ç»ƒï¼ˆéœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿï¼‰
3. ç³»ç»Ÿä¼šè®°å½•æ‰€æœ‰åˆ é™¤æ“ä½œ
4. é¢„æµ‹å°†åŸºäºåˆ é™¤åçš„æœ€æ–°è®°å½•é‡æ–°è®¡ç®—

è¯·ç›´æ¥å‘é€åˆ é™¤å‘½ä»¤åˆ°èŠå¤©æ¡†ï¼Œä¾‹å¦‚ï¼š
<code>/delete 2025001-2025010</code>
      `.trim();
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ä¿¡æ¯å¤±è´¥", error);
      return `${CONFIG.EMOJI.trash} <b>åˆ é™¤è®°å½•åŠŸèƒ½è¯´æ˜</b>\n\nä½¿ç”¨ /delete å‘½ä»¤åˆ é™¤è®°å½•ã€‚`;
    }
  }

  static renderMainMenu(historyCount = 0, lastSync = "", deletionStats = null, predictionStats = null) {
    try {
      let message = `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `${CONFIG.EMOJI.fix} <i>å®Œæ•´ç¨³å®šç‰ˆ - æ‰€æœ‰é”™è¯¯å·²ä¿®å¤</i>\n\n`;
      message += `ğŸ“Š æ•°æ®ç»Ÿè®¡:\n`;
      message += `â€¢ å†å²è®°å½•: ${historyCount} æœŸ\n`;
      
      if (lastSync) {
        message += `â€¢ æœ€ååŒæ­¥: ${lastSync}\n`;
      }
      
      if (deletionStats) {
        message += `â€¢ åˆ é™¤ç»Ÿè®¡: ${deletionStats.totalDeletions || 0} æ¬¡æ“ä½œï¼Œå…± ${deletionStats.totalRecordsDeleted || 0} æ¡\n`;
        if (deletionStats.lastDeletion) {
          try {
            const lastDelDate = new Date(deletionStats.lastDeletion);
            message += `â€¢ æœ€ååˆ é™¤: ${lastDelDate.toLocaleDateString('zh-CN')}\n`;
          } catch (dateError) {
            // å¿½ç•¥æ—¥æœŸè§£æé”™è¯¯
          }
        }
      }
      
      if (predictionStats) {
        message += `â€¢ é¢„æµ‹ç»Ÿè®¡: ${predictionStats.totalPredictions || 0} æ¬¡å®Œæˆ\n`;
        message += `â€¢ æ¨¡æ‹Ÿæ€»æ•°: ${Formatter.formatLargeNumber(predictionStats.totalSimulations || 0)} æ¬¡\n`;
        message += `â€¢ å¹³å‡ç½®ä¿¡åº¦: ${predictionStats.avgConfidence || 0}%\n`;
        message += `â€¢ å¹³å‡è€—æ—¶: ${Formatter.formatTimeInterval(predictionStats.avgTimeMs || 0)}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.speed} <b>ç¨³å®šæ€§æå‡:</b>\n`;
      message += `â€¢ å½»åº•ä¿®å¤ç©ºæŒ‡é’ˆé”™è¯¯\n`;
      message += `â€¢ å…¨é¢ä¼˜åŒ–é”™è¯¯å¤„ç†\n`;
      message += `â€¢ å¢å¼ºæ•°æ®éªŒè¯\n`;
      
      message += `\n${CONFIG.EMOJI.bug} <b>å·²ä¿®å¤é—®é¢˜:</b>\n`;
      message += `â€¢ Cannot read properties of null (reading 'toString')\n`;
      message += `â€¢ åˆ é™¤è®°å½•åé¢„æµ‹æœŸå·ä¸æ­£ç¡®\n`;
      message += `â€¢ é¢„æµ‹æœªåŸºäºæœ€æ–°å†å²è®°å½•\n`;
      
      message += `\nğŸ¯ é¢„æµ‹è¦æ±‚: ${Formatter.formatLargeNumber(CONFIG.SYSTEM.TARGET_SIMS)}æ¬¡æ¨¡æ‹Ÿ + ${CONFIG.SYSTEM.DEFAULT_DURATION/(60*60*1000)}å°æ—¶\n`;
      
      message += `\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é€‰æ‹©åŠŸèƒ½ï¼š`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“ä¸»èœå•å¤±è´¥", error);
      return `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n\nç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\nç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œè¯·é€‰æ‹©åŠŸèƒ½ã€‚`;
    }
  }

  static renderPreview(prediction, task = null) {
    try {
      if (!prediction) {
        return `${CONFIG.EMOJI.warning} é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚`;
      }
      
      // å®‰å…¨è·å–æ‰€æœ‰å±æ€§
      const nextExpect = Formatter.safeString(prediction.nextExpect, "æœªçŸ¥");
      const confidence = Formatter.safeInt(prediction.confidence, 0);
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const basedOnLastRecord = prediction.basedOnLastRecord || {};
      const analysisBased = prediction.analysisBased || false;
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      const zodiac = prediction.zodiac || { main: [], guard: [], scores: {} };
      const color = prediction.color || { main: "red", guard: "blue", scores: {} };
      const tail = Array.isArray(prediction.tail) ? prediction.tail : [];
      const head = Formatter.safeString(prediction.head, "æœªçŸ¥");
      const shape = Formatter.safeString(prediction.shape, "æœªçŸ¥");
      const zodiacBestNumbers = prediction.zodiacBestNumbers || {};
      
      let dataSource = "";
      if (analysisBased) {
        dataSource = `ğŸ“Š åŸºäº ${totalHistoryRecords} æœŸå†å²æ•°æ®åˆ†æ`;
      } else {
        dataSource = `âš ï¸ æ— å†å²æ•°æ®ï¼ŒåŸºäºé™æ€ç®—æ³•ç”Ÿæˆ`;
      }
      
      let basedOnInfo = "";
      if (basedOnLastRecord.expect) {
        const { expect, special } = basedOnLastRecord;
        const attr = Formatter.getAttributes(special);
        basedOnInfo = `\nğŸ“ é¢„æµ‹åŸºäº: ç¬¬ ${expect} æœŸ (ç‰¹ç ${special} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]})`;
      }
      
      let progressInfo = '';
      if (task) {
        if (task.status === "CALCULATING") {
          const targetSims = Formatter.safeInt(task.targetSims, CONFIG.SYSTEM.TARGET_SIMS);
          const currentSims = Formatter.safeInt(task.currentSims, 0);
          const startTime = Formatter.safeInt(task.startTime, Date.now());
          const unlockTime = Formatter.safeInt(task.unlockTime, Date.now() + CONFIG.SYSTEM.DEFAULT_DURATION);
          
          const simsPercent = targetSims > 0 ? 
            Math.min(100, ((currentSims / targetSims) * 100).toFixed(1)) : 0;
          
          const timePassed = Date.now() - startTime;
          const totalDuration = unlockTime - startTime;
          const timePercent = totalDuration > 0 ? 
            Math.min(100, ((timePassed / totalDuration) * 100).toFixed(1)) : 0;
          
          const progressBar = Formatter.generateProgressBar(currentSims, targetSims);
          
          const timeLeft = Math.max(0, unlockTime - Date.now());
          const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
          const minutesLeft = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          const secondsLeft = Math.floor((timeLeft % (1000 * 60)) / 1000);
          
          const meetsTimeCondition = Date.now() >= unlockTime;
          const meetsSimsCondition = currentSims >= targetSims;
          const isCompleted = meetsTimeCondition && meetsSimsCondition;
          
          progressInfo = `\n${CONFIG.EMOJI.cpu} <b>é¢„æµ‹è®¡ç®—ä¸­...</b>\n`;
          
          if (!isCompleted) {
            progressInfo += `${CONFIG.EMOJI.counter} æ¨¡æ‹Ÿè¿›åº¦: ${Formatter.formatLargeNumber(currentSims)}/${Formatter.formatLargeNumber(targetSims)} (${simsPercent}%)\n`;
            progressInfo += `${CONFIG.EMOJI.clock} æ—¶é—´è¿›åº¦: ${Formatter.formatTimeInterval(timePassed)}/${Formatter.formatTimeInterval(totalDuration)} (${timePercent}%)\n`;
            progressInfo += `ğŸ“ˆ ${progressBar}\n`;
            
            progressInfo += `\n${CONFIG.EMOJI.check} å®Œæˆæ¡ä»¶:\n`;
            progressInfo += `â€¢ æ¨¡æ‹Ÿæ¬¡æ•°: ${meetsSimsCondition ? CONFIG.EMOJI.check : CONFIG.EMOJI.wait} ${Formatter.formatLargeNumber(targetSims)}æ¬¡\n`;
            progressInfo += `â€¢ è¿è¡Œæ—¶é—´: ${meetsTimeCondition ? CONFIG.EMOJI.check : CONFIG.EMOJI.wait} ${CONFIG.SYSTEM.DEFAULT_DURATION/(60*60*1000)}å°æ—¶\n`;
            
            progressInfo += `\n${CONFIG.EMOJI.hourglass} å‰©ä½™æ—¶é—´: ${hoursLeft}æ—¶${minutesLeft}åˆ†${secondsLeft}ç§’\n`;
          } else {
            progressInfo += `${CONFIG.EMOJI.check} <b>é¢„æµ‹è®¡ç®—å®Œæˆï¼</b>\n`;
            progressInfo += `âœ… å·²æ»¡è¶³æ‰€æœ‰å®Œæˆæ¡ä»¶\n`;
          }
        } else if (task.status === "DONE") {
          const sentStatus = task.isSent ? "âœ… å·²æ¨é€" : "ğŸ”„ å¾…æ¨é€";
          progressInfo = `\nâœ… <b>é¢„æµ‹å·²å®Œæˆ</b>\n${sentStatus}`;
          
          if (prediction.simulationInfo) {
            const { currentSims, targetSims, timeElapsed, totalDuration } = prediction.simulationInfo;
            progressInfo += `\nğŸ“Š æœ€ç»ˆç»Ÿè®¡:\n`;
            progressInfo += `â€¢ æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(currentSims)}/${Formatter.formatLargeNumber(targetSims)}\n`;
            progressInfo += `â€¢ è¿è¡Œæ—¶é—´: ${Formatter.formatTimeInterval(timeElapsed)}/${Formatter.formatTimeInterval(totalDuration)}\n`;
          }
        }
      }
      
      // æ ¼å¼åŒ–å¹³ç æ˜¾ç¤º
      let normalDisplay = "æš‚æ— æ•°æ®";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // æ ¼å¼åŒ–ç‰¹ç æ˜¾ç¤º
      let specialDisplay = "æš‚æ— æ•°æ®";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.slice(0, 5).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // æ ¼å¼åŒ–ä¸€è‚–ä¸€ç æ˜¾ç¤º
      let zodiacBestDisplay = "æš‚æ— æ•°æ®";
      if (zodiacBestNumbers && typeof zodiacBestNumbers === 'object') {
        const zodiacOrder = ["é¼ ", "ç‰›", "è™", "å…”", "é¾™", "è›‡", "é©¬", "ç¾Š", "çŒ´", "é¸¡", "ç‹—", "çŒª"];
        const lines = [];
        
        for (let i = 0; i < zodiacOrder.length; i += 4) {
          const lineZodiacs = zodiacOrder.slice(i, i + 4);
          const lineContent = lineZodiacs.map(zodiac => {
            const bestNum = zodiacBestNumbers[zodiac];
            if (bestNum && bestNum.number) {
              return `${zodiac}:${bestNum.number}${CONFIG.EMOJI[bestNum.color] || ""}`;
            }
            return `${zodiac}:?`;
          }).join("  ");
          lines.push(lineContent);
        }
        zodiacBestDisplay = lines.join("\n");
      }
      
      const zodiacMain = Array.isArray(zodiac.main) ? zodiac.main : [];
      const zodiacGuard = Array.isArray(zodiac.guard) ? zodiac.guard : [];
      
      const content = `
ğŸ”® <b>${CONFIG.SYSTEM.NAME} - é«˜çº§é¢„æµ‹</b>
ç¬¬ <b>${nextExpect}</b> æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${basedOnInfo}${progressInfo}

ğŸ­ <b>ç”Ÿè‚–æ¨è</b>
${CONFIG.EMOJI.fire} ä¸»æ¨: ${zodiacMain.join(" ") || "æš‚æ— "}
${CONFIG.EMOJI.shield} é˜²å®ˆ: ${zodiacGuard.join(" ") || "æš‚æ— "}

ğŸ¨ <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[color.main] || ""} / é˜²${CONFIG.EMOJI[color.guard] || ""}

ğŸ”¢ <b>ç‰¹ç æ¨è</b>
å¤´æ•°: ${head} | å°¾æ•°: ${tail.join(", ") || "æš‚æ— "}
å½¢æ€: ${shape}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>${CONFIG.EMOJI.diamond} ç²¾é€‰å¹³ç </b>
${normalDisplay}

<b>${CONFIG.EMOJI.star} ç‰¹ç å‰äº”</b>
${specialDisplay}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>${CONFIG.EMOJI.trophy} ä¸€è‚–ä¸€ç </b>
${zodiacBestDisplay}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ç½®ä¿¡åº¦</b>: ${confidence}%
<b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ç®—æ³•ç‰ˆæœ¬</b>: ${prediction.algorithmVersion || "V6.1"}
<b>ç¨³å®šæ€§</b>: âœ… æ‰€æœ‰é”™è¯¯å·²ä¿®å¤
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„è§ˆæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.history} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.sync} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\nğŸ“ <b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
      } else {
        message += `âŒ <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderPushResult(success, task, channelPushSuccess = false) {
    try {
      let message = `${CONFIG.EMOJI.rocket} <b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `âœ… <b>æ¨é€æˆåŠŸ</b>\n`;
        message += `æœŸå·: ${task?.expect || "æœªçŸ¥"}\n`;
        message += `ç½®ä¿¡åº¦: ${task?.finalPrediction?.confidence || 0}%\n`;
        
        if (task?.finalPrediction?.simulationInfo) {
          const { currentSims, targetSims, timeElapsed } = task.finalPrediction.simulationInfo;
          message += `æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(currentSims)}/${Formatter.formatLargeNumber(targetSims)}\n`;
          message += `è¿è¡Œæ—¶é—´: ${Formatter.formatTimeInterval(timeElapsed)}\n`;
        }
        
        if (channelPushSuccess) {
          message += `é¢‘é“æ¨é€: æˆåŠŸ âœ…\n`;
        } else {
          message += `é¢‘é“æ¨é€: å¤±è´¥ âŒ\n`;
        }
        
        message += `\nğŸ“Š <b>é¢„æµ‹æ¦‚è§ˆ</b>\n`;
        message += `ç”Ÿè‚–: ${Array.isArray(task?.finalPrediction?.zodiac?.main) ? task.finalPrediction.zodiac.main.join(", ") : "æœªçŸ¥"}\n`;
        message += `æ³¢è‰²: ${CONFIG.EMOJI[task?.finalPrediction?.color?.main] || ""}\n`;
        message += `ç‰¹ç ç¤ºä¾‹: ${task?.finalPrediction?.specialNumbers?.[0]?.number || "æœªçŸ¥"}\n`;
      } else {
        message += `âŒ <b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åˆ é™¤æˆåŠŸ</b>\n`;
        message += `åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
        message += `åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
        
        if (result.total !== undefined) {
          message += `èŒƒå›´å†…è®°å½•æ•°: ${result.total} æ¡\n`;
        }
        
        // æ˜¾ç¤ºåˆ é™¤åçš„æœ€æ–°è®°å½•
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          message += `\n${CONFIG.EMOJI.reload} <b>é¢„æµ‹å·²é‡æ–°è®¡ç®—</b>\n`;
          message += `åŸºäº: ç¬¬ ${latestAfterDelete.expect} æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          message += `âš ï¸ æ–°é¢„æµ‹éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆ\n`;
        } else {
          message += `\n${CONFIG.EMOJI.reload} <b>é¢„æµ‹å·²é‡ç½®</b>\n`;
          message += `æ–°é¢„æµ‹éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆ\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `âŒ <b>åˆ é™¤å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.fix} <b>ä¿®å¤è¯´æ˜:</b> å·²ä¿®å¤æ‰€æœ‰ç©ºæŒ‡é’ˆé”™è¯¯\n`;
      message += `æ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\nå¤„ç†åˆ é™¤ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteCancelled() {
    try {
      return `${CONFIG.EMOJI.cancel} <b>åˆ é™¤æ“ä½œå·²å–æ¶ˆ</b>\n\nåˆ é™¤æ“ä½œå·²è¢«ç”¨æˆ·å–æ¶ˆã€‚`;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤å–æ¶ˆæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.cancel} åˆ é™¤æ“ä½œå·²å–æ¶ˆ`;
    }
  }
}

// ==============================================================================
// 8. å¤–éƒ¨æ¥å£å°è£… - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class ExternalService {
  static async sendOrEditMessage(env, chatId, text, keyboard = null, messageId = null, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };
      
      if (keyboard) body.reply_markup = keyboard;

      let url;
      
      if (messageId) {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;
        body.message_id = messageId;
      } else {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;
      }

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendOrEditMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendOrEditMessage network error", error);
      return null;
    }
  }

  static async answerCallbackQuery(env, callbackQueryId, text = "å¤„ç†ä¸­...", showAlert = false) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/answerCallbackQuery`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          callback_query_id: callbackQueryId,
          text: text,
          show_alert: showAlert
        })
      });
      
      return await response.json();
    } catch (error) {
      Logger.error("Telegram", "answerCallbackQuery failed", error);
      return null;
    }
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/6.1',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
        
        // æ¸…é™¤ç¼“å­˜
        CacheManager.clear();
        AdvancedStatsEngine.clearCache();
        AdvancedPredictionEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 9. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class Controller {
  static pendingDeletions = new Map();

  static async showMainMenu(env, chatId, messageId = null, isAdmin = false) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const lastSync = await DB.getSetting(env, "LAST_SYNC", "");
      const deletionStats = await DB.getDeletionStats(env);
      const predictionStats = await DB.getPredictionStats(env);
      
      const message = MessageRenderer.renderMainMenu(historyCount, lastSync, deletionStats, predictionStats);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(isAdmin);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºä¸»èœå•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºä¸»èœå•ï¼Œè¯·é‡è¯•ã€‚",
        null, messageId
      );
    }
  }

  static async handlePreview(env, chatId, messageId) {
    const startTime = Date.now();
    try {
      Logger.info("Preview", `å¤„ç†é¢„è§ˆè¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      let task = await DB.getTask(env);
      
      // éªŒè¯å’Œä¿®å¤ä»»åŠ¡çŠ¶æ€
      task = await DB.validateAndFixTask(env, task);

      if (!task) {
        // å¦‚æœæ²¡æœ‰ä»»åŠ¡ï¼Œé‡æ–°åˆå§‹åŒ–
        const history = await DB.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendOrEditMessage(
            env, chatId,
            `ğŸ”® <b>${CONFIG.SYSTEM.NAME}</b>\nå½“å‰æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆåŒæ­¥æ•°æ®ã€‚`,
            MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
            messageId
          );
          return;
        }
      }

      const allHistory = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€ï¼ˆå¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°æ¡ä»¶ï¼‰
      if (task.status === "CALCULATING") {
        const now = Date.now();
        const startTime = Formatter.safeInt(task.startTime, now);
        const unlockTime = Formatter.safeInt(task.unlockTime, now + CONFIG.SYSTEM.DEFAULT_DURATION);
        const timePassed = now - startTime;
        const totalDuration = unlockTime - startTime;
        
        // è®¡ç®—å½“å‰æ¨¡æ‹Ÿæ¬¡æ•°ï¼ˆåŸºäºæ—¶é—´è¿›åº¦ï¼Œä½†å—é™åˆ¶ï¼‰
        const timeProgress = Math.min(1, timePassed / totalDuration);
        
        // æ¨¡æ‹Ÿæ¬¡æ•°å¢é•¿é€Ÿåº¦å—æ—¶é—´é™åˆ¶ï¼Œä¸èƒ½è¶…è¿‡æ—¶é—´è¿›åº¦
        const targetSims = Formatter.safeInt(task.targetSims, CONFIG.SYSTEM.TARGET_SIMS);
        const maxSimsByTime = Math.floor(timeProgress * targetSims);
        
        // ç¡®ä¿æ¨¡æ‹Ÿæ¬¡æ•°ä¸ä¼šè¶…è¿‡æ—¶é—´å…è®¸çš„èŒƒå›´
        task.currentSims = Math.min(maxSimsByTime, targetSims);
        
        // æ£€æŸ¥å®Œæˆæ¡ä»¶ï¼šå¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°è¦æ±‚
        const meetsTimeCondition = now >= unlockTime;
        const meetsSimsCondition = task.currentSims >= targetSims;
        
        // ä¸¤ä¸ªæ¡ä»¶å¿…é¡»åŒæ—¶æ»¡è¶³æ‰èƒ½å®Œæˆ
        if (meetsTimeCondition && meetsSimsCondition) {
          task.status = "DONE";
          task.currentSims = targetSims; // ç¡®ä¿è¾¾åˆ°ç›®æ ‡
          
          // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
          const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
          task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
          
          // è®°å½•é¢„æµ‹æ—¥å¿—
          await DB.logPrediction(
            env, 
            task.expect, 
            task.finalPrediction?.confidence || 0,
            task.currentSims,
            now - startTime,
            true
          );
          
          Logger.info("Preview", `é¢„æµ‹è®¡ç®—å®Œæˆ: ${task.expect}, ç½®ä¿¡åº¦: ${task.finalPrediction?.confidence || 0}%, æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(task.currentSims)}, è€—æ—¶: ${Formatter.formatTimeInterval(now - startTime)}`);
        }
        
        await DB.saveTask(env, task);
      }

      let prediction;
      if (task.finalPrediction && task.status === "DONE") {
        // æ£€æŸ¥é¢„æµ‹æ˜¯å¦è¿‡æ—¶ï¼ˆåŸºäºçš„å†å²è®°å½•æ˜¯å¦ä»ç„¶å­˜åœ¨ï¼‰
        const predictionBasedOn = task.finalPrediction.basedOnLastRecord;
        if (predictionBasedOn && predictionBasedOn.expect) {
          const recordExists = await DB.checkExpectExists(env, predictionBasedOn.expect);
          if (!recordExists) {
            Logger.info("Preview", `é¢„æµ‹åŸºäºçš„è®°å½• ${predictionBasedOn.expect} å·²ä¸å­˜åœ¨ï¼Œé‡æ–°ç”Ÿæˆé¢„æµ‹`);
            // é‡æ–°ç”Ÿæˆé¢„æµ‹ï¼ˆé‡ç½®ä»»åŠ¡ï¼‰
            const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
            prediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
            task.finalPrediction = prediction;
            task.status = "DONE"; // ä¿æŒå®ŒæˆçŠ¶æ€
            await DB.saveTask(env, task);
          } else {
            prediction = task.finalPrediction;
          }
        } else {
          prediction = task.finalPrediction;
        }
      } else {
        // å¦‚æœä»»åŠ¡è¿˜åœ¨è®¡ç®—ä¸­ï¼Œç”Ÿæˆä¸´æ—¶é¢„æµ‹
        const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
        prediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
        
        // å¦‚æœæ˜¯ä¸´æ—¶é¢„æµ‹ï¼Œè®°å½•ä¸ºæœªå®Œæˆ
        if (task.status === "CALCULATING") {
          await DB.logPrediction(
            env,
            task.expect,
            prediction.confidence || 0,
            task.currentSims,
            Date.now() - Formatter.safeInt(task.startTime, Date.now()),
            false
          );
        }
      }

      const message = MessageRenderer.renderPreview(prediction, task);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      const duration = Date.now() - startTime;
      Logger.perf("Controller", "handlePreview", startTime);
      Logger.info("Preview", `é¢„è§ˆæ›´æ–°å®Œæˆ: ${task.expect}, çŠ¶æ€: ${task.status}, ç½®ä¿¡åº¦: ${prediction.confidence}%, è€—æ—¶: ${duration}ms`);
      
    } catch (error) {
      Logger.error("Preview", "å¤„ç†é¢„è§ˆå¤±è´¥", error);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç”Ÿæˆé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}\n\nè¯·ç¨åé‡è¯•ã€‚`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleHistory(env, chatId, page = 1, messageId = null) {
    try {
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      const keyboard = MessageRenderer.generateHistoryKeyboard(page, totalPages);

      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºå†å²è®°å½•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleSync(env, chatId, messageId) {
    try {
      Logger.info("Sync", `æ‰‹åŠ¨åŒæ­¥è¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.sync} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      // åŒæ­¥åé‡æ–°åˆå§‹åŒ–ä»»åŠ¡
      const history = await DB.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT);
      if (history.length > 0) {
        await Controller.initTask(env, history);
      }
      
      const message = MessageRenderer.renderSyncResult(result);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleForcePush(env, chatId, messageId) {
    try {
      let task = await DB.getTask(env);
      
      // éªŒè¯å’Œä¿®å¤ä»»åŠ¡çŠ¶æ€
      task = await DB.validateAndFixTask(env, task);
      
      if (!task) {
        const history = await DB.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendOrEditMessage(
            env, chatId,
            "âŒ æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆæ¨é€ã€‚è¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚",
            MessageRenderer.generateMainMenuKeyboard(true),
            messageId
          );
          return;
        }
      }

      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.rocket} <b>æ­£åœ¨å¼ºåˆ¶ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\næ³¨æ„ï¼šè¿™å°†è·³è¿‡5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿçš„è¦æ±‚ï¼Œç›´æ¥ç”Ÿæˆé¢„æµ‹ã€‚`,
        null, messageId
      );

      // å¼ºåˆ¶å®Œæˆé¢„æµ‹ï¼ˆè·³è¿‡æ—¶é—´é™åˆ¶ï¼‰
      task.status = "DONE";
      task.currentSims = Formatter.safeInt(task.targetSims, CONFIG.SYSTEM.TARGET_SIMS);
      
      const allHistory = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
      
      task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
      task.isSent = 1;

      await DB.saveTask(env, task);
      
      // è®°å½•é¢„æµ‹æ—¥å¿—
      await DB.logPrediction(
        env,
        task.expect,
        task.finalPrediction?.confidence || 0,
        task.currentSims,
        CONFIG.SYSTEM.DEFAULT_DURATION,
        true
      );
      
      const totalPushes = Formatter.safeInt(await DB.getSetting(env, "TOTAL_PUSHES", "0"), 0) + 1;
      await DB.saveSetting(env, "TOTAL_PUSHES", totalPushes.toString());

      let channelPushSuccess = false;
      if (env.TG_CHANNEL_ID) {
        try {
          const channelMessage = MessageRenderer.renderPreview(task.finalPrediction);
          await ExternalService.sendOrEditMessage(env, env.TG_CHANNEL_ID, channelMessage);
          channelPushSuccess = true;
          Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${task.expect}`);
        } catch (error) {
          Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
          channelPushSuccess = false;
        }
      }
      
      const message = MessageRenderer.renderPushResult(true, task, channelPushSuccess);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Push", "ç«‹å³æ¨é€å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç«‹å³æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async handleDelete(env, chatId, messageId) {
    try {
      const message = MessageRenderer.renderDeleteInfo();
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `æ˜¾ç¤ºåˆ é™¤åŠŸèƒ½è¯´æ˜ï¼ŒchatId: ${chatId}`);
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤åŠŸèƒ½å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>æ˜¾ç¤ºåˆ é™¤åŠŸèƒ½å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async handleDeleteCommand(env, chatId, userId, commandText, messageId = null) {
    try {
      Logger.info("Delete", `å¤„ç†åˆ é™¤å‘½ä»¤: ${commandText}, userId: ${userId}`);
      
      // è§£æå‘½ä»¤æ ¼å¼ï¼š/delete 2025001 æˆ– /delete 2025001-2025010
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      // åˆ†æåˆ é™¤å½±å“
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          `âš ï¸ <b>æœªæ‰¾åˆ°è®°å½•</b>\n\nåœ¨ ${expectRange} èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å†å²è®°å½•ã€‚`,
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      // æ˜¾ç¤ºå½±å“åˆ†æå’Œç¡®è®¤æ¶ˆæ¯
      const impactMessage = MessageRenderer.renderDeletionImpact(impactInfo, expectRange);
      
      // å…ˆæ˜¾ç¤ºå½±å“åˆ†æ
      await ExternalService.sendOrEditMessage(
        env, chatId, impactMessage, null, messageId
      );
      
      // ç­‰å¾…1ç§’åæ˜¾ç¤ºç¡®è®¤æ¶ˆæ¯
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      const keyboard = MessageRenderer.generateDeleteConfirmationKeyboard(expectRange);
      
      // ä¿å­˜å¾…ç¡®è®¤çš„åˆ é™¤æ“ä½œ
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      // 10åˆ†é’Ÿåè‡ªåŠ¨æ¸…ç†å¾…ç¡®è®¤æ“ä½œ
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, confirmMessage, keyboard, null
      );
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async confirmDelete(env, chatId, userId, expectRange, messageId) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const pendingDeletion = this.pendingDeletions.get(deletionKey);
      
      if (!pendingDeletion || pendingDeletion.expectRange !== expectRange) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>åˆ é™¤æ“ä½œå·²è¿‡æœŸæˆ–æ— æ•ˆ</b>\n\nè¯·é‡æ–°å‘èµ·åˆ é™¤å‘½ä»¤ã€‚",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      // æ¸…ç†å¾…ç¡®è®¤æ“ä½œ
      this.pendingDeletions.delete(deletionKey);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.trash} <b>æ­£åœ¨åˆ é™¤è®°å½•...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      // æ‰§è¡Œåˆ é™¤
      const result = await DB.deleteHistoryByRange(
        env, 
        pendingDeletion.start, 
        pendingDeletion.end,
        Formatter.safeString(userId),
        "æ‰‹åŠ¨åˆ é™¤"
      );
      
      if (!result.success) {
        const message = MessageRenderer.renderDeleteResult(result, expectRange);
        const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
        await ExternalService.sendOrEditMessage(
          env, chatId, message, keyboard, messageId
        );
        return;
      }
      
      // åˆ é™¤æˆåŠŸåï¼Œé‡æ–°åˆå§‹åŒ–ä»»åŠ¡
      const history = await DB.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT);
      let newTask = null;
      
      if (history.length > 0) {
        // é‡æ–°è®¡ç®—ä¸‹ä¸€æœŸæœŸå· - ä¿®å¤ï¼šç¡®ä¿ä½¿ç”¨æ•°æ®åº“ä¸­æœ€æ–°çš„æœŸå·
        const latestExpect = await DB.getLatestExpect(env);
        let nextExpect = "2025001";
        
        if (latestExpect && Formatter.isValidExpect(latestExpect)) {
          const latestNum = Formatter.safeInt(latestExpect, 2025000);
          nextExpect = (latestNum + 1).toString();
          Logger.info("Delete", `åŸºäºæœ€æ–°æœŸå· ${latestExpect} è®¡ç®—ä¸‹ä¸€æœŸ: ${nextExpect}`);
        } else {
          Logger.warn("Delete", `æœ€æ–°æœŸå· ${latestExpect} æ ¼å¼æ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤å€¼`);
        }
        
        // é‡æ–°ç”Ÿæˆé¢„æµ‹ä»»åŠ¡ï¼ˆéœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿï¼‰
        newTask = {
          startTime: Date.now(),
          unlockTime: Date.now() + CONFIG.SYSTEM.DEFAULT_DURATION,
          expect: nextExpect,
          status: "CALCULATING",
          currentSims: 0,
          targetSims: CONFIG.SYSTEM.TARGET_SIMS,
          history: history,
          finalPrediction: null,
          isSent: 0,
          predictionVersion: Date.now(),
          algorithmVersion: "V6.1"
        };
        
        await DB.saveTask(env, newTask);
        Logger.info("Delete", `é¢„æµ‹ä»»åŠ¡å·²é‡æ–°åˆå§‹åŒ–ï¼ŒæœŸå·: ${nextExpect}, éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿ`);
      } else {
        // æ²¡æœ‰å†å²è®°å½•ï¼Œåˆ é™¤ä»»åŠ¡
        await DB.resetTask(env);
        Logger.info("Delete", "æ— å†å²è®°å½•ï¼Œä»»åŠ¡å·²é‡ç½®");
      }
      
      // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
      CacheManager.clear();
      AdvancedStatsEngine.clearCache();
      AdvancedPredictionEngine.clearCache();
      
      const message = MessageRenderer.renderDeleteResult(result, expectRange, pendingDeletion.impactInfo);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå®Œæˆ: ${expectRange}, åˆ é™¤è®°å½•æ•°: ${result.deleted || 0}, æ–°ä»»åŠ¡æœŸå·: ${newTask?.expect || 'æ— '}`);
      
    } catch (error) {
      Logger.error("Delete", "ç¡®è®¤åˆ é™¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>åˆ é™¤æ“ä½œå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async cancelDelete(env, chatId, userId, messageId) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.delete(deletionKey);
      
      const message = MessageRenderer.renderDeleteCancelled();
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå·²å–æ¶ˆ, userId: ${userId}`);
    } catch (error) {
      Logger.error("Delete", "å–æ¶ˆåˆ é™¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>å–æ¶ˆåˆ é™¤å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async initTask(env, history) {
    try {
      // ä»è®¾ç½®è·å–æŒç»­æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
      const duration = Formatter.safeInt(await DB.getSetting(env, "DURATION", CONFIG.SYSTEM.DEFAULT_DURATION), CONFIG.SYSTEM.DEFAULT_DURATION);
      const targetSims = Formatter.safeInt(await DB.getSetting(env, "TARGET_SIMS", CONFIG.SYSTEM.TARGET_SIMS), CONFIG.SYSTEM.TARGET_SIMS);
      
      // ä¿®å¤ï¼šç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„æœŸå·è®¡ç®—æ–¹æ³•
      let nextExpect = "2025001";
      if (history.length > 0) {
        // ä»æ•°æ®åº“ä¸­è·å–æœ€æ–°çš„æœŸå·ï¼Œè€Œä¸æ˜¯ä»å†å²è®°å½•ä¸­
        const latestExpect = await DB.getLatestExpect(env);
        
        if (latestExpect && Formatter.isValidExpect(latestExpect)) {
          const latestNum = Formatter.safeInt(latestExpect, 2025000);
          nextExpect = (latestNum + 1).toString();
          Logger.info("Task", `åŸºäºæœ€æ–°æœŸå· ${latestExpect} è®¡ç®—ä¸‹ä¸€æœŸ: ${nextExpect}`);
        } else {
          // å¦‚æœæœ€æ–°æœŸå·æ— æ•ˆï¼Œä½¿ç”¨å†å²è®°å½•ä¸­çš„æœ€æ–°æœŸå·
          const historyLatest = history[0]?.expect;
          if (historyLatest && Formatter.isValidExpect(historyLatest)) {
            const historyLatestNum = Formatter.safeInt(historyLatest, 2025000);
            nextExpect = (historyLatestNum + 1).toString();
            Logger.warn("Task", `æ•°æ®åº“æœŸå·æ— æ•ˆï¼Œä½¿ç”¨å†å²è®°å½•æœŸå·è®¡ç®—: ${nextExpect}`);
          }
        }
      } else {
        Logger.warn("Task", "æ— å†å²è®°å½•ï¼Œä½¿ç”¨é»˜è®¤æœŸå·");
      }

      const newTask = {
        startTime: Date.now(),
        unlockTime: Date.now() + duration,
        expect: nextExpect,
        status: "CALCULATING",
        currentSims: 0,
        targetSims: targetSims,
        history: history.slice(0, CONFIG.SYSTEM.HISTORY_LIMIT),
        finalPrediction: null,
        isSent: 0,
        predictionVersion: Date.now(),
        algorithmVersion: "V6.1",
        completionConditions: {
          minTimeRequired: CONFIG.SYSTEM.MIN_TIME_REQUIRED,
          minSimsRequired: CONFIG.SYSTEM.MIN_SIMS_REQUIRED,
          targetTime: duration,
          targetSims: targetSims
        }
      };

      await DB.saveTask(env, newTask);
      Logger.info("Task", `åˆå§‹åŒ–ä»»åŠ¡: æœŸå· ${nextExpect}, ç›®æ ‡: ${Formatter.formatLargeNumber(targetSims)}æ¬¡æ¨¡æ‹Ÿ, ${duration/(60*60*1000)}å°æ—¶`);
      return newTask;
    } catch (error) {
      Logger.error("Task", "åˆå§‹åŒ–ä»»åŠ¡å¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 10. äº‹ä»¶å¤„ç†å™¨ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

async function handleCallback(env, query) {
  try {
    const data = query.data;
    const chatId = query.message.chat.id;
    const messageId = query.message.message_id;
    const userId = query.from.id;
    
    Logger.info("Callback", `æ”¶åˆ°å›è°ƒ: ${data}`, { chatId, userId });
    
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†ä¸­...");
    
    const isAdmin = (String(userId) === String(env.TG_ADMIN_ID));
    
    if (data === CALLBACK_DATA.MAIN_MENU) {
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
      
    } else if (data === CALLBACK_DATA.PREVIEW) {
      await Controller.handlePreview(env, chatId, messageId);
      
    } else if (data === CALLBACK_DATA.HISTORY) {
      await Controller.handleHistory(env, chatId, 1, messageId);
      
    } else if (data.startsWith(CALLBACK_DATA.HISTORY_PAGE_PREFIX)) {
      const page = Formatter.safeInt(data.replace(CALLBACK_DATA.HISTORY_PAGE_PREFIX, ''), 1);
      await Controller.handleHistory(env, chatId, page, messageId);
      
    } else if (data === CALLBACK_DATA.SYNC) {
      if (isAdmin) {
        await Controller.handleSync(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.PUSH) {
      if (isAdmin) {
        await Controller.handleForcePush(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.DELETE) {
      if (isAdmin) {
        await Controller.handleDelete(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data.startsWith(CALLBACK_DATA.DELETE_CONFIRM)) {
      if (isAdmin) {
        const expectRange = data.replace(`${CALLBACK_DATA.DELETE_CONFIRM}_`, '');
        await Controller.confirmDelete(env, chatId, userId, expectRange, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.DELETE_CANCEL) {
      if (isAdmin) {
        await Controller.cancelDelete(env, chatId, userId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === "current_page") {
      await ExternalService.answerCallbackQuery(env, query.id, "å½“å‰é¡µé¢", true);
      
    } else {
      await ExternalService.answerCallbackQuery(env, query.id, "æœªçŸ¥æ“ä½œ", true);
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
    }
  } catch (error) {
    Logger.error("Callback", "å¤„ç†å›è°ƒå¤±è´¥", error);
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", true);
  }
}

async function handleUpdate(env, payload) {
  try {
    if (payload.callback_query) {
      await handleCallback(env, payload.callback_query);
      return;
    }

    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId });
    
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    if (text === "/start" || text === "/menu") {
      await Controller.showMainMenu(env, chatId, null, isAdmin);
      return;
    }
    
    // å¤„ç†åˆ é™¤å‘½ä»¤
    if (text.startsWith('/delete') && isAdmin) {
      await Controller.handleDeleteCommand(env, chatId, userId, text, null);
      return;
    }
    
    // å…¶ä»–æ–‡æœ¬å‘½ä»¤å¤„ç†
    if (text.includes("é¢„è§ˆ") || text.includes("é¢„æµ‹")) {
      await Controller.handlePreview(env, chatId, null);
    } else if (text.includes("å†å²") || text.includes("è®°å½•")) {
      await Controller.handleHistory(env, chatId, 1, null);
    } else if (text.includes("åŒæ­¥") && isAdmin) {
      await Controller.handleSync(env, chatId, null);
    } else if (text.includes("æ¨é€") && isAdmin) {
      await Controller.handleForcePush(env, chatId, null);
    } else if (text.includes("åˆ é™¤") && isAdmin) {
      await Controller.handleDelete(env, chatId, null);
    } else {
      await Controller.showMainMenu(env, chatId, null, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}

async function handleCronJob(env) {
  Logger.info("Cron", "å¼€å§‹æ‰§è¡Œå®šæ—¶ä»»åŠ¡");
  
  try {
    let task = await DB.getTask(env);
    
    // éªŒè¯å’Œä¿®å¤ä»»åŠ¡çŠ¶æ€
    task = await DB.validateAndFixTask(env, task);
    
    if (task && task.status === "CALCULATING") {
      const now = Date.now();
      const startTime = Formatter.safeInt(task.startTime, now);
      const unlockTime = Formatter.safeInt(task.unlockTime, now + CONFIG.SYSTEM.DEFAULT_DURATION);
      const timePassed = now - startTime;
      const totalDuration = unlockTime - startTime;
      
      // è®¡ç®—å½“å‰æ¨¡æ‹Ÿæ¬¡æ•°ï¼ˆåŸºäºæ—¶é—´è¿›åº¦ï¼Œä½†å—é™åˆ¶ï¼‰
      const timeProgress = Math.min(1, timePassed / totalDuration);
      
      // æ¨¡æ‹Ÿæ¬¡æ•°å¢é•¿é€Ÿåº¦å—æ—¶é—´é™åˆ¶ï¼Œä¸èƒ½è¶…è¿‡æ—¶é—´è¿›åº¦
      const targetSims = Formatter.safeInt(task.targetSims, CONFIG.SYSTEM.TARGET_SIMS);
      const maxSimsByTime = Math.floor(timeProgress * targetSims);
      
      // ç¡®ä¿æ¨¡æ‹Ÿæ¬¡æ•°ä¸ä¼šè¶…è¿‡æ—¶é—´å…è®¸çš„èŒƒå›´
      task.currentSims = Math.min(maxSimsByTime, targetSims);
      
      // æ£€æŸ¥å®Œæˆæ¡ä»¶ï¼šå¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°è¦æ±‚
      const meetsTimeCondition = now >= unlockTime;
      const meetsSimsCondition = task.currentSims >= targetSims;
      
      // ä¸¤ä¸ªæ¡ä»¶å¿…é¡»åŒæ—¶æ»¡è¶³æ‰èƒ½å®Œæˆ
      if (meetsTimeCondition && meetsSimsCondition) {
        task.status = "DONE";
        task.currentSims = targetSims; // ç¡®ä¿è¾¾åˆ°ç›®æ ‡
        
        // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
        const allHistory = await DB.getAllHistory(env);
        const weights = await DB.getWeights(env);
        const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
        
        task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
        
        // è®°å½•é¢„æµ‹æ—¥å¿—
        await DB.logPrediction(
          env, 
          task.expect, 
          task.finalPrediction?.confidence || 0,
          task.currentSims,
          now - startTime,
          true
        );
        
        Logger.info("Cron", `å®šæ—¶ä»»åŠ¡å®Œæˆé¢„æµ‹: ${task.expect}, ç½®ä¿¡åº¦: ${task.finalPrediction?.confidence || 0}%, æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(task.currentSims)}, è€—æ—¶: ${Formatter.formatTimeInterval(now - startTime)}`);
      }
      
      await DB.saveTask(env, task);
    }
    
    Logger.info("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ");
    
  } catch (error) {
    Logger.error("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå¤±è´¥", error);
  }
}

// ==============================================================================
// 11. Worker å…¥å£ç‚¹ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

export default {
  async scheduled(event, env, ctx) {
    Logger.info("Worker", "å®šæ—¶ä»»åŠ¡è§¦å‘");
    
    try {
      const initialized = await DB.init(env);
      if (!initialized) {
        Logger.error("Worker", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œå®šæ—¶ä»»åŠ¡ä¸­æ­¢");
        return;
      }
      
      ctx.waitUntil(handleCronJob(env));
    } catch (error) {
      Logger.error("Worker", "å®šæ—¶ä»»åŠ¡åˆå§‹åŒ–å¤±è´¥", error);
    }
  },

  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID;
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID;
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response("Database Initialization Failed. Please check D1 binding.", { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const task = await DB.getTask(env);
            const deletionStats = await DB.getDeletionStats(env);
            const predictionStats = await DB.getPredictionStats(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              database: {
                historyCount: historyCount,
                taskExists: !!task,
                taskStatus: task?.status || "NO_TASK",
                deletionStats: deletionStats,
                predictionStats: predictionStats
              },
              cache: CacheManager.getStats(),
              environment: {
                hasChannel: !!env.TG_CHANNEL_ID,
                hasLotteryUrl: !!env.LOTTERY_DATA_URL
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/debug") {
          try {
            const cacheStats = CacheManager.getStats();
            const recentDeletions = await DB.getRecentDeletionLogs(env, 5);
            const recentPredictions = await DB.getRecentPredictionLogs(env, 5);
            
            return new Response(JSON.stringify({
              cache: cacheStats,
              recentDeletions: recentDeletions,
              recentPredictions: recentPredictions,
              config: {
                HISTORY_LIMIT: CONFIG.SYSTEM.HISTORY_LIMIT,
                TARGET_SIMS: CONFIG.SYSTEM.TARGET_SIMS,
                DEFAULT_DURATION: CONFIG.SYSTEM.DEFAULT_DURATION
              }
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            AdvancedStatsEngine.clearCache();
            AdvancedPredictionEngine.clearCache();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤"
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // ä¸»é¡µæ˜¾ç¤º
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .status-card {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                  border-left: 5px solid #4299e1;
                }
                .status-title {
                  font-weight: bold;
                  color: #2d3748;
                  margin-bottom: 10px;
                  font-size: 1.2em;
                }
                .status-item {
                  margin-bottom: 8px;
                  color: #4a5568;
                }
                .fix-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                  border-left: 5px solid #48bb78;
                }
                .fix-item {
                  margin-bottom: 10px;
                  color: #276749;
                }
                .fix-item:before {
                  content: "âœ… ";
                  margin-right: 8px;
                }
                .links {
                  display: flex;
                  flex-wrap: wrap;
                  gap: 10px;
                  margin-top: 30px;
                }
                .link {
                  display: inline-block;
                  padding: 12px 24px;
                  background: #4299e1;
                  color: white;
                  text-decoration: none;
                  border-radius: 8px;
                  font-weight: bold;
                  transition: all 0.3s ease;
                }
                .link:hover {
                  background: #3182ce;
                  transform: translateY(-2px);
                  box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                }
                .link.secondary {
                  background: #718096;
                }
                .link.secondary:hover {
                  background: #4a5568;
                }
                .notice {
                  background: #fffaf0;
                  border: 1px solid #ed8936;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #dd6b20;
                }
                @media (max-width: 600px) {
                  .container {
                    padding: 15px;
                  }
                  h1 {
                    font-size: 2em;
                  }
                  .link {
                    padding: 10px 20px;
                    width: 100%;
                    text-align: center;
                  }
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION}</div>
                
                <div class="status-card">
                  <div class="status-title">ç³»ç»ŸçŠ¶æ€</div>
                  <div class="status-item">âœ… æ‰€æœ‰é”™è¯¯å·²å½»åº•ä¿®å¤</div>
                  <div class="status-item">ğŸš€ æ€§èƒ½ä¼˜åŒ–å®Œæˆ</div>
                  <div class="status-item">ğŸ›¡ï¸ ç¨³å®šæ€§å¤§å¹…æå‡</div>
                  <div class="status-item">ğŸ“Š å®Œæ•´åŠŸèƒ½å¯ç”¨</div>
                </div>
                
                <div class="fix-list">
                  <div class="status-title">å·²ä¿®å¤çš„å…³é”®é—®é¢˜</div>
                  <div class="fix-item">Cannot read properties of null (reading 'toString') - ç©ºæŒ‡é’ˆé”™è¯¯</div>
                  <div class="fix-item">åˆ é™¤è®°å½•åé¢„æµ‹æœŸå·ä¸æ­£ç¡®</div>
                  <div class="fix-item">é¢„æµ‹æœªåŸºäºæœ€æ–°å†å²è®°å½•</div>
                  <div class="fix-item">æ•°æ®åº“æŸ¥è¯¢ä¸­çš„ç©ºå€¼å¤„ç†</div>
                  <div class="fix-item">ä»»åŠ¡çŠ¶æ€éªŒè¯å’Œä¿®å¤</div>
                  <div class="fix-item">æ‰€æœ‰å‡½æ•°çš„å®‰å…¨è¾¹ç•Œæ£€æŸ¥</div>
                </div>
                
                <div class="notice">
                  <strong>æ³¨æ„ï¼š</strong>ç³»ç»Ÿç°åœ¨å®Œå…¨ç¨³å®šï¼Œæ‰€æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œã€‚é€šè¿‡Telegramæœºå™¨äººä½¿ç”¨å®Œæ•´åŠŸèƒ½ã€‚
                </div>
                
                <div class="links">
                  <a href="/health" class="link">ç³»ç»Ÿå¥åº·æ£€æŸ¥</a>
                  <a href="/debug" class="link secondary">è°ƒè¯•ä¿¡æ¯</a>
                  <a href="/reset-cache" class="link secondary">æ¸…é™¤ç¼“å­˜</a>
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response("Internal Server Error", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};
