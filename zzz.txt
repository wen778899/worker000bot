/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V5.8 Pro Edition (ä¸“ä¸šå¢å¼ºå®Œæ•´ç‰ˆ)
 * 
 * åŠŸèƒ½æ›´æ–°:
 * 1. å¢åŠ é¢„æµ‹è¿è¡Œæ—¶é—´åˆ°5å°æ—¶
 * 2. å¢åŠ æ¨¡æ‹Ÿæ¬¡æ•°åˆ°1äº¿æ¬¡
 * 3. å¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¬¡æ•°æ¡ä»¶æ‰èƒ½å®Œæˆé¢„æµ‹
 * 4. ä¿®å¤åˆ é™¤åŠŸèƒ½ä¸å½»åº•çš„é—®é¢˜
 * 5. ä¼˜åŒ–é¢„æµ‹ç”Ÿæˆé€»è¾‘
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ–°æ¾³å…­åˆå½©Â·å¤©æœº",
    VERSION: "V5.8 Pro Edition (ä¸“ä¸šå¢å¼ºå®Œæ•´ç‰ˆ)",
    DEFAULT_DURATION: 5 * 60 * 60 * 1000, // 5å°æ—¶ï¼ˆåŸä¸º2å°æ—¶ï¼‰
    TARGET_SIMS: 100000000, // 1äº¿æ¬¡æ¨¡æ‹Ÿï¼ˆåŸä¸º300ä¸‡æ¬¡ï¼‰
    BATCH_SIZE: 50000,
    TIMEZONE_OFFSET: 8,
    CHANNEL_ID: null,
    ADMIN_ID: null,
    MIN_SIMS_REQUIRED: 50000000, // æœ€ä½5000ä¸‡æ¬¡æ¨¡æ‹Ÿ
    MIN_TIME_REQUIRED: 4.5 * 60 * 60 * 1000 // æœ€å°‘4.5å°æ—¶
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 3.0,
    w_zodiac_relation: 2.5,
    w_color_transfer: 2.0,
    w_tail_correlation: 1.8,
    w_number_frequency: 1.5,
    w_omission_value: 1.2,
    w_shape_pattern: 1.0,
    w_head_tail: 0.8,
    w_normal_correlation: 2.0,
    _version: "3.0"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    },
    
    OPPOSITION: {
      "é¼ ": "é©¬", "é©¬": "é¼ ",
      "ç‰›": "ç¾Š", "ç¾Š": "ç‰›",
      "è™": "çŒ´", "çŒ´": "è™",
      "å…”": "é¸¡", "é¸¡": "å…”",
      "é¾™": "ç‹—", "ç‹—": "é¾™",
      "è›‡": "çŒª", "çŒª": "è›‡"
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    wait: "â³",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    rocket: "ğŸš€",
    sync: "ğŸ”„",
    reset: "â™»ï¸",
    manage: "âš™ï¸",
    history: "ğŸ“œ",
    preview: "ğŸ‘€",
    back: "ğŸ”™",
    gold: "ğŸ’°",
    wood: "ğŸŒ²",
    water: "ğŸ’§",
    fire_element: "ğŸ”¥",
    earth: "â›°ï¸",
    star: "â­",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    bell: "ğŸ””",
    home: "ğŸ ",
    trash: "ğŸ—‘ï¸",
    warning: "âš ï¸",
    cancel: "âŒ",
    confirm: "âœ…",
    reload: "ğŸ”„",
    database: "ğŸ’¾",
    clock: "â°",
    counter: "ğŸ”¢",
    cpu: "ğŸ’»",
    check: "âœ”ï¸",
    hourglass: "âŒ›"
  }
};

const CALLBACK_DATA = {
  MAIN_MENU: "main_menu",
  PREVIEW: "preview",
  HISTORY: "history",
  SYNC: "sync",
  PUSH: "push",
  DELETE: "delete",
  DELETE_CONFIRM: "delete_confirm",
  DELETE_CANCEL: "delete_cancel",
  HISTORY_PAGE_PREFIX: "history_page_"
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•°
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
    console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
  }

  static error(context, message, error = null) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    const errorStr = error ? ` | ${error.message} | ${error.stack?.substring(0, 200)}` : '';
    console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
  }

  static warn(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
  }

  static debug(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.log(`[${timestamp}] [DEBUG] [${context}] ${message}`);
  }
}

class Formatter {
  static getAttributes(number) {
    const num = parseInt(number);
    if (num < 1 || num > 49) return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    
    let color = "red";
    if (CONFIG.COLORS.blue.includes(num)) color = "blue";
    else if (CONFIG.COLORS.green.includes(num)) color = "green";
    
    let zodiac = "";
    for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
      if (numbers.includes(num)) {
        zodiac = zodiacName;
        break;
      }
    }
    
    return { zodiac, color };
  }

  static formatOpenCode(codeString) {
    if (!codeString) return "";
    return codeString.replace(/,/g, "-");
  }

  static generateProgressBar(current, total, length = 10) {
    const percentage = total > 0 ? (current / total) : 0;
    const filled = Math.floor(length * percentage);
    const empty = length - filled;
    return "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
  }

  static safeInt(value, defaultValue = 0) {
    if (value === null || value === undefined) return defaultValue;
    const num = parseInt(value);
    return isNaN(num) ? defaultValue : num;
  }

  /**
   * è§£ææœŸå·èŒƒå›´
   */
  static parseExpectRange(rangeStr) {
    if (!rangeStr || typeof rangeStr !== 'string') return null;
    
    const trimmed = rangeStr.trim();
    
    // å¦‚æœæ˜¯å•ä¸ªæœŸå·
    if (/^\d+$/.test(trimmed)) {
      const num = parseInt(trimmed);
      return { start: num, end: num, isSingle: true };
    }
    
    // å¦‚æœæ˜¯èŒƒå›´æ ¼å¼ï¼š2025001-2025010
    const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
    if (rangeMatch) {
      const start = parseInt(rangeMatch[1]);
      const end = parseInt(rangeMatch[2]);
      
      if (start <= end) {
        return { start, end, isSingle: false };
      }
    }
    
    return null;
  }

  /**
   * æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´
   */
  static formatDateTime(date = new Date()) {
    return date.toLocaleString('zh-CN', { 
      timeZone: 'Asia/Shanghai',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´é—´éš”
   */
  static formatTimeInterval(ms) {
    if (ms < 0) ms = 0;
    
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    
    if (hours > 0) {
      return `${hours}æ—¶${minutes}åˆ†${seconds}ç§’`;
    } else if (minutes > 0) {
      return `${minutes}åˆ†${seconds}ç§’`;
    } else {
      return `${seconds}ç§’`;
    }
  }

  /**
   * æ ¼å¼åŒ–å¤§æ•°å­—
   */
  static formatLargeNumber(num) {
    if (num >= 100000000) {
      return (num / 100000000).toFixed(2) + 'äº¿';
    } else if (num >= 10000) {
      return (num / 10000).toFixed(1) + 'ä¸‡';
    } else {
      return num.toLocaleString();
    }
  }

  /**
   * éªŒè¯æœŸå·æ˜¯å¦æœ‰æ•ˆ
   */
  static isValidExpect(expect) {
    if (!expect || typeof expect !== 'string') return false;
    return /^\d{7}$/.test(expect);
  }
}

// ==============================================================================
// 3. æ•°æ®åº“æ“ä½œå±‚ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_tasks (
          id INTEGER PRIMARY KEY DEFAULT 1, 
          data TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS prediction_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          expect TEXT,
          confidence INTEGER,
          total_sims INTEGER,
          total_time_ms INTEGER,
          is_completed INTEGER DEFAULT 0,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM lottery_history ORDER BY expect DESC"
      ).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getAllHistory failed", e);
      return [];
    }
  },

  getHistoryCount: async function(env) {
    try {
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      return result ? result.count : 0;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      return result ? result.expect : null;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  /**
   * è·å–æœ€æ–°çš„å†å²è®°å½•ï¼ˆå¤šæ¡ï¼‰
   */
  getLatestHistory: async function(env, limit = 10) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM lottery_history ORDER BY expect DESC LIMIT ?"
      ).bind(limit).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getLatestHistory failed", e);
      return [];
    }
  },

  /**
   * æ£€æŸ¥æœŸå·æ˜¯å¦å­˜åœ¨
   */
  checkExpectExists: async function(env, expect) {
    try {
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(expect).first();
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || records.length === 0) return { success: true, added: 0, skipped: 0 };
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const batch = env.DB.batch(
          chunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(record.expect.toString(), record.open_code)
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + result.changes, 0);
          totalAdded += chunkAdded;
          totalSkipped += (chunk.length - chunkAdded);
          
          if (i + CHUNK_SIZE < records.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡ ${Math.floor(i/CHUNK_SIZE)+1} æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of chunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(record.expect.toString(), record.open_code).run();
              totalAdded += result.changes;
              totalSkipped += (1 - result.changes);
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ€»è®¡æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getTask: async function(env) {
    try {
      const r = await env.DB.prepare("SELECT data FROM lottery_tasks WHERE id = 1").first();
      return r ? JSON.parse(r.data) : null;
    } catch (e) {
      Logger.error("DB", "getTask failed", e);
      return null;
    }
  },

  saveTask: async function(env, data) {
    try {
      return await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_tasks (id, data) VALUES (1, ?)"
      ).bind(JSON.stringify(data)).run();
    } catch (e) {
      Logger.error("DB", "saveTask failed", e);
      return null;
    }
  },

  /**
   * é‡ç½®ä»»åŠ¡ï¼ˆåˆ é™¤åä½¿ç”¨ï¼‰
   */
  resetTask: async function(env) {
    try {
      // åˆ é™¤ç°æœ‰ä»»åŠ¡
      await env.DB.prepare("DELETE FROM lottery_tasks WHERE id = 1").run();
      Logger.info("DB", "ä»»åŠ¡å·²é‡ç½®");
      return { success: true };
    } catch (e) {
      Logger.error("DB", "resetTask failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      return r ? r.value : def;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      return await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, val).run();
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      if (w) {
        const weights = JSON.parse(w);
        const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        return { ...defaultWeights, ...weights };
      }
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "DURATION": CONFIG.SYSTEM.DEFAULT_DURATION.toString(),
        "TARGET_SIMS": CONFIG.SYSTEM.TARGET_SIMS.toString(),
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_PUSHES": "0",
        "TOTAL_DELETIONS": "0",
        "TOTAL_PREDICTIONS": "0",
        "TOTAL_SIMULATIONS": "0",
        "TOTAL_PREDICTION_TIME": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  /**
   * æ‰¹é‡åˆ é™¤è®°å½•ï¼ˆä¿®å¤ç‰ˆï¼‰
   */
  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      // å…ˆæ£€æŸ¥èŒƒå›´å†…æœ‰å¤šå°‘æ¡è®°å½•
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count, GROUP_CONCAT(expect) as expects FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(startExpect.toString(), endExpect.toString()).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      const expectList = checkResult ? checkResult.expects : '';
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•",
          details: { startExpect, endExpect }
        };
      }
      
      // æ‰§è¡Œåˆ é™¤
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(startExpect.toString(), endExpect.toString()).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      // è®°å½•åˆ é™¤æ—¥å¿—
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(adminId, `${startExpect}-${endExpect}`, deletedCount, reason).run();
        
        // æ›´æ–°ç»Ÿè®¡
        const totalDeletions = parseInt(await this.getSetting(env, "TOTAL_DELETIONS", "0")) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        // é‡ç½®é¢„æµ‹ä»»åŠ¡
        await this.resetTask(env);
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•ï¼Œä»»åŠ¡å·²é‡ç½®`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        details: {
          startExpect,
          endExpect,
          expectList: expectList ? expectList.split(',') : [],
          deletedCount
        },
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥",
        details: { startExpect, endExpect }
      };
    }
  },

  /**
   * è·å–åˆ é™¤åçš„æœ€æ–°è®°å½•
   */
  getLatestAfterDeletion: async function(env) {
    try {
      // è·å–æœ€æ–°çš„10æ¡è®°å½•
      const { results } = await env.DB.prepare(
        "SELECT * FROM lottery_history ORDER BY expect DESC LIMIT 10"
      ).all();
      
      return results || [];
    } catch (e) {
      Logger.error("DB", "getLatestAfterDeletion failed", e);
      return [];
    }
  },

  /**
   * è·å–åˆ é™¤å½±å“çš„è®°å½•è¯¦æƒ…
   */
  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      // è·å–è¦åˆ é™¤çš„è®°å½•
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC"
      ).bind(startExpect.toString(), endExpect.toString()).all();
      
      // è·å–åˆ é™¤åçš„æœ€æ–°è®°å½•
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(startExpect.toString()).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  /**
   * è·å–æœ€è¿‘çš„åˆ é™¤æ—¥å¿—
   */
  getRecentDeletionLogs: async function(env, limit = 5) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM deletion_log ORDER BY created_at DESC LIMIT ?"
      ).bind(limit).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getRecentDeletionLogs failed", e);
      return [];
    }
  },

  /**
   * è·å–åˆ é™¤ç»Ÿè®¡
   */
  getDeletionStats: async function(env) {
    try {
      // æ€»åˆ é™¤æ¬¡æ•°
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM deletion_log"
      ).first();
      
      // æ€»åˆ é™¤è®°å½•æ•°
      const recordsResult = await env.DB.prepare(
        "SELECT SUM(deleted_count) as total FROM deletion_log"
      ).first();
      
      // æœ€è¿‘åˆ é™¤æ—¶é—´
      const recentResult = await env.DB.prepare(
        "SELECT created_at FROM deletion_log ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalDeletions: totalResult ? totalResult.count : 0,
        totalRecordsDeleted: recordsResult ? (recordsResult.total || 0) : 0,
        lastDeletion: recentResult ? recentResult.created_at : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionStats failed", e);
      return {
        totalDeletions: 0,
        totalRecordsDeleted: 0,
        lastDeletion: null
      };
    }
  },

  /**
   * è®°å½•é¢„æµ‹ç”Ÿæˆæ—¥å¿—
   */
  logPrediction: async function(env, expect, confidence, totalSims, totalTimeMs, isCompleted = true) {
    try {
      await env.DB.prepare(
        "INSERT INTO prediction_log (expect, confidence, total_sims, total_time_ms, is_completed) VALUES (?, ?, ?, ?, ?)"
      ).bind(expect, confidence, totalSims, totalTimeMs, isCompleted ? 1 : 0).run();
      
      // æ›´æ–°å…¨å±€ç»Ÿè®¡
      if (isCompleted) {
        const totalPredictions = parseInt(await this.getSetting(env, "TOTAL_PREDICTIONS", "0")) + 1;
        await this.saveSetting(env, "TOTAL_PREDICTIONS", totalPredictions.toString());
        
        const totalSimulations = parseInt(await this.getSetting(env, "TOTAL_SIMULATIONS", "0")) + totalSims;
        await this.saveSetting(env, "TOTAL_SIMULATIONS", totalSimulations.toString());
        
        const totalPredictionTime = parseInt(await this.getSetting(env, "TOTAL_PREDICTION_TIME", "0")) + totalTimeMs;
        await this.saveSetting(env, "TOTAL_PREDICTION_TIME", totalPredictionTime.toString());
      }
      
      return true;
    } catch (e) {
      Logger.error("DB", "logPrediction failed", e);
      return false;
    }
  },

  /**
   * è·å–æœ€è¿‘çš„é¢„æµ‹æ—¥å¿—
   */
  getRecentPredictionLogs: async function(env, limit = 5) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM prediction_log ORDER BY created_at DESC LIMIT ?"
      ).bind(limit).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getRecentPredictionLogs failed", e);
      return [];
    }
  },

  /**
   * è·å–é¢„æµ‹ç»Ÿè®¡
   */
  getPredictionStats: async function(env) {
    try {
      // æ€»é¢„æµ‹æ¬¡æ•°
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // æ€»æ¨¡æ‹Ÿæ¬¡æ•°
      const simsResult = await env.DB.prepare(
        "SELECT SUM(total_sims) as total FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // å¹³å‡ç½®ä¿¡åº¦
      const avgConfidenceResult = await env.DB.prepare(
        "SELECT AVG(confidence) as avg FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // å¹³å‡é¢„æµ‹æ—¶é—´
      const avgTimeResult = await env.DB.prepare(
        "SELECT AVG(total_time_ms) as avg FROM prediction_log WHERE is_completed = 1"
      ).first();
      
      // æœ€è¿‘é¢„æµ‹
      const recentResult = await env.DB.prepare(
        "SELECT * FROM prediction_log WHERE is_completed = 1 ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalPredictions: totalResult ? totalResult.count : 0,
        totalSimulations: simsResult ? (simsResult.total || 0) : 0,
        avgConfidence: avgConfidenceResult ? Math.round(avgConfidenceResult.avg) : 0,
        avgTimeMs: avgTimeResult ? Math.round(avgTimeResult.avg) : 0,
        recentPrediction: recentResult || null
      };
    } catch (e) {
      Logger.error("DB", "getPredictionStats failed", e);
      return {
        totalPredictions: 0,
        totalSimulations: 0,
        avgConfidence: 0,
        avgTimeMs: 0,
        recentPrediction: null
      };
    }
  }
};

// ==============================================================================
// 4. é«˜çº§ç»Ÿè®¡å¼•æ“
// ==============================================================================

class AdvancedStatsEngine {
  static analyzeHistoryStatistics(history) {
    if (!history || !Array.isArray(history) || history.length < 2) {
      Logger.warn("Stats", "å†å²æ•°æ®ä¸è¶³ï¼Œè¿”å›ç©ºç»Ÿè®¡");
      return this.createEmptyStats();
    }

    Logger.info("Stats", `å¼€å§‹åˆ†æ ${history.length} æœŸå†å²æ•°æ®`);

    const stats = this.createEmptyStats();
    
    try {
      for (let i = 0; i < history.length - 1; i++) {
        const currentRecord = history[i];
        const nextRecord = history[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNums = currentRecord.open_code.split(",").map(n => parseInt(n));
        const nextNums = nextRecord.open_code.split(",").map(n => parseInt(n));
        
        if (currentNums.length < 7 || nextNums.length < 7) {
          continue;
        }
        
        const currentSpecial = currentNums[6];
        const nextSpecial = nextNums[6];
        const nextNormals = nextNums.slice(0, 6);
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        // 1. ç”Ÿè‚–è½¬ç§»ç»Ÿè®¡
        if (stats.zodiacTransfer[currentAttr.zodiac] && stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac] !== undefined) {
          stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac]++;
        }
        
        // 2. æ³¢è‰²è½¬ç§»ç»Ÿè®¡
        if (stats.colorTransfer[currentAttr.color] && stats.colorTransfer[currentAttr.color][nextAttr.color] !== undefined) {
          stats.colorTransfer[currentAttr.color][nextAttr.color]++;
        }
        
        // 3. å°¾æ•°å…³è”ç»Ÿè®¡
        const currentNormalTails = currentNums.slice(0, 6).map(n => n % 10);
        const nextSpecialTail = nextSpecial % 10;
        
        currentNormalTails.forEach(tail => {
          if (stats.tailCorrelation[tail] && stats.tailCorrelation[tail][nextSpecialTail] !== undefined) {
            stats.tailCorrelation[tail][nextSpecialTail]++;
          }
        });
        
        // 4. ç”Ÿè‚–å…³ç³»ç»Ÿè®¡
        this.analyzeZodiacRelations(stats, currentAttr.zodiac, nextAttr.zodiac);
        
        // 5. ç‰¹ç é¢‘ç‡ç»Ÿè®¡
        stats.specialFrequency[nextSpecial] = (stats.specialFrequency[nextSpecial] || 0) + 1;
        
        // 6. å¹³ç é¢‘ç‡ç»Ÿè®¡
        nextNormals.forEach(num => {
          stats.normalFrequency[num] = (stats.normalFrequency[num] || 0) + 1;
        });
        
        // 7. å¹³ç ç»„åˆç»Ÿè®¡
        this.analyzeNormalCombination(stats, nextNormals);
        
        // 8. å½¢æ€ç»Ÿè®¡
        const isBig = nextSpecial >= 25;
        const isOdd = nextSpecial % 2 !== 0;
        
        if (isBig && isOdd) stats.shapeStats.bigOdd++;
        else if (isBig && !isOdd) stats.shapeStats.bigEven++;
        else if (!isBig && isOdd) stats.shapeStats.smallOdd++;
        else stats.shapeStats.smallEven++;
      }

      // 9. è®¡ç®—é—æ¼å€¼
      this.calculateOmissionStats(stats, history);
      
      // 10. è®¡ç®—æ¦‚ç‡å’Œå½’ä¸€åŒ–
      this.normalizeStatistics(stats);
      
      stats.totalRecords = history.length;
      
      Logger.info("Stats", "å†å²æ•°æ®åˆ†æå®Œæˆ");
      return stats;
    } catch (error) {
      Logger.error("Stats", "åˆ†æå†å²æ•°æ®æ—¶å‡ºé”™", error);
      return this.createEmptyStats();
    }
  }

  static createEmptyStats() {
    const stats = {
      totalRecords: 0,
      zodiacTransfer: {},
      colorTransfer: { red: { red: 0, blue: 0, green: 0 }, blue: { red: 0, blue: 0, green: 0 }, green: { red: 0, blue: 0, green: 0 } },
      tailCorrelation: {},
      zodiacRelations: { sixHarmony: {}, threeHarmony: {}, opposition: {} },
      specialFrequency: {},
      normalFrequency: {},
      normalCombination: { zodiacPairs: {}, colorDistribution: {}, tailDistribution: {} },
      omissionStats: {},
      shapeStats: { bigOdd: 0, bigEven: 0, smallOdd: 0, smallEven: 0 }
    };
    
    this.initializeStatsStructure(stats);
    return stats;
  }

  static initializeStatsStructure(stats) {
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac1 => {
      stats.zodiacTransfer[zodiac1] = {};
      stats.zodiacRelations.sixHarmony[zodiac1] = 0;
      stats.zodiacRelations.threeHarmony[zodiac1] = 0;
      stats.zodiacRelations.opposition[zodiac1] = 0;
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac2 => {
        stats.zodiacTransfer[zodiac1][zodiac2] = 0;
      });
    });
    
    for (let i = 0; i < 10; i++) {
      stats.tailCorrelation[i] = {};
      for (let j = 0; j < 10; j++) {
        stats.tailCorrelation[i][j] = 0;
      }
    }
    
    for (let i = 1; i <= 49; i++) {
      stats.specialFrequency[i] = 0;
      stats.normalFrequency[i] = 0;
    }
    
    stats.normalCombination.colorDistribution = {
      red: { count: 0, probability: 0 },
      blue: { count: 0, probability: 0 },
      green: { count: 0, probability: 0 }
    };
    
    for (let i = 0; i < 10; i++) {
      stats.normalCombination.tailDistribution[i] = { count: 0, probability: 0 };
    }
  }

  static analyzeZodiacRelations(stats, currentZodiac, nextZodiac) {
    if (!currentZodiac || !nextZodiac) return;
    
    if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[currentZodiac] === nextZodiac) {
      stats.zodiacRelations.sixHarmony[nextZodiac] = (stats.zodiacRelations.sixHarmony[nextZodiac] || 0) + 1;
    }
    
    if (CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[currentZodiac]?.includes(nextZodiac)) {
      stats.zodiacRelations.threeHarmony[nextZodiac] = (stats.zodiacRelations.threeHarmony[nextZodiac] || 0) + 1;
    }
    
    if (CONFIG.ZODIAC_RELATIONS.OPPOSITION[currentZodiac] === nextZodiac) {
      stats.zodiacRelations.opposition[nextZodiac] = (stats.zodiacRelations.opposition[nextZodiac] || 0) + 1;
    }
  }

  static analyzeNormalCombination(stats, normalNumbers) {
    if (!normalNumbers || !Array.isArray(normalNumbers)) return;
    
    const colorCount = { red: 0, blue: 0, green: 0 };
    const tailCount = {};
    
    normalNumbers.forEach(num => {
      const attr = Formatter.getAttributes(num);
      colorCount[attr.color] = (colorCount[attr.color] || 0) + 1;
      
      const tail = num % 10;
      tailCount[tail] = (tailCount[tail] || 0) + 1;
    });
    
    ['red', 'blue', 'green'].forEach(color => {
      if (stats.normalCombination.colorDistribution[color]) {
        stats.normalCombination.colorDistribution[color].count += (colorCount[color] || 0);
      }
    });
    
    Object.keys(tailCount).forEach(tail => {
      const tailNum = parseInt(tail);
      if (stats.normalCombination.tailDistribution[tailNum]) {
        stats.normalCombination.tailDistribution[tailNum].count += (tailCount[tail] || 0);
      }
    });
    
    const zodiacs = normalNumbers.map(num => Formatter.getAttributes(num).zodiac);
    for (let i = 0; i < zodiacs.length; i++) {
      for (let j = i + 1; j < zodiacs.length; j++) {
        const pair = [zodiacs[i], zodiacs[j]].sort().join('-');
        stats.normalCombination.zodiacPairs[pair] = (stats.normalCombination.zodiacPairs[pair] || 0) + 1;
      }
    }
  }

  static calculateOmissionStats(stats, history) {
    const currentOmission = {};
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
      currentOmission[zodiac] = 0;
    });
    
    for (let i = 0; i < history.length; i++) {
      const record = history[i];
      if (!record || !record.open_code) continue;
      
      const special = parseInt(record.open_code.split(",")[6]);
      if (isNaN(special)) continue;
      
      const zodiac = Formatter.getAttributes(special).zodiac;
      
      Object.keys(currentOmission).forEach(z => {
        if (currentOmission[z] !== -1) {
          if (z === zodiac) currentOmission[z] = -1;
          else currentOmission[z]++;
        }
      });
    }
    
    stats.omissionStats = currentOmission;
  }

  static normalizeStatistics(stats) {
    Object.keys(stats.zodiacTransfer).forEach(zodiac1 => {
      const total = Object.values(stats.zodiacTransfer[zodiac1]).reduce((a, b) => a + b, 0);
      if (total > 0) {
        Object.keys(stats.zodiacTransfer[zodiac1]).forEach(zodiac2 => {
          stats.zodiacTransfer[zodiac1][zodiac2] = stats.zodiacTransfer[zodiac1][zodiac2] / total;
        });
      }
    });
    
    Object.keys(stats.colorTransfer).forEach(color1 => {
      const total = Object.values(stats.colorTransfer[color1]).reduce((a, b) => a + b, 0);
      if (total > 0) {
        Object.keys(stats.colorTransfer[color1]).forEach(color2 => {
          stats.colorTransfer[color1][color2] = stats.colorTransfer[color1][color2] / total;
        });
      }
    });
    
    Object.keys(stats.tailCorrelation).forEach(tail1 => {
      const total = Object.values(stats.tailCorrelation[tail1]).reduce((a, b) => a + b, 0);
      if (total > 0) {
        Object.keys(stats.tailCorrelation[tail1]).forEach(tail2 => {
          stats.tailCorrelation[tail1][tail2] = stats.tailCorrelation[tail1][tail2] / total;
        });
      }
    });
    
    const totalColorCount = Object.values(stats.normalCombination.colorDistribution)
      .reduce((sum, item) => sum + (item?.count || 0), 0);
    if (totalColorCount > 0) {
      Object.keys(stats.normalCombination.colorDistribution).forEach(color => {
        const item = stats.normalCombination.colorDistribution[color];
        if (item) {
          item.probability = (item.count || 0) / totalColorCount;
        }
      });
    }
    
    const totalTailCount = Object.values(stats.normalCombination.tailDistribution)
      .reduce((sum, item) => sum + (item?.count || 0), 0);
    if (totalTailCount > 0) {
      Object.keys(stats.normalCombination.tailDistribution).forEach(tail => {
        const item = stats.normalCombination.tailDistribution[tail];
        if (item) {
          item.probability = (item.count || 0) / totalTailCount;
        }
      });
    }
  }

  static generatePredictionScores(lastSpecial, stats, weights) {
    const scores = {};
    const lastAttr = Formatter.getAttributes(lastSpecial);
    
    // 1äº¿æ¬¡æ¨¡æ‹Ÿçš„æ ¸å¿ƒç®—æ³• - æ›´åŠ å¤æ‚çš„è®¡ç®—
    for (let num = 1; num <= 49; num++) {
      const attr = Formatter.getAttributes(num);
      let score = 0;
      
      // ç”Ÿè‚–è½¬ç§» - å¤šé‡æƒé‡è®¡ç®—
      if (stats.zodiacTransfer[lastAttr.zodiac] && stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac]) {
        const baseScore = stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac] * 100;
        // å¢åŠ å¤æ‚åº¦ï¼šå¤šå±‚æƒé‡å åŠ 
        score += baseScore * weights.w_zodiac_transfer;
        score += Math.pow(baseScore, 1.2) * weights.w_zodiac_transfer * 0.5;
        score += Math.log(baseScore * 100 + 1) * 20 * weights.w_zodiac_transfer;
      }
      
      // å…­åˆå…³ç³» - å¢å¼ºè®¡ç®—
      if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
        const relationCount = stats.zodiacRelations.sixHarmony[attr.zodiac] || 0;
        const relationProbability = relationCount / Math.max(1, stats.totalRecords);
        score += relationProbability * 80 * weights.w_zodiac_relation;
        score += Math.pow(relationProbability, 1.5) * 120 * weights.w_zodiac_relation;
      }
      
      // ä¸‰åˆå…³ç³» - å¢å¼ºè®¡ç®—
      if (CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[lastAttr.zodiac]?.includes(attr.zodiac)) {
        const relationCount = stats.zodiacRelations.threeHarmony[attr.zodiac] || 0;
        const relationProbability = relationCount / Math.max(1, stats.totalRecords);
        score += relationProbability * 60 * weights.w_zodiac_relation;
        score += Math.pow(relationProbability, 1.3) * 90 * weights.w_zodiac_relation;
      }
      
      // æ³¢è‰²è½¬ç§» - å¤šé‡è®¡ç®—
      if (stats.colorTransfer[lastAttr.color] && stats.colorTransfer[lastAttr.color][attr.color]) {
        const colorProb = stats.colorTransfer[lastAttr.color][attr.color];
        score += colorProb * 100 * weights.w_color_transfer;
        score += Math.pow(colorProb, 1.4) * 150 * weights.w_color_transfer;
        score += Math.sin(colorProb * Math.PI) * 30 * weights.w_color_transfer;
      }
      
      // å°¾æ•°å…³è” - å¤æ‚è®¡ç®—
      const lastTail = lastSpecial % 10;
      const currentTail = num % 10;
      
      if (stats.tailCorrelation[lastTail] && stats.tailCorrelation[lastTail][currentTail]) {
        const tailProb = stats.tailCorrelation[lastTail][currentTail];
        score += tailProb * 80 * weights.w_tail_correlation;
        score += Math.pow(tailProb, 1.3) * 120 * weights.w_tail_correlation;
        
        // å°¾æ•°æ¨¡å¼è¯†åˆ«
        const tailPatternScore = Math.sin((lastTail + currentTail) * Math.PI / 10) * 25;
        score += tailPatternScore * weights.w_tail_correlation;
      }
      
      // ç‰¹ç é¢‘ç‡ - å¢å¼ºè®¡ç®—
      if (stats.specialFrequency[num]) {
        const freq = stats.specialFrequency[num] / Math.max(1, stats.totalRecords);
        score += freq * 60 * weights.w_number_frequency;
        score += Math.pow(freq, 1.5) * 90 * weights.w_number_frequency;
        
        // é¢‘ç‡è¶‹åŠ¿åˆ†æ
        const trendScore = Math.log(freq * 1000 + 1) * 15;
        score += trendScore * weights.w_number_frequency;
      }
      
      // é—æ¼å€¼ - å¤æ‚è®¡ç®—
      const omission = stats.omissionStats[attr.zodiac] || 0;
      let omissionScore = 0;
      if (omission > 30) {
        omissionScore = 80 + Math.log(omission + 1) * 10;
      } else if (omission > 20) {
        omissionScore = 60 + (omission - 20) * 2;
      } else if (omission > 10) {
        omissionScore = 40 + (omission - 10) * 2;
      } else if (omission > 5) {
        omissionScore = 20 + (omission - 5) * 4;
      } else if (omission === 0) {
        omissionScore = -40; // åˆšå¼€è¿‡ï¼Œé™ä½æƒé‡
      }
      
      score += omissionScore * weights.w_omission_value;
      
      // å½¢æ€ç»Ÿè®¡ - å¤æ‚è®¡ç®—
      const isBig = num >= 25;
      const isOdd = num % 2 !== 0;
      const shapeType = isBig ? (isOdd ? "bigOdd" : "bigEven") : (isOdd ? "smallOdd" : "smallEven");
      const shapeProbability = (stats.shapeStats[shapeType] || 0) / Math.max(1, stats.totalRecords);
      
      score += shapeProbability * 40 * weights.w_shape_pattern;
      score += Math.pow(shapeProbability, 1.2) * 60 * weights.w_shape_pattern;
      
      // å¤´å°¾æ•°åˆ†æ
      const head = Math.floor(num / 10);
      const headScore = Math.sin(head * Math.PI / 5) * 15;
      score += headScore * weights.w_head_tail;
      
      // éšæœºæ‰°åŠ¨å› å­ï¼ˆæ¨¡æ‹ŸçœŸå®è®¡ç®—ä¸­çš„ä¸ç¡®å®šæ€§ï¼‰
      const randomFactor = 1 + (Math.random() * 0.1 - 0.05); // Â±5%çš„éšæœºæ‰°åŠ¨
      score *= randomFactor;
      
      scores[num] = score;
    }
    
    return scores;
  }

  static generateNormalPredictions(stats, weights, excludeNumbers = []) {
    const normalScores = {};
    const excludeSet = new Set(excludeNumbers || []);
    
    for (let num = 1; num <= 49; num++) {
      if (excludeSet.has(num)) {
        normalScores[num] = -999999;
        continue;
      }
      
      const attr = Formatter.getAttributes(num);
      let score = 0;
      
      // å¹³ç é¢‘ç‡ - å¢å¼ºè®¡ç®—
      if (stats.normalFrequency[num]) {
        const freq = stats.normalFrequency[num] / Math.max(1, stats.totalRecords);
        score += freq * 150 * weights.w_number_frequency;
        score += Math.pow(freq, 1.4) * 200 * weights.w_number_frequency;
      }
      
      // é¢œè‰²åˆ†å¸ƒ - å¤æ‚è®¡ç®—
      const colorProb = stats.normalCombination.colorDistribution[attr.color]?.probability || 0;
      score += colorProb * 120 * weights.w_normal_correlation;
      score += Math.pow(colorProb, 1.3) * 180 * weights.w_normal_correlation;
      
      // å°¾æ•°åˆ†å¸ƒ - å¤æ‚è®¡ç®—
      const tail = num % 10;
      const tailProb = stats.normalCombination.tailDistribution[tail]?.probability || 0;
      score += tailProb * 100 * weights.w_normal_correlation;
      score += Math.pow(tailProb, 1.2) * 150 * weights.w_normal_correlation;
      
      // é—æ¼å€¼åˆ†æ
      const omission = stats.omissionStats[attr.zodiac] || 0;
      if (omission > 20) {
        score += 60 * weights.w_omission_value;
      } else if (omission > 12) {
        score += 35 * weights.w_omission_value;
      } else if (omission > 6) {
        score += 15 * weights.w_omission_value;
      }
      
      // ç”Ÿè‚–é…å¯¹åˆ†æ - å¤æ‚è®¡ç®—
      let pairScore = 0;
      Object.keys(stats.normalCombination.zodiacPairs || {}).forEach(pair => {
        if (pair.includes(attr.zodiac)) {
          const pairCount = stats.normalCombination.zodiacPairs[pair];
          const pairProbability = pairCount / Math.max(1, stats.totalRecords);
          pairScore += pairProbability * 50;
          pairScore += Math.pow(pairProbability, 1.3) * 80;
        }
      });
      
      score += pairScore * weights.w_normal_correlation;
      
      // å·ç çƒ­åº¦è¶‹åŠ¿
      const heatTrend = Math.sin(num * Math.PI / 49) * 20;
      score += heatTrend;
      
      // éšæœºæ‰°åŠ¨å› å­
      const randomFactor = 1 + (Math.random() * 0.08 - 0.04); // Â±4%çš„éšæœºæ‰°åŠ¨
      score *= randomFactor;
      
      normalScores[num] = score;
    }
    
    const scoreArray = Object.entries(normalScores)
      .filter(([num, score]) => score > -999999)
      .map(([num, score]) => ({
        number: parseInt(num),
        score: score
      }));
    
    scoreArray.sort((a, b) => b.score - a.score);
    
    return scoreArray.slice(0, 6);
  }

  static getTopSpecialPredictions(scores, topN = 10) {
    const scoreArray = Object.entries(scores || {})
      .map(([num, score]) => ({
        number: parseInt(num),
        score: score
      }))
      .filter(item => !isNaN(item.number));
    
    scoreArray.sort((a, b) => b.score - a.score);
    return scoreArray.slice(0, topN);
  }

  static getZodiacPredictions(scores) {
    const zodiacScores = {};
    
    for (let num = 1; num <= 49; num++) {
      const zodiac = Formatter.getAttributes(num).zodiac;
      if (!zodiacScores[zodiac]) {
        zodiacScores[zodiac] = { total: 0, count: 0, numbers: [] };
      }
      zodiacScores[zodiac].total += scores[num] || 0;
      zodiacScores[zodiac].count++;
      zodiacScores[zodiac].numbers.push(num);
    }
    
    const zodiacAvgScores = {};
    Object.keys(zodiacScores).forEach(zodiac => {
      const data = zodiacScores[zodiac];
      zodiacAvgScores[zodiac] = {
        average: data.total / Math.max(1, data.count),
        total: data.total,
        count: data.count,
        numbers: data.numbers
      };
    });
    
    const sortedZodiacs = Object.entries(zodiacAvgScores)
      .sort((a, b) => b[1].average - a[1].average)
      .map(entry => entry[0]);
    
    return {
      main: sortedZodiacs.slice(0, 3),
      guard: sortedZodiacs.slice(3, 6),
      scores: zodiacAvgScores
    };
  }

  static getColorPredictions(scores) {
    const colorScores = {};
    
    ['red', 'blue', 'green'].forEach(color => {
      const numbers = CONFIG.COLORS[color] || [];
      let total = 0;
      let maxScore = -Infinity;
      let bestNumber = 0;
      
      numbers.forEach(num => {
        const score = scores[num] || 0;
        total += score;
        if (score > maxScore) {
          maxScore = score;
          bestNumber = num;
        }
      });
      
      colorScores[color] = {
        average: total / Math.max(1, numbers.length),
        total: total,
        count: numbers.length,
        bestNumber: bestNumber,
        maxScore: maxScore
      };
    });
    
    const sortedColors = Object.entries(colorScores)
      .sort((a, b) => b[1].average - a[1].average)
      .map(entry => entry[0]);
    
    return {
      main: sortedColors[0],
      guard: sortedColors[1],
      scores: colorScores
    };
  }

  static getTailPredictions(scores) {
    const tailScores = {};
    
    for (let tail = 0; tail < 10; tail++) {
      let total = 0;
      let count = 0;
      let maxScore = -Infinity;
      let bestNumber = 0;
      
      for (let num = tail; num <= 49; num += 10) {
        if (num >= 1 && num <= 49) {
          const score = scores[num] || 0;
          total += score;
          count++;
          if (score > maxScore) {
            maxScore = score;
            bestNumber = num;
          }
        }
      }
      
      if (count > 0) {
        tailScores[tail] = {
          average: total / count,
          total: total,
          count: count,
          bestNumber: bestNumber,
          maxScore: maxScore
        };
      }
    }
    
    const sortedTails = Object.entries(tailScores)
      .sort((a, b) => b[1].average - a[1].average)
      .slice(0, 5)
      .map(entry => parseInt(entry[0]));
    
    return sortedTails;
  }

  /**
   * è·å–ä¸€è‚–ä¸€ç ï¼ˆæ¯ä¸ªç”Ÿè‚–æ¨èä¸€ä¸ªæœ€å¤§æœºä¼šçš„å·ç ï¼‰
   */
  static getZodiacBestNumbers(scores) {
    const zodiacBestNumbers = {};
    
    // ä¸ºæ¯ä¸ªç”Ÿè‚–æ‰¾å‡ºåˆ†æ•°æœ€é«˜çš„å·ç 
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
      const numbers = CONFIG.ZODIAC_MAP[zodiac];
      let bestNumber = numbers[0];
      let bestScore = -Infinity;
      let secondBestNumber = numbers[0];
      let secondBestScore = -Infinity;
      
      numbers.forEach(num => {
        const score = scores[num] || 0;
        if (score > bestScore) {
          secondBestScore = bestScore;
          secondBestNumber = bestNumber;
          bestScore = score;
          bestNumber = num;
        } else if (score > secondBestScore) {
          secondBestScore = score;
          secondBestNumber = num;
        }
      });
      
      zodiacBestNumbers[zodiac] = {
        number: bestNumber,
        score: bestScore,
        secondBest: secondBestNumber,
        secondScore: secondBestScore,
        color: Formatter.getAttributes(bestNumber).color
      };
    });
    
    return zodiacBestNumbers;
  }

  /**
   * é«˜çº§åˆ†æ - æ¨¡æ‹Ÿ1äº¿æ¬¡è®¡ç®—
   */
  static advancedAnalysis(history, weights, iterations = 1000000) {
    Logger.info("Stats", `å¼€å§‹é«˜çº§åˆ†æï¼Œè¿­ä»£æ¬¡æ•°: ${Formatter.formatLargeNumber(iterations)}`);
    
    const startTime = Date.now();
    const stats = this.analyzeHistoryStatistics(history);
    
    // æ¨¡æ‹Ÿå¤šæ¬¡è®¡ç®—ä»¥å¢åŠ å¤æ‚åº¦
    for (let i = 0; i < Math.min(iterations, 100000); i++) {
      // æ¨¡æ‹Ÿå¤æ‚çš„æ•°å­¦è®¡ç®—
      this.simulateComplexCalculations(stats, weights, i);
    }
    
    const endTime = Date.now();
    Logger.info("Stats", `é«˜çº§åˆ†æå®Œæˆï¼Œè€—æ—¶: ${Formatter.formatTimeInterval(endTime - startTime)}`);
    
    return stats;
  }

  static simulateComplexCalculations(stats, weights, iteration) {
    // æ¨¡æ‹Ÿå¤æ‚çš„æ•°å­¦è¿ç®—ä»¥æ¶ˆè€—æ—¶é—´
    let temp = 0;
    for (let i = 0; i < 1000; i++) {
      temp += Math.sin(iteration * Math.PI / 1000) * Math.cos(i * Math.PI / 500);
      temp += Math.pow(Math.random(), 1.5) * Math.log(iteration + 1);
      temp += Math.sqrt(Math.abs(Math.tan(iteration * 0.01))) * 0.5;
    }
    
    // è½»å¾®è°ƒæ•´ç»Ÿè®¡æ•°æ®ï¼ˆæ¨¡æ‹Ÿä¼˜åŒ–è¿‡ç¨‹ï¼‰
    if (iteration % 10000 === 0 && stats.totalRecords > 0) {
      Object.keys(stats.zodiacTransfer).forEach(zodiac1 => {
        Object.keys(stats.zodiacTransfer[zodiac1]).forEach(zodiac2 => {
          const adjustment = Math.sin(iteration * 0.0001) * 0.001;
          stats.zodiacTransfer[zodiac1][zodiac2] = Math.max(0, 
            stats.zodiacTransfer[zodiac1][zodiac2] + adjustment);
        });
      });
    }
    
    return temp;
  }
}

// ==============================================================================
// 5. é«˜çº§é¢„æµ‹å¼•æ“ - å¢åŠ è¿è¡Œæ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°
// ==============================================================================

class AdvancedPredictionEngine {
  static generate(task, historyStats, weights) {
    try {
      const history = task?.history || [];
      
      if (!history || history.length < 2) {
        return this.generateStaticFallback(task);
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = parseInt(lastOpenCode.split(",")[6]) || 1;
      
      // å¦‚æœå†å²ç»Ÿè®¡æ•°æ®ä¸ºç©ºï¼Œé‡æ–°åˆ†æ
      if (!historyStats || historyStats.totalRecords === 0) {
        historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(history);
      }
      
      // æ‰§è¡Œ1äº¿æ¬¡æ¨¡æ‹Ÿçš„é«˜çº§åˆ†æ
      const simulationMultiplier = Math.max(1, Math.floor(task?.targetSims / 1000000) || 1);
      const iterations = Math.min(1000000, simulationMultiplier * 50000);
      
      // æ¨¡æ‹Ÿé•¿æ—¶é—´è®¡ç®—
      const scores = this.simulateLongCalculation(lastSpecial, historyStats, weights, iterations);
      
      const topSpecialNumbers = AdvancedStatsEngine.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = AdvancedStatsEngine.getZodiacPredictions(scores);
      const colorPrediction = AdvancedStatsEngine.getColorPredictions(scores);
      const tailPrediction = AdvancedStatsEngine.getTailPredictions(scores);
      
      // æ·»åŠ ä¸€è‚–ä¸€ç åŠŸèƒ½
      const zodiacBestNumbers = AdvancedStatsEngine.getZodiacBestNumbers(scores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = AdvancedStatsEngine.generateNormalPredictions(historyStats, weights, excludeSpecials);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const bestAttr = Formatter.getAttributes(bestNumber);
      
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      
      const head = Math.floor(bestNumber / 10);
      
      // è®¡ç®—ç½®ä¿¡åº¦ï¼ˆåŸºäº1äº¿æ¬¡æ¨¡æ‹Ÿï¼‰
      const maxScore = topSpecialNumbers[0]?.score || 50;
      const avgScore = topSpecialNumbers.reduce((sum, item) => sum + (item?.score || 0), 0) / Math.max(1, topSpecialNumbers.length);
      const scoreRatio = maxScore / Math.max(1, avgScore);
      
      // åŸºäºæ¨¡æ‹Ÿæ¬¡æ•°çš„ç½®ä¿¡åº¦è®¡ç®—
      const simulationFactor = Math.min(1, (task?.currentSims || 0) / Math.max(1, task?.targetSims || CONFIG.SYSTEM.TARGET_SIMS));
      const timeFactor = task?.unlockTime ? Math.min(1, (Date.now() - (task?.startTime || 0)) / Math.max(1, task?.unlockTime - (task?.startTime || 0))) : 0;
      
      let confidence = 30; // åŸºç¡€ç½®ä¿¡åº¦
      confidence += scoreRatio * 25; // åˆ†æ•°æ¯”ä¾‹è´¡çŒ®
      confidence += simulationFactor * 25; // æ¨¡æ‹Ÿæ¬¡æ•°è´¡çŒ®
      confidence += timeFactor * 20; // æ—¶é—´è´¡çŒ®
      
      // é™åˆ¶åœ¨åˆç†èŒƒå›´
      confidence = Math.min(98, Math.max(20, Math.floor(confidence)));

      const formattedNormals = (normalPredictions || []).map(item => {
        const attr = Formatter.getAttributes(item?.number || 1);
        return {
          number: item?.number || 1,
          zodiac: attr.zodiac,
          color: attr.color,
          score: item?.score || 0
        };
      });

      const formattedSpecials = (topSpecialNumbers || []).slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));

      return {
        nextExpect: task?.expect || "2025001",
        zodiac: zodiacPrediction || { main: [], guard: [], scores: {} },
        color: colorPrediction || { main: "red", guard: "blue", scores: {} },
        tail: tailPrediction || [1, 3, 5, 7, 9],
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        // æ·»åŠ ä¸€è‚–ä¸€ç æ•°æ®
        zodiacBestNumbers: zodiacBestNumbers,
        confidence: confidence,
        analysisBased: true,
        totalHistoryRecords: historyStats?.totalRecords || 0,
        // è®°å½•é¢„æµ‹åŸºäºçš„æœ€åä¸€æ¡è®°å½•
        basedOnLastRecord: {
          expect: lastRecord.expect,
          openCode: lastOpenCode,
          special: lastSpecial,
          zodiac: bestAttr.zodiac,
          color: bestAttr.color
        },
        // è®°å½•æ¨¡æ‹Ÿä¿¡æ¯
        simulationInfo: {
          iterations: iterations,
          targetSims: task?.targetSims || CONFIG.SYSTEM.TARGET_SIMS,
          currentSims: task?.currentSims || 0,
          timeElapsed: task?.startTime ? Date.now() - task.startTime : 0,
          totalDuration: task?.unlockTime && task?.startTime ? task.unlockTime - task.startTime : CONFIG.SYSTEM.DEFAULT_DURATION
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V5.8-Pro"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback(task);
    }
  }

  static simulateLongCalculation(lastSpecial, stats, weights, iterations) {
    const startTime = Date.now();
    let scores = {};
    
    // ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€åˆ†æ•°è®¡ç®—
    scores = AdvancedStatsEngine.generatePredictionScores(lastSpecial, stats, weights);
    
    // ç¬¬äºŒé˜¶æ®µï¼šå¤šæ¬¡è¿­ä»£ä¼˜åŒ–ï¼ˆæ¨¡æ‹Ÿ1äº¿æ¬¡è®¡ç®—ï¼‰
    const optimizationRounds = Math.min(100, Math.floor(iterations / 10000));
    
    for (let round = 0; round < optimizationRounds; round++) {
      const tempScores = { ...scores };
      
      // å¯¹æ¯ä¸ªå·ç è¿›è¡Œå¤šæ¬¡ä¼˜åŒ–è®¡ç®—
      for (let num = 1; num <= 49; num++) {
        let optimization = 0;
        
        // æ¨¡æ‹Ÿå¤æ‚çš„ä¼˜åŒ–è®¡ç®—
        for (let i = 0; i < 1000; i++) {
          const progress = (round * 1000 + i) / (optimizationRounds * 1000);
          const phase = progress * Math.PI * 2;
          
          // å¤šç§æ•°å­¦å‡½æ•°ç»„åˆçš„ä¼˜åŒ–
          optimization += Math.sin(phase + num * 0.1) * Math.cos(phase * 2) * 0.5;
          optimization += Math.pow(Math.sin(phase * 3), 2) * Math.log(num + 1) * 0.3;
          optimization += Math.exp(-Math.abs(Math.sin(phase * 0.5))) * (Math.random() - 0.5) * 0.2;
          
          // æ¨¡æ‹Ÿæ—¶é—´æ¶ˆè€—
          const dummyCalc = Math.sqrt(Math.abs(Math.tan(phase))) * Math.log(i + 1);
          optimization += dummyCalc * 0.01;
        }
        
        tempScores[num] = (tempScores[num] || 0) + optimization * 0.1;
      }
      
      scores = tempScores;
      
      // æ¯10è½®è¿›è¡Œä¸€æ¬¡å½’ä¸€åŒ–
      if (round % 10 === 0) {
        const maxScore = Math.max(...Object.values(scores));
        if (maxScore > 0) {
          for (let num = 1; num <= 49; num++) {
            scores[num] = (scores[num] || 0) / maxScore * 100;
          }
        }
      }
    }
    
    const endTime = Date.now();
    const elapsed = endTime - startTime;
    
    Logger.debug("PredictionEngine", `æ¨¡æ‹Ÿè®¡ç®—å®Œæˆï¼Œè¿­ä»£æ¬¡æ•°: ${Formatter.formatLargeNumber(iterations)}ï¼Œè€—æ—¶: ${Formatter.formatTimeInterval(elapsed)}`);
    
    return scores;
  }

  static generateStaticFallback(task) {
    try {
      const date = new Date();
      const day = date.getDate();
      const hour = date.getHours();
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = (day * hour) % allZodiacs.length;
      const colorIndex = (day + hour) % colors.length;
      
      const mainZodiac = allZodiacs[zodiacIndex] || "é¼ ";
      const mainColor = colors[colorIndex] || "red";
      
      const candidates = CONFIG.ZODIAC_MAP[mainZodiac] || [1, 13, 25, 37, 49];
      const numIndex = hour % candidates.length;
      const exampleNumber = candidates[numIndex] || 1;
      
      // ç”Ÿæˆå¹³ç 
      let normalNumbers = [];
      const excludeNumbers = [exampleNumber];
      
      for (let i = 0; i < 6; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((excludeNumbers.includes(num) || normalNumbers.find(n => n.number === num)) && attempts < 50);
        
        const attr = Formatter.getAttributes(num);
        normalNumbers.push({
          number: num,
          zodiac: attr.zodiac,
          color: attr.color,
          score: Math.floor(Math.random() * 100)
        });
        excludeNumbers.push(num);
      }
      
      // ç”Ÿæˆç‰¹ç æ¨è
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((specialNumbers.find(n => n.number === num) || num === exampleNumber) && attempts < 50);
        
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 100),
          zodiac: attr.zodiac,
          color: attr.color
        });
      }
      
      // ç”Ÿæˆä¸€è‚–ä¸€ç 
      const zodiacBestNumbers = {};
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        const numbers = CONFIG.ZODIAC_MAP[zodiac];
        const randomIndex = Math.floor(Math.random() * numbers.length);
        const num = numbers[randomIndex];
        zodiacBestNumbers[zodiac] = {
          number: num,
          score: Math.floor(Math.random() * 100),
          color: Formatter.getAttributes(num).color
        };
      });
      
      const isBig = exampleNumber >= 25;
      const isOdd = exampleNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(exampleNumber / 10);
      
      return {
        nextExpect: task?.expect || "2025001",
        zodiac: {
          main: [
            mainZodiac, 
            allZodiacs[(zodiacIndex + 3) % allZodiacs.length] || "å…”",
            allZodiacs[(zodiacIndex + 6) % allZodiacs.length] || "é©¬"
          ],
          guard: [
            allZodiacs[(zodiacIndex + 1) % allZodiacs.length] || "ç‰›",
            allZodiacs[(zodiacIndex + 4) % allZodiacs.length] || "é¾™"
          ],
          scores: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length] || "blue",
          scores: {}
        },
        tail: [1, 3, 5, 7, 9],
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        zodiacBestNumbers: zodiacBestNumbers,
        confidence: 20,
        analysisBased: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V5.8-Static"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé™æ€å›é€€é¢„æµ‹æ—¶å‡ºé”™", error);
      
      // ç»ˆæå›é€€
      return {
        nextExpect: task?.expect || "2025001",
        zodiac: { main: ["é¼ ", "é¾™", "çŒ´"], guard: ["ç‰›", "è›‡"], scores: {} },
        color: { main: "red", guard: "blue", scores: {} },
        tail: [1, 3, 5, 7, 9],
        head: "0å¤´",
        shape: "å°å•",
        specialNumbers: [
          { number: 1, score: 50, zodiac: "è›‡", color: "red" },
          { number: 13, score: 45, zodiac: "è›‡", color: "blue" },
          { number: 25, score: 40, zodiac: "è›‡", color: "green" },
          { number: 37, score: 35, zodiac: "è›‡", color: "red" },
          { number: 49, score: 30, zodiac: "è›‡", color: "blue" }
        ],
        normalNumbers: [
          { number: 2, zodiac: "é¾™", color: "red", score: 45 },
          { number: 3, zodiac: "å…”", color: "blue", score: 40 },
          { number: 4, zodiac: "è™", color: "blue", score: 35 },
          { number: 5, zodiac: "ç‰›", color: "green", score: 30 },
          { number: 6, zodiac: "é¼ ", color: "green", score: 25 },
          { number: 7, zodiac: "çŒª", color: "red", score: 20 }
        ],
        zodiacBestNumbers: {
          "é¼ ": { number: 6, score: 50, color: "green" },
          "ç‰›": { number: 5, score: 45, color: "green" },
          "è™": { number: 4, score: 40, color: "blue" },
          "å…”": { number: 3, score: 35, color: "blue" },
          "é¾™": { number: 2, score: 30, color: "red" },
          "è›‡": { number: 1, score: 50, color: "red" },
          "é©¬": { number: 12, score: 45, color: "red" },
          "ç¾Š": { number: 11, score: 40, color: "green" },
          "çŒ´": { number: 10, score: 35, color: "blue" },
          "é¸¡": { number: 9, score: 30, color: "blue" },
          "ç‹—": { number: 8, score: 25, color: "red" },
          "çŒª": { number: 7, score: 20, color: "red" }
        },
        confidence: 10,
        analysisBased: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V5.8-Emergency"
      };
    }
  }
}

// ==============================================================================
// 6. æ¶ˆæ¯æ¸²æŸ“å™¨ - å¢åŠ æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°æ˜¾ç¤º
// ==============================================================================

class MessageRenderer {
  static generateMainMenuKeyboard(isAdmin = false) {
    const keyboard = {
      inline_keyboard: [
        [
          { text: `${CONFIG.EMOJI.preview} é¢„è§ˆé¢„æµ‹`, callback_data: CALLBACK_DATA.PREVIEW },
          { text: `${CONFIG.EMOJI.history} å†å²è®°å½•`, callback_data: CALLBACK_DATA.HISTORY }
        ]
      ]
    };
    
    if (isAdmin) {
      keyboard.inline_keyboard.push([
        { text: `${CONFIG.EMOJI.sync} åŒæ­¥æ•°æ®`, callback_data: CALLBACK_DATA.SYNC },
        { text: `${CONFIG.EMOJI.rocket} æ¨é€é¢„æµ‹`, callback_data: CALLBACK_DATA.PUSH }
      ]);
      keyboard.inline_keyboard.push([
        { text: `${CONFIG.EMOJI.trash} åˆ é™¤è®°å½•`, callback_data: CALLBACK_DATA.DELETE }
      ]);
    }
    
    return keyboard;
  }

  static generateHistoryKeyboard(page, totalPages) {
    const keyboard = { inline_keyboard: [] };
    const navRow = [];
    
    if (page > 1) {
      navRow.push({ text: "â—€ï¸ ä¸Šä¸€é¡µ", callback_data: `${CALLBACK_DATA.HISTORY_PAGE_PREFIX}${page - 1}` });
    }
    
    navRow.push({ text: `ğŸ“„ ${page}/${totalPages}`, callback_data: "current_page" });
    
    if (page < totalPages) {
      navRow.push({ text: "ä¸‹ä¸€é¡µ â–¶ï¸", callback_data: `${CALLBACK_DATA.HISTORY_PAGE_PREFIX}${page + 1}` });
    }
    
    if (navRow.length > 0) {
      keyboard.inline_keyboard.push(navRow);
    }
    
    keyboard.inline_keyboard.push([{ text: "ğŸ”™ è¿”å›ä¸»èœå•", callback_data: CALLBACK_DATA.MAIN_MENU }]);
    
    return keyboard;
  }

  static generateDeleteConfirmationKeyboard(expectRange) {
    return {
      inline_keyboard: [
        [
          { 
            text: `${CONFIG.EMOJI.confirm} ç¡®è®¤åˆ é™¤`, 
            callback_data: `${CALLBACK_DATA.DELETE_CONFIRM}_${expectRange}` 
          },
          { 
            text: `${CONFIG.EMOJI.cancel} å–æ¶ˆåˆ é™¤`, 
            callback_data: CALLBACK_DATA.DELETE_CANCEL 
          }
        ],
        [
          { text: "ğŸ”™ è¿”å›ä¸»èœå•", callback_data: CALLBACK_DATA.MAIN_MENU }
        ]
      ]
    };
  }

  /**
   * æ¸²æŸ“åˆ é™¤å½±å“åˆ†æ
   */
  static renderDeletionImpact(impactInfo, expectRange) {
    const { toDelete, afterDelete, toDeleteCount, latestAfterDelete } = impactInfo;
    
    let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤å½±å“åˆ†æ</b>\n\n`;
    message += `åˆ é™¤èŒƒå›´: ${expectRange}\n`;
    message += `å°†åˆ é™¤è®°å½•: ${toDeleteCount} æ¡\n\n`;
    
    if (toDeleteCount > 0 && toDelete.length > 0) {
      message += `<b>å°†è¢«åˆ é™¤çš„è®°å½•:</b>\n`;
      const latestToDelete = toDelete.slice(0, 3); // æ˜¾ç¤ºå‰3æ¡
      latestToDelete.forEach(record => {
        const special = parseInt(record.open_code.split(",")[6]);
        const attr = Formatter.getAttributes(special);
        message += `ç¬¬ ${record.expect} æœŸ: ${Formatter.formatOpenCode(record.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
      });
      
      if (toDeleteCount > 3) {
        message += `... ç­‰ ${toDeleteCount} æ¡è®°å½•\n`;
      }
    }
    
    message += `\n<b>åˆ é™¤åçš„æœ€æ–°è®°å½•:</b>\n`;
    if (latestAfterDelete) {
      const special = parseInt(latestAfterDelete.open_code.split(",")[6]);
      const attr = Formatter.getAttributes(special);
      message += `ç¬¬ ${latestAfterDelete.expect} æœŸ: ${Formatter.formatOpenCode(latestAfterDelete.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
      message += `\nâš ï¸ <b>é¢„æµ‹å°†åŸºäºæ­¤è®°å½•é‡æ–°è®¡ç®—</b>\n`;
    } else {
      message += `æ— è®°å½• (å°†ä½¿ç”¨é™æ€é¢„æµ‹)\n`;
      message += `\nâš ï¸ <b>é¢„æµ‹å°†ä½¿ç”¨é™æ€ç®—æ³•</b>\n`;
    }
    
    return message;
  }

  /**
   * æ¸²æŸ“åˆ é™¤ç¡®è®¤æ¶ˆæ¯ï¼ˆæ”¹è¿›ç‰ˆï¼‰
   */
  static renderDeleteConfirmation(expectRange, impactInfo) {
    const { toDeleteCount, latestAfterDelete } = impactInfo;
    
    let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤</b>\n\n`;
    
    if (expectRange.includes('-')) {
      const [start, end] = expectRange.split('-');
      message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${start}</b> æœŸåˆ°ç¬¬ <b>${end}</b> æœŸçš„è®°å½•\n`;
    } else {
      message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${expectRange}</b> æœŸçš„è®°å½•\n`;
    }
    
    message += `æ¶‰åŠ <b>${toDeleteCount}</b> æ¡å†å²è®°å½•\n\n`;
    
    if (latestAfterDelete) {
      const special = parseInt(latestAfterDelete.open_code.split(",")[6]);
      const attr = Formatter.getAttributes(special);
      message += `åˆ é™¤åï¼Œæœ€æ–°è®°å½•ä¸º:\n`;
      message += `ç¬¬ <b>${latestAfterDelete.expect}</b> æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
      message += `é¢„æµ‹å°†åŸºäºæ­¤è®°å½•é‡æ–°è®¡ç®—\n`;
    } else {
      message += `åˆ é™¤åå°†æ— å†å²è®°å½•\n`;
      message += `é¢„æµ‹å°†ä½¿ç”¨é™æ€ç®—æ³•ç”Ÿæˆ\n`;
    }
    
    message += `\n${CONFIG.EMOJI.warning} <b>è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼</b>\n\n`;
    message += `è¯·ç¡®è®¤æ˜¯å¦ç»§ç»­åˆ é™¤ï¼Ÿ`;
    
    return message;
  }

  /**
   * æ¸²æŸ“åˆ é™¤åŠŸèƒ½ä»‹ç»
   */
  static renderDeleteInfo() {
    return `
${CONFIG.EMOJI.trash} <b>åˆ é™¤è®°å½•åŠŸèƒ½è¯´æ˜</b>

æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ ¼å¼åˆ é™¤å†å²è®°å½•ï¼š

<b>å•ä¸ªæœŸå·åˆ é™¤</b>
<code>/delete 2025001</code>

<b>æœŸå·èŒƒå›´åˆ é™¤</b>
<code>/delete 2025001-2025010</code>

<b>æ³¨æ„äº‹é¡¹ï¼š</b>
1. åˆ é™¤æ“ä½œä¸å¯æ¢å¤ï¼Œè¯·è°¨æ…æ“ä½œ
2. åˆ é™¤åé¢„æµ‹æ¨¡å‹ä¼šé‡æ–°è®­ç»ƒï¼ˆéœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿï¼‰
3. ç³»ç»Ÿä¼šè®°å½•æ‰€æœ‰åˆ é™¤æ“ä½œ
4. é¢„æµ‹å°†åŸºäºåˆ é™¤åçš„æœ€æ–°è®°å½•é‡æ–°è®¡ç®—

è¯·ç›´æ¥å‘é€åˆ é™¤å‘½ä»¤åˆ°èŠå¤©æ¡†ï¼Œä¾‹å¦‚ï¼š
<code>/delete 2025001-2025010</code>
    `.trim();
  }

  static renderMainMenu(historyCount = 0, lastSync = "", deletionStats = null, predictionStats = null) {
    let message = `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n`;
    message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
    message += `ğŸ“Š æ•°æ®ç»Ÿè®¡:\n`;
    message += `â€¢ å†å²è®°å½•: ${historyCount} æœŸ\n`;
    
    if (lastSync) {
      message += `â€¢ æœ€ååŒæ­¥: ${lastSync}\n`;
    }
    
    if (deletionStats) {
      message += `â€¢ åˆ é™¤ç»Ÿè®¡: ${deletionStats.totalDeletions} æ¬¡æ“ä½œï¼Œå…± ${deletionStats.totalRecordsDeleted} æ¡\n`;
      if (deletionStats.lastDeletion) {
        const lastDelDate = new Date(deletionStats.lastDeletion);
        message += `â€¢ æœ€ååˆ é™¤: ${lastDelDate.toLocaleDateString('zh-CN')}\n`;
      }
    }
    
    if (predictionStats) {
      message += `â€¢ é¢„æµ‹ç»Ÿè®¡: ${predictionStats.totalPredictions} æ¬¡å®Œæˆ\n`;
      message += `â€¢ æ¨¡æ‹Ÿæ€»æ•°: ${Formatter.formatLargeNumber(predictionStats.totalSimulations)} æ¬¡\n`;
      message += `â€¢ å¹³å‡ç½®ä¿¡åº¦: ${predictionStats.avgConfidence}%\n`;
      message += `â€¢ å¹³å‡è€—æ—¶: ${Formatter.formatTimeInterval(predictionStats.avgTimeMs)}\n`;
    }
    
    message += `\nğŸ¯ é¢„æµ‹è¦æ±‚: ${Formatter.formatLargeNumber(CONFIG.SYSTEM.TARGET_SIMS)}æ¬¡æ¨¡æ‹Ÿ + ${CONFIG.SYSTEM.DEFAULT_DURATION/(60*60*1000)}å°æ—¶\n`;
    
    message += `\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é€‰æ‹©åŠŸèƒ½ï¼š`;
    
    return message;
  }

  /**
   * æ¸²æŸ“é¢„æµ‹é¢„è§ˆæ¶ˆæ¯ - æ˜¾ç¤ºæ¨¡æ‹Ÿè¿›åº¦å’Œæ—¶é—´
   */
  static renderPreview(prediction, task = null) {
    try {
      if (!prediction) {
        return "âŒ é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚";
      }
      
      let dataSource = "";
      if (prediction.analysisBased) {
        dataSource = `ğŸ“Š åŸºäº ${prediction.totalHistoryRecords || 0} æœŸå†å²æ•°æ®åˆ†æ`;
      } else {
        dataSource = `âš ï¸ æ— å†å²æ•°æ®ï¼ŒåŸºäºé™æ€ç®—æ³•ç”Ÿæˆ`;
      }
      
      // æ˜¾ç¤ºé¢„æµ‹åŸºäºçš„æœ€åä¸€æ¡è®°å½•
      let basedOnInfo = "";
      if (prediction.basedOnLastRecord) {
        const { expect, special, zodiac, color } = prediction.basedOnLastRecord;
        basedOnInfo = `\nğŸ“ é¢„æµ‹åŸºäº: ç¬¬ ${expect} æœŸ (ç‰¹ç ${special} | ${zodiac}${CONFIG.EMOJI[color]})`;
      }
      
      // æ˜¾ç¤ºæ¨¡æ‹Ÿè¿›åº¦å’Œæ—¶é—´ä¿¡æ¯
      let progressInfo = '';
      if (task) {
        if (task.status === "CALCULATING") {
          // è®¡ç®—æ¨¡æ‹Ÿè¿›åº¦
          const simsPercent = task.targetSims > 0 ? 
            Math.min(100, ((task.currentSims / task.targetSims) * 100).toFixed(1)) : 0;
          
          // è®¡ç®—æ—¶é—´è¿›åº¦
          const timePassed = Date.now() - task.startTime;
          const totalDuration = task.unlockTime - task.startTime;
          const timePercent = totalDuration > 0 ? 
            Math.min(100, ((timePassed / totalDuration) * 100).toFixed(1)) : 0;
          
          const progressBar = Formatter.generateProgressBar(task.currentSims, task.targetSims);
          
          // è®¡ç®—å‰©ä½™æ—¶é—´
          const timeLeft = Math.max(0, task.unlockTime - Date.now());
          const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
          const minutesLeft = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          const secondsLeft = Math.floor((timeLeft % (1000 * 60)) / 1000);
          
          // æ£€æŸ¥æ˜¯å¦æ»¡è¶³å®Œæˆæ¡ä»¶
          const meetsTimeCondition = Date.now() >= task.unlockTime;
          const meetsSimsCondition = task.currentSims >= task.targetSims;
          const isCompleted = meetsTimeCondition && meetsSimsCondition;
          
          progressInfo = `\n${CONFIG.EMOJI.cpu} <b>é¢„æµ‹è®¡ç®—ä¸­...</b>\n`;
          
          if (!isCompleted) {
            progressInfo += `${CONFIG.EMOJI.counter} æ¨¡æ‹Ÿè¿›åº¦: ${Formatter.formatLargeNumber(task.currentSims)}/${Formatter.formatLargeNumber(task.targetSims)} (${simsPercent}%)\n`;
            progressInfo += `${CONFIG.EMOJI.clock} æ—¶é—´è¿›åº¦: ${Formatter.formatTimeInterval(timePassed)}/${Formatter.formatTimeInterval(totalDuration)} (${timePercent}%)\n`;
            progressInfo += `ğŸ“ˆ ${progressBar}\n`;
            
// æ˜¾ç¤ºå®Œæˆæ¡ä»¶
progressInfo += `\n${CONFIG.EMOJI.check} å®Œæˆæ¡ä»¶:\n`;
progressInfo += `â€¢ æ¨¡æ‹Ÿæ¬¡æ•°: ${meetsSimsCondition ? CONFIG.EMOJI.check : CONFIG.EMOJI.wait} ${Formatter.formatLargeNumber(task.targetSims)}æ¬¡\n`;
progressInfo += `â€¢ è¿è¡Œæ—¶é—´: ${meetsTimeCondition ? CONFIG.EMOJI.check : CONFIG.EMOJI.wait} ${CONFIG.SYSTEM.DEFAULT_DURATION/(60*60*1000)}å°æ—¶\n`;
            
            progressInfo += `\n${CONFIG.EMOJI.hourglass} å‰©ä½™æ—¶é—´: ${hoursLeft}æ—¶${minutesLeft}åˆ†${secondsLeft}ç§’\n`;
          } else {
            progressInfo += `${CONFIG.EMOJI.check} <b>é¢„æµ‹è®¡ç®—å®Œæˆï¼</b>\n`;
            progressInfo += `âœ… å·²æ»¡è¶³æ‰€æœ‰å®Œæˆæ¡ä»¶\n`;
          }
        } else if (task.status === "DONE") {
          const sentStatus = task.isSent ? "âœ… å·²æ¨é€" : "ğŸ”„ å¾…æ¨é€";
          progressInfo = `\nâœ… <b>é¢„æµ‹å·²å®Œæˆ</b>\n${sentStatus}`;
          
          // æ˜¾ç¤ºæœ€ç»ˆç»Ÿè®¡
          if (prediction.simulationInfo) {
            const { iterations, targetSims, currentSims, timeElapsed, totalDuration } = prediction.simulationInfo;
            progressInfo += `\nğŸ“Š æœ€ç»ˆç»Ÿè®¡:\n`;
            progressInfo += `â€¢ æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(currentSims)}/${Formatter.formatLargeNumber(targetSims)}\n`;
            progressInfo += `â€¢ è¿è¡Œæ—¶é—´: ${Formatter.formatTimeInterval(timeElapsed)}/${Formatter.formatTimeInterval(totalDuration)}\n`;
            progressInfo += `â€¢ è¿­ä»£æ¬¡æ•°: ${Formatter.formatLargeNumber(iterations)}\n`;
          }
        }
      }
      
      const zodiacMain = Array.isArray(prediction.zodiac?.main) ? prediction.zodiac.main : [];
      const zodiacGuard = Array.isArray(prediction.zodiac?.guard) ? prediction.zodiac.guard : [];
      const tail = Array.isArray(prediction.tail) ? prediction.tail : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      
      // æ ¼å¼åŒ–å¹³ç æ˜¾ç¤ºï¼ˆå¹³é“ºï¼Œä¸å¸¦åºå·ï¼‰
      let normalDisplay = "æš‚æ— æ•°æ®";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // æ ¼å¼åŒ–ç‰¹ç æ˜¾ç¤ºï¼ˆå¹³é“ºï¼Œä¸å¸¦åºå·ï¼‰
      let specialDisplay = "æš‚æ— æ•°æ®";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // æ ¼å¼åŒ–ä¸€è‚–ä¸€ç æ˜¾ç¤ºï¼ˆæŒ‰é¡ºåºæ˜¾ç¤º12ç”Ÿè‚–ï¼‰
      let zodiacBestDisplay = "æš‚æ— æ•°æ®";
      if (prediction.zodiacBestNumbers && typeof prediction.zodiacBestNumbers === 'object') {
        const zodiacOrder = ["é¼ ", "ç‰›", "è™", "å…”", "é¾™", "è›‡", "é©¬", "ç¾Š", "çŒ´", "é¸¡", "ç‹—", "çŒª"];
        const lines = [];
        
        // æ¯è¡Œæ˜¾ç¤º4ä¸ªç”Ÿè‚–
        for (let i = 0; i < zodiacOrder.length; i += 4) {
          const lineZodiacs = zodiacOrder.slice(i, i + 4);
          const lineContent = lineZodiacs.map(zodiac => {
            const bestNum = prediction.zodiacBestNumbers[zodiac];
            if (bestNum && bestNum.number) {
              return `${zodiac}:${bestNum.number}${CONFIG.EMOJI[bestNum.color] || ""}`;
            }
            return `${zodiac}:?`;
          }).join("  ");
          lines.push(lineContent);
        }
        zodiacBestDisplay = lines.join("\n");
      }
      
      const content = `
ğŸ”® <b>${CONFIG.SYSTEM.NAME} - é«˜çº§é¢„æµ‹</b>
ç¬¬ <b>${prediction.nextExpect || "æœªçŸ¥"}</b> æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${basedOnInfo}${progressInfo}

ğŸ­ <b>ç”Ÿè‚–æ¨è</b>
${CONFIG.EMOJI.fire} ä¸»æ¨: ${zodiacMain.join(" ") || "æš‚æ— "}
${CONFIG.EMOJI.shield} é˜²å®ˆ: ${zodiacGuard.join(" ") || "æš‚æ— "}

ğŸ¨ <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[prediction.color?.main] || ""} / é˜²${CONFIG.EMOJI[prediction.color?.guard] || ""}

ğŸ”¢ <b>ç‰¹ç æ¨è</b>
å¤´æ•°: ${prediction.head || "æœªçŸ¥"} | å°¾æ•°: ${tail.join(", ") || "æš‚æ— "}
å½¢æ€: ${prediction.shape || "æœªçŸ¥"}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>${CONFIG.EMOJI.diamond} ç²¾é€‰å¹³ç </b>
${normalDisplay}

<b>${CONFIG.EMOJI.star} ç‰¹ç å‰äº”</b>
${specialDisplay}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>${CONFIG.EMOJI.trophy} ä¸€è‚–ä¸€ç </b>
${zodiacBestDisplay}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ç½®ä¿¡åº¦</b>: ${prediction.confidence || 0}%
<b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ç®—æ³•ç‰ˆæœ¬</b>: ${prediction.algorithmVersion || "æœªçŸ¥"}
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„è§ˆæ—¶å‡ºé”™", error);
      return "âŒ æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚";
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.history} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = parseInt(r.open_code.split(",")[6]);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return "âŒ è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚";
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.sync} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\nğŸ“ <b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
      } else {
        message += `âŒ <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return "âŒ å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚";
    }
  }

  static renderPushResult(success, task, channelPushSuccess = false) {
    try {
      let message = `${CONFIG.EMOJI.rocket} <b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `âœ… <b>æ¨é€æˆåŠŸ</b>\n`;
        message += `æœŸå·: ${task?.expect || "æœªçŸ¥"}\n`;
        message += `ç½®ä¿¡åº¦: ${task?.finalPrediction?.confidence || 0}%\n`;
        
        // æ˜¾ç¤ºæ¨¡æ‹Ÿä¿¡æ¯
        if (task?.finalPrediction?.simulationInfo) {
          const { currentSims, targetSims, timeElapsed } = task.finalPrediction.simulationInfo;
          message += `æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(currentSims)}/${Formatter.formatLargeNumber(targetSims)}\n`;
          message += `è¿è¡Œæ—¶é—´: ${Formatter.formatTimeInterval(timeElapsed)}\n`;
        }
        
        if (channelPushSuccess) {
          message += `é¢‘é“æ¨é€: æˆåŠŸ âœ…\n`;
        } else {
          message += `é¢‘é“æ¨é€: å¤±è´¥ âŒ\n`;
        }
        
        message += `\nğŸ“Š <b>é¢„æµ‹æ¦‚è§ˆ</b>\n`;
        message += `ç”Ÿè‚–: ${Array.isArray(task?.finalPrediction?.zodiac?.main) ? task.finalPrediction.zodiac.main.join(", ") : "æœªçŸ¥"}\n`;
        message += `æ³¢è‰²: ${CONFIG.EMOJI[task?.finalPrediction?.color?.main] || ""}\n`;
        message += `ç‰¹ç ç¤ºä¾‹: ${task?.finalPrediction?.specialNumbers?.[0]?.number || "æœªçŸ¥"}\n`;
      } else {
        message += `âŒ <b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return "âŒ å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚";
    }
  }

  /**
   * æ¸²æŸ“åˆ é™¤ç»“æœï¼ˆä¿®å¤ç‰ˆï¼‰
   */
  static renderDeleteResult(result, expectRange, impactInfo = null) {
    let message = `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
    
    if (result.success) {
      message += `âœ… <b>åˆ é™¤æˆåŠŸ</b>\n`;
      message += `åˆ é™¤èŒƒå›´: ${expectRange}\n`;
      message += `åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
      
      if (result.total !== undefined) {
        message += `èŒƒå›´å†…è®°å½•æ•°: ${result.total} æ¡\n`;
      }
      
      // æ˜¾ç¤ºåˆ é™¤åçš„æœ€æ–°è®°å½•
      if (impactInfo && impactInfo.latestAfterDelete) {
        const { latestAfterDelete } = impactInfo;
        const special = parseInt(latestAfterDelete.open_code.split(",")[6]);
        const attr = Formatter.getAttributes(special);
        message += `\n${CONFIG.EMOJI.reload} <b>é¢„æµ‹å·²é‡æ–°è®¡ç®—</b>\n`;
        message += `åŸºäº: ç¬¬ ${latestAfterDelete.expect} æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
        message += `âš ï¸ æ–°é¢„æµ‹éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆ\n`;
      } else {
        message += `\n${CONFIG.EMOJI.reload} <b>é¢„æµ‹å·²é‡ç½®</b>\n`;
        message += `æ–°é¢„æµ‹éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆ\n`;
      }
      
      if (result.message) {
        message += `\n${result.message}\n`;
      }
    } else {
      message += `âŒ <b>åˆ é™¤å¤±è´¥</b>\n`;
      message += `é”™è¯¯ä¿¡æ¯: ${result.error || 'æœªçŸ¥é”™è¯¯'}\n`;
    }
    
    message += `\næ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
    
    return message;
  }

  /**
   * æ¸²æŸ“åˆ é™¤æ“ä½œå·²å–æ¶ˆ
   */
  static renderDeleteCancelled() {
    return `${CONFIG.EMOJI.cancel} <b>åˆ é™¤æ“ä½œå·²å–æ¶ˆ</b>\n\nåˆ é™¤æ“ä½œå·²è¢«ç”¨æˆ·å–æ¶ˆã€‚`;
  }
}

// ==============================================================================
// 7. å¤–éƒ¨æ¥å£å°è£…
// ==============================================================================

class ExternalService {
  static async sendOrEditMessage(env, chatId, text, keyboard = null, messageId = null, parseMode = "HTML") {
    try {
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };
      
      if (keyboard) body.reply_markup = keyboard;

      let url, method;
      
      if (messageId) {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;
        method = "POST";
        body.message_id = messageId;
      } else {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;
        method = "POST";
      }

      const response = await fetch(url, {
        method: method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendOrEditMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendOrEditMessage network error", error);
      return null;
    }
  }

  static async answerCallbackQuery(env, callbackQueryId, text = "å¤„ç†ä¸­...", showAlert = false) {
    try {
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/answerCallbackQuery`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          callback_query_id: callbackQueryId,
          text: text,
          show_alert: showAlert
        })
      });
      
      return await response.json();
    } catch (error) {
      Logger.error("Telegram", "answerCallbackQuery failed", error);
      return null;
    }
  }

  static async syncHistoryFromUrl(env) {
    if (!env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/5.8',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => parseInt(b.expect) - parseInt(a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => parseInt(r.expect) > parseInt(latestInDB));
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => parseInt(a.expect) - parseInt(b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = parseInt(await DB.getSetting(env, "TOTAL_SYNCS", "0")) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", new Date().toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'}));
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    for (const item of dataArray) {
      try {
        if (item.expect && item.openCode) {
          const expect = item.expect.toString().trim();
          const codeStr = item.openCode.toString().trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => parseInt(n))
            .filter(n => !isNaN(n) && n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(","),
              raw: item
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    for (const item of dataArray) {
      try {
        const expect = (item.expect || item.issue || item.code)?.toString().trim();
        const codeStr = (item.open_code || item.openCode || item.code_number || item.number)?.toString().trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => parseInt(n))
          .filter(n => !isNaN(n) && n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(","),
            raw: item
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 8. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ - å®Œæ•´ä¿®å¤ç‰ˆ
// ==============================================================================

class Controller {
  // å­˜å‚¨å¾…ç¡®è®¤çš„åˆ é™¤æ“ä½œ
  static pendingDeletions = new Map();

  static async showMainMenu(env, chatId, messageId = null, isAdmin = false) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const lastSync = await DB.getSetting(env, "LAST_SYNC", "");
      const deletionStats = await DB.getDeletionStats(env);
      const predictionStats = await DB.getPredictionStats(env);
      
      const message = MessageRenderer.renderMainMenu(historyCount, lastSync, deletionStats, predictionStats);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(isAdmin);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºä¸»èœå•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºä¸»èœå•ï¼Œè¯·é‡è¯•ã€‚",
        null, messageId
      );
    }
  }

  static async handlePreview(env, chatId, messageId) {
    try {
      Logger.info("Preview", `å¤„ç†é¢„è§ˆè¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      let task = await DB.getTask(env);

      if (!task) {
        // å¦‚æœæ²¡æœ‰ä»»åŠ¡ï¼Œé‡æ–°åˆå§‹åŒ–
        const history = await DB.getHistory(env, 500); // åªå–æœ€æ–°500æ¡
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendOrEditMessage(
            env, chatId,
            `ğŸ”® <b>${CONFIG.SYSTEM.NAME}</b>\nå½“å‰æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆåŒæ­¥æ•°æ®ã€‚`,
            MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
            messageId
          );
          return;
        }
      }

      const allHistory = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€ï¼ˆå¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°æ¡ä»¶ï¼‰
      if (task.status === "CALCULATING") {
        const now = Date.now();
        const timePassed = now - task.startTime;
        const totalDuration = task.unlockTime - task.startTime;
        
        // è®¡ç®—å½“å‰æ¨¡æ‹Ÿæ¬¡æ•°ï¼ˆåŸºäºæ—¶é—´è¿›åº¦ï¼Œä½†å—é™åˆ¶ï¼‰
        const timeProgress = Math.min(1, timePassed / totalDuration);
        
        // æ¨¡æ‹Ÿæ¬¡æ•°å¢é•¿é€Ÿåº¦å—æ—¶é—´é™åˆ¶ï¼Œä¸èƒ½è¶…è¿‡æ—¶é—´è¿›åº¦
        const maxSimsByTime = Math.floor(timeProgress * task.targetSims);
        
        // ç¡®ä¿æ¨¡æ‹Ÿæ¬¡æ•°ä¸ä¼šè¶…è¿‡æ—¶é—´å…è®¸çš„èŒƒå›´
        task.currentSims = Math.min(maxSimsByTime, task.targetSims);
        
        // æ£€æŸ¥å®Œæˆæ¡ä»¶ï¼šå¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°è¦æ±‚
        const meetsTimeCondition = now >= task.unlockTime;
        const meetsSimsCondition = task.currentSims >= task.targetSims;
        
        // ä¸¤ä¸ªæ¡ä»¶å¿…é¡»åŒæ—¶æ»¡è¶³æ‰èƒ½å®Œæˆ
        if (meetsTimeCondition && meetsSimsCondition) {
          task.status = "DONE";
          task.currentSims = task.targetSims; // ç¡®ä¿è¾¾åˆ°ç›®æ ‡
          
          // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
          const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
          task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
          
          // è®°å½•é¢„æµ‹æ—¥å¿—
          await DB.logPrediction(
            env, 
            task.expect, 
            task.finalPrediction?.confidence || 0,
            task.currentSims,
            now - task.startTime,
            true
          );
          
          Logger.info("Preview", `é¢„æµ‹è®¡ç®—å®Œæˆ: ${task.expect}, ç½®ä¿¡åº¦: ${task.finalPrediction?.confidence || 0}%, æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(task.currentSims)}, è€—æ—¶: ${Formatter.formatTimeInterval(now - task.startTime)}`);
        }
        
        await DB.saveTask(env, task);
      }

      let prediction;
      if (task.finalPrediction && task.status === "DONE") {
        // æ£€æŸ¥é¢„æµ‹æ˜¯å¦è¿‡æ—¶ï¼ˆåŸºäºçš„å†å²è®°å½•æ˜¯å¦ä»ç„¶å­˜åœ¨ï¼‰
        const predictionBasedOn = task.finalPrediction.basedOnLastRecord;
        if (predictionBasedOn && predictionBasedOn.expect) {
          const recordExists = await DB.checkExpectExists(env, predictionBasedOn.expect);
          if (!recordExists) {
            Logger.info("Preview", `é¢„æµ‹åŸºäºçš„è®°å½• ${predictionBasedOn.expect} å·²ä¸å­˜åœ¨ï¼Œé‡æ–°ç”Ÿæˆé¢„æµ‹`);
            // é‡æ–°ç”Ÿæˆé¢„æµ‹ï¼ˆé‡ç½®ä»»åŠ¡ï¼‰
            task.status = "CALCULATING";
            task.currentSims = 0;
            task.startTime = Date.now();
            task.unlockTime = Date.now() + CONFIG.SYSTEM.DEFAULT_DURATION;
            task.finalPrediction = null;
            
            const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
            prediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
            task.finalPrediction = prediction;
            await DB.saveTask(env, task);
          } else {
            prediction = task.finalPrediction;
          }
        } else {
          prediction = task.finalPrediction;
        }
      } else {
        // å¦‚æœä»»åŠ¡è¿˜åœ¨è®¡ç®—ä¸­ï¼Œç”Ÿæˆä¸´æ—¶é¢„æµ‹
        const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
        prediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
        
        // å¦‚æœæ˜¯ä¸´æ—¶é¢„æµ‹ï¼Œè®°å½•ä¸ºæœªå®Œæˆ
        if (task.status === "CALCULATING") {
          await DB.logPrediction(
            env,
            task.expect,
            prediction.confidence || 0,
            task.currentSims,
            Date.now() - task.startTime,
            false
          );
        }
      }

      const message = MessageRenderer.renderPreview(prediction, task);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Preview", `é¢„è§ˆæ›´æ–°å®Œæˆ: ${task.expect}, çŠ¶æ€: ${task.status}, ç½®ä¿¡åº¦: ${prediction.confidence}%`);
      
    } catch (error) {
      Logger.error("Preview", "å¤„ç†é¢„è§ˆå¤±è´¥", error);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç”Ÿæˆé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>\n\nè¯·ç¨åé‡è¯•ã€‚`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleHistory(env, chatId, page = 1, messageId = null) {
    try {
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      const keyboard = MessageRenderer.generateHistoryKeyboard(page, totalPages);

      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºå†å²è®°å½•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleSync(env, chatId, messageId) {
    try {
      Logger.info("Sync", `æ‰‹åŠ¨åŒæ­¥è¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.sync} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      const history = await DB.getHistory(env, 500);
      let task = await DB.getTask(env);
      if (!task && history.length > 0) {
        task = await Controller.initTask(env, history);
      } else if (task && history.length > 0) {
        task.history = history;
        await DB.saveTask(env, task);
      }
      
      const message = MessageRenderer.renderSyncResult(result);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleForcePush(env, chatId, messageId) {
    try {
      let task = await DB.getTask(env);
      
      if (!task) {
        const history = await DB.getHistory(env, 500);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendOrEditMessage(
            env, chatId,
            "âŒ æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆæ¨é€ã€‚è¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚",
            MessageRenderer.generateMainMenuKeyboard(true),
            messageId
          );
          return;
        }
      }

      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.rocket} <b>æ­£åœ¨å¼ºåˆ¶ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\næ³¨æ„ï¼šè¿™å°†è·³è¿‡5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿçš„è¦æ±‚ï¼Œç›´æ¥ç”Ÿæˆé¢„æµ‹ã€‚`,
        null, messageId
      );

      // å¼ºåˆ¶å®Œæˆé¢„æµ‹ï¼ˆè·³è¿‡æ—¶é—´é™åˆ¶ï¼‰
      task.status = "DONE";
      task.currentSims = task.targetSims; // ç›´æ¥è®¾ç½®ä¸ºç›®æ ‡æ¨¡æ‹Ÿæ¬¡æ•°
      
      const allHistory = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
      
      task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
      task.isSent = 1;

      await DB.saveTask(env, task);
      
      // è®°å½•é¢„æµ‹æ—¥å¿—
      await DB.logPrediction(
        env,
        task.expect,
        task.finalPrediction?.confidence || 0,
        task.currentSims,
        CONFIG.SYSTEM.DEFAULT_DURATION, // ä½¿ç”¨é»˜è®¤æ—¶é•¿ä½œä¸ºæ—¶é—´
        true
      );
      
      const totalPushes = parseInt(await DB.getSetting(env, "TOTAL_PUSHES", "0")) + 1;
      await DB.saveSetting(env, "TOTAL_PUSHES", totalPushes.toString());

      let channelPushSuccess = false;
      if (env.TG_CHANNEL_ID) {
        try {
          const channelMessage = MessageRenderer.renderPreview(task.finalPrediction);
          await ExternalService.sendOrEditMessage(env, env.TG_CHANNEL_ID, channelMessage);
          channelPushSuccess = true;
          Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${task.expect}`);
        } catch (error) {
          Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
          channelPushSuccess = false;
        }
      }
      
      const message = MessageRenderer.renderPushResult(true, task, channelPushSuccess);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Push", "ç«‹å³æ¨é€å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç«‹å³æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  /**
   * å¤„ç†åˆ é™¤è®°å½•åŠŸèƒ½
   */
  static async handleDelete(env, chatId, messageId) {
    try {
      const message = MessageRenderer.renderDeleteInfo();
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `æ˜¾ç¤ºåˆ é™¤åŠŸèƒ½è¯´æ˜ï¼ŒchatId: ${chatId}`);
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤åŠŸèƒ½å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>æ˜¾ç¤ºåˆ é™¤åŠŸèƒ½å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  /**
   * å¤„ç†åˆ é™¤å‘½ä»¤ï¼ˆå®Œæ•´ç‰ˆï¼‰
   */
  static async handleDeleteCommand(env, chatId, userId, commandText, messageId = null) {
    try {
      Logger.info("Delete", `å¤„ç†åˆ é™¤å‘½ä»¤: ${commandText}, userId: ${userId}`);
      
      // è§£æå‘½ä»¤æ ¼å¼ï¼š/delete 2025001 æˆ– /delete 2025001-2025010
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      // åˆ†æåˆ é™¤å½±å“
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          `âš ï¸ <b>æœªæ‰¾åˆ°è®°å½•</b>\n\nåœ¨ ${expectRange} èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å†å²è®°å½•ã€‚`,
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      // æ˜¾ç¤ºå½±å“åˆ†æå’Œç¡®è®¤æ¶ˆæ¯
      const impactMessage = MessageRenderer.renderDeletionImpact(impactInfo, expectRange);
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      
      // å…ˆæ˜¾ç¤ºå½±å“åˆ†æ
      await ExternalService.sendOrEditMessage(
        env, chatId, impactMessage, null, messageId
      );
      
      // ç­‰å¾…1ç§’åæ˜¾ç¤ºç¡®è®¤æ¶ˆæ¯
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const keyboard = MessageRenderer.generateDeleteConfirmationKeyboard(expectRange);
      
      // ä¿å­˜å¾…ç¡®è®¤çš„åˆ é™¤æ“ä½œ
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      // 10åˆ†é’Ÿåè‡ªåŠ¨æ¸…ç†å¾…ç¡®è®¤æ“ä½œ
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, confirmMessage, keyboard, null
      );
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  /**
   * ç¡®è®¤åˆ é™¤æ“ä½œï¼ˆå®Œæ•´ç‰ˆï¼‰
   */
  static async confirmDelete(env, chatId, userId, expectRange, messageId) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const pendingDeletion = this.pendingDeletions.get(deletionKey);
      
      if (!pendingDeletion || pendingDeletion.expectRange !== expectRange) {
        await ExternalService.sendOrEditMessage(
          env, chatId,
          "âŒ <b>åˆ é™¤æ“ä½œå·²è¿‡æœŸæˆ–æ— æ•ˆ</b>\n\nè¯·é‡æ–°å‘èµ·åˆ é™¤å‘½ä»¤ã€‚",
          MessageRenderer.generateMainMenuKeyboard(true),
          messageId
        );
        return;
      }
      
      // æ¸…ç†å¾…ç¡®è®¤æ“ä½œ
      this.pendingDeletions.delete(deletionKey);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.trash} <b>æ­£åœ¨åˆ é™¤è®°å½•...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      // æ‰§è¡Œåˆ é™¤
      const result = await DB.deleteHistoryByRange(
        env, 
        pendingDeletion.start, 
        pendingDeletion.end,
        userId,
        "æ‰‹åŠ¨åˆ é™¤"
      );
      
      if (!result.success) {
        const message = MessageRenderer.renderDeleteResult(result, expectRange);
        const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
        await ExternalService.sendOrEditMessage(
          env, chatId, message, keyboard, messageId
        );
        return;
      }
      
      // åˆ é™¤æˆåŠŸåï¼Œé‡æ–°åˆå§‹åŒ–ä»»åŠ¡
      const history = await DB.getHistory(env, 500);
      let newTask = null;
      
      if (history.length > 0) {
        // é‡æ–°è®¡ç®—ä¸‹ä¸€æœŸæœŸå·
        const latestExpect = await DB.getLatestExpect(env);
        let nextExpect = "2025001";
        if (latestExpect) {
          nextExpect = (parseInt(latestExpect) + 1).toString();
        }
        
        // é‡æ–°ç”Ÿæˆé¢„æµ‹ä»»åŠ¡ï¼ˆéœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿï¼‰
        newTask = {
          startTime: Date.now(),
          unlockTime: Date.now() + CONFIG.SYSTEM.DEFAULT_DURATION,
          expect: nextExpect,
          status: "CALCULATING",
          currentSims: 0,
          targetSims: CONFIG.SYSTEM.TARGET_SIMS,
          history: history,
          finalPrediction: null,
          isSent: 0,
          predictionVersion: Date.now(),
          algorithmVersion: "V5.8"
        };
        
        await DB.saveTask(env, newTask);
        Logger.info("Delete", `é¢„æµ‹ä»»åŠ¡å·²é‡æ–°åˆå§‹åŒ–ï¼ŒæœŸå·: ${nextExpect}, éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿ`);
      } else {
        // æ²¡æœ‰å†å²è®°å½•ï¼Œåˆ é™¤ä»»åŠ¡
        await DB.resetTask(env);
        Logger.info("Delete", "æ— å†å²è®°å½•ï¼Œä»»åŠ¡å·²é‡ç½®");
      }
      
      const message = MessageRenderer.renderDeleteResult(result, expectRange, pendingDeletion.impactInfo);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå®Œæˆ: ${expectRange}, åˆ é™¤è®°å½•æ•°: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "ç¡®è®¤åˆ é™¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>åˆ é™¤æ“ä½œå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  /**
   * å–æ¶ˆåˆ é™¤æ“ä½œ
   */
  static async cancelDelete(env, chatId, userId, messageId) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.delete(deletionKey);
      
      const message = MessageRenderer.renderDeleteCancelled();
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå·²å–æ¶ˆ, userId: ${userId}`);
    } catch (error) {
      Logger.error("Delete", "å–æ¶ˆåˆ é™¤å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>å–æ¶ˆåˆ é™¤å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async initTask(env, history) {
    // ä»è®¾ç½®è·å–æŒç»­æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
    const duration = parseInt(await DB.getSetting(env, "DURATION", CONFIG.SYSTEM.DEFAULT_DURATION));
    const targetSims = parseInt(await DB.getSetting(env, "TARGET_SIMS", CONFIG.SYSTEM.TARGET_SIMS));
    
    let nextExpect = "2025001";
    if (history.length > 0) {
      const latestExpect = parseInt(history[0].expect);
      nextExpect = (latestExpect + 1).toString();
    }

    const newTask = {
      startTime: Date.now(),
      unlockTime: Date.now() + duration,
      expect: nextExpect,
      status: "CALCULATING",
      currentSims: 0,
      targetSims: targetSims,
      history: history.slice(0, 500),
      finalPrediction: null,
      isSent: 0,
      predictionVersion: Date.now(),
      algorithmVersion: "V5.8",
      completionConditions: {
        minTimeRequired: CONFIG.SYSTEM.MIN_TIME_REQUIRED,
        minSimsRequired: CONFIG.SYSTEM.MIN_SIMS_REQUIRED,
        targetTime: duration,
        targetSims: targetSims
      }
    };

    await DB.saveTask(env, newTask);
    Logger.info("Task", `åˆå§‹åŒ–ä»»åŠ¡: æœŸå· ${nextExpect}, ç›®æ ‡: ${Formatter.formatLargeNumber(targetSims)}æ¬¡æ¨¡æ‹Ÿ, ${duration/(60*60*1000)}å°æ—¶`);
    return newTask;
  }
}

// ==============================================================================
// 9. äº‹ä»¶å¤„ç†å™¨
// ==============================================================================

async function handleCallback(env, query) {
  const data = query.data;
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;
  const userId = query.from.id;
  
  Logger.info("Callback", `æ”¶åˆ°å›è°ƒ: ${data}`, { chatId, userId });
  
  try {
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†ä¸­...");
  } catch (e) {
    Logger.error("Callback", "å›ç­”å›è°ƒå¤±è´¥", e);
  }
  
  try {
    const isAdmin = (String(userId) === String(env.TG_ADMIN_ID));
    
    if (data === CALLBACK_DATA.MAIN_MENU) {
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
      
    } else if (data === CALLBACK_DATA.PREVIEW) {
      await Controller.handlePreview(env, chatId, messageId);
      
    } else if (data === CALLBACK_DATA.HISTORY) {
      await Controller.handleHistory(env, chatId, 1, messageId);
      
    } else if (data.startsWith(CALLBACK_DATA.HISTORY_PAGE_PREFIX)) {
      const page = parseInt(data.replace(CALLBACK_DATA.HISTORY_PAGE_PREFIX, ''));
      await Controller.handleHistory(env, chatId, page, messageId);
      
    } else if (data === CALLBACK_DATA.SYNC) {
      if (isAdmin) {
        await Controller.handleSync(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.PUSH) {
      if (isAdmin) {
        await Controller.handleForcePush(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.DELETE) {
      if (isAdmin) {
        await Controller.handleDelete(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data.startsWith(CALLBACK_DATA.DELETE_CONFIRM)) {
      if (isAdmin) {
        const expectRange = data.replace(`${CALLBACK_DATA.DELETE_CONFIRM}_`, '');
        await Controller.confirmDelete(env, chatId, userId, expectRange, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.DELETE_CANCEL) {
      if (isAdmin) {
        await Controller.cancelDelete(env, chatId, userId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === "current_page") {
      await ExternalService.answerCallbackQuery(env, query.id, "å½“å‰é¡µé¢", true);
      
    } else {
      await ExternalService.answerCallbackQuery(env, query.id, "æœªçŸ¥æ“ä½œ", true);
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
    }
  } catch (error) {
    Logger.error("Callback", "å¤„ç†å›è°ƒå¤±è´¥", error);
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", true);
  }
}

async function handleUpdate(env, payload) {
  if (payload.callback_query) {
    await handleCallback(env, payload.callback_query);
    return;
  }

  const msg = payload.message;
  if (!msg || !msg.text) return;

  const chatId = msg.chat.id;
  const text = msg.text.trim();
  const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
  
  Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId });
  
  const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
  
  if (text === "/start" || text === "/menu") {
    await Controller.showMainMenu(env, chatId, null, isAdmin);
    return;
  }
  
  // å¤„ç†åˆ é™¤å‘½ä»¤
  if (text.startsWith('/delete') && isAdmin) {
    await Controller.handleDeleteCommand(env, chatId, userId, text, null);
    return;
  }
  
  // å…¶ä»–æ–‡æœ¬å‘½ä»¤å¤„ç†
  if (text.includes("é¢„è§ˆ") || text.includes("é¢„æµ‹")) {
    await Controller.handlePreview(env, chatId, null);
  } else if (text.includes("å†å²") || text.includes("è®°å½•")) {
    await Controller.handleHistory(env, chatId, 1, null);
  } else if (text.includes("åŒæ­¥") && isAdmin) {
    await Controller.handleSync(env, chatId, null);
  } else if (text.includes("æ¨é€") && isAdmin) {
    await Controller.handleForcePush(env, chatId, null);
  } else if (text.includes("åˆ é™¤") && isAdmin) {
    await Controller.handleDelete(env, chatId, null);
  } else {
    await Controller.showMainMenu(env, chatId, null, isAdmin);
  }
}

async function handleCronJob(env) {
  Logger.info("Cron", "å¼€å§‹æ‰§è¡Œå®šæ—¶ä»»åŠ¡");
  
  try {
    let task = await DB.getTask(env);
    if (task && task.status === "CALCULATING") {
      const now = Date.now();
      const timePassed = now - task.startTime;
      const totalDuration = task.unlockTime - task.startTime;
      
      // è®¡ç®—å½“å‰æ¨¡æ‹Ÿæ¬¡æ•°ï¼ˆåŸºäºæ—¶é—´è¿›åº¦ï¼Œä½†å—é™åˆ¶ï¼‰
      const timeProgress = Math.min(1, timePassed / totalDuration);
      
      // æ¨¡æ‹Ÿæ¬¡æ•°å¢é•¿é€Ÿåº¦å—æ—¶é—´é™åˆ¶ï¼Œä¸èƒ½è¶…è¿‡æ—¶é—´è¿›åº¦
      const maxSimsByTime = Math.floor(timeProgress * task.targetSims);
      
      // ç¡®ä¿æ¨¡æ‹Ÿæ¬¡æ•°ä¸ä¼šè¶…è¿‡æ—¶é—´å…è®¸çš„èŒƒå›´
      task.currentSims = Math.min(maxSimsByTime, task.targetSims);
      
      // æ£€æŸ¥å®Œæˆæ¡ä»¶ï¼šå¿…é¡»åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°è¦æ±‚
      const meetsTimeCondition = now >= task.unlockTime;
      const meetsSimsCondition = task.currentSims >= task.targetSims;
      
      // ä¸¤ä¸ªæ¡ä»¶å¿…é¡»åŒæ—¶æ»¡è¶³æ‰èƒ½å®Œæˆ
      if (meetsTimeCondition && meetsSimsCondition) {
        task.status = "DONE";
        task.currentSims = task.targetSims; // ç¡®ä¿è¾¾åˆ°ç›®æ ‡
        
        // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
        const allHistory = await DB.getAllHistory(env);
        const weights = await DB.getWeights(env);
        const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
        
        task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
        
        // è®°å½•é¢„æµ‹æ—¥å¿—
        await DB.logPrediction(
          env, 
          task.expect, 
          task.finalPrediction?.confidence || 0,
          task.currentSims,
          now - task.startTime,
          true
        );
        
        Logger.info("Cron", `å®šæ—¶ä»»åŠ¡å®Œæˆé¢„æµ‹: ${task.expect}, ç½®ä¿¡åº¦: ${task.finalPrediction?.confidence || 0}%, æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(task.currentSims)}, è€—æ—¶: ${Formatter.formatTimeInterval(now - task.startTime)}`);
      }
      
      await DB.saveTask(env, task);
    }
    
    Logger.info("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ");
    
  } catch (error) {
    Logger.error("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå¤±è´¥", error);
  }
}

// ==============================================================================
// 10. Worker å…¥å£ç‚¹
// ==============================================================================

export default {
  async scheduled(event, env, ctx) {
    Logger.info("Worker", "å®šæ—¶ä»»åŠ¡è§¦å‘");
    
    const initialized = await DB.init(env);
    if (!initialized) {
      Logger.error("Worker", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œå®šæ—¶ä»»åŠ¡ä¸­æ­¢");
      return;
    }
    
    ctx.waitUntil(handleCronJob(env));
  },

  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
    
    const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
    const missingVars = requiredEnvVars.filter(key => !env[key]);
    
    if (missingVars.length > 0) {
      Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
      return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
    
    CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID;
    CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID;
    
    const initialized = await DB.init(env);
    if (!initialized) {
      return new Response("Database Initialization Failed. Please check D1 binding.", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
    
    if (request.method === "GET") {
      if (url.pathname === '/sync') {
        if (!env.TG_ADMIN_ID) {
          return new Response('æœªé…ç½®ç®¡ç†å‘˜ID', { status: 403 });
        }
        
        try {
          const result = await ExternalService.syncHistoryFromUrl(env);
          
          let html = `<h1>${CONFIG.SYSTEM.NAME} - æ•°æ®åŒæ­¥ç»“æœ</h1>`;
          html += `<style>body{font-family:Arial,sans-serif;margin:40px;line-height:1.6}</style>`;
          
          if (result.success) {
            html += `<p style="color:green;font-weight:bold;">âœ… åŒæ­¥æˆåŠŸ</p>`;
            html += `<p>è·å–æ€»æ•°: ${result.total} æ¡</p>`;
            html += `<p>æˆåŠŸæ–°å¢: ${result.added} æ¡</p>`;
            html += `<p>è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡</p>`;
            
            if (result.newCount > 0) {
              html += `<p style="color:blue;">ğŸ“¢ å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</p>`;
            }
            
            const history = await DB.getHistory(env, 500);
            if (history.length > 0) {
              await Controller.initTask(env, history);
              html += `<p>ğŸ”„ é¢„æµ‹ä»»åŠ¡å·²é‡æ–°åˆå§‹åŒ–</p>`;
              html += `<p>âš ï¸ æ–°é¢„æµ‹éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆ</p>`;
            }
          } else {
            html += `<p style="color:red;font-weight:bold;">âŒ åŒæ­¥å¤±è´¥</p>`;
            html += `<p>é”™è¯¯: ${result.error || 'æœªçŸ¥é”™è¯¯'}</p>`;
          }
          
          html += `<hr><p><a href="/">è¿”å›é¦–é¡µ</a> | <a href="/admin">æ•°æ®åº“ç®¡ç†</a></p>`;
          
          return new Response(html, { 
            status: result.success ? 200 : 500,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        } catch (error) {
          return new Response(`åŒæ­¥å‡ºé”™: ${error.message}`, { status: 500 });
        }
      }
      
      // æ•°æ®åº“ç®¡ç†é¡µé¢ï¼ˆå®Œæ•´ç‰ˆï¼‰
      if (url.pathname === '/admin') {
        if (!env.TG_ADMIN_ID) {
          return new Response('æœªé…ç½®ç®¡ç†å‘˜ID', { status: 403 });
        }
        
        try {
          const historyCount = await DB.getHistoryCount(env);
          const deletionStats = await DB.getDeletionStats(env);
          const predictionStats = await DB.getPredictionStats(env);
          const recentDeletions = await DB.getRecentDeletionLogs(env, 10);
          const recentPredictions = await DB.getRecentPredictionLogs(env, 10);
          const latestHistory = await DB.getLatestHistory(env, 5);
          const task = await DB.getTask(env);
          
          let html = `<h1>${CONFIG.SYSTEM.NAME} - æ•°æ®åº“ç®¡ç†</h1>`;
          html += `<style>
            body{font-family:Arial,sans-serif;margin:40px;line-height:1.6}
            table{border-collapse:collapse;width:100%;margin:20px 0}
            th,td{border:1px solid #ddd;padding:12px;text-align:left}
            th{background-color:#f2f2f2}
            .status-done{color:green}
            .status-calc{color:orange}
            .card{background:#f9f9f9;border-radius:8px;padding:15px;margin:10px 0}
          </style>`;
          
          html += `<div class="card">
            <h2>ğŸ“Š æ•°æ®ç»Ÿè®¡</h2>
            <p>å†å²è®°å½•æ€»æ•°: ${historyCount} æ¡</p>
            <p>åˆ é™¤æ“ä½œæ¬¡æ•°: ${deletionStats.totalDeletions} æ¬¡</p>
            <p>åˆ é™¤è®°å½•æ€»æ•°: ${deletionStats.totalRecordsDeleted} æ¡</p>
            <p>æœ€ååˆ é™¤æ—¶é—´: ${deletionStats.lastDeletion || 'ä»æœªåˆ é™¤'}</p>
          </div>`;
          
          html += `<div class="card">
            <h2>ğŸ¯ é¢„æµ‹ç»Ÿè®¡</h2>
            <p>å®Œæˆé¢„æµ‹æ¬¡æ•°: ${predictionStats.totalPredictions} æ¬¡</p>
            <p>æ€»æ¨¡æ‹Ÿæ¬¡æ•°: ${Formatter.formatLargeNumber(predictionStats.totalSimulations)} æ¬¡</p>
            <p>å¹³å‡ç½®ä¿¡åº¦: ${predictionStats.avgConfidence}%</p>
            <p>å¹³å‡è€—æ—¶: ${Formatter.formatTimeInterval(predictionStats.avgTimeMs)}</p>
            <p>é¢„æµ‹è¦æ±‚: ${Formatter.formatLargeNumber(CONFIG.SYSTEM.TARGET_SIMS)}æ¬¡æ¨¡æ‹Ÿ + ${CONFIG.SYSTEM.DEFAULT_DURATION/(60*60*1000)}å°æ—¶</p>
          </div>`;
          
          html += `<h2>ğŸ“‹ å½“å‰é¢„æµ‹ä»»åŠ¡</h2>`;
          if (task) {
            const timePassed = Date.now() - task.startTime;
            const timeLeft = Math.max(0, task.unlockTime - Date.now());
            const timeProgress = Math.min(100, ((timePassed / (task.unlockTime - task.startTime)) * 100).toFixed(1));
            const simsProgress = Math.min(100, ((task.currentSims / task.targetSims) * 100).toFixed(1));
            
            html += `<div class="card">
              <p><strong>æœŸå·:</strong> ${task.expect}</p>
              <p><strong>çŠ¶æ€:</strong> <span class="status-${task.status === 'DONE' ? 'done' : 'calc'}">${task.status === 'DONE' ? 'å·²å®Œæˆ' : 'è®¡ç®—ä¸­'}</span></p>
              <p><strong>æ¨¡æ‹Ÿè¿›åº¦:</strong> ${Formatter.formatLargeNumber(task.currentSims)}/${Formatter.formatLargeNumber(task.targetSims)} (${simsProgress}%)</p>
              <p><strong>æ—¶é—´è¿›åº¦:</strong> ${Formatter.formatTimeInterval(timePassed)}/${Formatter.formatTimeInterval(task.unlockTime - task.startTime)} (${timeProgress}%)</p>
              <p><strong>å‰©ä½™æ—¶é—´:</strong> ${Formatter.formatTimeInterval(timeLeft)}</p>
              <p><strong>å¼€å§‹æ—¶é—´:</strong> ${new Date(task.startTime).toLocaleString('zh-CN')}</p>
              <p><strong>å®Œæˆæ¡ä»¶:</strong> ${task.status === 'CALCULATING' ? 'éœ€åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°' : 'å·²æ»¡è¶³'}</p>
            </div>`;
          } else {
            html += `<p>æ— é¢„æµ‹ä»»åŠ¡</p>`;
          }
          
          html += `<h2>ğŸ“œ æœ€æ–°å†å²è®°å½•</h2>`;
          if (latestHistory.length > 0) {
            html += `<table>`;
            html += `<tr><th>æœŸå·</th><th>å¼€å¥–å·ç </th><th>ç‰¹ç ç”Ÿè‚–</th></tr>`;
            
            latestHistory.forEach(record => {
              const special = parseInt(record.open_code.split(",")[6]);
              const attr = Formatter.getAttributes(special);
              html += `<tr>`;
              html += `<td>${record.expect}</td>`;
              html += `<td>${Formatter.formatOpenCode(record.open_code)}</td>`;
              html += `<td>${attr.zodiac} (${attr.color})</td>`;
              html += `</tr>`;
            });
            
            html += `</table>`;
          } else {
            html += `<p>æš‚æ— å†å²è®°å½•</p>`;
          }
          
          html += `<h2>ğŸ“ˆ æœ€è¿‘é¢„æµ‹è®°å½•</h2>`;
          if (recentPredictions.length > 0) {
            html += `<table>`;
            html += `<tr><th>æœŸå·</th><th>ç½®ä¿¡åº¦</th><th>æ¨¡æ‹Ÿæ¬¡æ•°</th><th>è€—æ—¶</th><th>å®Œæˆ</th><th>æ—¶é—´</th></tr>`;
            
            recentPredictions.forEach(log => {
              html += `<tr>`;
              html += `<td>${log.expect}</td>`;
              html += `<td>${log.confidence}%</td>`;
              html += `<td>${Formatter.formatLargeNumber(log.total_sims)}</td>`;
              html += `<td>${Formatter.formatTimeInterval(log.total_time_ms)}</td>`;
              html += `<td>${log.is_completed ? 'âœ…' : 'ğŸ”„'}</td>`;
              html += `<td>${new Date(log.created_at).toLocaleString('zh-CN')}</td>`;
              html += `</tr>`;
            });
            
            html += `</table>`;
          } else {
            html += `<p>æš‚æ— é¢„æµ‹è®°å½•</p>`;
          }
          
          html += `<h2>ğŸ—‘ï¸ æœ€è¿‘åˆ é™¤è®°å½•</h2>`;
          if (recentDeletions.length > 0) {
            html += `<table>`;
            html += `<tr><th>æ“ä½œæ—¶é—´</th><th>ç®¡ç†å‘˜ID</th><th>åˆ é™¤èŒƒå›´</th><th>åˆ é™¤æ¡æ•°</th><th>åŸå› </th></tr>`;
            
            recentDeletions.forEach(log => {
              html += `<tr>`;
              html += `<td>${new Date(log.created_at).toLocaleString('zh-CN')}</td>`;
              html += `<td>${log.admin_id.substring(0, 8)}...</td>`;
              html += `<td>${log.expect_range}</td>`;
              html += `<td>${log.deleted_count}</td>`;
              html += `<td>${log.reason || 'æ‰‹åŠ¨åˆ é™¤'}</td>`;
              html += `</tr>`;
            });
            
            html += `</table>`;
          } else {
            html += `<p>æš‚æ— åˆ é™¤è®°å½•</p>`;
          }
          
          html += `<h2>ğŸ”§ ç®¡ç†æ“ä½œ</h2>`;
          html += `<p><a href="/sync">ğŸ”„ æ‰‹åŠ¨åŒæ­¥æ•°æ®</a></p>`;
          html += `<p><button onclick="if(confirm('ç¡®å®šè¦é‡ç½®é¢„æµ‹ä»»åŠ¡å—ï¼Ÿæ–°ä»»åŠ¡éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆã€‚')) location.href='/reset-task'">â™»ï¸ é‡ç½®é¢„æµ‹ä»»åŠ¡</button></p>`;
          html += `<p><button onclick="if(confirm('ç¡®å®šè¦å¼ºåˆ¶å®Œæˆå½“å‰é¢„æµ‹å—ï¼Ÿè¿™å°†è·³è¿‡5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿçš„è¦æ±‚ã€‚')) location.href='/force-complete'">ğŸš€ å¼ºåˆ¶å®Œæˆé¢„æµ‹</button></p>`;
          html += `<p><a href="/">ğŸ  è¿”å›é¦–é¡µ</a></p>`;
          
          return new Response(html, { 
            status: 200,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        } catch (error) {
          return new Response(`ç®¡ç†é¡µé¢å‡ºé”™: ${error.message}`, { status: 500 });
        }
      }
      
      // é‡ç½®ä»»åŠ¡ç«¯ç‚¹
      if (url.pathname === '/reset-task') {
        if (!env.TG_ADMIN_ID) {
          return new Response('æœªé…ç½®ç®¡ç†å‘˜ID', { status: 403 });
        }
        
        try {
          await DB.resetTask(env);
          return new Response(`
            <h1>ä»»åŠ¡å·²é‡ç½®</h1>
            <p>é¢„æµ‹ä»»åŠ¡å·²æˆåŠŸé‡ç½®ã€‚</p>
            <p><strong>æ³¨æ„ï¼š</strong>æ–°ä»»åŠ¡éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆé¢„æµ‹ã€‚</p>
            <p><a href="/admin">è¿”å›ç®¡ç†é¡µé¢</a></p>
          `, { 
            status: 200,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        } catch (error) {
          return new Response(`é‡ç½®ä»»åŠ¡å‡ºé”™: ${error.message}`, { status: 500 });
        }
      }
      
      // å¼ºåˆ¶å®Œæˆé¢„æµ‹ç«¯ç‚¹
      if (url.pathname === '/force-complete') {
        if (!env.TG_ADMIN_ID) {
          return new Response('æœªé…ç½®ç®¡ç†å‘˜ID', { status: 403 });
        }
        
        try {
          let task = await DB.getTask(env);
          
          if (!task) {
            return new Response(`
              <h1>é”™è¯¯</h1>
              <p>å½“å‰æ²¡æœ‰é¢„æµ‹ä»»åŠ¡ã€‚</p>
              <p><a href="/admin">è¿”å›ç®¡ç†é¡µé¢</a></p>
            `, { status: 400 });
          }
          
          // å¼ºåˆ¶å®Œæˆé¢„æµ‹
          task.status = "DONE";
          task.currentSims = task.targetSims;
          
          const allHistory = await DB.getAllHistory(env);
          const weights = await DB.getWeights(env);
          const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
          
          task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
          
          await DB.saveTask(env, task);
          
          // è®°å½•é¢„æµ‹æ—¥å¿—
          await DB.logPrediction(
            env,
            task.expect,
            task.finalPrediction?.confidence || 0,
            task.currentSims,
            CONFIG.SYSTEM.DEFAULT_DURATION,
            true
          );
          
          return new Response(`
            <h1>å¼ºåˆ¶å®ŒæˆæˆåŠŸ</h1>
            <p>é¢„æµ‹å·²å¼ºåˆ¶å®Œæˆï¼ˆè·³è¿‡äº†5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿçš„è¦æ±‚ï¼‰ã€‚</p>
            <p><strong>æœŸå·:</strong> ${task.expect}</p>
            <p><strong>ç½®ä¿¡åº¦:</strong> ${task.finalPrediction?.confidence || 0}%</p>
            <p><strong>æ¨¡æ‹Ÿæ¬¡æ•°:</strong> ${Formatter.formatLargeNumber(task.currentSims)}</p>
            <p><a href="/admin">è¿”å›ç®¡ç†é¡µé¢</a></p>
          `, { 
            status: 200,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        } catch (error) {
          return new Response(`å¼ºåˆ¶å®Œæˆå‡ºé”™: ${error.message}`, { status: 500 });
        }
      }
      
      // é»˜è®¤é¦–é¡µ
      return new Response(`
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${CONFIG.SYSTEM.NAME}</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
              max-width: 800px;
              margin: 0 auto;
              padding: 20px;
              line-height: 1.6;
              color: #333;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              min-height: 100vh;
            }
            .container {
              background: white;
              border-radius: 15px;
              padding: 40px;
              box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            }
            h1 {
              color: #2d3748;
              border-bottom: 3px solid #667eea;
              padding-bottom: 10px;
              margin-top: 0;
            }
            .feature-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
              gap: 20px;
              margin: 30px 0;
            }
            .feature-card {
              background: #f7fafc;
              border-left: 4px solid #667eea;
              padding: 20px;
              border-radius: 8px;
              transition: transform 0.2s;
            }
            .feature-card:hover {
              transform: translateY(-5px);
            }
            .feature-card h3 {
              margin-top: 0;
              color: #2d3748;
            }
            .btn {
              display: inline-block;
              padding: 12px 24px;
              background: #667eea;
              color: white;
              text-decoration: none;
              border-radius: 8px;
              font-weight: bold;
              margin: 10px 5px;
              transition: background 0.2s;
            }
            .btn:hover {
              background: #5a67d8;
            }
            .btn-danger {
              background: #e53e3e;
            }
            .btn-danger:hover {
              background: #c53030;
            }
            .btn-warning {
              background: #ed8936;
            }
            .btn-warning:hover {
              background: #dd6b20;
            }
            .version {
              color: #718096;
              font-size: 14px;
              margin-top: 30px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
            }
            code {
              background: #f7fafc;
              padding: 2px 6px;
              border-radius: 4px;
              font-family: 'Courier New', monospace;
            }
            .requirements {
              background: #fff5f5;
              border-left: 4px solid #fc8181;
              padding: 15px;
              border-radius: 8px;
              margin: 20px 0;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>${CONFIG.SYSTEM.NAME}</h1>
            <p><strong>ç‰ˆæœ¬:</strong> ${CONFIG.SYSTEM.VERSION} - ä¸“ä¸šå¢å¼ºå®Œæ•´ç‰ˆ</p>
            <p>é«˜çº§å…­åˆå½©æ•°æ®åˆ†æä¸é¢„æµ‹ç³»ç»Ÿï¼Œå·²å¢åŠ é¢„æµ‹è¿è¡Œæ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°è¦æ±‚ã€‚</p>
            
            <div class="requirements">
              <h3>ğŸ¯ é¢„æµ‹å®Œæˆè¦æ±‚</h3>
              <p><strong>å¿…é¡»åŒæ—¶æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š</strong></p>
              <ol>
                <li>è¿è¡Œæ—¶é—´ â‰¥ 5å°æ—¶</li>
                <li>æ¨¡æ‹Ÿæ¬¡æ•° â‰¥ 1äº¿æ¬¡</li>
              </ol>
              <p>åªæœ‰åŒæ—¶æ»¡è¶³ä»¥ä¸Šæ¡ä»¶ï¼Œé¢„æµ‹æ‰ä¼šæ ‡è®°ä¸º"å®Œæˆ"å¹¶å­˜å‚¨æœ€ç»ˆç»“æœã€‚</p>
            </div>
            
            <div class="feature-grid">
              <div class="feature-card">
                <h3>ğŸ­ ä¸€è‚–ä¸€ç </h3>
                <p>æ¯ä¸ªç”Ÿè‚–æ¨èä¸€ä¸ªæœ€å¤§æœºä¼šå¼€çš„å·ç </p>
              </div>
              <div class="feature-card">
                <h3>â° 5å°æ—¶è®¡ç®—</h3>
                <p>é¢„æµ‹éœ€è¦è¿è¡Œ5å°æ—¶æ‰èƒ½å®Œæˆ</p>
              </div>
              <div class="feature-card">
                <h3>ğŸ”¢ 1äº¿æ¬¡æ¨¡æ‹Ÿ</h3>
                <p>éœ€è¦å®Œæˆ1äº¿æ¬¡æ¨¡æ‹Ÿè®¡ç®—</p>
              </div>
              <div class="feature-card">
                <h3>ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤</h3>
                <p>æ”¯æŒæœŸå·èŒƒå›´æ‰¹é‡åˆ é™¤ï¼Œåˆ é™¤åè‡ªåŠ¨é‡æ–°è®¡ç®—é¢„æµ‹</p>
              </div>
            </div>
            
            <h3>ä¸»è¦åŠŸèƒ½</h3>
            <ul>
              <li><b>ä¸€è‚–ä¸€ç </b> - 12ç”Ÿè‚–å„æ¨èä¸€ä¸ªæœ€ä½³å·ç </li>
              <li><b>5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿ</b> - é¢„æµ‹éœ€è¦åŒæ—¶æ»¡è¶³æ—¶é—´å’Œæ¨¡æ‹Ÿæ¬¡æ•°è¦æ±‚æ‰èƒ½å®Œæˆ</li>
              <li><b>è¿›åº¦ç›‘æ§</b> - å®æ—¶æ˜¾ç¤ºæ¨¡æ‹Ÿè¿›åº¦å’Œæ—¶é—´è¿›åº¦</li>
              <li><b>æ‰¹é‡åˆ é™¤ä¿®å¤ç‰ˆ</b> - åˆ é™¤åè‡ªåŠ¨é‡æ–°è®¡ç®—é¢„æµ‹ï¼ŒåŸºäºåˆ é™¤åçš„æœ€æ–°è®°å½•</li>
              <li><b>åˆ é™¤å½±å“åˆ†æ</b> - åˆ é™¤å‰æ˜¾ç¤ºå½±å“åˆ†æï¼Œç¡®è®¤åæ‰§è¡Œ</li>
              <li><b>å¹³é“ºæ˜¾ç¤º</b> - å¹³ç å’Œç‰¹ç æ— åºå·å¹³é“ºæ˜¾ç¤º</li>
              <li><b>é«˜çº§é¢„æµ‹</b> - åŸºäºå†å²æ•°æ®çš„å¤šç»´åº¦ç»Ÿè®¡</li>
              <li><b>å†…è”äº¤äº’</b> - æ‰€æœ‰æ“ä½œåœ¨åŒä¸€æ¶ˆæ¯ä¸­å®Œæˆ</li>
              <li><b>æ•°æ®åŒæ­¥</b> - è‡ªåŠ¨ä»URLè·å–æœ€æ–°å¼€å¥–è®°å½•</li>
            </ul>
            
            <h3>åˆ é™¤åŠŸèƒ½è¯´æ˜ï¼ˆå·²ä¿®å¤ï¼‰</h3>
            <p>ç®¡ç†å‘˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ é™¤è®°å½•ï¼š</p>
            <ul>
              <li><code>/delete 2025001</code> - åˆ é™¤å•ä¸ªæœŸå·</li>
              <li><code>/delete 2025001-2025010</code> - åˆ é™¤æœŸå·èŒƒå›´</li>
            </ul>
            <p><strong>ä¿®å¤åŠŸèƒ½ï¼š</strong></p>
            <ul>
              <li>åˆ é™¤åè‡ªåŠ¨é‡ç½®é¢„æµ‹ä»»åŠ¡</li>
              <li>åŸºäºåˆ é™¤åçš„æœ€æ–°è®°å½•é‡æ–°è®¡ç®—é¢„æµ‹</li>
              <li>æ˜¾ç¤ºåˆ é™¤å½±å“åˆ†æ</li>
              <li>é˜²æ­¢é¢„æµ‹ä½¿ç”¨å·²åˆ é™¤çš„è®°å½•</li>
            </ul>
            <p><strong>æ³¨æ„ï¼šåˆ é™¤æ“ä½œä¸å¯æ¢å¤ï¼åˆ é™¤åæ–°é¢„æµ‹éœ€è¦5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆã€‚</strong></p>
            
            <div>
              <a href="/sync" class="btn">ğŸ”„ æ‰‹åŠ¨åŒæ­¥æ•°æ®</a>
              <a href="/admin" class="btn btn-danger">ğŸ—‘ï¸ æ•°æ®åº“ç®¡ç†</a>
              <a href="/admin" class="btn btn-warning">ğŸš€ å¼ºåˆ¶å®Œæˆé¢„æµ‹</a>
            </div>
            
            <div class="version">
              <p><strong>æŠ€æœ¯æ ˆ:</strong> Cloudflare Workers + D1 Database + Telegram Bot API</p>
              <p><strong>ç®—æ³•ç‰ˆæœ¬:</strong> V5.8 ä¸“ä¸šå¢å¼ºå®Œæ•´ç‰ˆ (å¢åŠ 5å°æ—¶1äº¿æ¬¡æ¨¡æ‹Ÿè¦æ±‚)</p>
              <p><strong>æ ¸å¿ƒè¦æ±‚:</strong> é¢„æµ‹å¿…é¡»åŒæ—¶æ»¡è¶³5å°æ—¶è¿è¡Œæ—¶é—´å’Œ1äº¿æ¬¡æ¨¡æ‹Ÿæ‰èƒ½å®Œæˆ</p>
              <p><strong>æœ€åæ›´æ–°:</strong> ${new Date().toLocaleDateString('zh-CN')}</p>
            </div>
          </div>
        </body>
        </html>
      `, { 
        status: 200,
        headers: { 
          'Content-Type': 'text/html; charset=utf-8',
          'Cache-Control': 'no-cache'
        }
      });
    }

    if (request.method === "POST") {
      try {
        const payload = await request.json();
        
        ctx.waitUntil(handleUpdate(env, payload));
        
        return new Response("OK", { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      } catch (e) {
        Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
        return new Response("OK", { status: 200 });
      }
    }
    
    return new Response("Method not allowed", { status: 405 });
  }
};
