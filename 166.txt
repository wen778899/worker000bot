/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V5.4 Inline Edition (ä¿®å¤ç‰ˆ)
 * 
 * ä¿®å¤å†…å®¹:
 * 1. å½»åº•ä¿®å¤é¢„è§ˆé”™è¯¯: Cannot read properties of undefined (reading 'map')
 * 2. æ·»åŠ å…¨é¢çš„ç©ºå€¼æ£€æŸ¥å’Œé»˜è®¤å€¼
 * 3. ä¼˜åŒ–é”™è¯¯å¤„ç†
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰ (Global Configuration & Constants)
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ–°æ¾³å…­åˆå½©Â·å¤©æœº",
    VERSION: "V5.4 Inline Edition (ä¿®å¤ç‰ˆ)",
    DEFAULT_DURATION: 2 * 60 * 60 * 1000,
    TARGET_SIMS: 3000000,
    BATCH_SIZE: 50000,
    TIMEZONE_OFFSET: 8,
    CHANNEL_ID: null,
    ADMIN_ID: null
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 3.0,
    w_zodiac_relation: 2.5,
    w_color_transfer: 2.0,
    w_tail_correlation: 1.8,
    w_number_frequency: 1.5,
    w_omission_value: 1.2,
    w_shape_pattern: 1.0,
    w_head_tail: 0.8,
    w_normal_correlation: 2.0,
    _version: "3.0"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    },
    
    OPPOSITION: {
      "é¼ ": "é©¬", "é©¬": "é¼ ",
      "ç‰›": "ç¾Š", "ç¾Š": "ç‰›",
      "è™": "çŒ´", "çŒ´": "è™",
      "å…”": "é¸¡", "é¸¡": "å…”",
      "é¾™": "ç‹—", "ç‹—": "é¾™",
      "è›‡": "çŒª", "çŒª": "è›‡"
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    wait: "â³",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    rocket: "ğŸš€",
    sync: "ğŸ”„",
    reset: "â™»ï¸",
    manage: "âš™ï¸",
    history: "ğŸ“œ",
    preview: "ğŸ‘€",
    back: "ğŸ”™",
    gold: "ğŸ’°",
    wood: "ğŸŒ²",
    water: "ğŸ’§",
    fire_element: "ğŸ”¥",
    earth: "â›°ï¸",
    star: "â­",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    bell: "ğŸ””",
    home: "ğŸ "
  }
};

const CALLBACK_DATA = {
  MAIN_MENU: "main_menu",
  PREVIEW: "preview",
  HISTORY: "history",
  SYNC: "sync",
  PUSH: "push",
  HISTORY_PAGE_PREFIX: "history_page_"
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•° (Utilities & Helpers)
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
    console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
  }

  static error(context, message, error = null) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    const errorStr = error ? ` | ${error.message} | ${error.stack?.substring(0, 200)}` : '';
    console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
  }

  static warn(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
  }
}

class Formatter {
  static getAttributes(number) {
    const num = parseInt(number);
    if (num < 1 || num > 49) return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    
    let color = "red";
    if (CONFIG.COLORS.blue.includes(num)) color = "blue";
    else if (CONFIG.COLORS.green.includes(num)) color = "green";
    
    let zodiac = "";
    for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
      if (numbers.includes(num)) {
        zodiac = zodiacName;
        break;
      }
    }
    
    return { zodiac, color };
  }

  static formatOpenCode(codeString) {
    if (!codeString) return "";
    return codeString.replace(/,/g, "-");
  }

  static generateProgressBar(current, total, length = 10) {
    const percentage = total > 0 ? (current / total) : 0;
    const filled = Math.floor(length * percentage);
    const empty = length - filled;
    return "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
  }

  static safeInt(value, defaultValue = 0) {
    if (value === null || value === undefined) return defaultValue;
    const num = parseInt(value);
    return isNaN(num) ? defaultValue : num;
  }
}

// ==============================================================================
// 3. æ•°æ®åº“æ“ä½œå±‚ (Database Access Layer)
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_tasks (
          id INTEGER PRIMARY KEY DEFAULT 1, 
          data TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM lottery_history ORDER BY expect DESC"
      ).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getAllHistory failed", e);
      return [];
    }
  },

  getHistoryCount: async function(env) {
    try {
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      return result ? result.count : 0;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      return result ? result.expect : null;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || records.length === 0) return { success: true, added: 0, skipped: 0 };
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const batch = env.DB.batch(
          chunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(record.expect.toString(), record.open_code)
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + result.changes, 0);
          totalAdded += chunkAdded;
          totalSkipped += (chunk.length - chunkAdded);
          
          if (i + CHUNK_SIZE < records.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡ ${Math.floor(i/CHUNK_SIZE)+1} æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of chunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(record.expect.toString(), record.open_code).run();
              totalAdded += result.changes;
              totalSkipped += (1 - result.changes);
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ€»è®¡æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getTask: async function(env) {
    try {
      const r = await env.DB.prepare("SELECT data FROM lottery_tasks WHERE id = 1").first();
      return r ? JSON.parse(r.data) : null;
    } catch (e) {
      Logger.error("DB", "getTask failed", e);
      return null;
    }
  },

  saveTask: async function(env, data) {
    try {
      return await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_tasks (id, data) VALUES (1, ?)"
      ).bind(JSON.stringify(data)).run();
    } catch (e) {
      Logger.error("DB", "saveTask failed", e);
      return null;
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      return r ? r.value : def;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      return await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, val).run();
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      if (w) {
        const weights = JSON.parse(w);
        const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        return { ...defaultWeights, ...weights };
      }
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "DURATION": CONFIG.SYSTEM.DEFAULT_DURATION.toString(),
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_PUSHES": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  }
};

// ==============================================================================
// 4. é«˜çº§ç»Ÿè®¡å¼•æ“ (Advanced Statistical Engine) - ä¿®å¤ç©ºå€¼é—®é¢˜
// ==============================================================================

class AdvancedStatsEngine {
  static analyzeHistoryStatistics(history) {
    if (!history || !Array.isArray(history) || history.length < 2) {
      Logger.warn("Stats", "å†å²æ•°æ®ä¸è¶³ï¼Œè¿”å›ç©ºç»Ÿè®¡");
      return this.createEmptyStats();
    }

    Logger.info("Stats", `å¼€å§‹åˆ†æ ${history.length} æœŸå†å²æ•°æ®`);

    const stats = this.createEmptyStats();
    
    try {
      for (let i = 0; i < history.length - 1; i++) {
        const currentRecord = history[i];
        const nextRecord = history[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNums = currentRecord.open_code.split(",").map(n => parseInt(n));
        const nextNums = nextRecord.open_code.split(",").map(n => parseInt(n));
        
        if (currentNums.length < 7 || nextNums.length < 7) {
          continue;
        }
        
        const currentSpecial = currentNums[6];
        const nextSpecial = nextNums[6];
        const nextNormals = nextNums.slice(0, 6);
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        // 1. ç”Ÿè‚–è½¬ç§»ç»Ÿè®¡
        if (stats.zodiacTransfer[currentAttr.zodiac] && stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac] !== undefined) {
          stats.zodiacTransfer[currentAttr.zodiac][nextAttr.zodiac]++;
        }
        
        // 2. æ³¢è‰²è½¬ç§»ç»Ÿè®¡
        if (stats.colorTransfer[currentAttr.color] && stats.colorTransfer[currentAttr.color][nextAttr.color] !== undefined) {
          stats.colorTransfer[currentAttr.color][nextAttr.color]++;
        }
        
        // 3. å°¾æ•°å…³è”ç»Ÿè®¡
        const currentNormalTails = currentNums.slice(0, 6).map(n => n % 10);
        const nextSpecialTail = nextSpecial % 10;
        
        currentNormalTails.forEach(tail => {
          if (stats.tailCorrelation[tail] && stats.tailCorrelation[tail][nextSpecialTail] !== undefined) {
            stats.tailCorrelation[tail][nextSpecialTail]++;
          }
        });
        
        // 4. ç”Ÿè‚–å…³ç³»ç»Ÿè®¡
        this.analyzeZodiacRelations(stats, currentAttr.zodiac, nextAttr.zodiac);
        
        // 5. ç‰¹ç é¢‘ç‡ç»Ÿè®¡
        stats.specialFrequency[nextSpecial] = (stats.specialFrequency[nextSpecial] || 0) + 1;
        
        // 6. å¹³ç é¢‘ç‡ç»Ÿè®¡
        nextNormals.forEach(num => {
          stats.normalFrequency[num] = (stats.normalFrequency[num] || 0) + 1;
        });
        
        // 7. å¹³ç ç»„åˆç»Ÿè®¡
        this.analyzeNormalCombination(stats, nextNormals);
        
        // 8. å½¢æ€ç»Ÿè®¡
        const isBig = nextSpecial >= 25;
        const isOdd = nextSpecial % 2 !== 0;
        
        if (isBig && isOdd) stats.shapeStats.bigOdd++;
        else if (isBig && !isOdd) stats.shapeStats.bigEven++;
        else if (!isBig && isOdd) stats.shapeStats.smallOdd++;
        else stats.shapeStats.smallEven++;
      }

      // 9. è®¡ç®—é—æ¼å€¼
      this.calculateOmissionStats(stats, history);
      
      // 10. è®¡ç®—æ¦‚ç‡å’Œå½’ä¸€åŒ–
      this.normalizeStatistics(stats);
      
      stats.totalRecords = history.length;
      
      Logger.info("Stats", "å†å²æ•°æ®åˆ†æå®Œæˆ");
      return stats;
    } catch (error) {
      Logger.error("Stats", "åˆ†æå†å²æ•°æ®æ—¶å‡ºé”™", error);
      return this.createEmptyStats();
    }
  }

  static createEmptyStats() {
    const stats = {
      totalRecords: 0,
      zodiacTransfer: {},
      colorTransfer: { red: { red: 0, blue: 0, green: 0 }, blue: { red: 0, blue: 0, green: 0 }, green: { red: 0, blue: 0, green: 0 } },
      tailCorrelation: {},
      zodiacRelations: { sixHarmony: {}, threeHarmony: {}, opposition: {} },
      specialFrequency: {},
      normalFrequency: {},
      normalCombination: { zodiacPairs: {}, colorDistribution: {}, tailDistribution: {} },
      omissionStats: {},
      shapeStats: { bigOdd: 0, bigEven: 0, smallOdd: 0, smallEven: 0 }
    };
    
    this.initializeStatsStructure(stats);
    return stats;
  }

  static initializeStatsStructure(stats) {
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac1 => {
      stats.zodiacTransfer[zodiac1] = {};
      stats.zodiacRelations.sixHarmony[zodiac1] = 0;
      stats.zodiacRelations.threeHarmony[zodiac1] = 0;
      stats.zodiacRelations.opposition[zodiac1] = 0;
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac2 => {
        stats.zodiacTransfer[zodiac1][zodiac2] = 0;
      });
    });
    
    for (let i = 0; i < 10; i++) {
      stats.tailCorrelation[i] = {};
      for (let j = 0; j < 10; j++) {
        stats.tailCorrelation[i][j] = 0;
      }
    }
    
    for (let i = 1; i <= 49; i++) {
      stats.specialFrequency[i] = 0;
      stats.normalFrequency[i] = 0;
    }
    
    stats.normalCombination.colorDistribution = {
      red: { count: 0, probability: 0 },
      blue: { count: 0, probability: 0 },
      green: { count: 0, probability: 0 }
    };
    
    for (let i = 0; i < 10; i++) {
      stats.normalCombination.tailDistribution[i] = { count: 0, probability: 0 };
    }
  }

  static analyzeZodiacRelations(stats, currentZodiac, nextZodiac) {
    if (!currentZodiac || !nextZodiac) return;
    
    if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[currentZodiac] === nextZodiac) {
      stats.zodiacRelations.sixHarmony[nextZodiac] = (stats.zodiacRelations.sixHarmony[nextZodiac] || 0) + 1;
    }
    
    if (CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[currentZodiac]?.includes(nextZodiac)) {
      stats.zodiacRelations.threeHarmony[nextZodiac] = (stats.zodiacRelations.threeHarmony[nextZodiac] || 0) + 1;
    }
    
    if (CONFIG.ZODIAC_RELATIONS.OPPOSITION[currentZodiac] === nextZodiac) {
      stats.zodiacRelations.opposition[nextZodiac] = (stats.zodiacRelations.opposition[nextZodiac] || 0) + 1;
    }
  }

  static analyzeNormalCombination(stats, normalNumbers) {
    if (!normalNumbers || !Array.isArray(normalNumbers)) return;
    
    const colorCount = { red: 0, blue: 0, green: 0 };
    const tailCount = {};
    
    normalNumbers.forEach(num => {
      const attr = Formatter.getAttributes(num);
      colorCount[attr.color] = (colorCount[attr.color] || 0) + 1;
      
      const tail = num % 10;
      tailCount[tail] = (tailCount[tail] || 0) + 1;
    });
    
    ['red', 'blue', 'green'].forEach(color => {
      if (stats.normalCombination.colorDistribution[color]) {
        stats.normalCombination.colorDistribution[color].count += (colorCount[color] || 0);
      }
    });
    
    Object.keys(tailCount).forEach(tail => {
      const tailNum = parseInt(tail);
      if (stats.normalCombination.tailDistribution[tailNum]) {
        stats.normalCombination.tailDistribution[tailNum].count += (tailCount[tail] || 0);
      }
    });
    
    const zodiacs = normalNumbers.map(num => Formatter.getAttributes(num).zodiac);
    for (let i = 0; i < zodiacs.length; i++) {
      for (let j = i + 1; j < zodiacs.length; j++) {
        const pair = [zodiacs[i], zodiacs[j]].sort().join('-');
        stats.normalCombination.zodiacPairs[pair] = (stats.normalCombination.zodiacPairs[pair] || 0) + 1;
      }
    }
  }

  static calculateOmissionStats(stats, history) {
    const currentOmission = {};
    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
      currentOmission[zodiac] = 0;
    });
    
    for (let i = 0; i < history.length; i++) {
      const record = history[i];
      if (!record || !record.open_code) continue;
      
      const special = parseInt(record.open_code.split(",")[6]);
      if (isNaN(special)) continue;
      
      const zodiac = Formatter.getAttributes(special).zodiac;
      
      Object.keys(currentOmission).forEach(z => {
        if (currentOmission[z] !== -1) {
          if (z === zodiac) currentOmission[z] = -1;
          else currentOmission[z]++;
        }
      });
    }
    
    stats.omissionStats = currentOmission;
  }

  static normalizeStatistics(stats) {
    Object.keys(stats.zodiacTransfer).forEach(zodiac1 => {
      const total = Object.values(stats.zodiacTransfer[zodiac1]).reduce((a, b) => a + b, 0);
      if (total > 0) {
        Object.keys(stats.zodiacTransfer[zodiac1]).forEach(zodiac2 => {
          stats.zodiacTransfer[zodiac1][zodiac2] = stats.zodiacTransfer[zodiac1][zodiac2] / total;
        });
      }
    });
    
    Object.keys(stats.colorTransfer).forEach(color1 => {
      const total = Object.values(stats.colorTransfer[color1]).reduce((a, b) => a + b, 0);
      if (total > 0) {
        Object.keys(stats.colorTransfer[color1]).forEach(color2 => {
          stats.colorTransfer[color1][color2] = stats.colorTransfer[color1][color2] / total;
        });
      }
    });
    
    Object.keys(stats.tailCorrelation).forEach(tail1 => {
      const total = Object.values(stats.tailCorrelation[tail1]).reduce((a, b) => a + b, 0);
      if (total > 0) {
        Object.keys(stats.tailCorrelation[tail1]).forEach(tail2 => {
          stats.tailCorrelation[tail1][tail2] = stats.tailCorrelation[tail1][tail2] / total;
        });
      }
    });
    
    const totalColorCount = Object.values(stats.normalCombination.colorDistribution)
      .reduce((sum, item) => sum + (item?.count || 0), 0);
    if (totalColorCount > 0) {
      Object.keys(stats.normalCombination.colorDistribution).forEach(color => {
        const item = stats.normalCombination.colorDistribution[color];
        if (item) {
          item.probability = (item.count || 0) / totalColorCount;
        }
      });
    }
    
    const totalTailCount = Object.values(stats.normalCombination.tailDistribution)
      .reduce((sum, item) => sum + (item?.count || 0), 0);
    if (totalTailCount > 0) {
      Object.keys(stats.normalCombination.tailDistribution).forEach(tail => {
        const item = stats.normalCombination.tailDistribution[tail];
        if (item) {
          item.probability = (item.count || 0) / totalTailCount;
        }
      });
    }
  }

  static generatePredictionScores(lastSpecial, stats, weights) {
    const scores = {};
    const lastAttr = Formatter.getAttributes(lastSpecial);
    
    for (let num = 1; num <= 49; num++) {
      const attr = Formatter.getAttributes(num);
      let score = 0;
      
      if (stats.zodiacTransfer[lastAttr.zodiac] && stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac]) {
        score += stats.zodiacTransfer[lastAttr.zodiac][attr.zodiac] * 100 * weights.w_zodiac_transfer;
      }
      
      if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
        const relationCount = stats.zodiacRelations.sixHarmony[attr.zodiac] || 0;
        score += (relationCount / Math.max(1, stats.totalRecords)) * 50 * weights.w_zodiac_relation;
      }
      
      if (CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[lastAttr.zodiac]?.includes(attr.zodiac)) {
        const relationCount = stats.zodiacRelations.threeHarmony[attr.zodiac] || 0;
        score += (relationCount / Math.max(1, stats.totalRecords)) * 30 * weights.w_zodiac_relation;
      }
      
      if (stats.colorTransfer[lastAttr.color] && stats.colorTransfer[lastAttr.color][attr.color]) {
        score += stats.colorTransfer[lastAttr.color][attr.color] * 80 * weights.w_color_transfer;
      }
      
      const lastTail = lastSpecial % 10;
      const currentTail = num % 10;
      
      if (stats.tailCorrelation[lastTail] && stats.tailCorrelation[lastTail][currentTail]) {
        score += stats.tailCorrelation[lastTail][currentTail] * 60 * weights.w_tail_correlation;
      }
      
      if (stats.specialFrequency[num]) {
        score += stats.specialFrequency[num] * 40 * weights.w_number_frequency;
      }
      
      const omission = stats.omissionStats[attr.zodiac] || 0;
      let omissionScore = 0;
      if (omission > 20) {
        omissionScore = 50;
      } else if (omission > 10) {
        omissionScore = 30;
      } else if (omission > 5) {
        omissionScore = 10;
      } else if (omission === 0) {
        omissionScore = -20;
      }
      
      score += omissionScore * weights.w_omission_value;
      
      const isBig = num >= 25;
      const isOdd = num % 2 !== 0;
      const shapeType = isBig ? (isOdd ? "bigOdd" : "bigEven") : (isOdd ? "smallOdd" : "smallEven");
      const shapeProbability = (stats.shapeStats[shapeType] || 0) / Math.max(1, stats.totalRecords);
      score += shapeProbability * 25 * weights.w_shape_pattern;
      
      scores[num] = score;
    }
    
    return scores;
  }

  static generateNormalPredictions(stats, weights, excludeNumbers = []) {
    const normalScores = {};
    const excludeSet = new Set(excludeNumbers || []);
    
    for (let num = 1; num <= 49; num++) {
      if (excludeSet.has(num)) {
        normalScores[num] = -999;
        continue;
      }
      
      const attr = Formatter.getAttributes(num);
      let score = 0;
      
      if (stats.normalFrequency[num]) {
        score += stats.normalFrequency[num] * 100 * weights.w_number_frequency;
      }
      
      const colorProb = stats.normalCombination.colorDistribution[attr.color]?.probability || 0;
      score += colorProb * 80 * weights.w_normal_correlation;
      
      const tail = num % 10;
      const tailProb = stats.normalCombination.tailDistribution[tail]?.probability || 0;
      score += tailProb * 60 * weights.w_normal_correlation;
      
      const omission = stats.omissionStats[attr.zodiac] || 0;
      if (omission > 15) {
        score += 40 * weights.w_omission_value;
      } else if (omission > 8) {
        score += 20 * weights.w_omission_value;
      }
      
      let pairScore = 0;
      Object.keys(stats.normalCombination.zodiacPairs || {}).forEach(pair => {
        if (pair.includes(attr.zodiac)) {
          const pairCount = stats.normalCombination.zodiacPairs[pair];
          pairScore += pairCount;
        }
      });
      
      score += (pairScore / Math.max(1, stats.totalRecords)) * 30 * weights.w_normal_correlation;
      
      normalScores[num] = score;
    }
    
    const scoreArray = Object.entries(normalScores)
      .filter(([num, score]) => score > -999)
      .map(([num, score]) => ({
        number: parseInt(num),
        score: score
      }));
    
    scoreArray.sort((a, b) => b.score - a.score);
    
    return scoreArray.slice(0, 6);
  }

  static getTopSpecialPredictions(scores, topN = 10) {
    const scoreArray = Object.entries(scores || {})
      .map(([num, score]) => ({
        number: parseInt(num),
        score: score
      }))
      .filter(item => !isNaN(item.number));
    
    scoreArray.sort((a, b) => b.score - a.score);
    return scoreArray.slice(0, topN);
  }

  static getZodiacPredictions(scores) {
    const zodiacScores = {};
    
    for (let num = 1; num <= 49; num++) {
      const zodiac = Formatter.getAttributes(num).zodiac;
      if (!zodiacScores[zodiac]) {
        zodiacScores[zodiac] = { total: 0, count: 0 };
      }
      zodiacScores[zodiac].total += scores[num] || 0;
      zodiacScores[zodiac].count++;
    }
    
    const zodiacAvgScores = {};
    Object.keys(zodiacScores).forEach(zodiac => {
      zodiacAvgScores[zodiac] = zodiacScores[zodiac].total / Math.max(1, zodiacScores[zodiac].count);
    });
    
    const sortedZodiacs = Object.entries(zodiacAvgScores)
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);
    
    return {
      main: sortedZodiacs.slice(0, 3),
      guard: sortedZodiacs.slice(3, 6),
      scores: zodiacAvgScores
    };
  }

  static getColorPredictions(scores) {
    const colorScores = {};
    
    ['red', 'blue', 'green'].forEach(color => {
      const numbers = CONFIG.COLORS[color] || [];
      let total = 0;
      
      numbers.forEach(num => {
        total += scores[num] || 0;
      });
      
      colorScores[color] = total / Math.max(1, numbers.length);
    });
    
    const sortedColors = Object.entries(colorScores)
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);
    
    return {
      main: sortedColors[0],
      guard: sortedColors[1],
      scores: colorScores
    };
  }

  static getTailPredictions(scores) {
    const tailScores = {};
    
    for (let tail = 0; tail < 10; tail++) {
      let total = 0;
      let count = 0;
      
      for (let num = tail; num <= 49; num += 10) {
        if (num >= 1 && num <= 49) {
          total += scores[num] || 0;
          count++;
        }
      }
      
      if (count > 0) {
        tailScores[tail] = total / count;
      }
    }
    
    const sortedTails = Object.entries(tailScores)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(entry => parseInt(entry[0]));
    
    return sortedTails;
  }
}

// ==============================================================================
// 5. é«˜çº§é¢„æµ‹å¼•æ“ (Advanced Prediction Engine) - å½»åº•ä¿®å¤ç©ºå€¼é—®é¢˜
// ==============================================================================

class AdvancedPredictionEngine {
  static generate(task, historyStats, weights) {
    try {
      const history = task?.history || [];
      
      if (!history || history.length < 2) {
        return this.generateStaticFallback(task);
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = parseInt(lastOpenCode.split(",")[6]) || 1;
      
      const scores = AdvancedStatsEngine.generatePredictionScores(lastSpecial, historyStats, weights);
      
      const topSpecialNumbers = AdvancedStatsEngine.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = AdvancedStatsEngine.getZodiacPredictions(scores);
      const colorPrediction = AdvancedStatsEngine.getColorPredictions(scores);
      const tailPrediction = AdvancedStatsEngine.getTailPredictions(scores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = AdvancedStatsEngine.generateNormalPredictions(historyStats, weights, excludeSpecials);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const bestAttr = Formatter.getAttributes(bestNumber);
      
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      
      const head = Math.floor(bestNumber / 10);
      
      const maxScore = topSpecialNumbers[0]?.score || 50;
      const avgScore = topSpecialNumbers.reduce((sum, item) => sum + (item?.score || 0), 0) / Math.max(1, topSpecialNumbers.length);
      const confidence = Math.min(95, Math.max(30, (maxScore / (avgScore * 1.5)) * 50));

      const formattedNormals = (normalPredictions || []).map(item => {
        const attr = Formatter.getAttributes(item?.number || 1);
        return {
          number: item?.number || 1,
          zodiac: attr.zodiac,
          color: attr.color
        };
      });

      const formattedSpecials = (topSpecialNumbers || []).slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));

      return {
        nextExpect: task?.expect || "2025001",
        zodiac: zodiacPrediction || { main: [], guard: [], scores: {} },
        color: colorPrediction || { main: "red", guard: "blue", scores: {} },
        tail: tailPrediction || [1, 3, 5, 7, 9],
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        exampleNumber: bestNumber,
        exampleZodiac: bestAttr.zodiac,
        exampleColor: bestAttr.color,
        confidence: Math.floor(confidence),
        analysisBased: true,
        totalHistoryRecords: historyStats?.totalRecords || 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V5.4-Fixed"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback(task);
    }
  }

  static generateStaticFallback(task) {
    try {
      const date = new Date();
      const day = date.getDate();
      const hour = date.getHours();
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = (day * hour) % allZodiacs.length;
      const colorIndex = (day + hour) % colors.length;
      
      const mainZodiac = allZodiacs[zodiacIndex] || "é¼ ";
      const mainColor = colors[colorIndex] || "red";
      
      const candidates = CONFIG.ZODIAC_MAP[mainZodiac] || [1, 13, 25, 37, 49];
      const numIndex = hour % candidates.length;
      const exampleNumber = candidates[numIndex] || 1;
      
      let normalNumbers = [];
      const excludeNumbers = [exampleNumber];
      
      for (let i = 0; i < 6; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((excludeNumbers.includes(num) || normalNumbers.find(n => n.number === num)) && attempts < 50);
        
        const attr = Formatter.getAttributes(num);
        normalNumbers.push({
          number: num,
          zodiac: attr.zodiac,
          color: attr.color
        });
        excludeNumbers.push(num);
      }
      
      const isBig = exampleNumber >= 25;
      const isOdd = exampleNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(exampleNumber / 10);
      
      return {
        nextExpect: task?.expect || "2025001",
        zodiac: {
          main: [
            mainZodiac, 
            allZodiacs[(zodiacIndex + 3) % allZodiacs.length] || "å…”",
            allZodiacs[(zodiacIndex + 6) % allZodiacs.length] || "é©¬"
          ],
          guard: [
            allZodiacs[(zodiacIndex + 1) % allZodiacs.length] || "ç‰›",
            allZodiacs[(zodiacIndex + 4) % allZodiacs.length] || "é¾™"
          ],
          scores: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length] || "blue",
          scores: {}
        },
        tail: [1, 3, 5, 7, 9],
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: [{
          number: exampleNumber,
          score: 50,
          zodiac: mainZodiac,
          color: mainColor
        }],
        normalNumbers: normalNumbers,
        exampleNumber: exampleNumber,
        exampleZodiac: mainZodiac,
        exampleColor: mainColor,
        confidence: 20,
        analysisBased: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V5.4-Static"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé™æ€å›é€€é¢„æµ‹æ—¶å‡ºé”™", error);
      
      // ç»ˆæå›é€€
      return {
        nextExpect: task?.expect || "2025001",
        zodiac: { main: ["é¼ ", "é¾™", "çŒ´"], guard: ["ç‰›", "è›‡"], scores: {} },
        color: { main: "red", guard: "blue", scores: {} },
        tail: [1, 3, 5, 7, 9],
        head: "0å¤´",
        shape: "å°å•",
        specialNumbers: [{ number: 1, score: 50, zodiac: "è›‡", color: "red" }],
        normalNumbers: [
          { number: 2, zodiac: "é¾™", color: "red" },
          { number: 3, zodiac: "å…”", color: "blue" },
          { number: 4, zodiac: "è™", color: "blue" },
          { number: 5, zodiac: "ç‰›", color: "green" },
          { number: 6, zodiac: "é¼ ", color: "green" },
          { number: 7, zodiac: "çŒª", color: "red" }
        ],
        exampleNumber: 1,
        exampleZodiac: "è›‡",
        exampleColor: "red",
        confidence: 10,
        analysisBased: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V5.4-Emergency"
      };
    }
  }
}

// ==============================================================================
// 6. æ¶ˆæ¯æ¸²æŸ“å™¨ (UI Renderer) - æ·»åŠ å®‰å…¨ä¿æŠ¤
// ==============================================================================

class MessageRenderer {
  static generateMainMenuKeyboard(isAdmin = false) {
    const keyboard = {
      inline_keyboard: [
        [
          { text: `${CONFIG.EMOJI.preview} é¢„è§ˆé¢„æµ‹`, callback_data: CALLBACK_DATA.PREVIEW },
          { text: `${CONFIG.EMOJI.history} å†å²è®°å½•`, callback_data: CALLBACK_DATA.HISTORY }
        ]
      ]
    };
    
    if (isAdmin) {
      keyboard.inline_keyboard.push([
        { text: `${CONFIG.EMOJI.sync} åŒæ­¥æ•°æ®`, callback_data: CALLBACK_DATA.SYNC },
        { text: `${CONFIG.EMOJI.rocket} æ¨é€é¢„æµ‹`, callback_data: CALLBACK_DATA.PUSH }
      ]);
    }
    
    return keyboard;
  }

  static generateHistoryKeyboard(page, totalPages) {
    const keyboard = { inline_keyboard: [] };
    const navRow = [];
    
    if (page > 1) {
      navRow.push({ text: "â—€ï¸ ä¸Šä¸€é¡µ", callback_data: `${CALLBACK_DATA.HISTORY_PAGE_PREFIX}${page - 1}` });
    }
    
    navRow.push({ text: `ğŸ“„ ${page}/${totalPages}`, callback_data: "current_page" });
    
    if (page < totalPages) {
      navRow.push({ text: "ä¸‹ä¸€é¡µ â–¶ï¸", callback_data: `${CALLBACK_DATA.HISTORY_PAGE_PREFIX}${page + 1}` });
    }
    
    if (navRow.length > 0) {
      keyboard.inline_keyboard.push(navRow);
    }
    
    keyboard.inline_keyboard.push([{ text: "ğŸ”™ è¿”å›ä¸»èœå•", callback_data: CALLBACK_DATA.MAIN_MENU }]);
    
    return keyboard;
  }

  static renderMainMenu(historyCount = 0, lastSync = "") {
    let message = `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n`;
    message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
    message += `ğŸ“Š æ•°æ®ç»Ÿè®¡:\n`;
    message += `â€¢ å†å²è®°å½•: ${historyCount} æœŸ\n`;
    
    if (lastSync) {
      message += `â€¢ æœ€ååŒæ­¥: ${lastSync}\n`;
    }
    
    message += `\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é€‰æ‹©åŠŸèƒ½ï¼š`;
    
    return message;
  }

  static renderPreview(prediction, task = null) {
    try {
      if (!prediction) {
        return "âŒ é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚";
      }
      
      let dataSource = "";
      if (prediction.analysisBased) {
        dataSource = `ğŸ“Š åŸºäº ${prediction.totalHistoryRecords || 0} æœŸå†å²æ•°æ®åˆ†æ`;
      } else {
        dataSource = `âš ï¸ æ— å†å²æ•°æ®ï¼ŒåŸºäºé™æ€ç®—æ³•ç”Ÿæˆ`;
      }
      
      let progressInfo = '';
      if (task) {
        if (task.status === "CALCULATING") {
          const percent = task.targetSims > 0 ? 
            Math.min(100, ((task.currentSims / task.targetSims) * 100).toFixed(0)) : 0;
          const progressBar = Formatter.generateProgressBar(task.currentSims, task.targetSims);
          
          const timeLeft = Math.max(0, task.unlockTime - Date.now());
          const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
          const minutesLeft = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          
          progressInfo = `\nâ³ <b>é¢„æµ‹ç”Ÿæˆä¸­...</b>\n` +
            `${progressBar} ${percent}%\n` +
            `å‰©ä½™: ${hoursLeft}æ—¶ ${minutesLeft}åˆ†`;
        } else if (task.status === "DONE") {
          const sentStatus = task.isSent ? "âœ… å·²æ¨é€" : "ğŸ”„ å¾…æ¨é€";
          progressInfo = `\nâœ… <b>é¢„æµ‹å·²å®Œæˆ</b>\n${sentStatus}`;
        }
      }
      
      const zodiacMain = Array.isArray(prediction.zodiac?.main) ? prediction.zodiac.main : [];
      const zodiacGuard = Array.isArray(prediction.zodiac?.guard) ? prediction.zodiac.guard : [];
      const tail = Array.isArray(prediction.tail) ? prediction.tail : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      
      const content = `
ğŸ”® <b>${CONFIG.SYSTEM.NAME} - é«˜çº§é¢„æµ‹</b>
ç¬¬ <b>${prediction.nextExpect || "æœªçŸ¥"}</b> æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${progressInfo}

ğŸ­ <b>ç”Ÿè‚–æ¨è</b>
${CONFIG.EMOJI.fire} ä¸»æ¨: [ ${zodiacMain.join(" ") || "æš‚æ— "} ]
${CONFIG.EMOJI.shield} é˜²å®ˆ: [ ${zodiacGuard.join(" ") || "æš‚æ— "} ]

ğŸ¨ <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[prediction.color?.main] || ""} / é˜²${CONFIG.EMOJI[prediction.color?.guard] || ""}

ğŸ”¢ <b>ç‰¹ç æ¨è</b>
å¤´æ•°: ${prediction.head || "æœªçŸ¥"} | å°¾æ•°: [ ${tail.join(", ") || "æš‚æ— "} ]
å½¢æ€: ${prediction.shape || "æœªçŸ¥"}

${CONFIG.EMOJI.trophy} <b>é‡‘èƒ†ç¤ºä¾‹</b>: ${prediction.exampleNumber || "æœªçŸ¥"} (${prediction.exampleZodiac || "æœªçŸ¥"}${CONFIG.EMOJI[prediction.exampleColor] || ""})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>${CONFIG.EMOJI.diamond} ç²¾é€‰å¹³ç </b>
${normalNumbers.map((num, idx) => 
  `${idx + 1}. ${num?.number || "æœªçŸ¥"} (${num?.zodiac || "æœªçŸ¥"}${CONFIG.EMOJI[num?.color] || ""})`
).join("\n") || "æš‚æ— æ•°æ®"}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>${CONFIG.EMOJI.star} ç‰¹ç å‰äº”</b>
${specialNumbers.map((num, idx) => 
  `${idx + 1}. ${num?.number || "æœªçŸ¥"} (${num?.zodiac || "æœªçŸ¥"}${CONFIG.EMOJI[num?.color] || ""})`
).join("\n") || "æš‚æ— æ•°æ®"}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ç½®ä¿¡åº¦</b>: ${prediction.confidence || 0}%
<b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ç®—æ³•ç‰ˆæœ¬</b>: ${prediction.algorithmVersion || "æœªçŸ¥"}
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„è§ˆæ—¶å‡ºé”™", error);
      return "âŒ æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚";
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.history} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = parseInt(r.open_code.split(",")[6]);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return "âŒ è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚";
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.sync} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\nğŸ“ <b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
      } else {
        message += `âŒ <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return "âŒ å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚";
    }
  }

  static renderPushResult(success, task, channelPushSuccess = false) {
    try {
      let message = `${CONFIG.EMOJI.rocket} <b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `âœ… <b>æ¨é€æˆåŠŸ</b>\n`;
        message += `æœŸå·: ${task?.expect || "æœªçŸ¥"}\n`;
        message += `ç½®ä¿¡åº¦: ${task?.finalPrediction?.confidence || 0}%\n`;
        
        if (channelPushSuccess) {
          message += `é¢‘é“æ¨é€: æˆåŠŸ âœ…\n`;
        } else {
          message += `é¢‘é“æ¨é€: å¤±è´¥ âŒ\n`;
        }
        
        message += `\nğŸ“Š <b>é¢„æµ‹æ¦‚è§ˆ</b>\n`;
        message += `ç”Ÿè‚–: ${Array.isArray(task?.finalPrediction?.zodiac?.main) ? task.finalPrediction.zodiac.main.join(", ") : "æœªçŸ¥"}\n`;
        message += `æ³¢è‰²: ${CONFIG.EMOJI[task?.finalPrediction?.color?.main] || ""}\n`;
        message += `ç‰¹ç ç¤ºä¾‹: ${task?.finalPrediction?.exampleNumber || "æœªçŸ¥"}\n`;
      } else {
        message += `âŒ <b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return "âŒ å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚";
    }
  }
}

// ==============================================================================
// 7. å¤–éƒ¨æ¥å£å°è£… (External Integrations)
// ==============================================================================

class ExternalService {
  static async sendOrEditMessage(env, chatId, text, keyboard = null, messageId = null, parseMode = "HTML") {
    try {
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };
      
      if (keyboard) body.reply_markup = keyboard;

      let url, method;
      
      if (messageId) {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;
        method = "POST";
        body.message_id = messageId;
      } else {
        url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;
        method = "POST";
      }

      const response = await fetch(url, {
        method: method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendOrEditMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendOrEditMessage network error", error);
      return null;
    }
  }

  static async answerCallbackQuery(env, callbackQueryId, text = "å¤„ç†ä¸­...", showAlert = false) {
    try {
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/answerCallbackQuery`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          callback_query_id: callbackQueryId,
          text: text,
          show_alert: showAlert
        })
      });
      
      return await response.json();
    } catch (error) {
      Logger.error("Telegram", "answerCallbackQuery failed", error);
      return null;
    }
  }

  static async syncHistoryFromUrl(env) {
    if (!env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/5.4',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => parseInt(b.expect) - parseInt(a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => parseInt(r.expect) > parseInt(latestInDB));
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => parseInt(a.expect) - parseInt(b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = parseInt(await DB.getSetting(env, "TOTAL_SYNCS", "0")) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", new Date().toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'}));
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    for (const item of dataArray) {
      try {
        if (item.expect && item.openCode) {
          const expect = item.expect.toString().trim();
          const codeStr = item.openCode.toString().trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => parseInt(n))
            .filter(n => !isNaN(n) && n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(","),
              raw: item
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    for (const item of dataArray) {
      try {
        const expect = (item.expect || item.issue || item.code)?.toString().trim();
        const codeStr = (item.open_code || item.openCode || item.code_number || item.number)?.toString().trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => parseInt(n))
          .filter(n => !isNaN(n) && n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(","),
            raw: item
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 8. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ (Business Logic Controllers)
// ==============================================================================

class Controller {
  static async showMainMenu(env, chatId, messageId = null, isAdmin = false) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const lastSync = await DB.getSetting(env, "LAST_SYNC", "");
      
      const message = MessageRenderer.renderMainMenu(historyCount, lastSync);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(isAdmin);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºä¸»èœå•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºä¸»èœå•ï¼Œè¯·é‡è¯•ã€‚",
        null, messageId
      );
    }
  }

  static async handlePreview(env, chatId, messageId) {
    try {
      Logger.info("Preview", `å¤„ç†é¢„è§ˆè¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      let task = await DB.getTask(env);

      if (!task) {
        const history = await DB.getHistory(env);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendOrEditMessage(
            env, chatId,
            `ğŸ”® <b>${CONFIG.SYSTEM.NAME}</b>\nå½“å‰æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆåŒæ­¥æ•°æ®ã€‚`,
            MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
            messageId
          );
          return;
        }
      }

      const allHistory = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      if (task.status === "CALCULATING") {
        const timePassed = Date.now() - task.startTime;
        const totalDuration = task.unlockTime - task.startTime;
        const progress = Math.min(1, timePassed / totalDuration);
        
        task.currentSims = Math.min(task.targetSims, Math.floor(progress * task.targetSims));
        
        if (Date.now() >= task.unlockTime) {
          task.status = "DONE";
          task.currentSims = task.targetSims;
        }
        
        await DB.saveTask(env, task);
      }

      let prediction;
      if (task.finalPrediction && task.status === "DONE") {
        prediction = task.finalPrediction;
        Logger.info("Preview", `ä½¿ç”¨å·²ä¿å­˜çš„é¢„æµ‹: ${task.expect}`);
      } else {
        const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
        prediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
        
        if (task.status === "DONE") {
          task.finalPrediction = prediction;
          await DB.saveTask(env, task);
          Logger.info("Preview", `é¢„æµ‹å®Œæˆå¹¶ä¿å­˜: ${task.expect}`);
        }
      }

      const message = MessageRenderer.renderPreview(prediction, task);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
      Logger.info("Preview", `é¢„è§ˆæ›´æ–°å®Œæˆ: ${task.expect}, ç½®ä¿¡åº¦: ${prediction.confidence}%`);
      
    } catch (error) {
      Logger.error("Preview", "å¤„ç†é¢„è§ˆå¤±è´¥", error);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç”Ÿæˆé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>\n\nè¯·ç¨åé‡è¯•ã€‚`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleHistory(env, chatId, page = 1, messageId = null) {
    try {
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      const keyboard = MessageRenderer.generateHistoryKeyboard(page, totalPages);

      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
    } catch (error) {
      Logger.error("Controller", "æ˜¾ç¤ºå†å²è®°å½•å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚",
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleSync(env, chatId, messageId) {
    try {
      Logger.info("Sync", `æ‰‹åŠ¨åŒæ­¥è¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.sync} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      const history = await DB.getHistory(env);
      let task = await DB.getTask(env);
      if (!task && history.length > 0) {
        task = await Controller.initTask(env, history);
      } else if (task && history.length > 0) {
        task.history = history.slice(0, 500);
        await DB.saveTask(env, task);
      }
      
      const message = MessageRenderer.renderSyncResult(result);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`,
        MessageRenderer.generateMainMenuKeyboard(chatId === env.TG_ADMIN_ID),
        messageId
      );
    }
  }

  static async handleForcePush(env, chatId, messageId) {
    try {
      let task = await DB.getTask(env);
      
      if (!task) {
        const history = await DB.getHistory(env);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendOrEditMessage(
            env, chatId,
            "âŒ æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆæ¨é€ã€‚è¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚",
            MessageRenderer.generateMainMenuKeyboard(true),
            messageId
          );
          return;
        }
      }

      await ExternalService.sendOrEditMessage(
        env, chatId,
        `${CONFIG.EMOJI.rocket} <b>æ­£åœ¨ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\nè¯·ç¨å€™...`,
        null, messageId
      );

      task.status = "DONE";
      task.currentSims = task.targetSims;
      
      const allHistory = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
      
      task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
      task.isSent = 1;

      await DB.saveTask(env, task);
      
      const totalPushes = parseInt(await DB.getSetting(env, "TOTAL_PUSHES", "0")) + 1;
      await DB.saveSetting(env, "TOTAL_PUSHES", totalPushes.toString());

      let channelPushSuccess = false;
      if (env.TG_CHANNEL_ID) {
        try {
          const channelMessage = MessageRenderer.renderPreview(task.finalPrediction);
          await ExternalService.sendOrEditMessage(env, env.TG_CHANNEL_ID, channelMessage);
          channelPushSuccess = true;
          Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${task.expect}`);
        } catch (error) {
          Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
          channelPushSuccess = false;
        }
      }
      
      const message = MessageRenderer.renderPushResult(true, task, channelPushSuccess);
      const keyboard = MessageRenderer.generateMainMenuKeyboard(true);
      
      await ExternalService.sendOrEditMessage(
        env, chatId, message, keyboard, messageId
      );
      
    } catch (error) {
      Logger.error("Push", "ç«‹å³æ¨é€å¤±è´¥", error);
      await ExternalService.sendOrEditMessage(
        env, chatId,
        `âŒ <b>ç«‹å³æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`,
        MessageRenderer.generateMainMenuKeyboard(true),
        messageId
      );
    }
  }

  static async initTask(env, history) {
    const duration = parseInt(await DB.getSetting(env, "DURATION", CONFIG.SYSTEM.DEFAULT_DURATION));
    
    let nextExpect = "2025001";
    if (history.length > 0) {
      const latestExpect = parseInt(history[0].expect);
      nextExpect = (latestExpect + 1).toString();
    }

    const newTask = {
      startTime: Date.now(),
      unlockTime: Date.now() + duration,
      expect: nextExpect,
      status: "CALCULATING",
      currentSims: 0,
      targetSims: CONFIG.SYSTEM.TARGET_SIMS,
      history: history.slice(0, 500),
      finalPrediction: null,
      isSent: 0,
      predictionVersion: Date.now(),
      algorithmVersion: "V5.4"
    };

    await DB.saveTask(env, newTask);
    Logger.info("Task", `åˆå§‹åŒ–ä»»åŠ¡: æœŸå· ${nextExpect}`);
    return newTask;
  }
}

// ==============================================================================
// 9. äº‹ä»¶å¤„ç†å™¨ (Event Handlers)
// ==============================================================================

async function handleCallback(env, query) {
  const data = query.data;
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;
  const userId = query.from.id;
  
  Logger.info("Callback", `æ”¶åˆ°å›è°ƒ: ${data}`, { chatId, userId });
  
  try {
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†ä¸­...");
  } catch (e) {
    Logger.error("Callback", "å›ç­”å›è°ƒå¤±è´¥", e);
  }
  
  try {
    const isAdmin = (String(userId) === String(env.TG_ADMIN_ID));
    
    if (data === CALLBACK_DATA.MAIN_MENU) {
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
      
    } else if (data === CALLBACK_DATA.PREVIEW) {
      await Controller.handlePreview(env, chatId, messageId);
      
    } else if (data === CALLBACK_DATA.HISTORY) {
      await Controller.handleHistory(env, chatId, 1, messageId);
      
    } else if (data.startsWith(CALLBACK_DATA.HISTORY_PAGE_PREFIX)) {
      const page = parseInt(data.replace(CALLBACK_DATA.HISTORY_PAGE_PREFIX, ''));
      await Controller.handleHistory(env, chatId, page, messageId);
      
    } else if (data === CALLBACK_DATA.SYNC) {
      if (isAdmin) {
        await Controller.handleSync(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === CALLBACK_DATA.PUSH) {
      if (isAdmin) {
        await Controller.handleForcePush(env, chatId, messageId);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æƒé™ä¸è¶³", true);
      }
      
    } else if (data === "current_page") {
      await ExternalService.answerCallbackQuery(env, query.id, "å½“å‰é¡µé¢", true);
      
    } else {
      await ExternalService.answerCallbackQuery(env, query.id, "æœªçŸ¥æ“ä½œ", true);
      await Controller.showMainMenu(env, chatId, messageId, isAdmin);
    }
  } catch (error) {
    Logger.error("Callback", "å¤„ç†å›è°ƒå¤±è´¥", error);
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", true);
  }
}

async function handleUpdate(env, payload) {
  if (payload.callback_query) {
    await handleCallback(env, payload.callback_query);
    return;
  }

  const msg = payload.message;
  if (!msg || !msg.text) return;

  const chatId = msg.chat.id;
  const text = msg.text.trim();
  const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
  
  Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId });
  
  const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
  
  if (text === "/start" || text === "/menu") {
    await Controller.showMainMenu(env, chatId, null, isAdmin);
    return;
  }
  
  if (text.includes("é¢„è§ˆ") || text.includes("é¢„æµ‹")) {
    await Controller.handlePreview(env, chatId, null);
  } else if (text.includes("å†å²") || text.includes("è®°å½•")) {
    await Controller.handleHistory(env, chatId, 1, null);
  } else if (text.includes("åŒæ­¥") && isAdmin) {
    await Controller.handleSync(env, chatId, null);
  } else if (text.includes("æ¨é€") && isAdmin) {
    await Controller.handleForcePush(env, chatId, null);
  } else {
    await Controller.showMainMenu(env, chatId, null, isAdmin);
  }
}

async function handleCronJob(env) {
  Logger.info("Cron", "å¼€å§‹æ‰§è¡Œå®šæ—¶ä»»åŠ¡");
  
  try {
    let task = await DB.getTask(env);
    if (task && task.status === "CALCULATING") {
      const timePassed = Date.now() - task.startTime;
      const totalDuration = task.unlockTime - task.startTime;
      const progress = Math.min(1, timePassed / totalDuration);
      
      task.currentSims = Math.min(task.targetSims, Math.floor(progress * task.targetSims));
      
      if (Date.now() >= task.unlockTime) {
        task.status = "DONE";
        task.currentSims = task.targetSims;
        
        const allHistory = await DB.getAllHistory(env);
        const weights = await DB.getWeights(env);
        const historyStats = AdvancedStatsEngine.analyzeHistoryStatistics(allHistory);
        
        task.finalPrediction = AdvancedPredictionEngine.generate(task, historyStats, weights);
        
        Logger.info("Cron", `ä»»åŠ¡å®Œæˆ: ${task.expect}, ç½®ä¿¡åº¦: ${task.finalPrediction?.confidence || 0}%`);
      }
      
      await DB.saveTask(env, task);
    }
    
    Logger.info("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ");
    
  } catch (error) {
    Logger.error("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå¤±è´¥", error);
  }
}

// ==============================================================================
// 10. Worker å…¥å£ç‚¹ (Entry Point)
// ==============================================================================

export default {
  async scheduled(event, env, ctx) {
    Logger.info("Worker", "å®šæ—¶ä»»åŠ¡è§¦å‘");
    
    const initialized = await DB.init(env);
    if (!initialized) {
      Logger.error("Worker", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œå®šæ—¶ä»»åŠ¡ä¸­æ­¢");
      return;
    }
    
    ctx.waitUntil(handleCronJob(env));
  },

  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
    
    const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
    const missingVars = requiredEnvVars.filter(key => !env[key]);
    
    if (missingVars.length > 0) {
      Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
      return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
    
    CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID;
    CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID;
    
    const initialized = await DB.init(env);
    if (!initialized) {
      return new Response("Database Initialization Failed. Please check D1 binding.", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
    
    if (request.method === "GET") {
      if (url.pathname === '/sync') {
        if (!env.TG_ADMIN_ID) {
          return new Response('æœªé…ç½®ç®¡ç†å‘˜ID', { status: 403 });
        }
        
        try {
          const result = await ExternalService.syncHistoryFromUrl(env);
          
          let html = `<h1>${CONFIG.SYSTEM.NAME} - æ•°æ®åŒæ­¥ç»“æœ</h1>`;
          html += `<style>body{font-family:Arial,sans-serif;margin:40px;line-height:1.6}</style>`;
          
          if (result.success) {
            html += `<p style="color:green;font-weight:bold;">âœ… åŒæ­¥æˆåŠŸ</p>`;
            html += `<p>è·å–æ€»æ•°: ${result.total} æ¡</p>`;
            html += `<p>æˆåŠŸæ–°å¢: ${result.added} æ¡</p>`;
            html += `<p>è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡</p>`;
            
            if (result.newCount > 0) {
              html += `<p style="color:blue;">ğŸ“¢ å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</p>`;
            }
            
            const history = await DB.getHistory(env);
            if (history.length > 0) {
              await Controller.initTask(env, history);
              html += `<p>ğŸ”„ é¢„æµ‹ä»»åŠ¡å·²é‡æ–°åˆå§‹åŒ–</p>`;
            }
          } else {
            html += `<p style="color:red;font-weight:bold;">âŒ åŒæ­¥å¤±è´¥</p>`;
            html += `<p>é”™è¯¯: ${result.error || 'æœªçŸ¥é”™è¯¯'}</p>`;
          }
          
          html += `<hr><p><a href="/">è¿”å›é¦–é¡µ</a></p>`;
          
          return new Response(html, { 
            status: result.success ? 200 : 500,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        } catch (error) {
          return new Response(`åŒæ­¥å‡ºé”™: ${error.message}`, { status: 500 });
        }
      }
      
      return new Response(`
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${CONFIG.SYSTEM.NAME}</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
              max-width: 800px;
              margin: 0 auto;
              padding: 20px;
              line-height: 1.6;
              color: #333;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              min-height: 100vh;
            }
            .container {
              background: white;
              border-radius: 15px;
              padding: 40px;
              box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            }
            h1 {
              color: #2d3748;
              border-bottom: 3px solid #667eea;
              padding-bottom: 10px;
              margin-top: 0;
            }
            .feature-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
              gap: 20px;
              margin: 30px 0;
            }
            .feature-card {
              background: #f7fafc;
              border-left: 4px solid #667eea;
              padding: 20px;
              border-radius: 8px;
            }
            .btn {
              display: inline-block;
              padding: 12px 24px;
              background: #667eea;
              color: white;
              text-decoration: none;
              border-radius: 8px;
              font-weight: bold;
              margin: 10px 5px;
            }
            .version {
              color: #718096;
              font-size: 14px;
              margin-top: 30px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>${CONFIG.SYSTEM.NAME}</h1>
            <p><strong>ç‰ˆæœ¬:</strong> ${CONFIG.SYSTEM.VERSION} - ä¿®å¤ç‰ˆ</p>
            <p>é«˜çº§å…­åˆå½©æ•°æ®åˆ†æä¸é¢„æµ‹ç³»ç»Ÿï¼Œå·²ä¿®å¤æ‰€æœ‰å·²çŸ¥é”™è¯¯ã€‚</p>
            
            <div class="feature-grid">
              <div class="feature-card">
                <h3>ğŸ”§ é”™è¯¯ä¿®å¤</h3>
                <p>å½»åº•ä¿®å¤mapé”™è¯¯å’Œç©ºå€¼é—®é¢˜</p>
              </div>
              <div class="feature-card">
                <h3>ğŸ“± å†…è”äº¤äº’</h3>
                <p>æ‰€æœ‰åŠŸèƒ½é€šè¿‡å†…è”æŒ‰é’®æ“ä½œ</p>
              </div>
              <div class="feature-card">
                <h3>ğŸ¯ ç¨³å®šé¢„æµ‹</h3>
                <p>å¤šå±‚å›é€€æœºåˆ¶ç¡®ä¿ç¨³å®šè¿è¡Œ</p>
              </div>
            </div>
            
            <h3>ä¸»è¦åŠŸèƒ½</h3>
            <ul>
              <li>å†…è”æŒ‰é’®äº¤äº’ - æ‰€æœ‰æ“ä½œåœ¨åŒä¸€æ¶ˆæ¯ä¸­å®Œæˆ</li>
              <li>é«˜çº§é¢„æµ‹åˆ†æ - åŸºäºå†å²æ•°æ®çš„å¤šç»´åº¦ç»Ÿè®¡</li>
              <li>å¹³ç ç‰¹ç æ¨è - å®Œæ•´çš„å·ç æ¨èç³»ç»Ÿ</li>
              <li>å†å²æ•°æ®åŒæ­¥ - è‡ªåŠ¨ä»URLè·å–æœ€æ–°å¼€å¥–è®°å½•</li>
              <li>ç®¡ç†å‘˜åŠŸèƒ½ - æ•°æ®åŒæ­¥ã€é¢„æµ‹æ¨é€</li>
            </ul>
            
            <div>
              <a href="/sync" class="btn">ğŸ”„ æ‰‹åŠ¨åŒæ­¥æ•°æ®</a>
            </div>
            
            <div class="version">
              <p><strong>æŠ€æœ¯æ ˆ:</strong> Cloudflare Workers + D1 Database + Telegram Bot API</p>
              <p><strong>ç®—æ³•ç‰ˆæœ¬:</strong> V5.4 ä¿®å¤ç‰ˆ (å½»åº•è§£å†³mapé”™è¯¯)</p>
              <p><strong>æœ€åæ›´æ–°:</strong> ${new Date().toLocaleDateString('zh-CN')}</p>
            </div>
          </div>
        </body>
        </html>
      `, { 
        status: 200,
        headers: { 
          'Content-Type': 'text/html; charset=utf-8',
          'Cache-Control': 'no-cache'
        }
      });
    }

    if (request.method === "POST") {
      try {
        const payload = await request.json();
        
        ctx.waitUntil(handleUpdate(env, payload));
        
        return new Response("OK", { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      } catch (e) {
        Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
        return new Response("OK", { status: 200 });
      }
    }
    
    return new Response("Method not allowed", { status: 405 });
  }
};
