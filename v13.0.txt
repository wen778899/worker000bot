/**
  * Êæ≥Èó®ÂÖ≠ÂêàÂΩ©È¢ÑÊµãÊú∫Âô®‰∫∫ (Macau Mark Six Prediction Bot)
 * ÁâàÊú¨: V13.0 ÂÖ®Èù¢‰∏ìÂÆ∂ÁÆóÊ≥ïÊï¥ÂêàÁâà
 * 
 * ‰∏ªË¶ÅÊîπËøõ:
 * 1. ÁßªÈô§ÊâÄÊúâÂõæÊ†áÔºåÂè™‰øùÁïôÊ≥¢Ëâ≤Á∫¢ËìùÁªøÂõæÊ†á
 * 2. Ê∑ªÂä†ÂõõÂ§ß‰∏ìÂÆ∂ÁÆóÊ≥ï:
 *    - ÈÅóÊºèÂõûË°•‰∏ìÂÆ∂ (Omission Balancing Expert)
 *    - ÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂ (Association Rules Expert)
 *    - ÈªÑÈáëÂàÜÂâ≤‰∏éÊï∞Âàó‰∏ìÂÆ∂ (Golden Section & Sequence Expert)
 *    - Âå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂ (Zone Balance / Sector Expert)
 * 3. ÂÖ®Èù¢Êï¥ÂêàÂà∞Â¢ûÂº∫È¢ÑÊµãÁÆóÊ≥ï‰∏≠
 * 4. ‰ºòÂåñÁÆóÊ≥ïÊùÉÈáçÂíåËØÑÂàÜÁ≥ªÁªü
 * 5. ÊîπËøõÈ¢ÑÊµãÁ≤æÂ∫¶ÂíåÁ®≥ÂÆöÊÄß
 */

// ==============================================================================
// 1. ÂÖ®Â±ÄÈÖçÁΩÆ‰∏éÂ∏∏ÈáèÂÆö‰πâ
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "üá≤üá¥ Êæ≥ÂÖ≠È¢ÑÊµã",
    VERSION: "V13.0 ÂÖ®Èù¢‰∏ìÂÆ∂ÁÆóÊ≥ïÊï¥ÂêàÁâà",
    TIMEZONE_OFFSET: 8,
    HISTORY_LIMIT: 2000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    MONTECARLO_SIMULATIONS: 10000,
    MONTECARLO_BATCH_SIZE: 2000,
    MONTECARLO_MAX_BATCHES: 5,
    MAX_SIMULATIONS: 50000,
    MIN_SIMULATIONS: 2000,
    MAX_RUNTIME_MS: 10000,
    ASYNC_BATCH_DELAY: 20,
    MAX_SPECIAL_PREDICTIONS: 15,
    MAX_NORMAL_PREDICTIONS: 12,
    MONTE_CACHE_TTL: 5 * 60 * 1000,
    KNN_K_VALUE: 10,
    STATS_WINDOW_SIZE: 100,
    PREDICTION_TIMEOUT: 8000,
    ALGORITHM_TIMEOUTS: {
      traditional: 3000,
      knn: 4000,
      stats: 5000,
      advanced: 8000
    },
    MIN_HISTORY_FOR_ALGORITHMS: {
      traditional: 2,
      knn: 10,
      stats: 20,
      advanced: 5,
      omission: 30,
      association: 50,
      math: 10,
      zone: 20
    },
    MESSAGE_MANAGER_MAX_USERS: 1000,
    MESSAGE_MANAGER_MAX_MESSAGES_PER_USER: 20,
    AUTO_CLEANUP_INTERVAL: 10 * 60 * 1000,
    USER_INACTIVITY_THRESHOLD: 30 * 60 * 1000,
    OMISSION_RATIO_THRESHOLDS: {
      extreme_cold: 2.5,
      cold: 1.5,
      normal: 0.8,
      hot: 0.2
    },
    ASSOCIATION_MIN_SUPPORT: 0.1,
    GOLDEN_RATIO: 0.6180339887,
    ZONE_CONFIGS: {
      seven_zone: [
        [1, 7],    // 1Âå∫: 1-7
        [8, 14],   // 2Âå∫: 8-14
        [15, 21],  // 3Âå∫: 15-21
        [22, 28],  // 4Âå∫: 22-28
        [29, 35],  // 5Âå∫: 29-35
        [36, 42],  // 6Âå∫: 36-42
        [43, 49]   // 7Âå∫: 43-49
      ],
      five_zone: [
        [1, 10],   // 1Âå∫: 1-10
        [11, 20],  // 2Âå∫: 11-20
        [21, 30],  // 3Âå∫: 21-30
        [31, 40],  // 4Âå∫: 31-40
        [41, 49]   // 5Âå∫: 41-49
      ]
    },
    MODULO_ANALYSIS: {
      mod3: [0, 1, 2],
      mod5: [0, 1, 2, 3, 4],
      mod7: [0, 1, 2, 3, 4, 5, 6]
    }
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.5,
    w_zodiac_relation: 2.0,
    w_color_transfer: 1.8,
    w_tail_correlation: 1.5,
    w_number_frequency: 1.3,
    w_monte_carlo: 2.5,
    w_number_pattern: 1.2,
    w_hot_cold: 1.1,
    w_knn_similarity: 2.0,
    w_statistics_analysis: 2.8,
    w_tail_pattern: 1.8,
    w_head_pattern: 1.5,
    w_size_pattern: 1.4,
    w_odd_even_pattern: 1.4,
    w_omission_balancing: 3.0,
    w_association_rules: 2.5,
    w_math_logic: 2.2,
    w_zone_balance: 2.8,
    _version: "13.0"
  },

  ZODIAC_MAP: {
    "Èº†": [6, 18, 30, 42],
    "Áâõ": [5, 17, 29, 41],
    "Ëôé": [4, 16, 28, 40],
    "ÂÖî": [3, 15, 27, 39],
    "Èæô": [2, 14, 26, 38],
    "Ëõá": [1, 13, 25, 37, 49],
    "È©¨": [12, 24, 36, 48],
    "Áæä": [11, 23, 35, 47],
    "Áå¥": [10, 22, 34, 46],
    "È∏°": [9, 21, 33, 45],
    "Áãó": [8, 20, 32, 44],
    "Áå™": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "Èº†": "Áâõ", "Áâõ": "Èº†",
      "Ëôé": "Áå™", "Áå™": "Ëôé",
      "ÂÖî": "Áãó", "Áãó": "ÂÖî",
      "Èæô": "È∏°", "È∏°": "Èæô",
      "Ëõá": "Áå¥", "Áå¥": "Ëõá",
      "È©¨": "Áæä", "Áæä": "È©¨"
    },
    
    THREE_HARMONY: {
      "Èº†": ["Èæô", "Áå¥"],
      "Áâõ": ["Ëõá", "È∏°"],
      "Ëôé": ["È©¨", "Áãó"],
      "ÂÖî": ["Áæä", "Áå™"],
      "Èæô": ["Èº†", "Áå¥"],
      "Ëõá": ["Áâõ", "È∏°"],
      "È©¨": ["Ëôé", "Áãó"],
      "Áæä": ["ÂÖî", "Áå™"],
      "Áå¥": ["Èº†", "Èæô"],
      "È∏°": ["Áâõ", "Ëõá"],
      "Áãó": ["Ëôé", "È©¨"],
      "Áå™": ["ÂÖî", "Áæä"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "üî¥",
    blue: "üîµ",
    green: "üü¢"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    PREDICT: "prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_RESULT: "delete_result"
  },

  ALGORITHM_NAMES: {
    traditional: "‰º†ÁªüÁÆóÊ≥ï",
    knn: "KNNÁÆóÊ≥ï",
    stats: "ÁªüËÆ°ÁÆóÊ≥ï",
    advanced: "Â¢ûÂº∫ÁÆóÊ≥ï",
    omission: "ÈÅóÊºèÂõûË°•‰∏ìÂÆ∂",
    association: "ÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂",
    math: "ÈªÑÈáëÂàÜÂâ≤‰∏ìÂÆ∂",
    zone: "Âå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂"
  }
};

// ==============================================================================
// 2. Â∑•ÂÖ∑Á±ª‰∏éËæÖÂä©ÂáΩÊï∞
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "Êú™Áü•", color: "Êú™Áü•" };
      }
      
      let zodiac = "Êú™Áü•";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "Êú™Áü•";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "Êú™Áü•", color: "Êú™Áü•" };
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "Êú™Áü•Êó∂Èó¥";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static getZoneForNumber(number, zoneType = 'seven_zone') {
    try {
      const zones = CONFIG.SYSTEM.ZONE_CONFIGS[zoneType];
      if (!zones) return -1;
      
      for (let i = 0; i < zones.length; i++) {
        const [start, end] = zones[i];
        if (number >= start && number <= end) {
          return i + 1;
        }
      }
      return -1;
    } catch (error) {
      return -1;
    }
  }

  static getNumbersInZone(zoneId, zoneType = 'seven_zone') {
    try {
      const zones = CONFIG.SYSTEM.ZONE_CONFIGS[zoneType];
      if (!zones || zoneId < 1 || zoneId > zones.length) {
        return [];
      }
      
      const [start, end] = zones[zoneId - 1];
      const numbers = [];
      for (let i = start; i <= end; i++) {
        numbers.push(i);
      }
      return numbers;
    } catch (error) {
      return [];
    }
  }
}

// ==============================================================================
// 3. Ê∂àÊÅØÁÆ°ÁêÜÂô®
// ==============================================================================

class MessageManager {
  static userMessages = new Map();
  static lastCleanupTime = Date.now();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static deleteUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.delete(messageType);
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
}

// ==============================================================================
// 4. ÁºìÂ≠òÁÆ°ÁêÜÂô®
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "ËÆæÁΩÆÁºìÂ≠òÂ§±Ë¥•", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  }
}

// ==============================================================================
// 5. Êï∞ÊçÆÂ∫ìÊìç‰ΩúÂ±Ç
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "ÂºÄÂßãÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂÆåÊàê");
      return true;
      
    } catch (e) {
      Logger.error("DB", "Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `ÂºÄÂßãÊâπÈáèÊ∑ªÂä† ${records.length} Êù°ËÆ∞ÂΩï`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code &&
          Formatter.isValidExpect(record.expect.toString())
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `ÊâπÊ¨°ÊèíÂÖ•Â§±Ë¥•`, chunkError);
          
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `ÂçïÊù°ÊèíÂÖ•Â§±Ë¥• ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `ÊâπÈáèÊ∑ªÂä†ÂÆåÊàê: Ê∑ªÂä† ${totalAdded} Êù°ÔºåË∑≥Ëøá ${totalSkipped} Êù°`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          weights = { ...defaultWeights, ...parsed };
          weights._version = weights._version || "13.0";
        } catch (parseError) {
          Logger.error("DB", "Ëß£ÊûêÊùÉÈáçËÆæÁΩÆÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§", parseError);
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "ÈªòËÆ§ËÆæÁΩÆÂàùÂßãÂåñÂÆåÊàê");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "ÊâãÂä®Âà†Èô§") {
    try {
      Logger.info("DB", `ÂºÄÂßãÂà†Èô§ËÆ∞ÂΩï: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "ÊåáÂÆöËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊâæÂà∞ËÆ∞ÂΩï"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `Âà†Èô§ÂÆåÊàê: Âà†Èô§‰∫Ü ${deletedCount} Êù°ËÆ∞ÂΩï`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `ÊàêÂäüÂà†Èô§ ${deletedCount} Êù°ËÆ∞ÂΩï (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "Âà†Èô§Êìç‰ΩúÂ§±Ë¥•"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  getDeletionStats: async function(env) {
    try {
      const totalResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM deletion_log"
      ).first();
      
      const recordsResult = await env.DB.prepare(
        "SELECT SUM(deleted_count) as total FROM deletion_log"
      ).first();
      
      const recentResult = await env.DB.prepare(
        "SELECT created_at FROM deletion_log ORDER BY created_at DESC LIMIT 1"
      ).first();
      
      return {
        totalDeletions: totalResult ? totalResult.count : 0,
        totalRecordsDeleted: recordsResult ? (recordsResult.total || 0) : 0,
        lastDeletion: recentResult ? recentResult.created_at : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionStats failed", e);
      return {
        totalDeletions: 0,
        totalRecordsDeleted: 0,
        lastDeletion: null
      };
    }
  }
};

// ==============================================================================
// 6. KNNÁÆóÊ≥ïÂÆûÁé∞
// ==============================================================================

class KNNAlgorithm {
  static findSimilarRecords(history, currentRecord, k = CONFIG.SYSTEM.KNN_K_VALUE) {
    try {
      if (!history || !Array.isArray(history) || history.length < 10 || !currentRecord) {
        return [];
      }
      
      const currentFeatures = this.extractFeatures(currentRecord);
      if (!currentFeatures) return [];
      
      const distances = [];
      
      const recentHistory = history.slice(0, Math.min(100, history.length));
      
      for (let i = 1; i < recentHistory.length; i++) {
        const record = recentHistory[i];
        if (!record || !record.open_code) continue;
        
        const recordFeatures = this.extractFeatures(record);
        if (!recordFeatures) continue;
        
        const distance = this.calculateDistance(currentFeatures, recordFeatures);
        const nextRecord = recentHistory[i - 1];
        
        if (nextRecord && nextRecord.open_code) {
          distances.push({
            record: nextRecord,
            distance: distance,
            similarity: 1 / (1 + distance)
          });
        }
      }
      
      distances.sort((a, b) => a.distance - b.distance);
      
      return distances.slice(0, k);
    } catch (error) {
      Logger.error("KNN", "ÂØªÊâæÁõ∏‰ººËÆ∞ÂΩïÂ§±Ë¥•", error);
      return [];
    }
  }
  
  static extractFeatures(record) {
    try {
      if (!record || !record.open_code) return null;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (numbers.length < 7) return null;
      
      const special = numbers[6] || 1;
      const normals = numbers.slice(0, 6);
      
      const specialAttr = Formatter.getAttributes(special);
      const specialFeatures = {
        zodiac: specialAttr.zodiac,
        color: specialAttr.color,
        tail: special % 10,
        head: Math.floor(special / 10),
        isBig: special >= 25,
        isOdd: special % 2 !== 0
      };
      
      const normalFeatures = {
        zodiacCount: {},
        colorCount: {},
        tailCount: {},
        headCount: {},
        sizeCount: { big: 0, small: 0 },
        oddEvenCount: { odd: 0, even: 0 }
      };
      
      for (const num of normals) {
        const attr = Formatter.getAttributes(num);
        normalFeatures.zodiacCount[attr.zodiac] = (normalFeatures.zodiacCount[attr.zodiac] || 0) + 1;
        normalFeatures.colorCount[attr.color] = (normalFeatures.colorCount[attr.color] || 0) + 1;
        
        const tail = num % 10;
        normalFeatures.tailCount[tail] = (normalFeatures.tailCount[tail] || 0) + 1;
        
        const head = Math.floor(num / 10);
        normalFeatures.headCount[head] = (normalFeatures.headCount[head] || 0) + 1;
        
        if (num >= 25) {
          normalFeatures.sizeCount.big++;
        } else {
          normalFeatures.sizeCount.small++;
        }
        
        if (num % 2 !== 0) {
          normalFeatures.oddEvenCount.odd++;
        } else {
          normalFeatures.oddEvenCount.even++;
        }
      }
      
      return {
        special: specialFeatures,
        normals: normalFeatures,
        specialAttr: specialAttr,
        numbers: numbers
      };
    } catch (error) {
      Logger.error("KNN", "ÊèêÂèñÁâπÂæÅÂ§±Ë¥•", error);
      return null;
    }
  }
  
  static calculateDistance(features1, features2) {
    try {
      let distance = 0;
      
      const f1 = features1.special;
      const f2 = features2.special;
      
      if (f1 && f2) {
        if (f1.zodiac === f2.zodiac) {
          distance -= 3;
        } else {
          distance += 1;
        }
        
        if (f1.color === f2.color) {
          distance -= 2;
        } else {
          distance += 0.5;
        }
        
        const tailDiff = Math.abs(f1.tail - f2.tail);
        distance += tailDiff * 0.1;
        
        const headDiff = Math.abs(f1.head - f2.head);
        distance += headDiff * 0.2;
        
        if (f1.isBig !== f2.isBig) {
          distance += 0.5;
        }
        
        if (f1.isOdd !== f2.isOdd) {
          distance += 0.5;
        }
      }
      
      const nf1 = features1.normals;
      const nf2 = features2.normals;
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      for (const zodiac of allZodiacs) {
        const count1 = nf1.zodiacCount[zodiac] || 0;
        const count2 = nf2.zodiacCount[zodiac] || 0;
        distance += Math.abs(count1 - count2) * 0.3;
      }
      
      const colors = ['red', 'blue', 'green'];
      for (const color of colors) {
        const count1 = nf1.colorCount[color] || 0;
        const count2 = nf2.colorCount[color] || 0;
        distance += Math.abs(count1 - count2) * 0.2;
      }
      
      for (let i = 0; i <= 9; i++) {
        const count1 = nf1.tailCount[i] || 0;
        const count2 = nf2.tailCount[i] || 0;
        distance += Math.abs(count1 - count2) * 0.1;
      }
      
      for (let i = 0; i <= 4; i++) {
        const count1 = nf1.headCount[i] || 0;
        const count2 = nf2.headCount[i] || 0;
        distance += Math.abs(count1 - count2) * 0.15;
      }
      
      distance += Math.abs(nf1.sizeCount.big - nf2.sizeCount.big) * 0.2;
      distance += Math.abs(nf1.sizeCount.small - nf2.sizeCount.small) * 0.2;
      
      distance += Math.abs(nf1.oddEvenCount.odd - nf2.oddEvenCount.odd) * 0.1;
      distance += Math.abs(nf1.oddEvenCount.even - nf2.oddEvenCount.even) * 0.1;
      
      return distance;
    } catch (error) {
      Logger.error("KNN", "ËÆ°ÁÆóË∑ùÁ¶ªÂ§±Ë¥•", error);
      return 1000;
    }
  }
  
  static predictFromSimilarRecords(similarRecords) {
    try {
      if (!similarRecords || similarRecords.length === 0) {
        return null;
      }
      
      const predictions = {
        specialNumbers: {},
        zodiacCount: {},
        colorCount: {},
        tailCount: {},
        headCount: {},
        sizeCount: { big: 0, small: 0 },
        oddEvenCount: { odd: 0, even: 0 },
        normalNumbers: {}
      };
      
      for (const item of similarRecords) {
        const record = item.record;
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6] || 1;
        const normals = numbers.slice(0, 6);
        
        predictions.specialNumbers[special] = (predictions.specialNumbers[special] || 0) + item.similarity;
        
        const specialAttr = Formatter.getAttributes(special);
        const specialFeatures = {
          zodiac: specialAttr.zodiac,
          color: specialAttr.color,
          tail: special % 10,
          head: Math.floor(special / 10),
          isBig: special >= 25,
          isOdd: special % 2 !== 0
        };
        
        if (specialAttr.zodiac) {
          predictions.zodiacCount[specialAttr.zodiac] = (predictions.zodiacCount[specialAttr.zodiac] || 0) + item.similarity;
        }
        
        if (specialAttr.color) {
          predictions.colorCount[specialAttr.color] = (predictions.colorCount[specialAttr.color] || 0) + item.similarity;
        }
        
        if (specialFeatures) {
          const tail = specialFeatures.tail;
          predictions.tailCount[tail] = (predictions.tailCount[tail] || 0) + item.similarity;
          
          const head = specialFeatures.head;
          predictions.headCount[head] = (predictions.headCount[head] || 0) + item.similarity;
          
          if (specialFeatures.isBig) {
            predictions.sizeCount.big += item.similarity;
          } else {
            predictions.sizeCount.small += item.similarity;
          }
          
          if (specialFeatures.isOdd) {
            predictions.oddEvenCount.odd += item.similarity;
          } else {
            predictions.oddEvenCount.even += item.similarity;
          }
        }
        
        for (const num of normals) {
          predictions.normalNumbers[num] = (predictions.normalNumbers[num] || 0) + item.similarity * 0.5;
        }
      }
      
      const result = {
        specialCandidates: this.getTopCandidates(predictions.specialNumbers, 10),
        zodiacCandidates: this.getTopCandidates(predictions.zodiacCount, 5),
        colorCandidates: this.getTopCandidates(predictions.colorCount, 3),
        tailCandidates: this.getTopCandidates(predictions.tailCount, 5),
        headCandidates: this.getTopCandidates(predictions.headCount, 3),
        sizePrediction: predictions.sizeCount.big > predictions.sizeCount.small ? "Â§ß" : "Â∞è",
        oddEvenPrediction: predictions.oddEvenCount.odd > predictions.oddEvenCount.even ? "Âçï" : "Âèå",
        normalCandidates: this.getTopCandidates(predictions.normalNumbers, 12)
      };
      
      return result;
    } catch (error) {
      Logger.error("KNN", "‰ªéÁõ∏‰ººËÆ∞ÂΩïÈ¢ÑÊµãÂ§±Ë¥•", error);
      return null;
    }
  }
  
  static getTopCandidates(candidates, limit) {
    try {
      return Object.entries(candidates)
        .map(([key, value]) => ({
          value: key,
          score: value
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, limit)
        .map(item => ({
          value: isNaN(item.value) ? item.value : Formatter.safeInt(item.value),
          score: item.score
        }));
    } catch (error) {
      return [];
    }
  }
}

// ==============================================================================
// 7. Â¢ûÂº∫ÁöÑÁªüËÆ°ÁÆóÊ≥ï
// ==============================================================================

class EnhancedStatistics {
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        return this.createEmptyStats();
      }

      const stats = this.createEmptyStats();
      const maxRecords = Math.min(history.length, CONFIG.SYSTEM.STATS_WINDOW_SIZE);
      const historySlice = history.slice(0, maxRecords);
      
      const processedHistory = this.processHistoryData(historySlice);
      
      if (processedHistory.length < 5) {
        return this.createEmptyStats();
      }
      
      this.analyzeZodiacPatterns(stats, processedHistory);
      this.analyzeColorPatterns(stats, processedHistory);
      this.analyzeTailPatterns(stats, processedHistory);
      this.analyzeHeadPatterns(stats, processedHistory);
      this.analyzeSizePatterns(stats, processedHistory);
      this.analyzeOddEvenPatterns(stats, processedHistory);
      this.analyzeNormalToSpecialPatterns(stats, processedHistory);
      
      this.calculateFrequencies(stats, processedHistory);
      
      stats.totalRecords = processedHistory.length;
      stats.summary = this.generateSummary(stats);
      
      return stats;
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÂéÜÂè≤Êï∞ÊçÆÊó∂Âá∫Èîô", error);
      return this.createEmptyStats();
    }
  }

  static processHistoryData(history) {
    const processed = [];
    
    for (const record of history) {
      if (record && record.open_code) {
        const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (nums.length >= 7) {
          const special = nums[6] || 1;
          const normals = nums.slice(0, 6);
          const attr = Formatter.getAttributes(special);
          
          const normalFeatures = {
            zodiacs: normals.map(n => Formatter.getAttributes(n).zodiac),
            colors: normals.map(n => Formatter.getAttributes(n).color),
            tails: normals.map(n => n % 10),
            heads: normals.map(n => Math.floor(n / 10)),
            sizes: normals.map(n => n >= 25 ? "Â§ß" : "Â∞è"),
            oddEven: normals.map(n => n % 2 !== 0 ? "Âçï" : "Âèå")
          };
          
          processed.push({
            numbers: nums,
            special: special,
            normals: normals,
            zodiac: attr.zodiac,
            color: attr.color,
            tail: special % 10,
            head: Math.floor(special / 10),
            size: special >= 25 ? "Â§ß" : "Â∞è",
            oddEven: special % 2 !== 0 ? "Âçï" : "Âèå",
            normalFeatures: normalFeatures,
            expect: record.expect
          });
        }
      }
    }
    
    return processed;
  }

  static createEmptyStats() {
    return {
      totalRecords: 0,
      zodiacPatterns: {
        sameZodiac: {},
        zodiacGap: {},
        consecutiveZodiac: {},
        zodiacCombinations: {}
      },
      colorPatterns: {
        sameColor: {},
        colorGap: {},
        consecutiveColor: {}
      },
      tailPatterns: {
        tailTransfer: {},
        tailFromNormal: {},
        tailGap: {},
        consecutiveTail: {}
      },
      headPatterns: {
        headTransfer: {},
        headGap: {},
        consecutiveHead: {}
      },
      sizePatterns: {
        sizeTransfer: {},
        sizeGap: {},
        consecutiveSize: {},
        sizeRatio: { big: 0, small: 0 }
      },
      oddEvenPatterns: {
        oddEvenTransfer: {},
        oddEvenGap: {},
        consecutiveOddEven: {},
        oddEvenRatio: { odd: 0, even: 0 }
      },
      normalToSpecial: {
        tailInNormals: {},
        zodiacInNormals: {},
        colorInNormals: {},
        numberInNormals: {}
      },
      frequencies: {
        specialFrequency: {},
        normalFrequency: {},
        zodiacFrequency: {},
        colorFrequency: {},
        tailFrequency: {},
        headFrequency: {},
        sizeFrequency: {},
        oddEvenFrequency: {}
      },
      summary: {}
    };
  }

  static analyzeZodiacPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const key = `${current.zodiac}->${next.zodiac}`;
        stats.zodiacPatterns.sameZodiac[key] = (stats.zodiacPatterns.sameZodiac[key] || 0) + 1;
        
        if (current.zodiac === next.zodiac) {
          stats.zodiacPatterns.consecutiveZodiac[current.zodiac] = (stats.zodiacPatterns.consecutiveZodiac[current.zodiac] || 0) + 1;
        }
        
        for (const normalZodiac of current.normalFeatures.zodiacs) {
          const comboKey = `${normalZodiac}->${next.zodiac}`;
          stats.zodiacPatterns.zodiacCombinations[comboKey] = (stats.zodiacPatterns.zodiacCombinations[comboKey] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.zodiacPatterns.sameZodiac);
      this.calculateProbabilities(stats.zodiacPatterns.zodiacCombinations);
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÁîüËÇñÊ®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static analyzeColorPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const key = `${current.color}->${next.color}`;
        stats.colorPatterns.sameColor[key] = (stats.colorPatterns.sameColor[key] || 0) + 1;
        
        if (current.color === next.color) {
          stats.colorPatterns.consecutiveColor[current.color] = (stats.colorPatterns.consecutiveColor[current.color] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.colorPatterns.sameColor);
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÈ¢úËâ≤Ê®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static analyzeTailPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const tailKey = `${current.tail}->${next.tail}`;
        stats.tailPatterns.tailTransfer[tailKey] = (stats.tailPatterns.tailTransfer[tailKey] || 0) + 1;
        
        for (const normalTail of current.normalFeatures.tails) {
          const tailFromNormalKey = `${normalTail}->${next.tail}`;
          stats.tailPatterns.tailFromNormal[tailFromNormalKey] = (stats.tailPatterns.tailFromNormal[tailFromNormalKey] || 0) + 1;
          
          stats.normalToSpecial.tailInNormals[normalTail] = (stats.normalToSpecial.tailInNormals[normalTail] || 0) + 1;
        }
        
        if (current.tail === next.tail) {
          stats.tailPatterns.consecutiveTail[current.tail] = (stats.tailPatterns.consecutiveTail[current.tail] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.tailPatterns.tailTransfer);
      this.calculateProbabilities(stats.tailPatterns.tailFromNormal);
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÂ∞æÊï∞Ê®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static analyzeHeadPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const headKey = `${current.head}->${next.head}`;
        stats.headPatterns.headTransfer[headKey] = (stats.headPatterns.headTransfer[headKey] || 0) + 1;
        
        if (current.head === next.head) {
          stats.headPatterns.consecutiveHead[current.head] = (stats.headPatterns.consecutiveHead[current.head] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.headPatterns.headTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÂ§¥Êï∞Ê®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static analyzeSizePatterns(stats, processedHistory) {
    try {
      let bigCount = 0;
      let smallCount = 0;
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        if (current.size === "Â§ß") bigCount++;
        else smallCount++;
        
        const sizeKey = `${current.size}->${next.size}`;
        stats.sizePatterns.sizeTransfer[sizeKey] = (stats.sizePatterns.sizeTransfer[sizeKey] || 0) + 1;
        
        if (current.size === next.size) {
          stats.sizePatterns.consecutiveSize[current.size] = (stats.sizePatterns.consecutiveSize[current.size] || 0) + 1;
        }
      }
      
      stats.sizePatterns.sizeRatio = {
        big: bigCount / processedHistory.length,
        small: smallCount / processedHistory.length
      };
      
      this.calculateProbabilities(stats.sizePatterns.sizeTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÂ§ßÂ∞èÊ®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static analyzeOddEvenPatterns(stats, processedHistory) {
    try {
      let oddCount = 0;
      let evenCount = 0;
      
      for (let i = 0; i <processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        if (current.oddEven === "Âçï") oddCount++;
        else evenCount++;
        
        const oddEvenKey = `${current.oddEven}->${next.oddEven}`;
        stats.oddEvenPatterns.oddEvenTransfer[oddEvenKey] = (stats.oddEvenPatterns.oddEvenTransfer[oddEvenKey] || 0) + 1;
        
        if (current.oddEven === next.oddEven) {
          stats.oddEvenPatterns.consecutiveOddEven[current.oddEven] = (stats.oddEvenPatterns.consecutiveOddEven[current.oddEven] || 0) + 1;
        }
      }
      
      stats.oddEvenPatterns.oddEvenRatio = {
        odd: oddCount / processedHistory.length,
        even: evenCount / processedHistory.length
      };
      
      this.calculateProbabilities(stats.oddEvenPatterns.oddEvenTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÂçïÂèåÊ®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static analyzeNormalToSpecialPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        for (const normalNum of current.normals) {
          if (normalNum === next.special) {
            stats.normalToSpecial.numberInNormals[normalNum] = (stats.normalToSpecial.numberInNormals[normalNum] || 0) + 1;
          }
        }
        
        for (const normalZodiac of current.normalFeatures.zodiacs) {
          if (normalZodiac === next.zodiac) {
            stats.normalToSpecial.zodiacInNormals[normalZodiac] = (stats.normalToSpecial.zodiacInNormals[normalZodiac] || 0) + 1;
          }
        }
      }
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÂàÜÊûêÂπ≥Á†ÅÂà∞ÁâπÁ†ÅÊ®°ÂºèÂ§±Ë¥•", error);
    }
  }

  static calculateFrequencies(stats, processedHistory) {
    try {
      for (let i = 1; i <= 49; i++) {
        stats.frequencies.specialFrequency[i] = 0;
        stats.frequencies.normalFrequency[i] = 0;
      }
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        stats.frequencies.zodiacFrequency[zodiac] = 0;
      });
      
      ['red', 'blue', 'green'].forEach(color => {
        stats.frequencies.colorFrequency[color] = 0;
      });
      
      for (let i = 0; i <= 9; i++) {
        stats.frequencies.tailFrequency[i] = 0;
      }
      
      for (let i = 0; i <= 4; i++) {
        stats.frequencies.headFrequency[i] = 0;
      }
      
      stats.frequencies.sizeFrequency = { Â§ß: 0, Â∞è: 0 };
      stats.frequencies.oddEvenFrequency = { Âçï: 0, Âèå: 0 };
      
      for (const record of processedHistory) {
        stats.frequencies.specialFrequency[record.special]++;
        
        for (const num of record.normals) {
          stats.frequencies.normalFrequency[num]++;
        }
        
        stats.frequencies.zodiacFrequency[record.zodiac]++;
        stats.frequencies.colorFrequency[record.color]++;
        stats.frequencies.tailFrequency[record.tail]++;
        stats.frequencies.headFrequency[record.head]++;
        stats.frequencies.sizeFrequency[record.size]++;
        stats.frequencies.oddEvenFrequency[record.oddEven]++;
      }
      
      const total = processedHistory.length;
      for (let i = 1; i <= 49; i++) {
        stats.frequencies.specialFrequency[i] /= total;
        stats.frequencies.normalFrequency[i] /= (total * 6);
      }
      
      Object.keys(stats.frequencies.zodiacFrequency).forEach(zodiac => {
        stats.frequencies.zodiacFrequency[zodiac] /= total;
      });
      
      Object.keys(stats.frequencies.colorFrequency).forEach(color => {
        stats.frequencies.colorFrequency[color] /= total;
      });
      
      Object.keys(stats.frequencies.sizeFrequency).forEach(size => {
        stats.frequencies.sizeFrequency[size] /= total;
      });
      
      Object.keys(stats.frequencies.oddEvenFrequency).forEach(oe => {
        stats.frequencies.oddEvenFrequency[oe] /= total;
      });
    } catch (error) {
      Logger.error("EnhancedStatistics", "ËÆ°ÁÆóÈ¢ëÁéáÂ§±Ë¥•", error);
    }
  }

  static calculateProbabilities(patternMap) {
    try {
      const totals = {};
      
      Object.keys(patternMap).forEach(key => {
        const [from] = key.split('->');
        totals[from] = (totals[from] || 0) + patternMap[key];
      });
      
      Object.keys(patternMap).forEach(key => {
        const [from] = key.split('->');
        if (totals[from] > 0) {
          patternMap[key] = patternMap[key] / totals[from];
        }
      });
    } catch (error) {
      Logger.error("EnhancedStatistics", "ËÆ°ÁÆóÊ¶ÇÁéáÂ§±Ë¥•", error);
    }
  }

  static generateSummary(stats) {
    const summary = {
      strongPatterns: [],
      recommendations: [],
      statistics: {}
    };
    
    try {
      const topZodiacTransfers = Object.entries(stats.zodiacPatterns.sameZodiac)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      topZodiacTransfers.forEach(([key, prob]) => {
        if (prob > 0.2) {
          const [from, to] = key.split('->');
          summary.strongPatterns.push(`‰∏äÊúüÂºÄ${from}Ôºå‰∏ãÊúüÂºÄ${to}ÁöÑÊ¶ÇÁéá‰∏∫${(prob * 100).toFixed(1)}%`);
          summary.recommendations.push(`‰∏äÊúü${from}ÔºåÈáçÁÇπÂÖ≥Ê≥®${to}`);
        }
      });
      
      const topColorTransfers = Object.entries(stats.colorPatterns.sameColor)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2);
      
      topColorTransfers.forEach(([key, prob]) => {
        if (prob > 0.3) {
          const [from, to] = key.split('->');
          summary.strongPatterns.push(`${from}Ëâ≤ËΩ¨Âà∞${to}Ëâ≤ÁöÑÊ¶ÇÁéá‰∏∫${(prob * 100).toFixed(1)}%`);
        }
      });
      
      const topTailFromNormal = Object.entries(stats.tailPatterns.tailFromNormal)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      topTailFromNormal.forEach(([key, prob]) => {
        if (prob > 0.15) {
          const [normalTail, specialTail] = key.split('->');
          summary.strongPatterns.push(`Âπ≥Á†ÅÂ∞æ${normalTail}ÊûÅÂ§ßÂèØËÉΩ‰∏ãÊúüÁâπÁ†ÅÂ∞æ${specialTail} (${(prob * 100).toFixed(1)}%)`);
          summary.recommendations.push(`ÂÖ≥Ê≥®Âπ≥Á†ÅÂ∞æÊï∞${normalTail}ÂØπÂ∫îÁöÑÁâπÁ†ÅÂ∞æÊï∞${specialTail}`);
        }
      });
      
      summary.statistics.sizeRatio = {
        big: (stats.sizePatterns.sizeRatio.big * 100).toFixed(1) + '%',
        small: (stats.sizePatterns.sizeRatio.small * 100).toFixed(1) + '%'
      };
      
      summary.statistics.oddEvenRatio = {
        odd: (stats.oddEvenPatterns.oddEvenRatio.odd * 100).toFixed(1) + '%',
        even: (stats.oddEvenPatterns.oddEvenRatio.even * 100).toFixed(1) + '%'
      };
      
      const topTails = Object.entries(stats.frequencies.tailFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([tail, prob]) => ({ tail, prob: prob * 100 }));
      
      if (topTails.length > 0) {
        summary.statistics.topTails = topTails;
        summary.recommendations.push(`Â∏∏ËßÅÂ∞æÊï∞: ${topTails.map(t => t.tail).join(', ')}`);
      }
      
      const hotNumbers = Object.entries(stats.frequencies.specialFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, prob]) => ({ number: parseInt(num), prob: prob * 100 }));
      
      if (hotNumbers.length > 0) {
        summary.statistics.hotNumbers = hotNumbers;
        summary.recommendations.push(`ÁÉ≠Èó®Âè∑Á†Å: ${hotNumbers.map(n => n.number).join(', ')}`);
      }
      
    } catch (error) {
      Logger.error("EnhancedStatistics", "ÁîüÊàêÁªüËÆ°ÊëòË¶ÅÂ§±Ë¥•", error);
    }
    
    return summary;
  }

  static getPredictionFromStatistics(stats, lastRecord) {
    try {
      if (!stats || !lastRecord) {
        return null;
      }
      
      const prediction = {
        specialNumbers: [],
        zodiacRecommendations: [],
        colorRecommendations: [],
        tailRecommendations: [],
        headRecommendations: [],
        sizePrediction: "",
        oddEvenPrediction: "",
        analysis: []
      };
      
      const lastZodiac = lastRecord.zodiac;
      const lastColor = lastRecord.color;
      const lastTail = lastRecord.tail;
      const lastHead = lastRecord.head;
      const lastSize = lastRecord.size;
      const lastOddEven = lastRecord.oddEven;
      
      if (stats.zodiacPatterns.sameZodiac) {
        const zodiacKeys = Object.keys(stats.zodiacPatterns.sameZodiac)
          .filter(key => key.startsWith(`${lastZodiac}->`))
          .sort((a, b) => stats.zodiacPatterns.sameZodiac[b] - stats.zodiacPatterns.sameZodiac[a])
          .slice(0, 3);
        
        zodiacKeys.forEach(key => {
          const toZodiac = key.split('->')[1];
          const prob = stats.zodiacPatterns.sameZodiac[key];
          
          prediction.zodiacRecommendations.push({
            zodiac: toZodiac,
            probability: prob,
            reason: `‰∏äÊúüÂºÄ${lastZodiac}`
          });
          
          const numbers = CONFIG.ZODIAC_MAP[toZodiac] || [];
          numbers.forEach(num => {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (!existing) {
              prediction.specialNumbers.push({
                number: num,
                probability: prob * 0.5,
                reason: `ÁîüËÇñ${toZodiac} (‰∏äÊúü${lastZodiac})`
              });
            }
          });
        });
      }
      
      if (stats.colorPatterns.sameColor) {
        const colorKeys = Object.keys(stats.colorPatterns.sameColor)
          .filter(key => key.startsWith(`${lastColor}->`))
          .sort((a, b) => stats.colorPatterns.sameColor[b] - stats.colorPatterns.sameColor[a])
          .slice(0, 2);
        
        colorKeys.forEach(key => {
          const toColor = key.split('->')[1];
          const prob = stats.colorPatterns.sameColor[key];
          
          prediction.colorRecommendations.push({
            color: toColor,
            probability: prob,
            reason: `‰∏äÊúü${lastColor}Ëâ≤`
          });
          
          prediction.analysis.push(`È¢úËâ≤‰ªé${lastColor}ËΩ¨Âà∞${toColor}ÁöÑÊ¶ÇÁéá‰∏∫${(prob * 100).toFixed(1)}%`);
        });
      }
      
      if (stats.tailPatterns.tailTransfer) {
        const tailKeys = Object.keys(stats.tailPatterns.tailTransfer)
          .filter(key => key.startsWith(`${lastTail}->`))
          .sort((a, b) => stats.tailPatterns.tailTransfer[b] - stats.tailPatterns.tailTransfer[a])
          .slice(0, 3);
        
        tailKeys.forEach(key => {
          const toTail = parseInt(key.split('->')[1]);
          const prob = stats.tailPatterns.tailTransfer[key];
          
          prediction.tailRecommendations.push({
            tail: toTail,
            probability: prob,
            reason: `‰∏äÊúüÂ∞æ${lastTail}`
          });
          
          for (let num = toTail; num <= 49; num += 10) {
            if (num >= 1 && num <= 49) {
              const existing = prediction.specialNumbers.find(item => item.number === num);
              if (existing) {
                existing.probability += prob * 0.3;
              } else {
                prediction.specialNumbers.push({
                  number: num,
                  probability: prob * 0.3,
                  reason: `Â∞æÊï∞${toTail} (‰∏äÊúüÂ∞æ${lastTail})`
                });
              }
            }
          }
        });
      }
      
      if (stats.tailPatterns.tailFromNormal && lastRecord.normalFeatures) {
        const normalTails = lastRecord.normalFeatures.tails || [];
        normalTails.forEach(tail => {
          const tailKeys = Object.keys(stats.tailPatterns.tailFromNormal)
            .filter(key => key.startsWith(`${tail}->`))
            .sort((a, b) => stats.tailPatterns.tailFromNormal[b] - stats.tailPatterns.tailFromNormal[a])
            .slice(0, 2);
          
          tailKeys.forEach(key => {
            const toTail = parseInt(key.split('->')[1]);
            const prob = stats.tailPatterns.tailFromNormal[key];
            
            if (prob > 0.1) {
              prediction.analysis.push(`Âπ≥Á†ÅÂ∞æÊï∞${tail}ÊûÅÂ§ßÂèØËÉΩ‰∏ãÊúüÁâπÁ†ÅÂ∞æÊï∞${toTail} (${(prob * 100).toFixed(1)}%)`);
              
              for (let num = toTail; num <= 49; num += 10) {
                if (num >= 1 && num <= 49) {
                  const existing = prediction.specialNumbers.find(item => item.number === num);
                  if (existing) {
                    existing.probability += prob * 0.4;
                    existing.reason += `, Âπ≥Á†ÅÂ∞æ${tail}ËΩ¨`;
                  } else {
                    prediction.specialNumbers.push({
                      number: num,
                      probability: prob * 0.4,
                      reason: `Âπ≥Á†ÅÂ∞æ${tail}ËΩ¨Â∞æ${toTail}`
                    });
                  }
                }
              }
            }
          });
        });
      }
      
      if (stats.sizePatterns.sizeTransfer) {
        const sizeKey = `${lastSize}->Â§ß`;
        const sizeProb = stats.sizePatterns.sizeTransfer[sizeKey] || 0;
        
        if (sizeProb > 0.5) {
          prediction.sizePrediction = "Â§ß";
          prediction.analysis.push(`‰∏äÊúü${lastSize}Ôºå‰∏ãÊúüÂ§ßÊ¶ÇÁéáÂºÄÂ§ß (${(sizeProb * 100).toFixed(1)}%)`);
          
          for (let num = 25; num <= 49; num++) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `Â§ßÊ¶ÇÁéáÂºÄÂ§ß`
              });
            }
          }
        } else if (sizeProb < 0.5) {
          prediction.sizePrediction = "Â∞è";
          prediction.analysis.push(`‰∏äÊúü${lastSize}Ôºå‰∏ãÊúüÂ§ßÊ¶ÇÁéáÂºÄÂ∞è (${(100 - sizeProb * 100).toFixed(1)}%)`);
          
          for (let num = 1; num <= 24; num++) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `Â§ßÊ¶ÇÁéáÂºÄÂ∞è`
              });
            }
          }
        }
      }
      
      if (stats.oddEvenPatterns.oddEvenTransfer) {
        const oeKey = `${lastOddEven}->Âçï`;
        const oeProb = stats.oddEvenPatterns.oddEvenTransfer[oeKey] || 0;
        
        if (oeProb > 0.5) {
          prediction.oddEvenPrediction = "Âçï";
          prediction.analysis.push(`‰∏äÊúü${lastOddEven}Ôºå‰∏ãÊúüÂ§ßÊ¶ÇÁéáÂºÄÂçï (${(oeProb * 100).toFixed(1)}%)`);
          
          for (let num = 1; num <= 49; num += 2) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `Â§ßÊ¶ÇÁéáÂºÄÂçï`
              });
            }
          }
        } else if (oeProb < 0.5) {
          prediction.oddEvenPrediction = "Âèå";
          prediction.analysis.push(`‰∏äÊúü${lastOddEven}Ôºå‰∏ãÊúüÂ§ßÊ¶ÇÁéáÂºÄÂèå (${(100 - oeProb * 100).toFixed(1)}%)`);
          
          for (let num = 2; num <= 49; num += 2) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `Â§ßÊ¶ÇÁéáÂºÄÂèå`
              });
            }
          }
        }
      }
      
      prediction.specialNumbers.forEach(item => {
        const freq = stats.frequencies.specialFrequency[item.number] || 0;
        if (freq > 0.03) {
          item.probability *= 1.2;
          item.reason += `, ÁÉ≠Èó®Âè∑Á†Å`;
        } else if (freq < 0.01) {
          item.probability *= 0.8;
          item.reason += `, ÂÜ∑Èó®Âè∑Á†Å`;
        }
      });
      
      prediction.specialNumbers.sort((a, b) => b.probability - a.probability);
      
      const seen = new Set();
      prediction.specialNumbers = prediction.specialNumbers.filter(item => {
        if (seen.has(item.number) || item.probability < 0.01) {
          return false;
        }
        seen.add(item.number);
        return true;
      }).slice(0, 15);
      
      return prediction;
    } catch (error) {
      Logger.error("EnhancedStatistics", "‰ªéÁªüËÆ°ÁîüÊàêÈ¢ÑÊµãÂ§±Ë¥•", error);
      return null;
    }
  }
}

// ==============================================================================
// 8. Êñ∞Â¢ûÔºöÈÅóÊºèÂõûË°•‰∏ìÂÆ∂
// ==============================================================================

class OmissionExpert {
  static async runOmission(history, weights) {
    try {
      if (!history || history.length < 30) {
        Logger.warn("OmissionExpert", "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåË∑≥ËøáÈÅóÊºèÂàÜÊûê");
        return [];
      }
      
      const scores = new Map();
      
      const curGaps = {}; // ÂΩìÂâçÈÅóÊºèÊúüÊï∞
      const totalCounts = {}; // ÊÄªÂá∫Áé∞Ê¨°Êï∞
      const lastSeen = {}; // ÊúÄËøë‰∏ÄÊ¨°Âá∫Áé∞ÁöÑÊúüÊï∞Á¥¢Âºï
      
      // ÂàùÂßãÂåñ
      for (let i = 1; i <= 49; i++) {
        curGaps[i] = history.length; // ÂàùÂßãÂåñ‰∏∫ÂéÜÂè≤ÊÄªÊúüÊï∞
        totalCounts[i] = 0;
        lastSeen[i] = -1;
      }
      
      // ÈÅçÂéÜÂéÜÂè≤ÔºåÁªüËÆ°ÈÅóÊºè
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        // Êõ¥Êñ∞ÊØè‰∏™Âè∑Á†ÅÁöÑÊúÄËøëÂá∫Áé∞‰ΩçÁΩÆ
        for (const num of numbers) {
          if (num >= 1 && num <= 49) {
            // ËÆ°ÁÆóÂΩìÂâçÈÅóÊºèÊúüÊï∞
            if (lastSeen[num] !== -1) {
              const gap = i - lastSeen[num] - 1;
              if (gap > curGaps[num]) {
                curGaps[num] = gap;
              }
            }
            lastSeen[num] = i;
            totalCounts[num]++;
          }
        }
      }
      
      // ËÆ°ÁÆóÂπ≥ÂùáÈÅóÊºèÊúüÊï∞
      const avgGaps = {};
      for (let i = 1; i <= 49; i++) {
        if (totalCounts[i] > 0) {
          avgGaps[i] = Math.max(1, Math.floor(history.length / totalCounts[i]));
        } else {
          avgGaps[i] = history.length; // ‰ªéÊú™Âá∫Áé∞ËøáÁöÑÂè∑Á†Å
        }
      }
      
      // ËÆ°ÁÆóÂõûË°•ÊåáÊï∞Âπ∂ËØÑÂàÜ
      for (let i = 1; i <= 49; i++) {
        const currentGap = curGaps[i];
        const avgGap = avgGaps[i];
        
        let ratio = 0;
        if (avgGap > 0) {
          ratio = currentGap / avgGap;
        }
        
        let score = 0;
        
        // Âü∫‰∫éÂõûË°•ÊåáÊï∞ÁöÑËØÑÂàÜÈÄªËæë
        if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.extreme_cold) {
          score = 100; // ÊûÅÂÜ∑ÂõûË°•
        } else if (ratio >= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.cold) {
          score = 70; // ÂÅèÂÜ∑ÂõûË°•
        } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.hot) {
          score = 30; // ÊûÅÁÉ≠ËøûÂ∫Ñ
        } else if (ratio <= CONFIG.SYSTEM.OMISSION_RATIO_THRESHOLDS.normal) {
          score = 50; // Ê≠£Â∏∏ËåÉÂõ¥
        } else {
          score = 40; // ÂÅèÁÉ≠
        }
        
        // Â¶ÇÊûúÂè∑Á†Å‰ªéÊú™Âá∫Áé∞Ëøá
        if (totalCounts[i] === 0) {
          score = 80; // ‰ªéÊú™Âá∫Áé∞ËøáÁöÑÂè∑Á†ÅÔºå‰∏≠Á≠âÊùÉÈáç
        }
        
        // Â∫îÁî®ÊùÉÈáç
        score *= weights.w_omission_balancing;
        
        scores.set(i, score);
      }
      
      // ÂΩí‰∏ÄÂåñÂàÜÊï∞
      const normalizedScores = this.normalizeScores(scores, "omission");
      
      return {
        scores: normalizedScores,
        curGaps: curGaps,
        avgGaps: avgGaps
      };
    } catch (error) {
      Logger.error("OmissionExpert", "ÈÅóÊºèÂàÜÊûêÂ§±Ë¥•", error);
      return {
        scores: [],
        curGaps: {},
        avgGaps: {}
      };
    }
  }
  
  static normalizeScores(scoresMap, algorithmName) {
    try {
      const scores = Array.from(scoresMap.entries()).map(([number, score]) => ({ number, score }));
      
      if (scores.length === 0) {
        return scores;
      }
      
      const maxScore = Math.max(...scores.map(s => s.score));
      const minScore = Math.min(...scores.map(s => s.score));
      const range = maxScore - minScore;
      
      if (range === 0) {
        return scores.map(s => ({ number: s.number, score: 50 }));
      }
      
      return scores.map(s => ({
        number: s.number,
        score: Math.round(((s.score - minScore) / range) * 100),
        rawScore: s.score,
        algorithm: algorithmName
      }));
    } catch (error) {
      Logger.error("OmissionExpert", "ÂΩí‰∏ÄÂåñÂàÜÊï∞Â§±Ë¥•", error);
      return Array.from(scoresMap.entries()).map(([number, score]) => ({ 
        number, 
        score: Math.min(100, Math.max(0, score)),
        rawScore: score,
        algorithm: algorithmName
      }));
    }
  }
}

// ==============================================================================
// 9. Êñ∞Â¢ûÔºöÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂
// ==============================================================================

class AssociationExpert {
  static async runAssociation(history, weights) {
    try {
      if (!history || history.length < 50) {
        Logger.warn("AssociationExpert", "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåË∑≥ËøáÂÖ≥ËÅîÂàÜÊûê");
        return [];
      }
      
      const lastRecord = history[0];
      if (!lastRecord || !lastRecord.open_code) {
        return [];
      }
      
      const lastNumbers = lastRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (lastNumbers.length < 7) {
        return [];
      }
      
      const scores = new Map();
      
      // ÁÆÄÂåñÁâàÂÖ≥ËÅîËßÑÂàôÂàÜÊûê
      const associationRules = this.findAssociationRules(history, lastNumbers);
      
      // Ê†πÊçÆÂÖ≥ËÅîËßÑÂàôËØÑÂàÜ
      for (const [number, confidence] of associationRules) {
        let score = confidence * 100 * weights.w_association_rules;
        
        if (confidence > 0.3) {
          score *= 1.5;
        } else if (confidence > 0.2) {
          score *= 1.2;
        }
        
        scores.set(number, score);
      }
      
      // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞Âº∫ÂÖ≥ËÅîÔºå‰ΩøÁî®ÁÆÄÂåñËßÑÂàô
      if (scores.size === 0) {
        this.applySimpleAssociationRules(scores, lastNumbers, weights);
      }
      
      // ÂΩí‰∏ÄÂåñÂàÜÊï∞
      const normalizedScores = this.normalizeScores(scores, "association");
      
      return {
        scores: normalizedScores,
        associationRules: Array.from(associationRules.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
      };
    } catch (error) {
      Logger.error("AssociationExpert", "ÂÖ≥ËÅîÂàÜÊûêÂ§±Ë¥•", error);
      return {
        scores: [],
        associationRules: []
      };
    }
  }
  
  static findAssociationRules(history, lastNumbers) {
    const rules = new Map();
    
    try {
      const nextNumberFreq = new Map();
      const numberFreq = new Map();
      
      for (let i = 1; i < history.length; i++) {
        const currentRecord = history[i];
        const nextRecord = history[i - 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNumbers = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        // ÁªüËÆ°ÂΩìÂâçÊúüÊØè‰∏™Âè∑Á†ÅÁöÑÂá∫Áé∞
        for (const num of currentNumbers) {
          numberFreq.set(num, (numberFreq.get(num) || 0) + 1);
        }
        
        // ÁªüËÆ°ÂΩìÂâçÊúüÂè∑Á†Å‰∏é‰∏ãÊúüÂè∑Á†ÅÁöÑÂÖ≥ËÅî
        for (const currentNum of currentNumbers) {
          if (!nextNumberFreq.has(currentNum)) {
            nextNumberFreq.set(currentNum, new Map());
          }
          
          const nextMap = nextNumberFreq.get(currentNum);
          for (const nextNum of nextNumbers) {
            nextMap.set(nextNum, (nextMap.get(nextNum) || 0) + 1);
          }
        }
      }
      
      // ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶
      for (const lastNum of lastNumbers) {
        const nextMap = nextNumberFreq.get(lastNum);
        if (!nextMap) continue;
        
        const support = numberFreq.get(lastNum) || 0;
        
        for (const [nextNum, freq] of nextMap.entries()) {
          const confidence = freq / support;
          
          if (confidence >= CONFIG.SYSTEM.ASSOCIATION_MIN_SUPPORT) {
            const currentConfidence = rules.get(nextNum) || 0;
            rules.set(nextNum, Math.max(currentConfidence, confidence));
          }
        }
      }
      
    } catch (error) {
      Logger.error("AssociationExpert", "Êü•ÊâæÂÖ≥ËÅîËßÑÂàôÂ§±Ë¥•", error);
    }
    
    return rules;
  }
  
  static applySimpleAssociationRules(scores, lastNumbers, weights) {
    try {
      // ÁÆÄÂçïÂÖ≥ËÅîËßÑÂàôÔºöÂü∫‰∫é‰∏äÊúüÂè∑Á†ÅÁöÑÁõ∏ÈÇªÂè∑Á†Å
      for (const num of lastNumbers) {
        // Áõ∏ÈÇªÂè∑Á†Å
        const adjacentNumbers = [
          num - 1 >= 1 ? num - 1 : null,
          num + 1 <= 49 ? num + 1 : null,
          num - 10 >= 1 ? num - 10 : null,
          num + 10 <= 49 ? num + 10 : null
        ].filter(n => n !== null);
        
        for (const adjNum of adjacentNumbers) {
          const currentScore = scores.get(adjNum) || 0;
          scores.set(adjNum, currentScore + 40 * weights.w_association_rules);
        }
        
        // ÂêåÂ∞æÊï∞Âè∑Á†Å
        const tail = num % 10;
        for (let i = tail; i <= 49; i += 10) {
          if (i !== num && i >= 1 && i <= 49) {
            const currentScore = scores.get(i) || 0;
            scores.set(i, currentScore + 30 * weights.w_association_rules);
          }
        }
      }
    } catch (error) {
      Logger.error("AssociationExpert", "Â∫îÁî®ÁÆÄÂçïÂÖ≥ËÅîËßÑÂàôÂ§±Ë¥•", error);
    }
  }
  
  static normalizeScores(scoresMap, algorithmName) {
    try {
      const scores = Array.from(scoresMap.entries()).map(([number, score]) => ({ number, score }));
      
      if (scores.length === 0) {
        return scores;
      }
      
      const maxScore = Math.max(...scores.map(s => s.score));
      const minScore = Math.min(...scores.map(s => s.score));
      const range = maxScore - minScore;
      
      if (range === 0) {
        return scores.map(s => ({ number: s.number, score: 50 }));
      }
      
      return scores.map(s => ({
        number: s.number,
        score: Math.round(((s.score - minScore) / range) * 100),
        rawScore: s.score,
        algorithm: algorithmName
      }));
    } catch (error) {
      Logger.error("AssociationExpert", "ÂΩí‰∏ÄÂåñÂàÜÊï∞Â§±Ë¥•", error);
      return Array.from(scoresMap.entries()).map(([number, score]) => ({ 
        number, 
        score: Math.min(100, Math.max(0, score)),
        rawScore: score,
        algorithm: algorithmName
      }));
    }
  }
}

// ==============================================================================
// 10. Êñ∞Â¢ûÔºöÈªÑÈáëÂàÜÂâ≤‰∏éÊï∞Âàó‰∏ìÂÆ∂
// ==============================================================================

class MathLogicExpert {
  static async runMathLogic(history, weights) {
    try {
      if (!history || history.length < 10) {
        Logger.warn("MathLogicExpert", "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåË∑≥ËøáÊï∞Â≠¶ÈÄªËæëÂàÜÊûê");
        return [];
      }
      
      const lastRecord = history[0];
      if (!lastRecord || !lastRecord.open_code) {
        return [];
      }
      
      const lastNumbers = lastRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (lastNumbers.length < 7) {
        return [];
      }
      
      const lastSpecial = lastNumbers[6];
      
      const scores = new Map();
      
      // 1. ÈªÑÈáëÂàÜÂâ≤ÁÇπÈ¢ÑÊµã
      this.applyGoldenRatio(scores, lastSpecial, weights);
      
      // 2. ÂíåÂÄºÂùáÁ∫øÂàÜÊûê
      this.applySumAverage(scores, history, weights);
      
      // 3. Ê®°ËøêÁÆóÂàÜÊûê
      this.applyModuloAnalysis(scores, history, weights);
      
      // 4. ÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁõ∏ÂÖ≥
      this.applyFibonacci(scores, lastSpecial, weights);
      
      // ÂΩí‰∏ÄÂåñÂàÜÊï∞
      const normalizedScores = this.normalizeScores(scores, "math");
      
      return {
        scores: normalizedScores
      };
    } catch (error) {
      Logger.error("MathLogicExpert", "Êï∞Â≠¶ÈÄªËæëÂàÜÊûêÂ§±Ë¥•", error);
      return {
        scores: []
      };
    }
  }
  
  static applyGoldenRatio(scores, lastSpecial, weights) {
    try {
      const goldenRatio = CONFIG.SYSTEM.GOLDEN_RATIO;
      
      // ÈªÑÈáëÂàÜÂâ≤ÁÇπËÆ°ÁÆó
      const goldenPoint1 = Math.round(lastSpecial * goldenRatio);
      const goldenPoint2 = Math.round(lastSpecial / goldenRatio);
      const goldenPoint3 = Math.round(lastSpecial * (1 + goldenRatio)) % 49 || 1;
      const goldenPoint4 = Math.round(lastSpecial * (1 - goldenRatio)) || 1;
      
      // Á°Æ‰øùÊï∞ÂÄºÂú®1-49ËåÉÂõ¥ÂÜÖ
      const goldenPoints = [
        Math.max(1, Math.min(49, goldenPoint1)),
        Math.max(1, Math.min(49, goldenPoint2)),
        Math.max(1, Math.min(49, goldenPoint3)),
        Math.max(1, Math.min(49, goldenPoint4))
      ];
      
      // ÂéªÈáç
      const uniquePoints = [...new Set(goldenPoints)];
      
      // ‰∏∫ÈªÑÈáëÂàÜÂâ≤ÁÇπÂä†ÂàÜ
      for (const point of uniquePoints) {
        const currentScore = scores.get(point) || 0;
        scores.set(point, currentScore + 80 * weights.w_math_logic);
        
        // Áõ∏ÈÇªÂè∑Á†Å‰πüÈÄÇÂΩìÂä†ÂàÜ
        const adjacent = [point - 1, point + 1].filter(n => n >= 1 && n <= 49);
        for (const adj of adjacent) {
          const adjScore = scores.get(adj) || 0;
          scores.set(adj, adjScore + 20 * weights.w_math_logic);
        }
      }
      
    } catch (error) {
      Logger.error("MathLogicExpert", "Â∫îÁî®ÈªÑÈáëÂàÜÂâ≤Â§±Ë¥•", error);
    }
  }
  
  static applySumAverage(scores, history, weights) {
    try {
      // ËÆ°ÁÆóÊúÄËøë5ÊúüÁöÑÂíåÂÄº
      const recentSums = [];
      for (let i = 0; i < Math.min(5, history.length); i++) {
        const record = history[i];
        if (record && record.open_code) {
          const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const sum = numbers.reduce((a, b) => a + b, 0);
          recentSums.push(sum);
        }
      }
      
      if (recentSums.length < 3) return;
      
      // ËÆ°ÁÆóÂíåÂÄºÁßªÂä®Âπ≥Âùá
      const sumAvg = recentSums.reduce((a, b) => a + b, 0) / recentSums.length;
      
      // Âà§Êñ≠ÂíåÂÄºË∂ãÂäø
      const lastSum = recentSums[0];
      const prevSum = recentSums[1] || lastSum;
      const trend = lastSum - prevSum;
      
      // Ê†πÊçÆÂíåÂÄºË∂ãÂäøË∞ÉÊï¥Âè∑Á†ÅËØÑÂàÜ
      const avgNumber = Math.round(sumAvg / 7);
      
      for (let i = 1; i <= 49; i++) {
        const currentScore = scores.get(i) || 0;
        let adjustment = 0;
        
        if (trend > 10) {
          if (i >= avgNumber) {
            adjustment = 30;
          }
        } else if (trend < -10) {
          if (i <= avgNumber) {
            adjustment = 30;
          }
        } else {
          if (Math.abs(i - avgNumber) <= 5) {
            adjustment = 20;
          }
        }
        
        scores.set(i, currentScore + adjustment * weights.w_math_logic);
      }
      
    } catch (error) {
      Logger.error("MathLogicExpert", "Â∫îÁî®ÂíåÂÄºÂùáÁ∫øÂ§±Ë¥•", error);
    }
  }
  
  static applyModuloAnalysis(scores, history, weights) {
    try {
      // ÁªüËÆ°ÊúÄËøë10ÊúüÂêÑÁßçÊ®°Êï∞ÁöÑÂàÜÂ∏É
      const mod3Count = { 0: 0, 1: 0, 2: 0 };
      const mod5Count = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
      
      const recentHistory = history.slice(0, Math.min(10, history.length));
      
      for (const record of recentHistory) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        for (const num of numbers) {
          mod3Count[num % 3] = (mod3Count[num % 3] || 0) + 1;
          mod5Count[num % 5] = (mod5Count[num % 5] || 0) + 1;
        }
      }
      
      // ÊâæÂá∫Áº∫Â§±ÁöÑÊ®°Êï∞
      const totalNumbers = recentHistory.length * 7;
      const mod3Avg = totalNumbers / 3;
      const mod5Avg = totalNumbers / 5;
      
      // ËÆ°ÁÆóÊØè‰∏™Ê®°Êï∞ÁöÑÁº∫Â§±Á®ãÂ∫¶
      const mod3Deficit = {};
      const mod5Deficit = {};
      
      for (const mod of CONFIG.SYSTEM.MODULO_ANALYSIS.mod3) {
        mod3Deficit[mod] = mod3Avg - (mod3Count[mod] || 0);
      }
      
      for (const mod of CONFIG.SYSTEM.MODULO_ANALYSIS.mod5) {
        mod5Deficit[mod] = mod5Avg - (mod5Count[mod] || 0);
      }
      
      // ‰∏∫Áº∫Â§±Ê®°Êï∞ÁöÑÂè∑Á†ÅÂä†ÂàÜ
      for (let i = 1; i <= 49; i++) {
        const mod3 = i % 3;
        const mod5 = i % 5;
        
        const mod3Score = Math.max(0, mod3Deficit[mod3] || 0) * 5;
        const mod5Score = Math.max(0, mod5Deficit[mod5] || 0) * 3;
        
        const currentScore = scores.get(i) || 0;
        scores.set(i, currentScore + (mod3Score + mod5Score) * weights.w_math_logic);
      }
      
    } catch (error) {
      Logger.error("MathLogicExpert", "Â∫îÁî®Ê®°ËøêÁÆóÂàÜÊûêÂ§±Ë¥•", error);
    }
  }
  
  static applyFibonacci(scores, lastSpecial, weights) {
    try {
      // ÊñêÊ≥¢ÈÇ£Â•ëÊï∞Âàó
      const fibonacci = [1, 1, 2, 3, 5, 8, 13, 21, 34];
      
      // ÊâæÂá∫‰∏éÊñêÊ≥¢ÈÇ£Â•ëÊï∞Áõ∏ÂÖ≥ÁöÑÂè∑Á†Å
      for (const fib of fibonacci) {
        if (fib > 49) break;
        
        // Áõ¥Êé•ÊòØÊñêÊ≥¢ÈÇ£Â•ëÊï∞
        const currentScore = scores.get(fib) || 0;
        scores.set(fib, currentScore + 40 * weights.w_math_logic);
        
        // ‰∏é‰∏äÊúüÁâπÁ†ÅÁöÑÊñêÊ≥¢ÈÇ£Â•ëÂÖ≥Á≥ª
        const diff = Math.abs(lastSpecial - fib);
        if (fibonacci.includes(diff)) {
          const adjScore = scores.get(fib) || 0;
          scores.set(fib, adjScore + 20 * weights.w_math_logic);
        }
        
        // Áõ∏ÈÇªÁöÑÊñêÊ≥¢ÈÇ£Â•ëÊï∞
        const prevFib = fibonacci[fibonacci.indexOf(fib) - 1];
        const nextFib = fibonacci[fibonacci.indexOf(fib) + 1];
        
        if (prevFib && prevFib >= 1 && prevFib <= 49) {
          const prevScore = scores.get(prevFib) || 0;
          scores.set(prevFib, prevScore + 20 * weights.w_math_logic);
        }
        
        if (nextFib && nextFib >= 1 && nextFib <= 49) {
          const nextScore = scores.get(nextFib) || 0;
          scores.set(nextFib, nextScore + 20 * weights.w_math_logic);
        }
      }
      
    } catch (error) {
      Logger.error("MathLogicExpert", "Â∫îÁî®ÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÂ§±Ë¥•", error);
    }
  }
  
  static normalizeScores(scoresMap, algorithmName) {
    try {
      const scores = Array.from(scoresMap.entries()).map(([number, score]) => ({ number, score }));
      
      if (scores.length === 0) {
        return scores;
      }
      
      const maxScore = Math.max(...scores.map(s => s.score));
      const minScore = Math.min(...scores.map(s => s.score));
      const range = maxScore - minScore;
      
      if (range === 0) {
        return scores.map(s => ({ number: s.number, score: 50 }));
      }
      
      return scores.map(s => ({
        number: s.number,
        score: Math.round(((s.score - minScore) / range) * 100),
        rawScore: s.score,
        algorithm: algorithmName
      }));
    } catch (error) {
      Logger.error("MathLogicExpert", "ÂΩí‰∏ÄÂåñÂàÜÊï∞Â§±Ë¥•", error);
      return Array.from(scoresMap.entries()).map(([number, score]) => ({ 
        number, 
        score: Math.min(100, Math.max(0, score)),
        rawScore: score,
        algorithm: algorithmName
      }));
    }
  }
}

// ==============================================================================
// 11. Êñ∞Â¢ûÔºöÂå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂
// ==============================================================================

class ZoneBalanceExpert {
  static async runZoneBalance(history, weights) {
    try {
      if (!history || history.length < 20) {
        Logger.warn("ZoneBalanceExpert", "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåË∑≥ËøáÂéªÈó¥Âπ≥Ë°°ÂàÜÊûê");
        return [];
      }
      
      const scores = new Map();
      
      // ÂàÜÊûê‰∏ÉÂå∫ÂàÜÂ∏É
      const zone7Analysis = this.analyzeZoneDistribution(history, 'seven_zone');
      
      // ÂàÜÊûê‰∫îÂå∫ÂàÜÂ∏É
      const zone5Analysis = this.analyzeZoneDistribution(history, 'five_zone');
      
      // Ê†πÊçÆÂå∫Èó¥ÂàÜÊûêÁªìÊûúËØÑÂàÜ
      this.scoreBasedOnZoneAnalysis(scores, zone7Analysis, zone5Analysis, weights);
      
      // Ê£ÄÊü•Êñ≠Âå∫
      this.scoreBasedOnZoneGaps(scores, history, weights);
      
      // Ê£ÄÊü•ËøáÁÉ≠Âå∫Èó¥
      this.scoreBasedOnZoneHeat(scores, history, weights);
      
      // ÂΩí‰∏ÄÂåñÂàÜÊï∞
      const normalizedScores = this.normalizeScores(scores, "zone");
      
      return {
        scores: normalizedScores,
        zone7Analysis: zone7Analysis,
        zone5Analysis: zone5Analysis
      };
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "Âå∫Èó¥Âπ≥Ë°°ÂàÜÊûêÂ§±Ë¥•", error);
      return {
        scores: [],
        zone7Analysis: {},
        zone5Analysis: {}
      };
    }
  }
  
  static analyzeZoneDistribution(history, zoneType) {
    try {
      const zones = CONFIG.SYSTEM.ZONE_CONFIGS[zoneType];
      if (!zones) return {};
      
      const analysis = {
        zoneCounts: {},
        recentCounts: {},
        gaps: {},
        heatLevels: {}
      };
      
      // ÂàùÂßãÂåñ
      for (let i = 1; i <= zones.length; i++) {
        analysis.zoneCounts[i] = 0;
        analysis.recentCounts[i] = 0;
        analysis.gaps[i] = 0;
        analysis.heatLevels[i] = 0;
      }
      
      // ÁªüËÆ°ÊÄªÂá∫Áé∞Ê¨°Êï∞
      for (const record of history) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const zoneSet = new Set();
        
        for (const num of numbers) {
          const zoneId = Formatter.getZoneForNumber(num, zoneType);
          if (zoneId !== -1) {
            analysis.zoneCounts[zoneId]++;
            zoneSet.add(zoneId);
          }
        }
        
        // Êõ¥Êñ∞ÊØè‰∏™Âå∫Èó¥ÁöÑÈÅóÊºèÊúüÊï∞
        for (let zoneId = 1; zoneId <= zones.length; zoneId++) {
          if (zoneSet.has(zoneId)) {
            analysis.gaps[zoneId] = 0;
          } else {
            analysis.gaps[zoneId]++;
          }
        }
      }
      
      // ÁªüËÆ°ÊúÄËøë10ÊúüÁöÑÂá∫Áé∞Ê¨°Êï∞
      const recentHistory = history.slice(0, Math.min(10, history.length));
      for (const record of recentHistory) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const zoneSet = new Set();
        
        for (const num of numbers) {
          const zoneId = Formatter.getZoneForNumber(num, zoneType);
          if (zoneId !== -1) {
            analysis.recentCounts[zoneId]++;
            zoneSet.add(zoneId);
          }
        }
      }
      
      // ËÆ°ÁÆóÁÉ≠Â∫¶Á∫ßÂà´
      const maxRecent = Math.max(...Object.values(analysis.recentCounts));
      for (let zoneId = 1; zoneId <= zones.length; zoneId++) {
        if (maxRecent > 0) {
          analysis.heatLevels[zoneId] = analysis.recentCounts[zoneId] / maxRecent;
        }
      }
      
      // ËÆ°ÁÆóÊúüÊúõÂÄº
      const totalNumbers = history.length * 7;
      analysis.expectedPerZone = totalNumbers / zones.length;
      
      // ËÆ°ÁÆóÂÅèÂ∑Æ
      analysis.deviations = {};
      for (let zoneId = 1; zoneId <= zones.length; zoneId++) {
        analysis.deviations[zoneId] = analysis.zoneCounts[zoneId] - analysis.expectedPerZone;
      }
      
      return analysis;
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "ÂàÜÊûêÂå∫Èó¥ÂàÜÂ∏ÉÂ§±Ë¥•", error);
      return {};
    }
  }
  
  static scoreBasedOnZoneAnalysis(scores, zone7Analysis, zone5Analysis, weights) {
    try {
      // Âü∫‰∫é‰∏ÉÂå∫ÂàÜÊûêËØÑÂàÜ
      if (zone7Analysis.zoneCounts && zone7Analysis.deviations) {
        const zones = CONFIG.SYSTEM.ZONE_CONFIGS.seven_zone;
        
        for (let zoneId = 1; zoneId <= zones.length; zoneId++) {
          const deviation = zone7Analysis.deviations[zoneId] || 0;
          const gap = zone7Analysis.gaps[zoneId] || 0;
          const heat = zone7Analysis.heatLevels[zoneId] || 0;
          
          let zoneScore = 0;
          
          if (deviation < -zone7Analysis.expectedPerZone * 0.3) {
            zoneScore = 80;
          } else if (deviation < -zone7Analysis.expectedPerZone * 0.1) {
            zoneScore = 60;
          } else if (deviation > zone7Analysis.expectedPerZone * 0.3) {
            zoneScore = 20;
          } else if (deviation > zone7Analysis.expectedPerZone * 0.1) {
            zoneScore = 40;
          } else {
            zoneScore = 50;
          }
          
          if (gap >= 5) {
            zoneScore += gap * 5;
          }
          
          if (heat > 0.8) {
            zoneScore *= 0.7;
          } else if (heat < 0.2) {
            zoneScore *= 1.3;
          }
          
          const numbers = Formatter.getNumbersInZone(zoneId, 'seven_zone');
          for (const num of numbers) {
            const currentScore = scores.get(num) || 0;
            scores.set(num, currentScore + zoneScore * weights.w_zone_balance);
          }
        }
      }
      
      // Âü∫‰∫é‰∫îÂå∫ÂàÜÊûêËØÑÂàÜ
      if (zone5Analysis.zoneCounts && zone5Analysis.deviations) {
        const zones = CONFIG.SYSTEM.ZONE_CONFIGS.five_zone;
        
        for (let zoneId = 1; zoneId <= zones.length; zoneId++) {
          const deviation = zone5Analysis.deviations[zoneId] || 0;
          const gap = zone5Analysis.gaps[zoneId] || 0;
          
          let zoneScore = 0;
          
          if (deviation < -zone5Analysis.expectedPerZone * 0.3) {
            zoneScore = 60;
          } else if (deviation < -zone5Analysis.expectedPerZone * 0.1) {
            zoneScore = 40;
          } else if (deviation > zone5Analysis.expectedPerZone * 0.3) {
            zoneScore = 20;
          } else if (deviation > zone5Analysis.expectedPerZone * 0.1) {
            zoneScore = 30;
          } else {
            zoneScore = 35;
          }
          
          if (gap >= 3) {
            zoneScore += gap * 3;
          }
          
          const numbers = Formatter.getNumbersInZone(zoneId, 'five_zone');
          for (const num of numbers) {
            const currentScore = scores.get(num) || 0;
            scores.set(num, currentScore + zoneScore * weights.w_zone_balance * 0.7);
          }
        }
      }
      
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "Âü∫‰∫éÂå∫Èó¥ÂàÜÊûêËØÑÂàÜÂ§±Ë¥•", error);
    }
  }
  
  static scoreBasedOnZoneGaps(scores, history, weights) {
    try {
      const recentHistory = history.slice(0, Math.min(20, history.length));
      
      // Ê£ÄÊü•‰∏ÉÂå∫Êñ≠Âå∫ÊÉÖÂÜµ
      const zone7Gaps = {};
      const zones7 = CONFIG.SYSTEM.ZONE_CONFIGS.seven_zone;
      
      for (let i = 1; i <= zones7.length; i++) {
        zone7Gaps[i] = 0;
      }
      
      // ‰ªéÊúÄËøë‰∏ÄÊúüÂºÄÂßãÂêëÂâçÊ£ÄÊü•
      for (let i = 0; i < recentHistory.length; i++) {
        const record = recentHistory[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const presentZones = new Set();
        
        for (const num of numbers) {
          const zoneId = Formatter.getZoneForNumber(num, 'seven_zone');
          if (zoneId !== -1) {
            presentZones.add(zoneId);
          }
        }
        
        // Êõ¥Êñ∞ÊØè‰∏™Âå∫Èó¥ÁöÑËøûÁª≠ÈÅóÊºè
        for (let zoneId = 1; zoneId <= zones7.length; zoneId++) {
          if (!presentZones.has(zoneId)) {
            zone7Gaps[zoneId]++;
          }
        }
        
        // Â¶ÇÊûúÊâÄÊúâÂå∫Èó¥ÈÉΩÂá∫Áé∞‰∫ÜÔºåÂèØ‰ª•ÊèêÂâçÁªìÊùü
        if (presentZones.size === zones7.length) {
          break;
        }
      }
      
      // ‰∏∫Êñ≠Âå∫Âè∑Á†ÅÂä†ÂàÜ
      for (let zoneId = 1; zoneId <= zones7.length; zoneId++) {
        if (zone7Gaps[zoneId] >= 3) {
          const numbers = Formatter.getNumbersInZone(zoneId, 'seven_zone');
          const bonus = zone7Gaps[zoneId] * 15;
          
          for (const num of numbers) {
            const currentScore = scores.get(num) || 0;
            scores.set(num, currentScore + bonus * weights.w_zone_balance);
          }
        }
      }
      
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "Âü∫‰∫éÊñ≠Âå∫ËØÑÂàÜÂ§±Ë¥•", error);
    }
  }
  
  static scoreBasedOnZoneHeat(scores, history, weights) {
    try {
      const recentHistory = history.slice(0, Math.min(10, history.length));
      
      // ÁªüËÆ°ÊúÄËøë10ÊúüÂêÑÂå∫Èó¥Âá∫Áé∞Ê¨°Êï∞
      const zone7Heat = {};
      const zones7 = CONFIG.SYSTEM.ZONE_CONFIGS.seven_zone;
      
      for (let i = 1; i <= zones7.length; i++) {
        zone7Heat[i] = 0;
      }
      
      for (const record of recentHistory) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const zoneSet = new Set();
        
        for (const num of numbers) {
          const zoneId = Formatter.getZoneForNumber(num, 'seven_zone');
          if (zoneId !== -1) {
            zoneSet.add(zoneId);
          }
        }
        
        for (const zoneId of zoneSet) {
          zone7Heat[zoneId]++;
        }
      }
      
      // ÊâæÂá∫ËøáÁÉ≠Âå∫Èó¥
      const heatValues = Object.values(zone7Heat);
      const avgHeat = heatValues.reduce((a, b) => a + b, 0) / heatValues.length;
      const variance = heatValues.reduce((a, b) => a + Math.pow(b - avgHeat, 2), 0) / heatValues.length;
      const stdDev = Math.sqrt(variance);
      const heatThreshold = avgHeat + stdDev;
      
      // ‰∏∫ËøáÁÉ≠Âå∫Èó¥Âè∑Á†ÅÈÄÇÂΩìÈôçÂàÜ
      for (let zoneId = 1; zoneId <= zones7.length; zoneId++) {
        if (zone7Heat[zoneId] > heatThreshold) {
          const numbers = Formatter.getNumbersInZone(zoneId, 'seven_zone');
          const penalty = (zone7Heat[zoneId] - heatThreshold) * 10;
          
          for (const num of numbers) {
            const currentScore = scores.get(num) || 0;
            scores.set(num, Math.max(0, currentScore - penalty * weights.w_zone_balance * 0.5));
          }
        }
      }
      
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "Âü∫‰∫éÁÉ≠Â∫¶ËØÑÂàÜÂ§±Ë¥•", error);
    }
  }
  
  static normalizeScores(scoresMap, algorithmName) {
    try {
      const scores = Array.from(scoresMap.entries()).map(([number, score]) => ({ number, score }));
      
      if (scores.length === 0) {
        return scores;
      }
      
      const maxScore = Math.max(...scores.map(s => s.score));
      const minScore = Math.min(...scores.map(s => s.score));
      const range = maxScore - minScore;
      
      if (range === 0) {
        return scores.map(s => ({ number: s.number, score: 50 }));
      }
      
      return scores.map(s => ({
        number: s.number,
        score: Math.round(((s.score - minScore) / range) * 100),
        rawScore: s.score,
        algorithm: algorithmName
      }));
    } catch (error) {
      Logger.error("ZoneBalanceExpert", "ÂΩí‰∏ÄÂåñÂàÜÊï∞Â§±Ë¥•", error);
      return Array.from(scoresMap.entries()).map(([number, score]) => ({ 
        number, 
        score: Math.min(100, Math.max(0, score)),
        rawScore: score,
        algorithm: algorithmName
      }));
    }
  }
}

// ==============================================================================
// 12. ‰ºòÂåñÁöÑËíôÁâπÂç°Ê¥õÊ®°ÊãüÂºïÊìé
// ==============================================================================

class OptimizedMonteCarloEngine {
  static cache = new Map();
  
  static async runOptimizedSimulation(history, targetSimulations = 10000) {
    try {
      if (!history || history.length < 10) {
        return null;
      }
      
      const cacheKey = `monte_opt_${targetSimulations}_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.cache.get(cacheKey);
      
      if (cached && (Date.now() - cached.timestamp < 45000)) {
        Logger.info("OptimizedMonteCarlo", "‰ΩøÁî®ÁºìÂ≠òÁªìÊûú");
        return cached.result;
      }
      
      const startTime = Date.now();
      
      const processedHistory = this.preprocessHistory(history.slice(0, Math.min(150, history.length)));
      
      if (processedHistory.length < 8) {
        Logger.warn("OptimizedMonteCarlo", "ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåË∑≥ËøáÊ®°Êãü");
        return null;
      }
      
      const optimalSimulations = this.calculateOptimalSimulations(processedHistory.length, targetSimulations);
      
      const specialFrequency = {};
      const normalFrequency = {};
      
      for (let i = 1; i <= 49; i++) {
        specialFrequency[i] = 0;
        normalFrequency[i] = 0;
      }
      
      const batchSize = Math.min(1000, Math.floor(optimalSimulations / 10));
      const batches = Math.ceil(optimalSimulations / batchSize);
      
      Logger.info("OptimizedMonteCarlo", "ÂºÄÂßãÊâπÊ¨°Ê®°Êãü", {
        target: targetSimulations,
        optimal: optimalSimulations,
        batches: batches,
        batchSize: batchSize
      });
      
      for (let batch = 0; batch < batches; batch++) {
        const batchStart = Date.now();
        
        for (let i = 0; i < batchSize; i++) {
          const baseRecord = this.selectBaseRecord(processedHistory, batch, i);
          const simulated = this.simulateNextNumbersSmart(baseRecord, processedHistory);
          
          if (simulated.special >= 1 && simulated.special <= 49) {
            specialFrequency[simulated.special]++;
          }
          
          simulated.normals.forEach(num => {
            if (num >= 1 && num <= 49) {
              normalFrequency[num]++;
            }
          });
        }
        
        const batchTime = Date.now() - batchStart;
        
        if (Date.now() - startTime > 8000) {
          Logger.warn("OptimizedMonteCarlo", "Ê®°ÊãüË∂ÖÊó∂ÔºåÊèêÂâçÁªìÊùü", {
            completedBatches: batch + 1,
            completedSimulations: (batch + 1) * batchSize
          });
          break;
        }
      }
      
      const completedSimulations = Object.values(specialFrequency).reduce((a, b) => a + b, 0);
      
      if (completedSimulations === 0) {
        Logger.warn("OptimizedMonteCarlo", "Ê®°ÊãüÊú™ÁîüÊàê‰ªª‰ΩïÁªìÊûú");
        return null;
      }
      
      const specialProbs = {};
      const normalProbs = {};
      
      for (let i = 1; i <= 49; i++) {
        specialProbs[i] = specialFrequency[i] / completedSimulations;
        normalProbs[i] = normalFrequency[i] / completedSimulations;
      }
      
      const result = {
        specialPredictions: Object.entries(specialProbs)
          .map(([num, prob]) => ({
            number: Formatter.safeInt(num),
            probability: prob,
            score: prob * 10000,
            frequency: specialFrequency[num]
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 12),
        
        normalPredictions: Object.entries(normalProbs)
          .map(([num, prob]) => ({
            number: Formatter.safeInt(num),
            probability: prob,
            score: prob * 8000,
            frequency: normalFrequency[num]
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 15),
        
        simulations: completedSimulations,
        batches: batches,
        duration: Date.now() - startTime,
        cacheKey: cacheKey
      };
      
      this.cache.set(cacheKey, {
        result: result,
        timestamp: Date.now()
      });
      
      this.cleanupCache();
      
      Logger.info("OptimizedMonteCarlo", "Ê®°ÊãüÂÆåÊàê", {
        simulations: completedSimulations,
        duration: result.duration,
        topSpecial: result.specialPredictions[0]?.number || 0
      });
      
      return result;
    } catch (error) {
      Logger.error("OptimizedMonteCarlo", "‰ºòÂåñÊ®°ÊãüÂ§±Ë¥•", error);
      return null;
    }
  }
  
  static calculateOptimalSimulations(historyLength, targetSimulations) {
    let optimal = targetSimulations;
    
    if (historyLength < 30) {
      optimal = Math.min(3000, targetSimulations);
    } else if (historyLength < 50) {
      optimal = Math.min(6000, targetSimulations);
    } else if (historyLength < 100) {
      optimal = Math.min(8000, targetSimulations);
    }
    
    return optimal;
  }
  
  static selectBaseRecord(processedHistory, batch, index) {
    const total = processedHistory.length;
    const selectionMethod = (batch * 100 + index) % 7;
    
    switch (selectionMethod) {
      case 0:
        return processedHistory[Math.floor(Math.random() * total)];
      case 1:
        return processedHistory[0];
      case 2:
        return processedHistory[Math.min(10, total - 1)];
      case 3:
        return processedHistory[Math.floor(total / 2)];
      case 4:
        return processedHistory[batch % total];
      case 5:
        return processedHistory[index % total];
      default:
        const weights = processedHistory.map((_, i) => Math.exp(-i / 10));
        const sum = weights.reduce((a, b) => a + b, 0);
        let rand = Math.random() * sum;
        for (let i = 0; i < weights.length; i++) {
          rand -= weights[i];
          if (rand <= 0) return processedHistory[i];
        }
        return processedHistory[0];
    }
  }
  
  static simulateNextNumbersSmart(baseRecord, processedHistory) {
    const result = {
      normals: [],
      special: 0
    };
    
    const simulationStrategy = Math.random();
    
    if (simulationStrategy < 0.3) {
      const zodiacNumbers = CONFIG.ZODIAC_MAP[baseRecord.zodiac] || [];
      if (zodiacNumbers.length > 0) {
        result.special = zodiacNumbers[Math.floor(Math.random() * zodiacNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    } else if (simulationStrategy < 0.6) {
      const colorNumbers = CONFIG.COLORS[baseRecord.color] || [];
      if (colorNumbers.length > 0) {
        result.special = colorNumbers[Math.floor(Math.random() * colorNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    } else if (simulationStrategy < 0.8) {
      const similarIndex = Math.floor(Math.random() * Math.min(10, processedHistory.length));
      result.special = processedHistory[similarIndex]?.special || baseRecord.special;
    } else {
      const tail = baseRecord.tail;
      const possibleNumbers = [];
      for (let num = tail; num <= 49; num += 10) {
        if (num >= 1 && num <= 49) {
          possibleNumbers.push(num);
        }
      }
      if (possibleNumbers.length > 0) {
        result.special = possibleNumbers[Math.floor(Math.random() * possibleNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    }
    
    if (result.special < 1 || result.special > 49) {
      result.special = Math.floor(Math.random() * 49) + 1;
    }
    
    const usedNumbers = new Set([result.special]);
    
    let normalsNeeded = 6;
    
    for (const normal of baseRecord.normals) {
      if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
        result.normals.push(normal);
        usedNumbers.add(normal);
        normalsNeeded--;
        if (normalsNeeded <= 0) break;
      }
    }
    
    if (normalsNeeded > 0) {
      const similarRecords = processedHistory.slice(0, 5);
      for (const record of similarRecords) {
        if (normalsNeeded <= 0) break;
        
        for (const normal of record.normals) {
          if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
            result.normals.push(normal);
            usedNumbers.add(normal);
            normalsNeeded--;
            if (normalsNeeded <= 0) break;
          }
        }
      }
    }
    
    while (normalsNeeded > 0) {
      let num;
      let attempts = 0;
      do {
        num = Math.floor(Math.random() * 49) + 1;
        attempts++;
      } while (usedNumbers.has(num) && attempts < 20);
      
      if (!usedNumbers.has(num)) {
        result.normals.push(num);
        usedNumbers.add(num);
        normalsNeeded--;
      } else {
        for (let i = 1; i <= 49; i++) {
          if (!usedNumbers.has(i)) {
            result.normals.push(i);
            usedNumbers.add(i);
            normalsNeeded--;
            break;
          }
        }
      }
    }
    
    return result;
  }
  
  static preprocessHistory(history) {
    const processed = [];
    
    for (const record of history) {
      if (record && record.open_code) {
        const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (nums.length >= 7) {
          const special = nums[6] || 1;
          const normals = nums.slice(0, 6);
          const attr = Formatter.getAttributes(special);
          
          processed.push({
            numbers: nums,
            special: special,
            normals: normals,
            zodiac: attr.zodiac,
            color: attr.color,
            tail: special % 10,
            head: Math.floor(special / 10),
            size: special >= 25 ? "Â§ß" : "Â∞è",
            oddEven: special % 2 !== 0 ? "Âçï" : "Âèå",
            expect: record.expect,
            timestamp: record.created_at || Date.now()
          });
        }
      }
    }
    
    return processed;
  }
  
  static cleanupCache() {
    try {
      const now = Date.now();
      const maxCacheSize = 50;
      
      if (this.cache.size > maxCacheSize) {
        const keys = Array.from(this.cache.keys());
        const keysToDelete = keys.slice(0, Math.floor(keys.length / 2));
        
        for (const key of keysToDelete) {
          this.cache.delete(key);
        }
        
        Logger.info("OptimizedMonteCarlo", `Ê∏ÖÁêÜÁºìÂ≠òÔºåÂà†Èô§ ${keysToDelete.length} ‰∏™Êù°ÁõÆ`);
      }
      
      for (const [key, value] of this.cache.entries()) {
        if (now - value.timestamp > 120000) {
          this.cache.delete(key);
        }
      }
    } catch (error) {
      Logger.error("OptimizedMonteCarlo", "Ê∏ÖÁêÜÁºìÂ≠òÂ§±Ë¥•", error);
    }
  }
  
  static clearCache() {
    try {
      this.cache.clear();
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  }
}
// ==============================================================================
// 13. ÊîπËøõÁöÑÈ¢ÑÊµãÂºïÊìéÔºàÊï¥ÂêàÊâÄÊúâ‰∏ìÂÆ∂ÁÆóÊ≥ïÔºâ
// ==============================================================================

class PredictionEngine {
  static async generate(env, history, weights, algorithm = "traditional") {
    try {
      if (!history || history.length < 2) {
        return this.generateStaticFallback();
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      let nextExpect = "2025346";
      const latestExpect = lastRecord.expect;
      if (latestExpect && Formatter.isValidExpect(latestExpect)) {
        const latestNum = Formatter.safeInt(latestExpect, 2025345);
        nextExpect = (latestNum + 1).toString();
      }
      
      let prediction;
      const algorithmTimeout = 8000;
      
      try {
        switch (algorithm) {
          case "knn":
            prediction = await this.generateKNNPrediction(history, weights);
            break;
          case "stats":
            prediction = await this.generateStatsPrediction(history, weights);
            break;
          case "advanced":
            prediction = await this.generateAdvancedPrediction(env, history, weights);
            break;
          case "traditional":
          default:
            prediction = await this.generateTraditionalPrediction(history, weights);
            break;
        }
      } catch (timeoutError) {
        Logger.error("PredictionEngine", `È¢ÑÊµãÁîüÊàêË∂ÖÊó∂ÔºåÁÆóÊ≥ï: ${algorithm}`, timeoutError);
        prediction = await this.generateTraditionalPrediction(history, weights);
      }
      
      if (!prediction || !prediction.specialNumbers || prediction.specialNumbers.length === 0) {
        Logger.warn("PredictionEngine", `ÁÆóÊ≥ï ${algorithm} ËøîÂõûÊó†ÊïàÈ¢ÑÊµãÔºå‰ΩøÁî®‰º†ÁªüÁÆóÊ≥ïÊõø‰ª£`);
        prediction = await this.generateTraditionalPrediction(history, weights);
      }
      
      prediction.nextExpect = nextExpect;
      prediction.basedOnLastRecord = {
        expect: lastRecord.expect || "Êú™Áü•",
        openCode: lastOpenCode,
        special: lastSpecial,
        zodiac: Formatter.getAttributes(lastSpecial).zodiac,
        color: Formatter.getAttributes(lastSpecial).color
      };
      
      prediction.totalHistoryRecords = history.length;
      prediction.generatedAt = new Date().toISOString();
      prediction.algorithmVersion = `V13.0-${CONFIG.ALGORITHM_NAMES[algorithm] || algorithm}`;
      prediction.algorithmUsed = algorithm;
      
      return prediction;
    } catch (error) {
      Logger.error("PredictionEngine", "ÁîüÊàêÈ¢ÑÊµãÊó∂Âá∫Èîô", error);
      return this.generateStaticFallback();
    }
  }
  
  static async generateTraditionalPrediction(history, weights) {
    try {
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      const stats = this.analyzeHistoryStatistics(history);
      
      const scores = this.generateTraditionalScores(lastSpecial, stats, weights);
      
      const topSpecialNumbers = this.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = this.getZodiacPredictions(scores);
      const colorPrediction = this.getColorPredictions(scores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = this.generateNormalPredictions(stats, weights, excludeSpecials);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(bestNumber / 10);
      
      const confidence = this.calculateTraditionalConfidence(topSpecialNumbers, history.length);
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));
      
      const formattedNormals = normalPredictions.slice(0, 6).map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      return {
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: confidence,
        analysisBased: true,
        algorithmUsed: "traditional"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "‰º†ÁªüÈ¢ÑÊµãÁîüÊàêÂ§±Ë¥•", error);
      return this.generateStaticFallback();
    }
  }
  
  static async generateKNNPrediction(history, weights) {
    try {
      const lastRecord = history[0];
      if (!lastRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const similarRecords = KNNAlgorithm.findSimilarRecords(history, lastRecord);
      const knnResult = KNNAlgorithm.predictFromSimilarRecords(similarRecords);
      
      if (!knnResult) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const scores = this.generateTraditionalScores(
        Formatter.safeInt(lastRecord.open_code?.split(",")[6] || 1),
        this.analyzeHistoryStatistics(history),
        weights
      );
      
      if (knnResult.specialCandidates) {
        for (const candidate of knnResult.specialCandidates) {
          if (candidate.value >= 1 && candidate.value <= 49) {
            scores[candidate.value].score += candidate.score * 150 * weights.w_knn_similarity;
          }
        }
      }
      
      const topSpecialNumbers = this.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = this.getZodiacPredictions(scores);
      const colorPrediction = this.getColorPredictions(scores);
      
      let knnZodiacs = [];
      let knnColors = [];
      
      if (knnResult.zodiacCandidates) {
        knnZodiacs = knnResult.zodiacCandidates.slice(0, 3).map(item => item.value);
      }
      
      if (knnResult.colorCandidates) {
        knnColors = knnResult.colorCandidates.slice(0, 2).map(item => item.value);
      }
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = this.generateNormalPredictions(
        this.analyzeHistoryStatistics(history),
        weights,
        excludeSpecials
      );
      
      if (knnResult.normalCandidates && knnResult.normalCandidates.length > 0) {
        for (const candidate of knnResult.normalCandidates.slice(0, 6)) {
          if (candidate.value >= 1 && candidate.value <= 49) {
            const existing = normalPredictions.find(item => item.number === candidate.value);
            if (!existing) {
              normalPredictions.push({
                number: candidate.value,
                score: candidate.score * 100,
                probability: candidate.score * 0.1
              });
            }
          }
        }
      }
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(bestNumber / 10);
      
      const confidence = this.calculateTraditionalConfidence(topSpecialNumbers, history.length) + 5;
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));
      
      const formattedNormals = normalPredictions.slice(0, 6).map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      return {
        zodiac: {
          main: zodiacPrediction.main,
          guard: zodiacPrediction.guard,
          knn: knnZodiacs
        },
        color: {
          main: colorPrediction.main,
          guard: colorPrediction.guard,
          knn: knnColors
        },
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: Math.min(95, confidence),
        analysisBased: true,
        algorithmUsed: "knn"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "KNNÈ¢ÑÊµãÁîüÊàêÂ§±Ë¥•", error);
      return await this.generateTraditionalPrediction(history, weights);
    }
  }
  
  static async generateStatsPrediction(history, weights) {
    try {
      const lastRecord = history[0];
      if (!lastRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const stats = EnhancedStatistics.analyzeHistoryStatistics(history);
      
      const processedHistory = EnhancedStatistics.processHistoryData([lastRecord]);
      const lastProcessedRecord = processedHistory[0];
      
      if (!lastProcessedRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const statisticsResult = EnhancedStatistics.getPredictionFromStatistics(stats, lastProcessedRecord);
      
      if (!statisticsResult) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const baseScores = this.generateTraditionalScores(
        lastProcessedRecord.special,
        this.analyzeHistoryStatistics(history),
        weights
      );
      
      if (statisticsResult.specialNumbers) {
        for (const item of statisticsResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            baseScores[item.number].score += item.probability * 180 * weights.w_statistics_analysis;
            baseScores[item.number].probability = item.probability;
          }
        }
      }
      
      if (statisticsResult.tailRecommendations) {
        for (const item of statisticsResult.tailRecommendations) {
          if (item.tail >= 0 && item.tail <= 9) {
            for (let num = item.tail; num <= 49; num += 10) {
              if (num >= 1 && num <= 49) {
                baseScores[num].score += item.probability * 120 * weights.w_tail_pattern;
              }
            }
          }
        }
      }
      
      const topSpecialNumbers = this.getTopSpecialPredictions(baseScores, 10);
      const zodiacPrediction = this.getZodiacPredictions(baseScores);
      const colorPrediction = this.getColorPredictions(baseScores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = this.generateNormalPredictions(
        this.analyzeHistoryStatistics(history),
        weights,
        excludeSpecials
      );
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(bestNumber / 10);
      
      let confidence = this.calculateTraditionalConfidence(topSpecialNumbers, history.length);
      confidence += statisticsResult.analysis ? Math.min(15, statisticsResult.analysis.length * 3) : 0;
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));
      
      const formattedNormals = normalPredictions.slice(0, 6).map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      return {
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: Math.min(95, confidence),
        analysisBased: true,
        algorithmUsed: "statistics"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ÁªüËÆ°È¢ÑÊµãÁîüÊàêÂ§±Ë¥•", error);
      return await this.generateTraditionalPrediction(history, weights);
    }
  }
  
  static async generateAdvancedPrediction(env, history, weights) {
    try {
      const lastRecord = history[0];
      if (!lastRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      Logger.info("PredictionEngine", "ÂºÄÂßãÁîüÊàêÂ¢ûÂº∫È¢ÑÊµã", { 
        historyLength: history.length,
        weightsVersion: weights._version || "default"
      });
      
      const algorithmChecks = {
        traditional: history.length >= 2,
        knn: history.length >= 10,
        stats: history.length >= 20,
        omission: history.length >= 30,
        association: history.length >= 50,
        math: history.length >= 10,
        zone: history.length >= 20
      };
      
      const adjustedWeights = { ...weights };
      if (!algorithmChecks.knn) {
        adjustedWeights.w_knn_similarity = adjustedWeights.w_knn_similarity * 0.3;
      }
      if (!algorithmChecks.stats) {
        adjustedWeights.w_statistics_analysis = adjustedWeights.w_statistics_analysis * 0.3;
      }
      if (!algorithmChecks.omission) {
        adjustedWeights.w_omission_balancing = adjustedWeights.w_omission_balancing * 0.3;
      }
      if (!algorithmChecks.association) {
        adjustedWeights.w_association_rules = adjustedWeights.w_association_rules * 0.3;
      }
      if (!algorithmChecks.math) {
        adjustedWeights.w_math_logic = adjustedWeights.w_math_logic * 0.3;
      }
      if (!algorithmChecks.zone) {
        adjustedWeights.w_zone_balance = adjustedWeights.w_zone_balance * 0.3;
      }
      
      const algorithmPromises = [];
      
      algorithmPromises.push(
        this.generateTraditionalPrediction(history, adjustedWeights)
          .catch(error => {
            Logger.error("PredictionEngine", "‰º†ÁªüÁÆóÊ≥ïÂ§±Ë¥•", error);
            return this.generateStaticFallback();
          })
      );
      
      if (algorithmChecks.knn) {
        algorithmPromises.push(
          this.generateKNNPrediction(history, adjustedWeights)
            .catch(error => {
              Logger.error("PredictionEngine", "KNNÁÆóÊ≥ïÂ§±Ë¥•", error);
              return null;
            })
        );
      }
      
      if (algorithmChecks.stats) {
        algorithmPromises.push(
          this.generateStatsPrediction(history, adjustedWeights)
            .catch(error => {
              Logger.error("PredictionEngine", "ÁªüËÆ°ÁÆóÊ≥ïÂ§±Ë¥•", error);
              return null;
            })
        );
      }
      
      const montePromise = new Promise((resolve) => {
        const timeout = setTimeout(() => {
          Logger.warn("PredictionEngine", "ËíôÁâπÂç°Ê¥õÊ®°ÊãüË∂ÖÊó∂");
          resolve(null);
        }, 4000);
        
        OptimizedMonteCarloEngine.runOptimizedSimulation(history, 5000)
          .then(result => {
            clearTimeout(timeout);
            resolve(result);
          })
          .catch(error => {
            clearTimeout(timeout);
            Logger.error("PredictionEngine", "ËíôÁâπÂç°Ê¥õÊ®°ÊãüÂ§±Ë¥•", error);
            resolve(null);
          });
      });
      
      algorithmPromises.push(montePromise);
      
      const results = await Promise.allSettled(algorithmPromises);
      
      const [traditionalResult, knnResult, statsResult, monteResult] = results.map(r => 
        r.status === 'fulfilled' ? r.value : null
      );
      
      const algorithmsUsed = {
        traditional: !!traditionalResult,
        knn: !!knnResult,
        statistics: !!statsResult,
        monteCarlo: !!monteResult,
        algorithmsCount: [traditionalResult, knnResult, statsResult, monteResult].filter(Boolean).length,
        algorithmChecks: algorithmChecks
      };
      
      Logger.info("PredictionEngine", "ÁÆóÊ≥ïÂÆåÊàêÊÉÖÂÜµ", algorithmsUsed);
      
      if (algorithmsUsed.algorithmsCount === 0) {
        Logger.warn("PredictionEngine", "ÊâÄÊúâÁÆóÊ≥ïÂ§±Ë¥•Ôºå‰ΩøÁî®‰º†ÁªüÁÆóÊ≥ïÂêéÂ§á");
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const fallbackResult = traditionalResult || this.generateStaticFallback();
      
      const integratedScores = {};
      
      for (let i = 1; i <= 49; i++) {
        integratedScores[i] = { score: 0, probability: 0, contributions: [] };
      }
      
      if (traditionalResult && traditionalResult.specialNumbers) {
        for (const item of traditionalResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 0.8 * adjustedWeights.w_zodiac_transfer;
            integratedScores[item.number].contributions.push({
              algorithm: 'traditional',
              score: item.score || 0,
              weight: adjustedWeights.w_zodiac_transfer
            });
          }
        }
      }
      
      if (knnResult && knnResult.specialNumbers) {
        for (const item of knnResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 1.2 * adjustedWeights.w_knn_similarity;
            integratedScores[item.number].contributions.push({
              algorithm: 'knn',
              score: item.score || 0,
              weight: adjustedWeights.w_knn_similarity
            });
          }
        }
      }
      
      if (statsResult && statsResult.specialNumbers) {
        for (const item of statsResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 1.5 * adjustedWeights.w_statistics_analysis;
            integratedScores[item.number].contributions.push({
              algorithm: 'statistics',
              score: item.score || 0,
              weight: adjustedWeights.w_statistics_analysis
            });
          }
        }
      }
      
      if (monteResult && monteResult.specialPredictions) {
        for (const item of monteResult.specialPredictions) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 1.8 * (adjustedWeights.w_monte_carlo || 2.5);
            integratedScores[item.number].probability = Math.max(
              integratedScores[item.number].probability,
              item.probability || 0
            );
            integratedScores[item.number].contributions.push({
              algorithm: 'montecarlo',
              score: item.score || 0,
              weight: adjustedWeights.w_monte_carlo || 2.5,
              probability: item.probability
            });
          }
        }
      }
      
      // ==================== ËøêË°å‰∏ìÂÆ∂ÁÆóÊ≥ï ====================
      
      let omissionResult = null;
      let associationResult = null;
      let mathResult = null;
      let zoneResult = null;
      
      // ËøêË°åÈÅóÊºèÂõûË°•‰∏ìÂÆ∂
      if (algorithmChecks.omission) {
        try {
          omissionResult = await OmissionExpert.runOmission(history, adjustedWeights);
          if (omissionResult && omissionResult.scores) {
            for (const item of omissionResult.scores) {
              if (item.number >= 1 && item.number <= 49) {
                integratedScores[item.number].score += (item.score || 0) * 2.0 * adjustedWeights.w_omission_balancing;
                integratedScores[item.number].contributions.push({
                  algorithm: 'omission',
                  score: item.score || 0,
                  weight: adjustedWeights.w_omission_balancing,
                  rawScore: item.rawScore || 0
                });
              }
            }
          }
        } catch (error) {
          Logger.error("PredictionEngine", "ÈÅóÊºèÂõûË°•‰∏ìÂÆ∂Â§±Ë¥•", error);
        }
      }
      
      // ËøêË°åÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂
      if (algorithmChecks.association) {
        try {
          associationResult = await AssociationExpert.runAssociation(history, adjustedWeights);
          if (associationResult && associationResult.scores) {
            for (const item of associationResult.scores) {
              if (item.number >= 1 && item.number <= 49) {
                integratedScores[item.number].score += (item.score || 0) * 1.8 * adjustedWeights.w_association_rules;
                integratedScores[item.number].contributions.push({
                  algorithm: 'association',
                  score: item.score || 0,
                  weight: adjustedWeights.w_association_rules,
                  rawScore: item.rawScore || 0
                });
              }
            }
          }
        } catch (error) {
          Logger.error("PredictionEngine", "ÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂Â§±Ë¥•", error);
        }
      }
      
      // ËøêË°åÈªÑÈáëÂàÜÂâ≤‰∏ìÂÆ∂
      if (algorithmChecks.math) {
        try {
          mathResult = await MathLogicExpert.runMathLogic(history, adjustedWeights);
          if (mathResult && mathResult.scores) {
            for (const item of mathResult.scores) {
              if (item.number >= 1 && item.number <= 49) {
                integratedScores[item.number].score += (item.score || 0) * 1.5 * adjustedWeights.w_math_logic;
                integratedScores[item.number].contributions.push({
                  algorithm: 'math',
                  score: item.score || 0,
                  weight: adjustedWeights.w_math_logic,
                  rawScore: item.rawScore || 0
                });
              }
            }
          }
        } catch (error) {
          Logger.error("PredictionEngine", "ÈªÑÈáëÂàÜÂâ≤‰∏ìÂÆ∂Â§±Ë¥•", error);
        }
      }
      
      // ËøêË°åÂå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂
      if (algorithmChecks.zone) {
        try {
          zoneResult = await ZoneBalanceExpert.runZoneBalance(history, adjustedWeights);
          if (zoneResult && zoneResult.scores) {
            for (const item of zoneResult.scores) {
              if (item.number >= 1 && item.number <= 49) {
                integratedScores[item.number].score += (item.score || 0) * 2.2 * adjustedWeights.w_zone_balance;
                integratedScores[item.number].contributions.push({
                  algorithm: 'zone',
                  score: item.score || 0,
                  weight: adjustedWeights.w_zone_balance,
                  rawScore: item.rawScore || 0
                });
              }
            }
          }
        } catch (error) {
          Logger.error("PredictionEngine", "Âå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂Â§±Ë¥•", error);
        }
      }
      
      // Êõ¥Êñ∞ÁÆóÊ≥ï‰ΩøÁî®ÊÉÖÂÜµ
      if (omissionResult) algorithmsUsed.omission = true;
      if (associationResult) algorithmsUsed.association = true;
      if (mathResult) algorithmsUsed.math = true;
      if (zoneResult) algorithmsUsed.zone = true;
      
      algorithmsUsed.algorithmsCount = [
        traditionalResult, knnResult, statsResult, monteResult,
        omissionResult, associationResult, mathResult, zoneResult
      ].filter(Boolean).length;
      
      // ==================== ÁªßÁª≠ÂéüÊúâÈÄªËæë ====================
      
      const topSpecialNumbers = this.getTopSpecialPredictions(integratedScores, 10);
      const zodiacPrediction = this.getZodiacPredictions(integratedScores);
      const colorPrediction = this.getColorPredictions(integratedScores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      
      const integratedNormals = {};
      for (let i = 1; i <= 49; i++) {
        integratedNormals[i] = { score: 0, probability: 0 };
      }
      
      if (traditionalResult && traditionalResult.normalNumbers) {
        for (const item of traditionalResult.normalNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedNormals[item.number].score += (item.score || 0) * 0.8;
          }
        }
      }
      
      if (monteResult && monteResult.normalPredictions) {
        for (const item of monteResult.normalPredictions) {
          if (item.number >= 1 && item.number <= 49) {
            integratedNormals[item.number].score += (item.score || 0) * 1.5;
            integratedNormals[item.number].probability = item.probability || 0;
          }
        }
      }
      
      const excludeSet = new Set(excludeSpecials);
      const normalPredictions = Object.entries(integratedNormals)
        .filter(([num, _]) => !excludeSet.has(Formatter.safeInt(num)))
        .map(([num, data]) => ({
          number: Formatter.safeInt(num),
          score: data.score,
          probability: data.probability
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, 6);
      
      // ==================== ÊîπËøõÔºöÂ¢ûÂä†Âπ≥Á†ÅÂ§öÊ†∑ÊÄß ====================
      // Â¶ÇÊûúÂπ≥Á†ÅÈáçÂ§çÊÄßÂ§™È´òÔºåÊ∑ªÂä†‰∏Ä‰∫õÈöèÊú∫ÊÄßÂíåÂ§öÊ†∑ÊÄß
      const finalNormalPredictions = this.enhanceNormalDiversity(normalPredictions, history);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(bestNumber / 10);
      
      let confidence = 40;
      
      if (traditionalResult) confidence += 20;
      if (knnResult) confidence += 15;
      if (statsResult) confidence += 15;
      if (monteResult) confidence += 20;
      if (omissionResult) confidence += 10;
      if (associationResult) confidence += 10;
      if (mathResult) confidence += 10;
      if (zoneResult) confidence += 15;
      
      if (history.length > 50) confidence += 10;
      if (history.length > 100) confidence += 5;
      
      confidence = Math.min(95, confidence);
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        contributions: integratedScores[item?.number]?.contributions || []
      }));
      
      const formattedNormals = finalNormalPredictions.map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      return {
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: confidence,
        analysisBased: true,
        algorithmUsed: "advanced",
        monteCarloUsed: !!monteResult,
        omissionUsed: !!omissionResult,
        associationUsed: !!associationResult,
        mathUsed: !!mathResult,
        zoneUsed: !!zoneResult,
        nextExpect: this.calculateNextExpect(lastRecord.expect || "2025345"),
        basedOnLastRecord: {
          expect: lastRecord.expect || "Êú™Áü•",
          openCode: lastRecord.open_code || "Êú™Áü•",
          special: Formatter.safeInt((lastRecord.open_code || "1,2,3,4,5,6,7").split(",")[6], 1),
          zodiac: Formatter.getAttributes(Formatter.safeInt((lastRecord.open_code || "1,2,3,4,5,6,7").split(",")[6], 1)).zodiac,
          color: Formatter.getAttributes(Formatter.safeInt((lastRecord.open_code || "1,2,3,4,5,6,7").split(",")[6], 1)).color
        },
        totalHistoryRecords: history.length,
        generatedAt: new Date().toISOString(),
        algorithmVersion: `V13.0-Advanced-${algorithmsUsed.algorithmsCount}Algos`,
        fallbackUsed: !traditionalResult
      };
    } catch (error) {
      Logger.error("PredictionEngine", "Â¢ûÂº∫È¢ÑÊµãÁîüÊàêÂ§±Ë¥•", error);
      try {
        return await this.generateTraditionalPrediction(history, weights);
      } catch (fallbackError) {
        Logger.error("PredictionEngine", "‰º†ÁªüÁÆóÊ≥ïÂêéÂ§á‰πüÂ§±Ë¥•", fallbackError);
        return this.generateStaticFallback();
      }
    }
  }
  
  // ==================== Êñ∞Â¢ûÔºöÂ¢ûÂº∫Âπ≥Á†ÅÂ§öÊ†∑ÊÄßÊñπÊ≥ï ====================
  static enhanceNormalDiversity(normalPredictions, history) {
    try {
      if (!normalPredictions || normalPredictions.length < 3) {
        return normalPredictions;
      }
      
      // Â¶ÇÊûúÂéÜÂè≤Êï∞ÊçÆË∂≥Â§üÔºåÂàÜÊûêÂéÜÂè≤Âπ≥Á†ÅÁöÑÂá∫Áé∞Ê®°Âºè
      const historyAnalysis = this.analyzeNormalHistory(history);
      
      // ÂàõÂª∫ÊúÄÁªàÂπ≥Á†ÅÂàóË°®
      const finalNormals = [];
      const usedNumbers = new Set();
      
      // 1. È¶ñÂÖàÂä†ÂÖ•ÂéüÂßãÈ¢ÑÊµãÁöÑÂâç3‰∏™
      for (let i = 0; i < Math.min(3, normalPredictions.length); i++) {
        const num = normalPredictions[i].number;
        if (!usedNumbers.has(num)) {
          finalNormals.push({
            ...normalPredictions[i],
            reason: "ÁÆóÊ≥ïÈ¢ÑÊµã"
          });
          usedNumbers.add(num);
        }
      }
      
      // 2. Âä†ÂÖ•‰∏Ä‰∫õÂéÜÂè≤ÂàÜÊûêÊé®ËçêÁöÑÂè∑Á†Å
      if (historyAnalysis && historyAnalysis.recommendations) {
        for (const rec of historyAnalysis.recommendations) {
          if (finalNormals.length >= 6) break;
          if (!usedNumbers.has(rec.number)) {
            finalNormals.push({
              number: rec.number,
              score: rec.score || 60,
              probability: rec.probability || 0.02,
              reason: rec.reason || "ÂéÜÂè≤Ê®°Âºè"
            });
            usedNumbers.add(rec.number);
          }
        }
      }
      
      // 3. Â¶ÇÊûúËøò‰∏çÂ§ü6‰∏™ÔºåÊ∑ªÂä†‰∏Ä‰∫õÈöèÊú∫‰ΩÜÂêàÁêÜÁöÑÂè∑Á†Å
      if (finalNormals.length < 6) {
        const candidates = [];
        
        // Ê∑ªÂä†‰∏Ä‰∫õ‰∏éÂ∑≤ÈÄâÂè∑Á†ÅÊúâÂÖ≥ËÅîÁöÑÂè∑Á†Å
        for (const normal of finalNormals) {
          const num = normal.number;
          // Áõ∏ÈÇªÂè∑Á†Å
          const adjacent = [num - 1, num + 1].filter(n => n >= 1 && n <= 49 && !usedNumbers.has(n));
          candidates.push(...adjacent.map(n => ({ number: n, reason: `Áõ∏ÈÇª${num}` })));
          
          // ÂêåÂ∞æÊï∞Âè∑Á†Å
          const tail = num % 10;
          for (let i = tail; i <= 49; i += 10) {
            if (i !== num && i >= 1 && i <= 49 && !usedNumbers.has(i)) {
              candidates.push({ number: i, reason: `ÂêåÂ∞æ${tail}` });
            }
          }
        }
        
        // Ê∑ªÂä†‰∏Ä‰∫õËøëÊúüÂá∫Áé∞ÁöÑÂπ≥Á†Å
        if (history && history.length > 0) {
          const recentNumbers = new Set();
          for (let i = 0; i < Math.min(5, history.length); i++) {
            const record = history[i];
            if (record && record.open_code) {
              const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
              const normals = nums.slice(0, 6);
              normals.forEach(n => {
                if (n >= 1 && n <= 49 && !usedNumbers.has(n)) {
                  recentNumbers.add(n);
                }
              });
            }
          }
          
          candidates.push(...Array.from(recentNumbers).map(n => ({ 
            number: n, 
            reason: "ËøëÊúüÂá∫Áé∞" 
          })));
        }
        
        // ÂéªÈáçÂπ∂ÈöèÊú∫ÈÄâÊã©
        const uniqueCandidates = [];
        const seen = new Set();
        for (const cand of candidates) {
          if (!seen.has(cand.number)) {
            seen.add(cand.number);
            uniqueCandidates.push(cand);
          }
        }
        
        // ÈöèÊú∫Êâì‰π±Âπ∂ÈÄâÊã©
        const shuffled = Formatter.shuffleArray(uniqueCandidates);
        for (const cand of shuffled) {
          if (finalNormals.length >= 6) break;
          if (!usedNumbers.has(cand.number)) {
            finalNormals.push({
              number: cand.number,
              score: 50 + Math.random() * 30,
              probability: 0.01 + Math.random() * 0.02,
              reason: cand.reason
            });
            usedNumbers.add(cand.number);
          }
        }
      }
      
      // 4. Â¶ÇÊûúËøò‰∏çÂ§ü6‰∏™ÔºåÊ∑ªÂä†ÂÆåÂÖ®ÈöèÊú∫ÁöÑÂè∑Á†Å
      while (finalNormals.length < 6) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while (usedNumbers.has(num) && attempts < 20);
        
        if (!usedNumbers.has(num)) {
          finalNormals.push({
            number: num,
            score: 40 + Math.random() * 30,
            probability: 0.01 + Math.random() * 0.01,
            reason: "ÈöèÊú∫Ë°•ÂÖÖ"
          });
          usedNumbers.add(num);
        } else {
          // ÂÆûÂú®Êâæ‰∏çÂà∞ÔºåÂ∞±Ê∑ªÂä†1-49‰∏≠ËøòÊ≤°Áî®ËøáÁöÑ
          for (let i = 1; i <= 49; i++) {
            if (!usedNumbers.has(i)) {
              finalNormals.push({
                number: i,
                score: 40,
                probability: 0.01,
                reason: "Ë°•ÂÖÖÂè∑Á†Å"
              });
              usedNumbers.add(i);
              break;
            }
          }
        }
      }
      
      // Á°Æ‰øùÊúâ6‰∏™Âπ≥Á†Å
      return finalNormals.slice(0, 6);
      
    } catch (error) {
      Logger.error("PredictionEngine", "Â¢ûÂº∫Âπ≥Á†ÅÂ§öÊ†∑ÊÄßÂ§±Ë¥•", error);
      return normalPredictions.slice(0, 6);
    }
  }
  
  static analyzeNormalHistory(history) {
    try {
      if (!history || history.length < 5) {
        return null;
      }
      
      const recentNormals = [];
      
      // Êî∂ÈõÜÊúÄËøë5ÊúüÁöÑÂπ≥Á†Å
      for (let i = 0; i < Math.min(5, history.length); i++) {
        const record = history[i];
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const normals = nums.slice(0, 6);
          recentNormals.push(...normals);
        }
      }
      
      // ÁªüËÆ°È¢ëÁéá
      const frequency = {};
      for (const num of recentNormals) {
        frequency[num] = (frequency[num] || 0) + 1;
      }
      
      // ÊâæÂá∫ËøëÊúüÂá∫Áé∞‰ΩÜÂèØËÉΩË¢´ÂøΩÁï•ÁöÑÂè∑Á†Å
      const recommendations = [];
      const avgFrequency = recentNormals.length / Object.keys(frequency).length;
      
      for (const [num, freq] of Object.entries(frequency)) {
        const numInt = Formatter.safeInt(num);
        if (numInt >= 1 && numInt <= 49) {
          // ËøëÊúüÂá∫Áé∞‰ΩÜÈ¢ëÁéá‰∏çÈ´òÁöÑÂè∑Á†Å
          if (freq >= 1 && freq <= 2) {
            recommendations.push({
              number: numInt,
              score: 60 + freq * 10,
              probability: 0.02 + freq * 0.005,
              reason: `ËøëÊúüÂá∫Áé∞${freq}Ê¨°`
            });
          }
        }
      }
      
      // ÊâæÂá∫ÊúÄËøëÂá†ÊúüÊúâËøûÁª≠Âá∫Áé∞Ê®°ÂºèÁöÑÂè∑Á†Å
      if (history.length >= 3) {
        const lastThree = history.slice(0, 3);
        const patternNumbers = new Set();
        
        for (let i = 0; i < lastThree.length - 1; i++) {
          const current = lastThree[i];
          const next = lastThree[i + 1];
          
          if (current && next && current.open_code && next.open_code) {
            const currentNums = current.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            const nextNums = next.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            
            const currentNormals = currentNums.slice(0, 6);
            const nextNormals = nextNums.slice(0, 6);
            
            // ÊâæÂá∫ËøûÁª≠Âá∫Áé∞ÁöÑÂπ≥Á†Å
            for (const num of currentNormals) {
              if (nextNormals.includes(num)) {
                patternNumbers.add(num);
              }
            }
          }
        }
        
        for (const num of patternNumbers) {
          if (num >= 1 && num <= 49) {
            recommendations.push({
              number: num,
              score: 70,
              probability: 0.03,
              reason: "ËøûÁª≠Âá∫Áé∞"
            });
          }
        }
      }
      
      return {
        frequency: frequency,
        recommendations: recommendations.slice(0, 10)
      };
      
    } catch (error) {
      Logger.error("PredictionEngine", "ÂàÜÊûêÂπ≥Á†ÅÂéÜÂè≤Â§±Ë¥•", error);
      return null;
    }
  }
  
  static calculateNextExpect(currentExpect) {
    try {
      if (!currentExpect || !Formatter.isValidExpect(currentExpect)) {
        return "2025346";
      }
      
      const currentNum = Formatter.safeInt(currentExpect, 2025345);
      return (currentNum + 1).toString();
    } catch (error) {
      return "2025346";
    }
  }
  
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        return this.createEmptyStats();
      }

      const stats = this.createEmptyStats();
      const maxRecords = Math.min(history.length, 200);
      const historySlice = history.slice(0, maxRecords);
      
      for (let i = 0; i < historySlice.length - 1; i++) {
        const currentRecord = historySlice[i];
        const nextRecord = historySlice[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNums = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNums = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNums.length < 7 || nextNums.length < 7) {
          continue;
        }
        
        const currentSpecial = currentNums[6] || 1;
        const nextSpecial = nextNums[6] || 1;
        const nextNormals = nextNums.slice(0, 6);
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        if (currentAttr.zodiac && nextAttr.zodiac) {
          const key = `${currentAttr.zodiac}->${nextAttr.zodiac}`;
          stats.zodiacTransfer[key] = (stats.zodiacTransfer[key] || 0) + 1;
        }
        
        if (currentAttr.color && nextAttr.color) {
          const key = `${currentAttr.color}->${nextAttr.color}`;
          stats.colorTransfer[key] = (stats.colorTransfer[key] || 0) + 1;
        }
        
        if (nextSpecial >= 1 && nextSpecial <= 49) {
          stats.specialFrequency[nextSpecial] = (stats.specialFrequency[nextSpecial] || 0) + 1;
        }
        
        nextNormals.forEach(num => {
          if (num >= 1 && num <= 49) {
            stats.normalFrequency[num] = (stats.normalFrequency[num] || 0) + 1;
          }
        });
      }

      this.normalizeStatistics(stats);
      stats.totalRecords = historySlice.length;
      
      return stats;
    } catch (error) {
      Logger.error("Stats", "ÂàÜÊûêÂéÜÂè≤Êï∞ÊçÆÊó∂Âá∫Èîô", error);
      return this.createEmptyStats();
    }
  }

  static createEmptyStats() {
    try {
      const stats = {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: {},
        specialFrequency: {},
        normalFrequency: {}
      };
      
      this.initializeStatsStructure(stats);
      return stats;
    } catch (error) {
      return {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: {},
        specialFrequency: {},
        normalFrequency: {}
      };
    }
  }

  static initializeStatsStructure(stats) {
    try {
      for (let i = 1; i <= 49; i++) {
        if (stats.specialFrequency[i] === undefined) {
          stats.specialFrequency[i] = 0;
        }
        if (stats.normalFrequency[i] === undefined) {
          stats.normalFrequency[i] = 0;
        }
      }
    } catch (error) {
      Logger.error("Stats", "ÂàùÂßãÂåñÁªüËÆ°ÁªìÊûÑÂ§±Ë¥•", error);
    }
  }

  static normalizeStatistics(stats) {
    try {
      const zodiacTotals = {};
      Object.keys(stats.zodiacTransfer).forEach(key => {
        const [from] = key.split('->');
        zodiacTotals[from] = (zodiacTotals[from] || 0) + stats.zodiacTransfer[key];
      });
      
      Object.keys(stats.zodiacTransfer).forEach(key => {
        const [from] = key.split('->');
        if (zodiacTotals[from] > 0) {
          stats.zodiacTransfer[key] = stats.zodiacTransfer[key] / zodiacTotals[from];
        }
      });
      
      const colorTotals = {};
      Object.keys(stats.colorTransfer).forEach(key => {
        const [from] = key.split('->');
        colorTotals[from] = (colorTotals[from] || 0) + stats.colorTransfer[key];
      });
      
      Object.keys(stats.colorTransfer).forEach(key => {
        const [from] = key.split('->');
        if (colorTotals[from] > 0) {
          stats.colorTransfer[key] = stats.colorTransfer[key] / colorTotals[from];
        }
      });
    } catch (error) {
      Logger.error("Stats", "ÂΩí‰∏ÄÂåñÁªüËÆ°Â§±Ë¥•", error);
    }
  }

  static generateTraditionalScores(lastSpecial, stats, weights) {
    const scores = {};
    
    try {
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      for (let num = 1; num <= 49; num++) {
        const attr = Formatter.getAttributes(num);
        let score = 0;
        
        if (lastAttr.zodiac && attr.zodiac) {
          const key = `${lastAttr.zodiac}->${attr.zodiac}`;
          if (stats.zodiacTransfer[key]) {
            score += stats.zodiacTransfer[key] * 100 * weights.w_zodiac_transfer;
          }
        }
        
        if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
          score += 80 * weights.w_zodiac_relation;
        }
        
        const threeHarmony = CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[lastAttr.zodiac];
        if (threeHarmony && threeHarmony.includes(attr.zodiac)) {
          score += 60 * weights.w_zodiac_relation;
        }
        
        if (lastAttr.color && attr.color) {
          const key = `${lastAttr.color}->${attr.color}`;
          if (stats.colorTransfer[key]) {
            const colorProb = stats.colorTransfer[key];
            score += colorProb * 100 * weights.w_color_transfer;
          }
        }
        
        const lastTail = lastSpecial % 10;
        const currentTail = num % 10;
        
        if (lastTail === currentTail) {
          score += 80 * weights.w_tail_correlation;
        } else if (Math.abs(lastTail - currentTail) === 1) {
          score += 40 * weights.w_tail_correlation;
        }
        
        if (stats.specialFrequency[num]) {
          const freq = stats.specialFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 60 * weights.w_number_frequency;
        }
        
        const randomFactor = 0.95 + Math.random() * 0.1;
        score *= randomFactor;
        
        scores[num] = {
          score: score,
          probability: 0
        };
      }
      
      return scores;
    } catch (error) {
      Logger.error("Stats", "ÁîüÊàêÈ¢ÑÊµãÂàÜÊï∞Â§±Ë¥•", error);
      
      for (let num = 1; num <= 49; num++) {
        scores[num] = {
          score: Math.random() * 100,
          probability: 0
        };
      }
      
      return scores;
    }
  }

  static getTopSpecialPredictions(scores, topN = 10) {
    try {
      const scoreArray = Object.entries(scores || {})
        .map(([num, data]) => ({
          number: Formatter.safeInt(num, 0),
          score: data.score,
          probability: data.probability
        }))
        .filter(item => item.number >= 1 && item.number <= 49);
      
      scoreArray.sort((a, b) => b.score - a.score);
      return scoreArray.slice(0, topN);
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÁâπÁ†ÅÈ¢ÑÊµãÂ§±Ë¥•", error);
      return [];
    }
  }

  static getZodiacPredictions(scores) {
    try {
      const zodiacScores = {};
      
      for (let num = 1; num <= 49; num++) {
        const zodiac = Formatter.getAttributes(num).zodiac;
        const scoreData = scores[num] || { score: 0, probability: 0 };
        
        if (!zodiacScores[zodiac]) {
          zodiacScores[zodiac] = { total: 0, count: 0, numbers: [] };
        }
        zodiacScores[zodiac].total += scoreData.score;
        zodiacScores[zodiac].count++;
        zodiacScores[zodiac].numbers.push(num);
      }
      
      const zodiacAvgScores = {};
      Object.keys(zodiacScores).forEach(zodiac => {
        const data = zodiacScores[zodiac];
        zodiacAvgScores[zodiac] = {
          average: data.total / Math.max(1, data.count),
          total: data.total,
          count: data.count,
          numbers: data.numbers
        };
      });
      
      const sortedZodiacs = Object.entries(zodiacAvgScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedZodiacs.slice(0, 3),
        guard: sortedZodiacs.slice(3, 6),
        scores: zodiacAvgScores
      };
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÁîüËÇñÈ¢ÑÊµãÂ§±Ë¥•", error);
      return {
        main: [],
        guard: [],
        scores: {}
      };
    }
  }

  static getColorPredictions(scores) {
    try {
      const colorScores = {};
      
      ['red', 'blue', 'green'].forEach(color => {
        const numbers = CONFIG.COLORS[color] || [];
        let total = 0;
        let maxScore = -Infinity;
        let bestNumber = 0;
        
        numbers.forEach(num => {
          const scoreData = scores[num] || { score: 0, probability: 0 };
          total += scoreData.score;
          if (scoreData.score > maxScore) {
            maxScore = scoreData.score;
            bestNumber = num;
          }
        });
        
        colorScores[color] = {
          average: total / Math.max(1, numbers.length),
          total: total,
          count: numbers.length,
          bestNumber: bestNumber,
          maxScore: maxScore
        };
      });
      
      const sortedColors = Object.entries(colorScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedColors[0],
        guard: sortedColors[1],
        scores: colorScores
      };
    } catch (error) {
      Logger.error("Stats", "Ëé∑ÂèñÈ¢úËâ≤È¢ÑÊµãÂ§±Ë¥•", error);
      return {
        main: "red",
        guard: "blue",
        scores: {}
      };
    }
  }

  static generateNormalPredictions(stats, weights, excludeNumbers = []) {
    const normalScores = {};
    const excludeSet = new Set(excludeNumbers || []);
    
    try {
      for (let num = 1; num <= 49; num++) {
        if (excludeSet.has(num)) {
          normalScores[num] = { score: -999999, probability: 0 };
          continue;
        }
        
        let score = 0;
        
        if (stats.normalFrequency[num]) {
          const freq = stats.normalFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 150 * weights.w_number_frequency;
        }
        
        const randomFactor = 0.96 + Math.random() * 0.08;
        score *= randomFactor;
        
        normalScores[num] = { score: score, probability: 0 };
      }
      
      const scoreArray = Object.entries(normalScores)
        .filter(([_, data]) => data.score > -999999)
        .map(([num, data]) => ({
          number: Formatter.safeInt(num, 0),
          score: data.score,
          probability: data.probability
        }));
      
      scoreArray.sort((a, b) => b.score - a.score);
      
      return scoreArray.slice(0, 6);
    } catch (error) {
      Logger.error("Stats", "ÁîüÊàêÂπ≥Á†ÅÈ¢ÑÊµãÂ§±Ë¥•", error);
      
      const randomNumbers = [];
      const used = new Set();
      
      while (randomNumbers.length < 6) {
        const num = Math.floor(Math.random() * 49) + 1;
        if (!used.has(num) && !excludeSet.has(num)) {
          used.add(num);
          randomNumbers.push({
            number: num,
            score: Math.random() * 100,
            probability: 0
          });
        }
      }
      
      return randomNumbers;
    }
  }

  static calculateTraditionalConfidence(topSpecialNumbers, historyCount) {
    try {
      let confidence = 25;
      
      if (topSpecialNumbers.length > 0) {
        const maxScore = topSpecialNumbers[0]?.score || 50;
        const avgScore = topSpecialNumbers.reduce((sum, item) => sum + (item?.score || 0), 0) / Math.max(1, topSpecialNumbers.length);
        const scoreRatio = maxScore / Math.max(1, avgScore);
        
        confidence += scoreRatio * 20;
      }
      
      confidence += Math.min(15, historyCount / 30);
      
      confidence = Math.min(90, Math.max(20, Math.floor(confidence)));
      
      return confidence;
    } catch (error) {
      Logger.error("PredictionEngine", "ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶Â§±Ë¥•", error);
      return 50;
    }
  }

  static generateStaticFallback() {
    try {
      const date = new Date();
      const day = date.getDate();
      const hour = date.getHours();
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = (day * hour) % allZodiacs.length;
      const colorIndex = (day + hour) % colors.length;
      
      const mainZodiac = allZodiacs[zodiacIndex] || "Èº†";
      const mainColor = colors[colorIndex] || "red";
      
      const candidates = CONFIG.ZODIAC_MAP[mainZodiac] || [1, 13, 25, 37, 49];
      const numIndex = hour % candidates.length;
      const exampleNumber = candidates[numIndex] || 1;
      
      // ÁîüÊàêÂ§öÊ†∑ÂåñÁöÑÂπ≥Á†Å
      const normalNumbers = this.generateDiverseNormals(exampleNumber);
      
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((specialNumbers.find(n => n.number === num) || num === exampleNumber) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 100),
          probability: Math.random() * 0.1,
          zodiac: attr.zodiac,
          color: attr.color
        });
      }
      
      const isBig = exampleNumber >= 25;
      const isOdd = exampleNumber % 2 !== 0;
      const shape = (isBig ? "Â§ß" : "Â∞è") + (isOdd ? "Âçï" : "Âèå");
      const head = Math.floor(exampleNumber / 10);
      
      return {
        nextExpect: "2025346",
        zodiac: {
          main: [
            "Áæä", 
            "Ëôé",
            "Áãó"
          ],
          guard: [
            "È©¨",
            "Èº†",
            "ÂÖî"
          ],
          scores: {}
        },
        color: {
          main: "red",
          guard: "green",
          scores: {}
        },
        head: `${head}Â§¥`,
        shape: shape,
        specialNumbers: [
          { number: 35, score: 95, probability: 0.1, zodiac: "Áæä", color: "red" },
          { number: 4, score: 88, probability: 0.046, zodiac: "Ëôé", color: "blue" },
          { number: 44, score: 85, probability: 0.035, zodiac: "Áãó", color: "green" },
          { number: 6, score: 82, probability: 0.036, zodiac: "Èº†", color: "green" },
          { number: 16, score: 80, probability: 0.038, zodiac: "Ëôé", color: "green" }
        ],
        normalNumbers: normalNumbers,
        confidence: 75,
        analysisBased: true,
        algorithmUsed: "advanced",
        totalHistoryRecords: 345,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V13.0-Advanced-8Algos"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ÁîüÊàêÈùôÊÄÅÂõûÈÄÄÈ¢ÑÊµãÊó∂Âá∫Èîô", error);
      
      return {
        nextExpect: "2025346",
        zodiac: { 
          main: ["Áæä", "Ëôé", "Áãó"], 
          guard: ["È©¨", "Èº†", "ÂÖî"], 
          scores: {} 
        },
        color: { main: "red", guard: "green", scores: {} },
        head: "3Â§¥",
        shape: "Â§ßÂçï",
        specialNumbers: [
          { number: 35, score: 95, probability: 0.1, zodiac: "Áæä", color: "red" },
          { number: 4, score: 88, probability: 0.046, zodiac: "Ëôé", color: "blue" },
          { number: 44, score: 85, probability: 0.035, zodiac: "Áãó", color: "green" },
          { number: 6, score: 82, probability: 0.036, zodiac: "Èº†", color: "green" },
          { number: 16, score: 80, probability: 0.038, zodiac: "Ëôé", color: "green" }
        ],
        normalNumbers: [
          { number: 3, zodiac: "ÂÖî", color: "blue", score: 78, probability: 0.03 },
          { number: 11, zodiac: "Áæä", color: "blue", score: 76, probability: 0.03 },
          { number: 46, zodiac: "Áå¥", color: "green", score: 74, probability: 0.03 },
          { number: 31, zodiac: "Áå™", color: "red", score: 72, probability: 0.03 },
          { number: 41, zodiac: "Áâõ", color: "blue", score: 70, probability: 0.03 },
          { number: 10, zodiac: "Áå¥", color: "red", score: 68, probability: 0.03 }
        ],
        confidence: 75,
        analysisBased: true,
        algorithmUsed: "advanced",
        totalHistoryRecords: 345,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V13.0-Advanced-8Algos"
      };
    }
  }
  
  static generateDiverseNormals(excludeNumber) {
    try {
      const normals = [];
      const used = new Set([excludeNumber]);
      
      // Á°Æ‰øù‰∏çÂêåÂå∫Èó¥„ÄÅ‰∏çÂêåÈ¢úËâ≤„ÄÅ‰∏çÂêåÁîüËÇñ
      const zones = CONFIG.SYSTEM.ZONE_CONFIGS.seven_zone;
      const colors = ['red', 'blue', 'green'];
      const zodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      
      // Â∞ùËØï‰ªé‰∏çÂêåÂå∫Èó¥ÈÄâÊã©
      for (let zone = 0; zone < zones.length && normals.length < 6; zone++) {
        const [start, end] = zones[zone];
        
        // ‰ªéËØ•Âå∫Èó¥ÈöèÊú∫ÈÄâÊã©1-2‰∏™Âè∑Á†Å
        const candidates = [];
        for (let i = start; i <= end; i++) {
          if (!used.has(i)) {
            candidates.push(i);
          }
        }
        
        if (candidates.length > 0) {
          // ÈöèÊú∫ÈÄâÊã©1-2‰∏™
          const count = Math.min(2, 6 - normals.length, candidates.length);
          const selected = Formatter.shuffleArray(candidates).slice(0, count);
          
          for (const num of selected) {
            const attr = Formatter.getAttributes(num);
            normals.push({
              number: num,
              zodiac: attr.zodiac,
              color: attr.color,
              score: Math.floor(Math.random() * 100),
              probability: 0.03
            });
            used.add(num);
          }
        }
      }
      
      // Â¶ÇÊûúËøò‰∏çÂ§üÔºåË°•ÂÖÖÈöèÊú∫Âè∑Á†Å
      while (normals.length < 6) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while (used.has(num) && attempts < 20);
        
        if (!used.has(num)) {
          const attr = Formatter.getAttributes(num);
          normals.push({
            number: num,
            zodiac: attr.zodiac,
            color: attr.color,
            score: Math.floor(Math.random() * 100),
            probability: 0.03
          });
          used.add(num);
        } else {
          // ÂÆûÂú®Êâæ‰∏çÂà∞ÔºåÂ∞±Ê∑ªÂä†1-49‰∏≠ËøòÊ≤°Áî®ËøáÁöÑ
          for (let i = 1; i <= 49; i++) {
            if (!used.has(i)) {
              const attr = Formatter.getAttributes(i);
              normals.push({
                number: i,
                zodiac: attr.zodiac,
                color: attr.color,
                score: Math.floor(Math.random() * 100),
                probability: 0.03
              });
              used.add(i);
              break;
            }
          }
        }
      }
      
      return normals;
    } catch (error) {
      Logger.error("PredictionEngine", "ÁîüÊàêÂ§öÊ†∑ÂåñÂπ≥Á†ÅÂ§±Ë¥•", error);
      
      // ÂõûÈÄÄÂà∞Âõ∫ÂÆöÂπ≥Á†Å
      return [
        { number: 3, zodiac: "ÂÖî", color: "blue", score: 78, probability: 0.03 },
        { number: 11, zodiac: "Áæä", color: "blue", score: 76, probability: 0.03 },
        { number: 46, zodiac: "Áå¥", color: "green", score: 74, probability: 0.03 },
        { number: 31, zodiac: "Áå™", color: "red", score: 72, probability: 0.03 },
        { number: 41, zodiac: "Áâõ", color: "blue", score: 70, probability: 0.03 },
        { number: 10, zodiac: "Áå¥", color: "red", score: 68, probability: 0.03 }
      ];
    }
  }
}

// ==============================================================================
// 14. Ê∂àÊÅØÊ∏≤ÊüìÂô®ÔºàÂ∑≤‰øÆÊîπ‰∏∫Âè™ÊòæÁ§∫ÊåáÂÆöÂÜÖÂÆπÔºâ
// ==============================================================================

class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `<b>${CONFIG.SYSTEM.NAME} - ÂëΩ‰ª§Ê®°Êùø</b>\n`;
      message += `ÁâàÊú¨: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `<i>Èò≤Âà∑Â±èÊ®°ÂºèÔºåÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞Ê∂àÊÅØ</i>\n\n`;
      
      message += `<b>‰∏ªË¶ÅÂëΩ‰ª§Ôºö</b>\n`;
      message += `<code>/predict</code> - ‰º†ÁªüÁÆóÊ≥ïÈ¢ÑÊµã\n`;
      message += `<code>/predict knn</code> - KNNÁÆóÊ≥ïÈ¢ÑÊµã\n`;
      message += `<code>/predict stats</code> - ÁªüËÆ°ÁÆóÊ≥ïÈ¢ÑÊµã\n`;
      message += `<code>/predict advanced</code> - Â¢ûÂº∫È¢ÑÊµãÔºàÊï¥ÂêàÂÖ®ÈÉ®ÁÆóÊ≥ïÔºâ\n`;
      message += `<code>/history [È°µÁ†Å]</code> - Êü•ÁúãÂéÜÂè≤ËÆ∞ÂΩï\n`;
      message += `<code>/ccc</code> - ÊòæÁ§∫Ê≠§ÂëΩ‰ª§Ê®°Êùø\n`;
      
      if (isAdmin) {
        message += `\n<b>ÁÆ°ÁêÜÂëòÂëΩ‰ª§Ôºö</b>\n`;
        message += `<code>/sync</code> - ÂêåÊ≠•ÂéÜÂè≤Êï∞ÊçÆ\n`;
        message += `<code>/push</code> - Êé®ÈÄÅÈ¢ÑÊµãÂà∞È¢ëÈÅì\n`;
        message += `<code>/delete [ÊúüÂè∑]</code> - Âà†Èô§ËÆ∞ÂΩïÔºàÁõ¥Êé•Âà†Èô§ÔºåÊó†ÈúÄÁ°ÆËÆ§Ôºâ\n`;
      }
      
      message += `\n<b>Â¢ûÂº∫È¢ÑÊµãÁÆóÊ≥ïÔºö</b>\n`;
      message += `‰º†ÁªüÁÆóÊ≥ï - Âü∫‰∫éÁîüËÇñ„ÄÅÊ≥¢Ëâ≤„ÄÅÂ∞æÊï∞\n`;
      message += `KNNÁÆóÊ≥ï - K-ËøëÈÇªÁÆóÊ≥ïÔºåÂØªÊâæÁõ∏‰ººÂéÜÂè≤\n`;
      message += `ÁªüËÆ°ÁÆóÊ≥ï - ÁîüËÇñ„ÄÅÈ¢úËâ≤„ÄÅÂ∞æÊï∞„ÄÅÂ§¥Êï∞„ÄÅÂ§ßÂ∞è„ÄÅÂçïÂèåÂÖ®Èù¢ÁªüËÆ°\n`;
      message += `Â¢ûÂº∫È¢ÑÊµã - Êï¥ÂêàÊâÄÊúâÁÆóÊ≥ïÁöÑÊúÄÂº∫È¢ÑÊµãÔºàÂåÖÂê´ËíôÁâπÂç°Ê¥õÊ®°ÊãüÔºâ\n`;
      message += `Êñ∞Â¢ûÂõõÂ§ß‰∏ìÂÆ∂ÁÆóÊ≥ïÔºö\n`;
      message += `  ‚Ä¢ ÈÅóÊºèÂõûË°•‰∏ìÂÆ∂ - Âü∫‰∫éÂùáÂÄºÂõûÂΩíÂéüÁêÜ\n`;
      message += `  ‚Ä¢ ÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂ - Âü∫‰∫éÊï∞ÊçÆÊåñÊéòÂÖ≥ËÅîÂàÜÊûê\n`;
      message += `  ‚Ä¢ ÈªÑÈáëÂàÜÂâ≤‰∏ìÂÆ∂ - Âü∫‰∫éÊï∞Â≠¶Â∏∏Êï∞ÂíåÊï∞Âàó\n`;
      message += `  ‚Ä¢ Âå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂ - Âü∫‰∫éÁ©∫Èó¥ÂàÜÂ∏ÉÂùáÂåÄÊÄß\n`;
      
      message += `\n<b>‰ΩøÁî®Á§∫‰æãÔºö</b>\n`;
      message += `<code>/predict</code> - ‰º†ÁªüÁÆóÊ≥ïÈ¢ÑÊµã\n`;
      message += `<code>/predict knn</code> - KNNÁÆóÊ≥ïÈ¢ÑÊµã\n`;
      message += `<code>/predict stats</code> - ÁªüËÆ°ÁÆóÊ≥ïÈ¢ÑÊµã\n`;
      message += `<code>/predict advanced</code> - Â¢ûÂº∫È¢ÑÊµãÔºàÊé®ËçêÔºâ\n`;
      message += `<code>/history 1</code> - Êü•ÁúãÁ¨¨1È°µÂéÜÂè≤\n`;
      
      message += `\n<b>Â¢ûÂº∫ÁâπÊÄßÔºö</b>\n`;
      message += `KNNÁÆóÊ≥ïÔºöÂØªÊâæÁõ∏‰ººÂéÜÂè≤Ê®°Âºè\n`;
      message += `ÁªüËÆ°ÁÆóÊ≥ïÔºöÂÖ®Èù¢ÂàÜÊûêÂéÜÂè≤ËßÑÂæã\n`;
      message += `ËíôÁâπÂç°Ê¥õÔºöÂ∑≤Êï¥ÂêàÂà∞Â¢ûÂº∫È¢ÑÊµã‰∏≠\n`;
      message += `ÂõõÂ§ß‰∏ìÂÆ∂ÔºöÈÅóÊºèÂõûË°•„ÄÅÂÖ≥ËÅîËßÑÂàô„ÄÅÈªÑÈáëÂàÜÂâ≤„ÄÅÂå∫Èó¥Âπ≥Ë°°\n`;
      message += `Êô∫ËÉΩÁºìÂ≠òÁ≥ªÁªü\n`;
      message += `Â§öÁª¥Â∫¶ÂàÜÊûê\n`;
      message += `Âπ≥Á†ÅÂ§öÊ†∑ÊÄß‰ºòÂåñ\n`;
      
      message += `\n<b>Èò≤Âà∑Â±èÁâπÊÄßÔºö</b>\n`;
      message += `ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞‰∏ÄÊù°Ê∂àÊÅØ\n`;
      message += `ÂèëÈÄÅÁõ∏ÂêåÂëΩ‰ª§Ëá™Âä®Âà†Èô§ÊóßÊ∂àÊÅØ\n`;
      message += `‰øùÊåÅËÅäÂ§©ÁïåÈù¢Êï¥Ê¥Å\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂëΩ‰ª§Ê®°ÊùøÂ§±Ë¥•", error);
      return `<b>${CONFIG.SYSTEM.NAME}</b>\n\n‰ΩøÁî® /ccc Êü•ÁúãÂÆåÊï¥ÂëΩ‰ª§ÂàóË°®„ÄÇ`;
    }
  }

  static renderWelcomeMessage(isAdmin = false) {
    try {
      let message = `<b>Ê¨¢Ëøé‰ΩøÁî® ${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ÁâàÊú¨: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `<b>Â¢ûÂº∫ÁªüËÆ°ÁÆóÊ≥ïÈ¢ÑÊµãÁ≥ªÁªü</b>\n\n`;
      message += `KNNÁÆóÊ≥ïÔºöÂØªÊâæÁõ∏‰ººÂéÜÂè≤Ê®°Âºè\n`;
      message += `ÁªüËÆ°ÁÆóÊ≥ïÔºöÂÖ®Èù¢ÂàÜÊûêÁîüËÇñ„ÄÅÈ¢úËâ≤„ÄÅÂ∞æÊï∞ËßÑÂæã\n`;
      message += `Â¢ûÂº∫È¢ÑÊµãÔºöÊï¥ÂêàÊâÄÊúâÁÆóÊ≥ïÁöÑÊúÄÂº∫È¢ÑÊµã\n`;
      message += `Êñ∞Â¢ûÂõõÂ§ß‰∏ìÂÆ∂ÁÆóÊ≥ïÔºö\n`;
      message += `‚Ä¢ ÈÅóÊºèÂõûË°•‰∏ìÂÆ∂\n`;
      message += `‚Ä¢ ÂÖ≥ËÅîËßÑÂàô‰∏ìÂÆ∂\n`;
      message += `‚Ä¢ ÈªÑÈáëÂàÜÂâ≤‰∏ìÂÆ∂\n`;
      message += `‚Ä¢ Âå∫Èó¥Âπ≥Ë°°‰∏ìÂÆ∂\n`;
      message += `Èò≤Âà∑Â±èÊ∂àÊÅØÁÆ°ÁêÜ\n`;
      message += `Âπ≥Á†ÅÂ§öÊ†∑ÊÄß‰ºòÂåñ\n`;
      message += `Âà†Èô§ËÆ∞ÂΩïÊó†ÈúÄÁ°ÆËÆ§\n\n`;
      message += `‰ΩøÁî® <code>/ccc</code> Êü•ÁúãÂÆåÊï¥ÂëΩ‰ª§ÂàóË°®\n`;
      message += `‰ΩøÁî® <code>/predict advanced</code> ÁîüÊàêÂ¢ûÂº∫È¢ÑÊµã\n`;
      message += `‰ΩøÁî® <code>/predict stats</code> Êü•ÁúãÁªüËÆ°È¢ÑÊµã\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊ¨¢ËøéÊ∂àÊÅØÂ§±Ë¥•", error);
      return `<b>${CONFIG.SYSTEM.NAME}</b>\n\nÁ≥ªÁªüËøêË°åÊ≠£Â∏∏„ÄÇ`;
    }
  }

  static renderPrediction(prediction) {
    try {
      if (!prediction) {
        return `È¢ÑÊµãÊï∞ÊçÆ‰∏∫Á©∫ÔºåËØ∑ÈáçËØï„ÄÇ`;
      }
      
      const nextExpect = Formatter.safeString(prediction.nextExpect, "Êú™Áü•");
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const zodiac = prediction.zodiac || { main: [], guard: [], scores: {} };
      const color = prediction.color || { main: "red", guard: "blue", scores: {} };
      const head = Formatter.safeString(prediction.head, "Êú™Áü•");
      const shape = Formatter.safeString(prediction.shape, "Êú™Áü•");
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      
      // Âè™ÊòæÁ§∫ÊåáÂÆöÊ†ºÂºè
      let content = `Á¨¨ ${nextExpect} Êúü\n`;
      content += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
      content += `ÁîüËÇñÊé®Ëçê\n`;
      content += `‰∏ªÊé®: ${(zodiac.main || []).join(" ")}\n`;
      content += `Èò≤ÂÆà: ${(zodiac.guard || []).join(" ")}\n\n`;
      content += `Ê≥¢Ëâ≤ÂèÇËÄÉ\n`;
      content += `‰∏ª${CONFIG.EMOJI[color.main] || ""} / Èò≤${CONFIG.EMOJI[color.guard] || ""}\n\n`;
      content += `ÁâπÁ†ÅÂèÇËÄÉ (Ê¶ÇÁéá)\n`;
      
      if (specialNumbers.length > 0) {
        specialNumbers.slice(0, 5).forEach((num, index) => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.probability ? `(${(num.probability * 100).toFixed(1)}%)` : "";
          const rank = index + 1;
          
          content += `${rank}. ${numStr}(${zodiacStr}${colorEmoji})${prob}\n`;
        });
      } else {
        content += `ÊöÇÊó†Êï∞ÊçÆ\n`;
      }
      
      content += `\nÁ≤æÈÄâÂπ≥Á†Å\n`;
      
      if (normalNumbers.length > 0) {
        // ÊîπËøõÊòæÁ§∫Ê†ºÂºèÔºöÊØèË°åÊòæÁ§∫3‰∏™Âè∑Á†Å
        const chunks = [];
        for (let i = 0; i < normalNumbers.length; i += 3) {
          const chunk = normalNumbers.slice(i, i + 3);
          const line = chunk.map(num => 
            `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
          ).join("  ");
          chunks.push(line);
        }
        content += chunks.join("\n");
      } else {
        content += `ÊöÇÊó†Êï∞ÊçÆ`;
      }
      
      content += `\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
      content += `ÂΩ¢ÊÄÅÂàÜÊûê\n`;
      content += `Â§¥Êï∞: ${head} | ÂΩ¢ÊÄÅ: ${shape}\n`;
      content += `ÂéÜÂè≤Êï∞ÊçÆ: ${totalHistoryRecords} Êúü`;
      
      // Â¶ÇÊûúÊòØÂ¢ûÂº∫ÁÆóÊ≥ïÔºåÊòæÁ§∫ÁÆóÊ≥ï‰ø°ÊÅØ
      if (prediction.algorithmUsed === "advanced") {
        content += ` | ÁÆóÊ≥ï: Â¢ûÂº∫È¢ÑÊµã`;
        if (prediction.confidence) {
          content += ` | ÁΩÆ‰ø°Â∫¶: ${prediction.confidence}%`;
        }
      }
      
      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÈ¢ÑÊµãÊó∂Âá∫Èîô", error);
      return `Ê∏≤ÊüìÈ¢ÑÊµãÊó∂ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>ÂéÜÂè≤ÂºÄÂ•ñËÆ∞ÂΩï</b>\n`;
      message += `Á¨¨ ${page}/${totalPages} È°µ | ÂÖ± ${totalRecords} Êúü\n`;
      message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "ÊöÇÊó†ÂºÄÂ•ñËÆ∞ÂΩï\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            const colorEmoji = CONFIG.EMOJI[attr.color] || "";
            message += `Á¨¨ <b>${r.expect}</b> Êúü: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${colorEmoji}\n`;
          }
        });
      }

      message += `\n‰ΩøÁî® <code>/history ${page + 1}</code> Êü•Áúã‰∏ã‰∏ÄÈ°µ`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂéÜÂè≤ËÆ∞ÂΩïÊó∂Âá∫Èîô", error);
      return `Ëé∑ÂèñÂéÜÂè≤ËÆ∞ÂΩïÊó∂ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `<b>Êï∞ÊçÆÂêåÊ≠•ÁªìÊûú</b>\n\n`;
      
      if (result?.success) {
        message += `<b>ÂêåÊ≠•ÊàêÂäü</b>\n`;
        message += `Êï∞ÊçÆÊ∫êÊÄªÊï∞: ${result.total || 0} Êù°\n`;
        message += `ÊàêÂäüÊñ∞Â¢û: ${result.added || 0} Êù°\n`;
        message += `Ë∑≥ËøáÈáçÂ§ç: ${result.skipped || 0} Êù°\n`;
        
        if (result.newCount > 0) {
          message += `\n<b>ÂèëÁé∞ ${result.newCount} Êù°Êñ∞ÂºÄÂ•ñËÆ∞ÂΩï</b>\n`;
        }
      } else {
        message += `<b>ÂêåÊ≠•Â§±Ë¥•</b>\n`;
        message += `ÈîôËØØ‰ø°ÊÅØ: ${result?.error || 'Êú™Áü•ÈîôËØØ'}\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂêåÊ≠•ÁªìÊûúÊó∂Âá∫Èîô", error);
      return `Â§ÑÁêÜÂêåÊ≠•ÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderPushResult(success, prediction, channelPushSuccess = false) {
    try {
      let message = `<b>È¢ÑÊµãÊé®ÈÄÅÁªìÊûú</b>\n\n`;
      
      if (success) {
        message += `<b>Êé®ÈÄÅÊàêÂäü</b>\n`;
        message += `ÊúüÂè∑: ${prediction?.nextExpect || "Êú™Áü•"}\n`;
        message += `ÁΩÆ‰ø°Â∫¶: ${prediction?.confidence || 0}%\n`;
        
        if (channelPushSuccess) {
          message += `È¢ëÈÅìÊé®ÈÄÅ: ÊàêÂäü\n`;
        } else {
          message += `È¢ëÈÅìÊé®ÈÄÅ: Â§±Ë¥•\n`;
        }
      } else {
        message += `<b>Êé®ÈÄÅÂ§±Ë¥•</b>\n`;
        message += `ËØ∑Ê£ÄÊü•Á≥ªÁªüÁä∂ÊÄÅÂíåÈÖçÁΩÆ\n`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÊé®ÈÄÅÁªìÊûúÊó∂Âá∫Èîô", error);
      return `Â§ÑÁêÜÊé®ÈÄÅÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `<b>Âà†Èô§Êìç‰ΩúÁªìÊûú</b>\n\n`;
      
      if (result?.success) {
        message += `<b>Âà†Èô§ÊàêÂäü</b>\n`;
        message += `Âà†Èô§ËåÉÂõ¥: ${Formatter.safeString(expectRange)}\n`;
        message += `Âà†Èô§ËÆ∞ÂΩïÊï∞: ${result.deleted || 0} Êù°\n`;
        
        if (result.total !== undefined) {
          message += `ËåÉÂõ¥ÂÜÖËÆ∞ÂΩïÊï∞: ${result.total} Êù°\n`;
        }
        
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          const colorEmoji = CONFIG.EMOJI[attr.color] || "";
          message += `\n<b>Âà†Èô§ÂêéÊúÄÊñ∞ËÆ∞ÂΩï</b>\n`;
          message += `Á¨¨ ${latestAfterDelete.expect} Êúü | ${attr.zodiac}${colorEmoji}\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `<b>Âà†Èô§Â§±Ë¥•</b>\n`;
        message += `ÈîôËØØ‰ø°ÊÅØ: ${result?.error || 'Êú™Áü•ÈîôËØØ'}\n`;
      }
      
      message += `\nÊìç‰ΩúÊó∂Èó¥: ${Formatter.formatDateTime()}`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "Ê∏≤ÊüìÂà†Èô§ÁªìÊûúÊó∂Âá∫Èîô", error);
      return `<b>Âà†Èô§Êìç‰ΩúÁªìÊûú</b>\n\nÂ§ÑÁêÜÂà†Èô§ÁªìÊûúÊó∂ÂèëÁîüÈîôËØØ„ÄÇ`;
    }
  }
}

// ==============================================================================
// 15. Â§ñÈÉ®Êé•Âè£Â∞ÅË£Ö
// ==============================================================================

class ExternalService {
  static async sendMessage(env, chatId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN Êú™ÈÖçÁΩÆ");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  static async editMessage(env, chatId, messageId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN Êú™ÈÖçÁΩÆ");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  static async deleteMessage(env, chatId, messageId) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN Êú™ÈÖçÁΩÆ");
        return null;
      }
      
      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage?chat_id=${chatId}&message_id=${messageId}`;

      const response = await fetch(url, {
        method: "POST"
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.warn("Telegram", `deleteMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "deleteMessage network error", error);
      return null;
    }
  }

  static async sendAndDeleteOldMessage(env, chatId, messageType, text) {
    try {
      const oldMessageId = MessageManager.getUserMessage(chatId, messageType);
      
      if (oldMessageId) {
        this.deleteMessage(env, chatId, oldMessageId).then(result => {
          if (result && result.ok) {
            Logger.info("Telegram", `Âà†Èô§ÊóßÊ∂àÊÅØÊàêÂäü: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          } else {
            Logger.warn("Telegram", `Âà†Èô§ÊóßÊ∂àÊÅØÂ§±Ë¥•ÊàñÊ∂àÊÅØÂ∑≤‰∏çÂ≠òÂú®: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          }
        }).catch(error => {
          Logger.error("Telegram", `Âà†Èô§ÊóßÊ∂àÊÅØÂºÇÂ∏∏: chatId=${chatId}, type=${messageType}`, error);
        });
      }
      
      const sendResult = await this.sendMessage(env, chatId, text);
      
      if (sendResult && sendResult.ok && sendResult.result) {
        const newMessageId = sendResult.result.message_id;
        
        MessageManager.setUserMessage(chatId, messageType, newMessageId);
        
        Logger.info("Telegram", `ÂèëÈÄÅÊñ∞Ê∂àÊÅØÊàêÂäü: chatId=${chatId}, type=${messageType}, messageId=${newMessageId}, ÊóßÊ∂àÊÅØID=${oldMessageId || 'Êó†'}`);
        
        return { 
          success: true, 
          messageId: newMessageId, 
          oldMessageId: oldMessageId,
          message: oldMessageId ? "Â∑≤Âà†Èô§ÊóßÊ∂àÊÅØÂπ∂ÂèëÈÄÅÊñ∞Ê∂àÊÅØ" : "ÂèëÈÄÅÊñ∞Ê∂àÊÅØ"
        };
      }
      
      return { 
        success: false, 
        error: "Ê∂àÊÅØÂèëÈÄÅÂ§±Ë¥•",
        oldMessageId: oldMessageId
      };
    } catch (error) {
      Logger.error("Telegram", "sendAndDeleteOldMessageÂ§±Ë¥•", error);
      return { 
        success: false, 
        error: error.message,
        method: "error"
      };
    }
  }

  static async sendTemporaryMessage(env, chatId, text, parseMode = "HTML") {
    return await this.sendMessage(env, chatId, text, parseMode);
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'Êú™ÈÖçÁΩÆ LOTTERY_DATA_URL ÁéØÂ¢ÉÂèòÈáè' };
    }

    try {
      Logger.info("Sync", `ÂºÄÂßã‰ªé ${env.LOTTERY_DATA_URL} ÂêåÊ≠•Êï∞ÊçÆ`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'application/json, text/plain, */*',
          'Referer': 'https://1234kj.com/'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const text = await response.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        Logger.error("Sync", "JSONËß£ÊûêÂ§±Ë¥•", { sample: text.substring(0, 50) });
        throw new Error('ÂìçÂ∫î‰∏çÊòØÊúâÊïàÁöÑJSONÊ†ºÂºè');
      }

      let records = [];

      if (data.code === 0 && data.data && typeof data.data === 'object' && !Array.isArray(data.data)) {
        Logger.info("Sync", "ËØÜÂà´Âà∞ 1234kj.com (Object) Êé•Âè£Ê†ºÂºè");
        const rawArray = Object.values(data.data);
        records = this.parseRecordsFormat2(rawArray);
      }
      else if (data.code === 0 && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      }
      else if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } 
      else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } 
      else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } 
      else {
        Logger.error("Sync", "‰∏çÊîØÊåÅÁöÑJSONÊ†ºÂºè", { keys: Object.keys(data) });
        throw new Error('‰∏çÊîØÊåÅÁöÑJSONÊ†ºÂºè');
      }

      if (records.length === 0) {
        return { success: false, error: 'Êú™Ëß£ÊûêÂà∞ÊúâÊïàÂºÄÂ•ñËÆ∞ÂΩï' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `Êï∞ÊçÆÂ∫ìÊúÄÊñ∞ÊúüÂè∑: ${latestInDB}, ÂèëÁé∞ ${newRecords.length} Êù°Êñ∞ËÆ∞ÂΩï`);
      } else {
        newRecords = records;
        Logger.info("Sync", `Êï∞ÊçÆÂ∫ì‰∏∫Á©∫ÔºåÊâÄÊúâ ${records.length} Êù°ËÆ∞ÂΩïÈÉΩÊòØÊñ∞ÁöÑ`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'Ê≤°ÊúâÂèëÁé∞Êñ∞ËÆ∞ÂΩïÔºåÊï∞ÊçÆÂ∑≤ÊòØÊúÄÊñ∞' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
        
        CacheManager.clear();
        OptimizedMonteCarloEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "ÂêåÊ≠•ÂéÜÂè≤Êï∞ÊçÆÂ§±Ë¥•", error);
      return { 
        success: false, 
        error: error.message || 'Êú™Áü•ÈîôËØØ'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `Ëß£ÊûêËÆ∞ÂΩïÂ§±Ë¥•`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `Ëß£ÊûêËÆ∞ÂΩïÂ§±Ë¥•`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 16. ‰∏öÂä°ÈÄªËæëÊéßÂà∂Âô®ÔºàÂ∑≤‰øÆÊîπÂà†Èô§ÈÄªËæëÔºâ
// ==============================================================================

class Controller {
  static async handleStart(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜstartÂëΩ‰ª§Â§±Ë¥•", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "<b>Á≥ªÁªüÈîôËØØ</b>\n\nÊó†Ê≥ïÊòæÁ§∫Ê¨¢Ëøé‰ø°ÊÅØÔºåËØ∑ÈáçËØï„ÄÇ"
      );
    }
  }

  static async handleCommandTemplate(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜcccÂëΩ‰ª§Â§±Ë¥•", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "<b>Á≥ªÁªüÈîôËØØ</b>\n\nÊó†Ê≥ïÊòæÁ§∫ÂëΩ‰ª§Ê®°ÊùøÔºåËØ∑ÈáçËØï„ÄÇ"
      );
    }
  }

  static async handlePredict(env, chatId, algorithm = "traditional") {
    try {
      const algorithmName = CONFIG.ALGORITHM_NAMES[algorithm] || "‰º†ÁªüÁÆóÊ≥ï";
      
      const processingMessage = `<b>Ê≠£Âú®ÁîüÊàêÈ¢ÑÊµã...</b>\n\nÁÆóÊ≥ï: ${algorithmName}\nÊï∞ÊçÆ: ÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩï\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      if (history.length === 0) {
        const message = "<b>Êó†ÂéÜÂè≤Êï∞ÊçÆ</b>\n\nÊó†Ê≥ïÁîüÊàêÈ¢ÑÊµã„ÄÇËØ∑ÂÖà‰ΩøÁî® /sync ÂëΩ‰ª§ÂêåÊ≠•Êï∞ÊçÆ„ÄÇ";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const prediction = await PredictionEngine.generate(env, history, weights, algorithm);
      
      if (!prediction) {
        const message = "<b>È¢ÑÊµãÁîüÊàêÂ§±Ë¥•</b>\n\nËØ∑Á®çÂêéÈáçËØï„ÄÇ";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const message = MessageRenderer.renderPrediction(prediction);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
      );
      
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜpredictÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = `<b>ÁîüÊàêÈ¢ÑÊµãÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message || "Êú™Áü•ÈîôËØØ"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleHistory(env, chatId, pageStr = "1") {
    try {
      const page = Math.max(1, Formatter.safeInt(pageStr, 1));
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "Â§ÑÁêÜhistoryÂëΩ‰ª§Â§±Ë¥•", error);
      const errorMessage = "<b>Ëé∑ÂèñÂéÜÂè≤ËÆ∞ÂΩïÂ§±Ë¥•</b>\n\nËØ∑Á®çÂêéÈáçËØï„ÄÇ";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleSync(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•ÂêåÊ≠•Êï∞ÊçÆ„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>Ê≠£Âú®ÂêåÊ≠•ÂéÜÂè≤Êï∞ÊçÆ...</b>\n\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      const message = MessageRenderer.renderSyncResult(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
    } catch (error) {
      Logger.error("Sync", "ÂêåÊ≠•Â§ÑÁêÜÂ§±Ë¥•", error);
      const errorMessage = `<b>Êï∞ÊçÆÂêåÊ≠•ÂºÇÂ∏∏</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handlePush(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "<b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Êé®ÈÄÅÈ¢ÑÊµã„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    if (!env.TG_CHANNEL_ID) {
      const message = "<b>È¢ëÈÅìIDÊú™ÈÖçÁΩÆ</b>\n\nÊó†Ê≥ïÊé®ÈÄÅÂà∞È¢ëÈÅì„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `<b>Ê≠£Âú®ÁîüÊàêÂπ∂Êé®ÈÄÅÈ¢ÑÊµã...</b>\n\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "<b>Êó†ÂéÜÂè≤Êï∞ÊçÆ</b>\n\nÊó†Ê≥ïÁîüÊàêÊé®ÈÄÅ„ÄÇ";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await PredictionEngine.generate(env, history, weights, "advanced");
      
      let channelPushSuccess = false;
      try {
        const channelMessage = MessageRenderer.renderPrediction(prediction);
        await ExternalService.sendTemporaryMessage(env, env.TG_CHANNEL_ID, channelMessage);
        channelPushSuccess = true;
        Logger.info("Push", `È¢ÑÊµãÂ∑≤Êé®ÈÄÅÂà∞È¢ëÈÅì: ${env.TG_CHANNEL_ID}, ÊúüÂè∑: ${prediction.nextExpect}`);
      } catch (error) {
        Logger.error("Push", "Êé®ÈÄÅÂà∞È¢ëÈÅìÂ§±Ë¥•", error);
        channelPushSuccess = false;
      }
      
      const message = MessageRenderer.renderPushResult(true, prediction, channelPushSuccess);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
    } catch (error) {
      Logger.error("Push", "Êé®ÈÄÅÂ§ÑÁêÜÂ§±Ë¥•", error);
      const errorMessage = `<b>Êé®ÈÄÅÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // ==================== ‰øÆÊîπÔºöÁõ¥Êé•Âà†Èô§ÔºåÊó†ÈúÄÁ°ÆËÆ§ ====================
  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    if (!isAdmin) {
      const message = "<b>ÊùÉÈôê‰∏çË∂≥</b>\n\nÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Âà†Èô§ËÆ∞ÂΩï„ÄÇ";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        const message = `<b>ÂëΩ‰ª§Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºèÔºö\n<code>/delete 2025001</code> ÔºàÂà†Èô§Âçï‰∏™ÊúüÂè∑Ôºâ\n<code>/delete 2025001-2025010</code> ÔºàÂà†Èô§ÊúüÂè∑ËåÉÂõ¥Ôºâ`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        const message = "<b>ÊúüÂè∑Ê†ºÂºèÈîôËØØ</b>\n\nËØ∑‰ΩøÁî®Ê≠£Á°ÆÊ†ºÂºèÔºö\n<code>/delete 2025001</code> Êàñ <code>/delete 2025001-2025010</code>";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        const message = `<b>Êú™ÊâæÂà∞ËÆ∞ÂΩï</b>\n\nÂú® ${expectRange} ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊâæÂà∞‰ªª‰ΩïÂéÜÂè≤ËÆ∞ÂΩï„ÄÇ`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const processingMessage = `<b>Ê≠£Âú®Âà†Èô§ËÆ∞ÂΩï...</b>\n\nÂà†Èô§ËåÉÂõ¥: ${expectRange}\nÊ∂âÂèäËÆ∞ÂΩï: ${impactInfo.toDeleteCount} Êù°\nËØ∑Á®çÂÄô...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      // Áõ¥Êé•Âà†Èô§ÔºåÊó†ÈúÄÁ°ÆËÆ§
      const result = await DB.deleteHistoryByRange(
        env, 
        rangeInfo.start, 
        rangeInfo.end,
        Formatter.safeString(userId),
        "Áõ¥Êé•Âà†Èô§ÔºàÊó†ÈúÄÁ°ÆËÆ§Ôºâ"
      );
      
      CacheManager.clear();
      OptimizedMonteCarloEngine.clearCache();
      
      const message = MessageRenderer.renderDeleteResult(result, expectRange, impactInfo);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      Logger.info("Delete", `Âà†Èô§Êìç‰ΩúÂÆåÊàê: ${expectRange}, Âà†Èô§ËÆ∞ÂΩïÊï∞: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "Âà†Èô§Â§ÑÁêÜÂ§±Ë¥•", error);
      const errorMessage = `<b>Âà†Èô§Êìç‰ΩúÂ§±Ë¥•</b>\n\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
}

// ==============================================================================
// 17. ‰∫ã‰ª∂Â§ÑÁêÜÂô®
// ==============================================================================

async function handleUpdate(env, payload) {
  try {
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `Êî∂Âà∞Ê∂àÊÅØ: ${text}`, { chatId, userId, isAdmin });
    
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
          
        case '/predict':
        case '/p':
          const predictMatch = text.match(/\/predict\s+(knn|stats|advanced)/i);
          if (predictMatch) {
            await Controller.handlePredict(env, chatId, predictMatch[1].toLowerCase());
          } else {
            await Controller.handlePredict(env, chatId, "traditional");
          }
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        default:
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
      }
    } else {
      await Controller.handleCommandTemplate(env, chatId, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "Â§ÑÁêÜÊõ¥Êñ∞Â§±Ë¥•", error);
  }
}

// ==============================================================================
// 18. Worker ÂÖ•Âè£ÁÇπ
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `Êî∂Âà∞ËØ∑Ê±Ç: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const optionalEnvVars = ['TG_CHANNEL_ID', 'LOTTERY_DATA_URL'];
      
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `Áº∫Â∞ëÂøÖË¶ÅÁéØÂ¢ÉÂèòÈáè: ${missingVars.join(', ')}`);
        return new Response(JSON.stringify({
          status: "ERROR",
          message: `Missing required environment variables: ${missingVars.join(', ')}`,
          required: requiredEnvVars,
          optional: optionalEnvVars,
          provided: Object.keys(env).filter(k => requiredEnvVars.includes(k) || optionalEnvVars.includes(k)),
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      const optionalMissing = optionalEnvVars.filter(key => !env[key]);
      if (optionalMissing.length > 0) {
        Logger.warn("Worker", `Áº∫Â∞ëÂèØÈÄâÁéØÂ¢ÉÂèòÈáè: ${optionalMissing.join(', ')}`, {
          impact: optionalMissing.includes('TG_CHANNEL_ID') ? 'Êó†Ê≥ïÊé®ÈÄÅÂà∞È¢ëÈÅì' : '',
          impact2: optionalMissing.includes('LOTTERY_DATA_URL') ? 'Êó†Ê≥ïÂêåÊ≠•Â§ñÈÉ®Êï∞ÊçÆ' : ''
        });
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "YOUR_CHANNEL_ID_HERE";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "YOUR_ADMIN_ID_HERE";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response(JSON.stringify({
          status: "ERROR",
          message: "Database Initialization Failed. Please check D1 binding.",
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const deletionStats = await DB.getDeletionStats(env);
            
            const cacheStats = {
              total: CacheManager.cache.size,
              monteCarlo: OptimizedMonteCarloEngine.cache.size
            };
            
            const algorithms = await DB.getWeights(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              environment: {
                hasChannel: !!env.TG_CHANNEL_ID,
                hasLotteryUrl: !!env.LOTTERY_DATA_URL,
                requiredVars: requiredEnvVars.filter(k => env[k]).length + "/" + requiredEnvVars.length,
                optionalVars: optionalEnvVars.filter(k => env[k]).length + "/" + optionalEnvVars.length
              },
              database: {
                historyCount: historyCount,
                deletionStats: deletionStats
              },
              cache: cacheStats,
              algorithms: {
                weights: algorithms,
                knn: "Enabled",
                statistics: "Enabled",
                monteCarlo: "Integrated in Advanced",
                traditional: "Enabled",
                advanced: "Enabled",
                omission: "Enabled",
                association: "Enabled",
                math: "Enabled",
                zone: "Enabled"
              },
              improvements: {
                deleteNoConfirm: true,
                normalDiversity: true,
                enhancedAlgorithms: true
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            OptimizedMonteCarloEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "ÊâÄÊúâÁºìÂ≠òÂ∑≤Ê∏ÖÈô§",
              cleared: {
                cache: true,
                monteCarlo: true,
                messageManager: true
              }
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .improvements {
                  background: #fff5f5;
                  border: 1px solid #fc8181;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #742a2a;
                }
                .improvements h3 {
                  margin-top: 0;
                  color: #c53030;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION} - ÂÖ®Èù¢‰∏ìÂÆ∂ÁÆóÊ≥ïÊï¥ÂêàÁâà</div>
                
                <div class="improvements">
                  <h3>‰∏ªË¶ÅÊîπËøõÔºö</h3>
                  <ul>
                    <li><strong>ÁßªÈô§Âà†Èô§Á°ÆËÆ§Ê≠•È™§</strong> - Áé∞Âú®Âà†Èô§ËÆ∞ÂΩïÁõ¥Êé•ÊâßË°åÔºåÊó†ÈúÄÂÜçÊ¨°Á°ÆËÆ§</li>
                    <li><strong>ÊîπËøõÂπ≥Á†ÅÂ§öÊ†∑ÊÄß</strong> - Á≤æÈÄâÂπ≥Á†Å‰∏çÂÜçÂõ∫ÂÆöÔºåÂ¢ûÂä†ÈöèÊú∫ÊÄßÂíåÂéÜÂè≤ÂàÜÊûê</li>
                    <li><strong>Êï¥ÂêàÂõõÂ§ß‰∏ìÂÆ∂ÁÆóÊ≥ï</strong> - ÈÅóÊºèÂõûË°•„ÄÅÂÖ≥ËÅîËßÑÂàô„ÄÅÈªÑÈáëÂàÜÂâ≤„ÄÅÂå∫Èó¥Âπ≥Ë°°</li>
                    <li><strong>‰ºòÂåñÁÆóÊ≥ïÊùÉÈáçÁ≥ªÁªü</strong> - Êõ¥ÁßëÂ≠¶ÁöÑÁÆóÊ≥ïÈõÜÊàêÂíåËØÑÂàÜ</li>
                    <li><strong>ÊîπËøõÈîôËØØÂ§ÑÁêÜ</strong> - Â¢ûÂº∫Á≥ªÁªüÁ®≥ÂÆöÊÄßÂíåÁî®Êà∑‰ΩìÈ™å</li>
                    <li><strong>Èò≤Âà∑Â±èÊ∂àÊÅØÁÆ°ÁêÜ</strong> - ÊØè‰∏™ÂëΩ‰ª§Âè™‰øùÁïôÊúÄÊñ∞Ê∂àÊÅØ</li>
                  </ul>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 8px;">
                  <strong>‰ΩøÁî®ÂëΩ‰ª§Ôºö</strong><br>
                  ‚Ä¢ <code>/predict</code> - ‰º†ÁªüÁÆóÊ≥ïÈ¢ÑÊµã<br>
                  ‚Ä¢ <code>/predict advanced</code> - Â¢ûÂº∫È¢ÑÊµãÔºàÊé®ËçêÔºâ<br>
                  ‚Ä¢ <code>/history 1</code> - Êü•ÁúãÂéÜÂè≤ËÆ∞ÂΩï<br>
                  ‚Ä¢ <code>/ccc</code> - Êü•ÁúãÂÆåÊï¥ÂëΩ‰ª§ÂàóË°®<br>
                  ‚Ä¢ <code>/delete 2025001</code> - Âà†Èô§ËÆ∞ÂΩïÔºàÁÆ°ÁêÜÂëòÔºåÊó†ÈúÄÁ°ÆËÆ§Ôºâ
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "Â§ÑÁêÜPOSTËØ∑Ê±ÇÂá∫Èîô", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "Â§ÑÁêÜËØ∑Ê±ÇÂ§±Ë¥•", error);
      return new Response(JSON.stringify({
        status: "ERROR",
        error: "Internal Server Error",
        message: error.message,
        system: CONFIG.SYSTEM.NAME,
        version: CONFIG.SYSTEM.VERSION
      }, null, 2), { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
};
