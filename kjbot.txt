// index.js - ä¿®å¤è¯­æ³•é”™è¯¯çš„å®Œæ•´ä»£ç 
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const pathname = url.pathname;
    const method = request.method;

    try {
      // ç¡®ä¿æ•°æ®åº“è¿æ¥æ­£å¸¸
      if (!env.DB) {
        return new Response(JSON.stringify({
          result: false,
          message: 'æ•°æ®åº“è¿æ¥æœªé…ç½®',
          code: 500,
          data: null,
          timestamp: Date.now()
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      // å¤„ç†APIæŸ¥è¯¢è¯·æ±‚
      if (method === 'GET') {
        // æ¾³é—¨å¼€å¥–è®°å½• /om/{year}
        if (pathname.match(/^\/om\/\d{4}$/)) {
          const year = pathname.split('/')[2];
          return await getLotteryRecords(env.DB, 'mo', parseInt(year));
        }
        
        // é¦™æ¸¯å¼€å¥–è®°å½• /xg/{year}
        if (pathname.match(/^\/xg\/\d{4}$/)) {
          const year = pathname.split('/')[2];
          return await getLotteryRecords(env.DB, 'hk', parseInt(year));
        }
        
        // è®¾ç½®Webhook
        if (pathname === '/set-webhook') {
          const token = url.searchParams.get('token') || env.TELEGRAM_BOT_TOKEN;
          const webhookUrl = `${url.origin}/webhook`;
          return await setWebhook(token, webhookUrl);
        }
        
        // åˆ é™¤Webhook
        if (pathname === '/delete-webhook') {
          const token = url.searchParams.get('token') || env.TELEGRAM_BOT_TOKEN;
          return await deleteWebhook(token);
        }
        
        // åˆå§‹åŒ–æ•°æ®åº“
        if (pathname === '/init-db') {
          return await initDatabase(env.DB);
        }
        
        // æŸ¥çœ‹æ‰€æœ‰è¡¨
        if (pathname === '/tables') {
          return await listTables(env.DB);
        }
        
        // ç»Ÿè®¡ä¿¡æ¯
        if (pathname === '/stats') {
          return await getStats(env.DB);
        }
        
        // ç®¡ç†ç•Œé¢
        if (pathname === '/manage') {
          return getManagePage();
        }
        
        // å¥åº·æ£€æŸ¥
        if (pathname === '/health') {
          return await healthCheck(env.DB);
        }
      }
      
      // å¤„ç†POSTè¯·æ±‚
      if (method === 'POST') {
        // Telegram Webhook
        if (pathname === '/webhook') {
          return await handleTelegramWebhook(request, env);
        }
        
        // æ‰‹åŠ¨æ·»åŠ è®°å½•
        if (pathname === '/add-record') {
          const data = await request.json();
          return await addRecordManual(env.DB, data);
        }
        
        // æ‰¹é‡æ·»åŠ è®°å½•
        if (pathname === '/batch-add') {
          const data = await request.json();
          return await batchAddRecords(env.DB, data);
        }
        
        // åˆ é™¤è®°å½•
        if (pathname === '/delete-record') {
          const data = await request.json();
          return await deleteRecordManual(env.DB, data);
        }
        
        // æœç´¢è®°å½•
        if (pathname === '/search') {
          const data = await request.json();
          return await searchRecords(env.DB, data);
        }
      }

      // é»˜è®¤è¿”å›æ¬¢è¿ä¿¡æ¯
      return new Response(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>å¼€å¥–è®°å½•APIæœåŠ¡</title>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font-family: Arial, sans-serif; margin: 40px; }
            .endpoint { background: #f5f5f5; padding: 10px; margin: 10px 0; border-left: 4px solid #007bff; }
            code { background: #f0f0f0; padding: 2px 4px; border-radius: 3px; }
            a { color: #007bff; text-decoration: none; }
            a:hover { text-decoration: underline; }
          </style>
        </head>
        <body>
          <h1>ğŸ° å¼€å¥–è®°å½•APIæœåŠ¡</h1>
          <p>è¿™æ˜¯ä¸€ä¸ªå¼€å¥–è®°å½•ç®¡ç†å’ŒæŸ¥è¯¢æœåŠ¡ï¼Œæ”¯æŒé¦™æ¸¯å…­åˆå½©å’Œè€æ¾³21.30</p>
          
          <h3>APIæ¥å£ï¼š</h3>
          <div class="endpoint">
            <strong>GET /xg/{year}</strong> - è·å–é¦™æ¸¯å¼€å¥–è®°å½•<br>
            ç¤ºä¾‹ï¼š<code>${url.origin}/xg/2025</code><br>
            è¿”å›JSONæ ¼å¼æ•°æ®ï¼ŒåŒ…å«æŒ‡å®šå¹´ä»½çš„æ‰€æœ‰é¦™æ¸¯å¼€å¥–è®°å½•
          </div>
          <div class="endpoint">
            <strong>GET /om/{year}</strong> - è·å–æ¾³é—¨å¼€å¥–è®°å½•<br>
            ç¤ºä¾‹ï¼š<code>${url.origin}/om/2025</code><br>
            è¿”å›JSONæ ¼å¼æ•°æ®ï¼ŒåŒ…å«æŒ‡å®šå¹´ä»½çš„æ‰€æœ‰æ¾³é—¨å¼€å¥–è®°å½•
          </div>
          
          <h3>ç®¡ç†åŠŸèƒ½ï¼š</h3>
          <p><a href="/manage" style="font-size: 18px; font-weight: bold;">ğŸ“Š ç‚¹å‡»è¿›å…¥ç®¡ç†é¡µé¢</a></p>
          
          <h3>æ•°æ®åº“åˆå§‹åŒ–ï¼š</h3>
          <p><a href="/init-db">/init-db</a> - åˆå§‹åŒ–æ•°æ®åº“è¡¨ï¼ˆå¦‚æœè®¿é—®å‡ºé”™è¯·å…ˆæ‰§è¡Œæ­¤æ“ä½œï¼‰</p>
          
          <h3>å¥åº·æ£€æŸ¥ï¼š</h3>
          <p><a href="/health">/health</a> - æ£€æŸ¥æœåŠ¡çŠ¶æ€å’Œæ•°æ®åº“è¿æ¥</p>
          
          <h3>Telegram Bot:</h3>
          <p>è®¾ç½®Webhook: <code>${url.origin}/set-webhook?token=YOUR_BOT_TOKEN</code></p>
          
          <hr>
          <p>Â© ${new Date().getFullYear()} å¼€å¥–è®°å½•æœåŠ¡ | æ”¯æŒé¦™æ¸¯å…­åˆå½©ã€è€æ¾³21.30</p>
        </body>
        </html>
      `, {
        headers: { 'Content-Type': 'text/html;charset=utf-8' }
      });

    } catch (error) {
      console.error('å¤„ç†è¯·æ±‚æ—¶å‡ºé”™:', error);
      return new Response(JSON.stringify({
        result: false,
        message: error.message,
        code: 500,
        data: null,
        timestamp: Date.now()
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
};

// ==================== æ•°æ®åº“ç›¸å…³å‡½æ•° ====================

async function initDatabase(db) {
  try {
    console.log('å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“...');
    
    // åˆ›å»ºä¸»è¡¨
    const createMainTable = `
      CREATE TABLE IF NOT EXISTS lottery_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        year INTEGER NOT NULL,
        expect TEXT NOT NULL,
        openTime TEXT NOT NULL,
        type TEXT NOT NULL,
        openCode TEXT NOT NULL,
        wave TEXT NOT NULL,
        zodiac TEXT NOT NULL,
        verify BOOLEAN DEFAULT true,
        source TEXT DEFAULT 'è‡ªåŠ¨æŠ“å–',
        info TEXT DEFAULT 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com',
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(type, expect)
      )
    `;
    
    await db.prepare(createMainTable).run();
    
    // åˆ›å»ºåˆ é™¤è®°å½•è¡¨
    const createDeletedTable = `
      CREATE TABLE IF NOT EXISTS deleted_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        recordId INTEGER,
        year INTEGER,
        expect TEXT,
        type TEXT,
        openCode TEXT,
        deletedBy TEXT,
        deletedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        reason TEXT
      )
    `;
    
    await db.prepare(createDeletedTable).run();
    
    // åˆ›å»ºç”¨æˆ·è¡¨ï¼ˆç”¨äºå­˜å‚¨æˆæƒç”¨æˆ·ï¼‰
    const createUsersTable = `
      CREATE TABLE IF NOT EXISTS bot_users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId INTEGER NOT NULL UNIQUE,
        username TEXT,
        firstName TEXT,
        lastName TEXT,
        isAdmin BOOLEAN DEFAULT false,
        joinDate TEXT DEFAULT CURRENT_TIMESTAMP,
        lastActive TEXT
      )
    `;
    
    await db.prepare(createUsersTable).run();
    
    return new Response(JSON.stringify({
      result: true,
      message: 'æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ',
      code: 200,
      data: null,
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: `æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function listTables(db) {
  try {
    const result = await db.prepare(`
      SELECT name, sql 
      FROM sqlite_master 
      WHERE type='table' 
      ORDER BY name
    `).all();
    
    let html = '<!DOCTYPE html><html><head><title>æ•°æ®åº“è¡¨ç»“æ„</title><meta charset="utf-8"></head><body>';
    html += '<h1>æ•°æ®åº“è¡¨ç»“æ„</h1>';
    html += `<p>æ€»å…±: ${result.results ? result.results.length : 0} ä¸ªè¡¨</p>`;
    
    if (result.results && result.results.length > 0) {
      result.results.forEach(table => {
        html += `<h2>è¡¨: ${table.name}</h2>`;
        html += `<pre>${table.sql || 'æ²¡æœ‰SQLè¯­å¥'}</pre>`;
        html += '<hr>';
      });
    } else {
      html += '<p>æ²¡æœ‰æ‰¾åˆ°ä»»ä½•è¡¨</p>';
    }
    
    html += '<p><a href="/init-db">åˆå§‹åŒ–æ•°æ®åº“</a> | <a href="/health">å¥åº·æ£€æŸ¥</a> | <a href="/">è¿”å›é¦–é¡µ</a></p>';
    html += '</body></html>';
    
    return new Response(html, {
      headers: { 'Content-Type': 'text/html;charset=utf-8' }
    });
    
  } catch (error) {
    return new Response(JSON.stringify({
      result: false,
      message: `æŸ¥çœ‹è¡¨ç»“æ„å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function getStats(db) {
  try {
    // è·å–æ€»æ•°
    const totalResult = await db.prepare(`
      SELECT type, COUNT(*) as count FROM lottery_records GROUP BY type
    `).all();
    
    // è·å–å¹´ä»½ç»Ÿè®¡
    const yearResult = await db.prepare(`
      SELECT year, type, COUNT(*) as count 
      FROM lottery_records 
      GROUP BY year, type 
      ORDER BY year DESC, type
    `).all();
    
    // è·å–æœ€æ–°è®°å½•
    const latestResult = await db.prepare(`
      SELECT * FROM lottery_records 
      ORDER BY openTime DESC 
      LIMIT 5
    `).all();
    
    // ç”¨æˆ·ç»Ÿè®¡
    const userResult = await db.prepare(`
      SELECT COUNT(*) as totalUsers, 
             SUM(CASE WHEN isAdmin = 1 THEN 1 ELSE 0 END) as adminUsers 
      FROM bot_users
    `).first();
    
    return new Response(JSON.stringify({
      result: true,
      message: 'ç»Ÿè®¡ä¿¡æ¯',
      code: 200,
      data: {
        summary: totalResult.results || [],
        byYear: yearResult.results || [],
        latest: latestResult.results || [],
        users: userResult || { totalUsers: 0, adminUsers: 0 },
        timestamp: new Date().toISOString()
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: `è·å–ç»Ÿè®¡å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function healthCheck(db) {
  try {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    const result = await db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
    
    // è·å–è®°å½•æ•°é‡
    const countResult = await db.prepare("SELECT COUNT(*) as total FROM lottery_records").first();
    
    // åˆ†ç±»è¡¨
    const systemTables = result.results.filter(t => t.name.startsWith('_cf_'));
    const userTables = result.results.filter(t => !t.name.startsWith('_cf_'));
    
    return new Response(JSON.stringify({
      status: 'ok',
      database: 'connected',
      total_tables: result.results ? result.results.length : 0,
      system_tables: systemTables.length,
      user_tables: userTables.length,
      user_table_names: userTables.map(t => t.name),
      total_records: countResult ? countResult.total : 0,
      timestamp: new Date().toISOString()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      status: 'error',
      database: 'disconnected',
      error: error.message,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// ==================== Telegram Botç›¸å…³å‡½æ•° ====================

async function setWebhook(botToken, webhookUrl) {
  try {
    if (!botToken) {
      return new Response(JSON.stringify({
        ok: false,
        description: 'Bot Tokenä¸èƒ½ä¸ºç©º'
      }), { status: 400 });
    }
    
    const response = await fetch(`https://api.telegram.org/bot${botToken}/setWebhook`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url: webhookUrl })
    });
    
    const result = await response.json();
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      ok: false,
      description: error.message
    }), { status: 500 });
  }
}

async function deleteWebhook(botToken) {
  try {
    if (!botToken) {
      return new Response(JSON.stringify({
        ok: false,
        description: 'Bot Tokenä¸èƒ½ä¸ºç©º'
      }), { status: 400 });
    }
    
    const response = await fetch(`https://api.telegram.org/bot${botToken}/deleteWebhook`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    
    const result = await response.json();
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      ok: false,
      description: error.message
    }), { status: 500 });
  }
}

async function handleTelegramWebhook(request, env) {
  try {
    const update = await request.json();
    
    // å¤„ç†é¢‘é“æ¶ˆæ¯
    if (update.channel_post) {
      const post = update.channel_post;
      const text = post.text || post.caption || '';
      
      console.log('æ”¶åˆ°é¢‘é“æ¶ˆæ¯:', text.substring(0, 100));
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯å…è®¸çš„ç±»å‹
      if (text.includes('é¦™æ¸¯å…­åˆå½©') || text.includes('è€æ¾³21.30')) {
        await processLotteryMessage(text, env.DB, env);
      }
    }
    
    // å¤„ç†ç§èŠæ¶ˆæ¯
    if (update.message) {
      const message = update.message;
      const chatId = message.chat.id;
      const text = message.text || '';
      const from = message.from;
      
      if (message.chat.type === 'private') {
        await handlePrivateMessage(chatId, text, from, env);
      }
    }
    
    return new Response('OK');
  } catch (error) {
    console.error('Webhook error:', error);
    return new Response('ERROR', { status: 500 });
  }
}

async function saveUserInfo(db, user) {
  try {
    await db.prepare(`
      INSERT OR REPLACE INTO bot_users (userId, username, firstName, lastName, lastActive)
      VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
    `).bind(
      user.id,
      user.username || '',
      user.first_name || '',
      user.last_name || ''
    ).run();
  } catch (error) {
    console.error('ä¿å­˜ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
  }
}

async function isUserAdmin(db, userId, env) {
  try {
    // é¦–å…ˆæ£€æŸ¥ç¯å¢ƒå˜é‡ä¸­çš„ç®¡ç†å‘˜ID
    const adminIds = (env.ADMIN_USER_IDS || '').split(',').map(id => parseInt(id.trim()));
    if (adminIds.includes(userId)) {
      return true;
    }
    
    // ç„¶åæ£€æŸ¥æ•°æ®åº“ä¸­çš„ç®¡ç†å‘˜æ ‡è®°
    const user = await db.prepare(
      'SELECT isAdmin FROM bot_users WHERE userId = ?'
    ).bind(userId).first();
    
    return user ? user.isAdmin === 1 : false;
  } catch (error) {
    console.error('æ£€æŸ¥ç®¡ç†å‘˜æƒé™å¤±è´¥:', error);
    return false;
  }
}

async function handleCallbackQuery(callbackQuery, env) {
  const chatId = callbackQuery.from.id;
  const data = callbackQuery.data;
  const messageId = callbackQuery.message.message_id;
  
  try {
    const botToken = env.TELEGRAM_BOT_TOKEN;
    
    if (data.startsWith('delete_')) {
      const [_, expect, type] = data.split('_');
      const isAdmin = await isUserAdmin(env.DB, chatId, env);
      
      if (!isAdmin) {
        await editMessage(botToken, chatId, messageId, 'âŒ æ‚¨æ²¡æœ‰æƒé™åˆ é™¤è®°å½•');
        return;
      }
      
      await deleteRecordManual(env.DB, { expect, type }, `telegram_${chatId}`);
      await editMessage(botToken, chatId, messageId, `âœ… è®°å½•åˆ é™¤æˆåŠŸï¼\næœŸå·: ${expect}\nç±»å‹: ${type}`);
    }
    
    // ç¡®è®¤å›è°ƒæŸ¥è¯¢
    await answerCallbackQuery(botToken, callbackQuery.id);
  } catch (error) {
    console.error('å¤„ç†å›è°ƒæŸ¥è¯¢å¤±è´¥:', error);
  }
}

async function handlePrivateMessage(chatId, text, from, env) {
  const botToken = env.TELEGRAM_BOT_TOKEN;
  
  try {
    // å¸®åŠ©å‘½ä»¤
    if (text.startsWith('/start') || text.startsWith('/help')) {
      await sendTelegramMessage(botToken, chatId,
        `ğŸ° *å¼€å¥–è®°å½•ç®¡ç† Bot*\n\n` +
        `*å‘½ä»¤åˆ—è¡¨ï¼š*\n` +
        `ğŸ“Š /stats - æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯\n` +
        `ğŸ“ /add - æ‰‹åŠ¨æ·»åŠ å¼€å¥–è®°å½•\n` +
        `ğŸ” /search [å…³é”®è¯] - æœç´¢å¼€å¥–è®°å½•\n` +
        `ğŸ“‹ /list [ç±»å‹] [å¹´ä»½] - æŸ¥çœ‹å¼€å¥–è®°å½•\n` +
        `ğŸ—‘ï¸ /delete [æœŸå·] [ç±»å‹] - åˆ é™¤è®°å½•ï¼ˆç®¡ç†å‘˜ï¼‰\n` +
        `â“ /help - æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯\n\n` +
        `*ç±»å‹è¯´æ˜ï¼š*\n` +
        `â€¢ hk - é¦™æ¸¯å…­åˆå½©\n` +
        `â€¢ mo - è€æ¾³21.30\n\n` +
        `*ç¤ºä¾‹ï¼š*\n` +
        `â€¢ /add 2025128 hk 1,30,25,42,6,5,43 è›‡,é¼ ,è›‡,é¼ ,é¼ ,ç‰›,çŒª red,red,blue,blue,green,green,green\n` +
        `â€¢ /list hk 2025\n` +
        `â€¢ /search 202512\n` +
        `â€¢ /delete 2025128 hk\n\n` +
        `*è‡ªåŠ¨åŠŸèƒ½ï¼š*\n` +
        `â€¢ è‡ªåŠ¨ç›‘æ§é¢‘é“å¼€å¥–ä¿¡æ¯\n` +
        `â€¢ æ™ºèƒ½è§£æé¦™æ¸¯å…­åˆå½©å’Œè€æ¾³21.30\n` +
        `â€¢ æ•°æ®è‡ªåŠ¨å»é‡å’Œå­˜å‚¨`,
        { parse_mode: 'Markdown' }
      );
      return;
    }
    
    // ç»Ÿè®¡å‘½ä»¤
    if (text.startsWith('/stats')) {
      const stats = await getStatsForChat(env.DB);
      await sendTelegramMessage(botToken, chatId, stats);
      return;
    }
    
    // æ·»åŠ è®°å½•å‘½ä»¤
    if (text.startsWith('/add')) {
      const args = parseAddCommand(text);
      if (args) {
        const record = {
          expect: args.expect,
          type: args.type,
          numbers: args.numbers.join(','),
          zodiacs: args.zodiacs.join(','),
          colors: args.colors.join(','),
          source: `telegramç”¨æˆ·: ${from.username || from.id}`
        };
        
        await addRecordManual(env.DB, record, 'telegram_bot');
        await sendTelegramMessage(botToken, chatId, 'âœ… å¼€å¥–è®°å½•æ·»åŠ æˆåŠŸï¼');
      } else {
        await sendTelegramMessage(botToken, chatId,
          `âŒ æ ¼å¼é”™è¯¯ï¼è¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n\n` +
          `/add [æœŸå·] [ç±»å‹] [å·ç ] [ç”Ÿè‚–] [é¢œè‰²]\n\n` +
          `*ç¤ºä¾‹ï¼š*\n` +
          `/add 2025128 hk 1,30,25,42,6,5,43 è›‡,é¼ ,è›‡,é¼ ,é¼ ,ç‰›,çŒª red,red,blue,blue,green,green,green\n\n` +
          `å·ç ã€ç”Ÿè‚–ã€é¢œè‰²éƒ½éœ€è¦7ä¸ªå€¼ï¼Œç”¨é€—å·åˆ†éš”`,
          { parse_mode: 'Markdown' }
        );
      }
      return;
    }
    
    // æœç´¢å‘½ä»¤
    if (text.startsWith('/search')) {
      const keyword = text.substring(7).trim();
      if (!keyword) {
        await sendTelegramMessage(botToken, chatId, 'âŒ è¯·æä¾›æœç´¢å…³é”®è¯ï¼Œä¾‹å¦‚ï¼š/search 202512');
        return;
      }
      
      const results = await searchRecordsForChat(env.DB, keyword);
      if (results.length === 0) {
        await sendTelegramMessage(botToken, chatId, `æ²¡æœ‰æ‰¾åˆ°åŒ…å« "${keyword}" çš„å¼€å¥–è®°å½•`);
      } else {
        let message = `ğŸ” æœç´¢åˆ° ${results.length} æ¡è®°å½•ï¼š\n\n`;
        results.slice(0, 10).forEach(record => {
          message += `*${record.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}* ${record.expect}\n`;
          message += `å·ç : ${record.openCode}\n`;
          message += `æ—¶é—´: ${record.openTime}\n\n`;
        });
        
        if (results.length > 10) {
          message += `... è¿˜æœ‰ ${results.length - 10} æ¡è®°å½•æœªæ˜¾ç¤º`;
        }
        
        await sendTelegramMessage(botToken, chatId, message, { parse_mode: 'Markdown' });
      }
      return;
    }
    
    // åˆ—è¡¨å‘½ä»¤
    if (text.startsWith('/list')) {
      const args = text.substring(5).trim().split(/\s+/);
      const type = (args[0] || 'hk').toLowerCase();
      const year = args[1] || new Date().getFullYear();
      
      if (type !== 'hk' && type !== 'mo') {
        await sendTelegramMessage(botToken, chatId, 'âŒ ç±»å‹é”™è¯¯ï¼è¯·ä½¿ç”¨ hk æˆ– mo');
        return;
      }
      
      const records = await getRecordsForChat(env.DB, type, parseInt(year));
      if (records.length === 0) {
        await sendTelegramMessage(botToken, chatId, `æ²¡æœ‰æ‰¾åˆ°${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${year}å¹´çš„å¼€å¥–è®°å½•`);
      } else {
        let message = `ğŸ“‹ ${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${year}å¹´å¼€å¥–è®°å½•ï¼ˆæœ€è¿‘${Math.min(records.length, 10)}æ¡ï¼‰ï¼š\n\n`;
        records.slice(0, 10).forEach((record, index) => {
          message += `${index + 1}. *${record.expect}*\n`;
          message += `   å·ç : ${record.openCode}\n`;
          message += `   æ—¶é—´: ${record.openTime}\n`;
          message += '\n';
        });
        
        await sendTelegramMessage(botToken, chatId, message, { 
          parse_mode: 'Markdown',
          disable_web_page_preview: true
        });
      }
      return;
    }
    
    // åˆ é™¤å‘½ä»¤
    if (text.startsWith('/delete')) {
      const isAdmin = await isUserAdmin(env.DB, chatId, env);
      if (!isAdmin) {
        await sendTelegramMessage(botToken, chatId, 'âŒ æ‚¨æ²¡æœ‰æƒé™åˆ é™¤è®°å½•');
        return;
      }
      
      const args = text.substring(7).trim().split(/\s+/);
      if (args.length < 2) {
        await sendTelegramMessage(botToken, chatId, 'âŒ å‚æ•°é”™è¯¯ï¼è¯·ä½¿ç”¨ï¼š/delete [æœŸå·] [ç±»å‹]');
        return;
      }
      
      const data = {
        expect: args[0],
        type: args[1]
      };
      
      // å‘é€ç¡®è®¤æ¶ˆæ¯
      const keyboard = {
        inline_keyboard: [[
          { text: "âœ… ç¡®è®¤åˆ é™¤", callback_data: `delete_${data.expect}_${data.type}` },
          { text: "âŒ å–æ¶ˆ", callback_data: "cancel_delete" }
        ]]
      };
      
      await sendTelegramMessage(botToken, chatId, 
        `âš ï¸ *ç¡®è®¤åˆ é™¤è®°å½•*\n\n` +
        `æœŸå·: ${data.expect}\n` +
        `ç±»å‹: ${data.type}\n\n` +
        `ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ`,
        { 
          parse_mode: 'Markdown',
          reply_markup: keyboard 
        }
      );
      return;
    }
    
    // å¤„ç†å…¶ä»–æ¶ˆæ¯
    if (text) {
      await sendTelegramMessage(botToken, chatId,
        `ğŸ¤– æ¬¢è¿ä½¿ç”¨å¼€å¥–è®°å½•ç®¡ç† Botï¼\n\n` +
        `æˆ‘å¯ä»¥å¸®æ‚¨ï¼š\n` +
        `â€¢ è‡ªåŠ¨è®°å½•å¼€å¥–ä¿¡æ¯\n` +
        `â€¢ æ‰‹åŠ¨æ·»åŠ å¼€å¥–è®°å½•\n` +
        `â€¢ æŸ¥è¯¢å†å²å¼€å¥–æ•°æ®\n` +
        `â€¢ ç®¡ç†å¼€å¥–è®°å½•\n\n` +
        `å‘é€ /help æŸ¥çœ‹è¯¦ç»†å‘½ä»¤è¯´æ˜`
      );
    }
    
  } catch (error) {
    console.error('å¤„ç†ç§èŠæ¶ˆæ¯å¤±è´¥:', error);
    await sendTelegramMessage(botToken, chatId, `âŒ æ“ä½œå¤±è´¥ï¼š${error.message}`);
  }
}

function parseAddCommand(text) {
  try {
    // ç§»é™¤ /add å‘½ä»¤éƒ¨åˆ†
    const content = text.substring(5).trim();
    
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
    const match = content.match(/^(\d+)\s+(hk|mo)\s+([\d,]+)\s+([\u4e00-\u9fa5,]+)\s+([\w,]+)$/);
    if (!match) return null;
    
    const [, expect, type, numbersStr, zodiacsStr, colorsStr] = match;
    
    // éªŒè¯æ•°æ®
    const numbers = numbersStr.split(',').map(n => parseInt(n.trim()));
    const zodiacs = zodiacsStr.split(',').map(z => z.trim());
    const colors = colorsStr.split(',').map(c => c.trim());
    
    if (numbers.length !== 7 || zodiacs.length !== 7 || colors.length !== 7) {
      return null;
    }
    
    return {
      expect,
      type,
      numbers,
      zodiacs,
      colors
    };
  } catch (error) {
    console.error('è§£ææ·»åŠ å‘½ä»¤å¤±è´¥:', error);
    return null;
  }
}

// ==================== å¼€å¥–æ¶ˆæ¯å¤„ç† ====================

async function processLotteryMessage(text, db, env) {
  const parsed = parseLotteryMessage(text);
  if (!parsed) {
    console.log('æ— æ³•è§£ææ¶ˆæ¯:', text.substring(0, 100));
    return;
  }
  
  try {
    // æå–å¹´ä»½
    let year;
    if (parsed.expect.length >= 4) {
      year = parseInt(parsed.expect.substring(0, 4));
    } else {
      year = new Date().getFullYear();
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await db.prepare(
      'SELECT id FROM lottery_records WHERE type = ? AND expect = ?'
    ).bind(parsed.type, parsed.expect).first();
    
    if (existing) {
      console.log(`è®°å½•å·²å­˜åœ¨: ${parsed.type} ${parsed.expect}`);
      return;
    }
    
    const record = {
      year: year,
      expect: parsed.expect,
      openTime: parsed.openTime,
      type: parsed.type,
      openCode: parsed.numbers.join(','),
      wave: parsed.colors.join(','),
      zodiac: parsed.zodiacs.join(',')
    };
    
    await insertRecord(db, record);
    console.log(`âœ… å­˜å‚¨æˆåŠŸï¼š${parsed.type} ${parsed.expect} (${year}å¹´)`);
    
    // å‘é€é€šçŸ¥ç»™ç®¡ç†å‘˜
    if (env.ADMIN_USER_IDS) {
      const adminIds = env.ADMIN_USER_IDS.split(',').map(id => parseInt(id.trim()));
      const message = `âœ… *è‡ªåŠ¨å­˜å‚¨å¼€å¥–è®°å½•*\n\n` +
        `*ç±»å‹:* ${parsed.type === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30'}\n` +
        `*æœŸå·:* ${parsed.expect}\n` +
        `*å·ç :* ${parsed.numbers.join(' ')}\n` +
        `*æ—¶é—´:* ${parsed.openTime}`;
      
      for (const adminId of adminIds) {
        try {
          await sendTelegramMessage(env.TELEGRAM_BOT_TOKEN, adminId, message, { parse_mode: 'Markdown' });
        } catch (error) {
          console.error('å‘é€é€šçŸ¥å¤±è´¥:', error);
        }
      }
    }
  } catch (error) {
    console.error('å­˜å‚¨å¼€å¥–æ¶ˆæ¯å¤±è´¥:', error);
  }
}

function parseLotteryMessage(text) {
  try {
    // æ£€æŸ¥æ¶ˆæ¯ç±»å‹
    let type = null;
    if (text.includes('é¦™æ¸¯å…­åˆå½©')) {
      type = 'hk';
    } else if (text.includes('è€æ¾³21.30')) {
      type = 'mo';
    } else {
      return null;
    }
    
    // æå–æœŸå·
    const expectMatch = text.match(/ç¬¬[:ï¼š]\s*(\d+)/);
    if (!expectMatch) return null;
    
    const expect = expectMatch[1];
    
    // æå–å·ç ï¼ˆæ‰¾7ä¸ªæ•°å­—ï¼‰
    const numbers = [];
    const lines = text.split('\n');
    
    // æ–¹æ³•1ï¼šæŸ¥æ‰¾åŒ…å«7ä¸ªæ•°å­—çš„è¡Œ
    for (const line of lines) {
      const numMatches = line.match(/\b\d{1,2}\b/g);
      if (numMatches && numMatches.length >= 7) {
        for (let i = 0; i < 7; i++) {
          numbers.push(parseInt(numMatches[i]));
        }
        break;
      }
    }
    
    // æ–¹æ³•2ï¼šå¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•æŸ¥æ‰¾æ‰€æœ‰æ•°å­—
    if (numbers.length !== 7) {
      const allNumbers = text.match(/\b\d{1,2}\b/g);
      if (allNumbers && allNumbers.length >= 7) {
        for (let i = 0; i < 7; i++) {
          numbers.push(parseInt(allNumbers[i]));
        }
      }
    }
    
    if (numbers.length !== 7) return null;
    
    // æå–ç”Ÿè‚–ï¼ˆæ‰¾7ä¸ªä¸­æ–‡å­—ç¬¦ï¼‰
    const zodiacs = [];
    const allZodiacs = text.match(/[\u4e00-\u9fa5]/g);
    if (allZodiacs && allZodiacs.length >= 7) {
      for (let i = 0; i < 7; i++) {
        zodiacs.push(allZodiacs[i]);
      }
    }
    
    if (zodiacs.length !== 7) return null;
    
    // æå–é¢œè‰²ï¼ˆemojiï¼‰
    const colors = [];
    const colorMap = {
      'ğŸ”µ': 'blue',
      'ğŸ”´': 'red',
      'ğŸŸ¢': 'green',
      'ğŸ”¶': 'orange',
      'ğŸŸ¡': 'yellow'
    };
    
    const emojis = text.match(/[ğŸ”µğŸ”´ğŸŸ¢ğŸ”¶ğŸŸ¡]/g) || [];
    for (let i = 0; i < 7; i++) {
      if (i < emojis.length) {
        colors.push(colorMap[emojis[i]] || 'unknown');
      } else {
        colors.push('unknown');
      }
    }
    
    // ç”Ÿæˆå¼€å¥–æ—¶é—´ï¼ˆä»æ¶ˆæ¯ä¸­æå–æˆ–ä½¿ç”¨å½“å‰æ—¶é—´ï¼‰
    let openTime;
    const timeMatch = text.match(/(\d{4}\/\d{1,2}\/\d{1,2}[\s\d:]+)/);
    if (timeMatch) {
      openTime = timeMatch[1].replace(/\//g, '-');
    } else {
      const now = new Date();
      openTime = now.toISOString().replace('T', ' ').substring(0, 19);
    }
    
    return {
      type,
      expect,
      openTime,
      numbers,
      zodiacs,
      colors
    };
  } catch (error) {
    console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
    return null;
  }
}

// ==================== æ•°æ®æ“ä½œå‡½æ•° ====================

async function insertRecord(db, record) {
  try {
    await db.prepare(`
      INSERT INTO lottery_records (year, expect, openTime, type, openCode, wave, zodiac)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      record.year,
      record.expect,
      record.openTime,
      record.type,
      record.openCode,
      record.wave,
      record.zodiac
    ).run();
  } catch (error) {
    console.error('æ’å…¥è®°å½•å¤±è´¥:', error);
    throw error;
  }
}

async function addRecordManual(db, data, source = 'web') {
  try {
    if (!data.expect || !data.numbers || !data.zodiacs || !data.colors) {
      throw new Error('ç¼ºå°‘å¿…è¦å‚æ•°');
    }
    
    // æå–å¹´ä»½
    let year;
    if (data.expect && data.expect.length >= 4) {
      year = parseInt(data.expect.substring(0, 4));
    } else {
      year = new Date().getFullYear();
    }
    
    // éªŒè¯ç±»å‹
    if (data.type !== 'hk' && data.type !== 'mo') {
      throw new Error('ç±»å‹å¿…é¡»æ˜¯ hk æˆ– mo');
    }
    
    // éªŒè¯æ•°æ®æ ¼å¼
    const numbers = data.numbers.split(',').map(n => parseInt(n.trim()));
    const zodiacs = data.zodiacs.split(',').map(z => z.trim());
    const colors = data.colors.split(',').map(c => c.trim());
    
    if (numbers.length !== 7 || zodiacs.length !== 7 || colors.length !== 7) {
      throw new Error('å·ç ã€ç”Ÿè‚–ã€é¢œè‰²éƒ½å¿…é¡»æœ‰7ä¸ªå€¼');
    }
    
    const record = {
      year: year,
      expect: data.expect.trim(),
      openTime: data.openTime || new Date().toISOString().replace('T', ' ').substring(0, 19),
      type: data.type,
      openCode: data.numbers,
      wave: data.colors,
      zodiac: data.zodiacs,
      verify: data.verify !== false,
      source: data.source || source,
      info: data.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    };
    
    await insertRecord(db, record);
    
    return new Response(JSON.stringify({
      result: true,
      message: 'è®°å½•æ·»åŠ æˆåŠŸ',
      code: 200,
      data: { 
        id: record.expect, 
        type: record.type,
        year: record.year
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('æ·»åŠ è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function batchAddRecords(db, data) {
  try {
    const records = data.records || [];
    const results = [];
    
    for (const recordData of records) {
      try {
        const result = await addRecordManual(db, recordData, 'batch');
        results.push({
          expect: recordData.expect,
          type: recordData.type,
          success: true
        });
      } catch (error) {
        results.push({
          expect: recordData.expect,
          type: recordData.type,
          success: false,
          error: error.message
        });
      }
    }
    
    return new Response(JSON.stringify({
      result: true,
      message: `æ‰¹é‡æ·»åŠ å®Œæˆï¼ŒæˆåŠŸ ${results.filter(r => r.success).length}/${records.length}`,
      code: 200,
      data: results,
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('æ‰¹é‡æ·»åŠ å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function deleteRecordManual(db, data, deletedBy = 'web_admin') {
  try {
    if (!data.expect || !data.type) {
      throw new Error('ç¼ºå°‘æœŸå·æˆ–ç±»å‹');
    }
    
    // éªŒè¯ç±»å‹
    if (data.type !== 'hk' && data.type !== 'mo') {
      throw new Error('ç±»å‹å¿…é¡»æ˜¯ hk æˆ– mo');
    }
    
    // å…ˆå¤‡ä»½
    const record = await db.prepare(
      'SELECT * FROM lottery_records WHERE expect = ? AND type = ?'
    ).bind(data.expect, data.type).first();
    
    if (!record) {
      throw new Error('è®°å½•ä¸å­˜åœ¨');
    }
    
    await db.prepare(`
      INSERT INTO deleted_records (recordId, year, expect, type, openCode, deletedBy, reason)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      record.id,
      record.year,
      record.expect,
      record.type,
      record.openCode,
      deletedBy,
      data.reason || 'æ‰‹åŠ¨åˆ é™¤'
    ).run();
    
    // åˆ é™¤è®°å½•
    await db.prepare(
      'DELETE FROM lottery_records WHERE expect = ? AND type = ?'
    ).bind(data.expect, data.type).run();
    
    return new Response(JSON.stringify({
      result: true,
      message: 'è®°å½•åˆ é™¤æˆåŠŸ',
      code: 200,
      data: { 
        deleted: true,
        expect: data.expect,
        type: data.type
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('åˆ é™¤è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function searchRecords(db, data) {
  try {
    const keyword = data.keyword || '';
    const type = data.type || '';
    const year = data.year || '';
    
    let query = 'SELECT * FROM lottery_records WHERE 1=1';
    const params = [];
    
    if (keyword) {
      query += ' AND (expect LIKE ? OR openCode LIKE ? OR zodiac LIKE ?)';
      params.push(`%${keyword}%`, `%${keyword}%`, `%${keyword}%`);
    }
    
    if (type) {
      query += ' AND type = ?';
      params.push(type);
    }
    
    if (year) {
      query += ' AND year = ?';
      params.push(year);
    }
    
    query += ' ORDER BY openTime DESC LIMIT 100';
    
    const { results } = await db.prepare(query).bind(...params).all();
    
    const responseData = results.map(record => ({
      expect: record.expect,
      openTime: record.openTime,
      type: record.type === 'hk' ? '8' : '7',
      openCode: record.openCode,
      wave: record.wave,
      zodiac: record.zodiac,
      oddEven: null,
      allOddEven: null,
      bigSmall: null,
      allBigSmall: null,
      firstsecend: 0,
      left3: null,
      mid3: null,
      right3: null,
      pet: null,
      pk: null,
      vs: null,
      verify: record.verify === 1,
      info: record.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    }));
    
    return new Response(JSON.stringify({
      result: true,
      message: 'æœç´¢æˆåŠŸ',
      code: 200,
      data: responseData,
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('æœç´¢è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function getLotteryRecords(db, type, year) {
  try {
    // å…ˆæ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    const tableExists = await db.prepare(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='lottery_records'"
    ).first();
    
    if (!tableExists) {
      return new Response(JSON.stringify({
        result: false,
        message: 'lottery_recordsè¡¨ä¸å­˜åœ¨ï¼Œè¯·å…ˆè®¿é—® /init-db åˆå§‹åŒ–æ•°æ®åº“',
        code: 404,
        data: [],
        timestamp: Date.now()
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    const { results } = await db.prepare(`
      SELECT * FROM lottery_records 
      WHERE type = ? AND year = ?
      ORDER BY openTime DESC
    `).bind(type, year).all();
    
    const data = (results || []).map(record => ({
      expect: record.expect || '',
      openTime: record.openTime || '',
      type: type === 'hk' ? '8' : '7',
      openCode: record.openCode || '',
      wave: record.wave || '',
      zodiac: record.zodiac || '',
      oddEven: null,
      allOddEven: null,
      bigSmall: null,
      allBigSmall: null,
      firstsecend: 0,
      left3: null,
      mid3: null,
      right3: null,
      pet: null,
      pk: null,
      vs: null,
      verify: record.verify === 1,
      info: record.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    }));
    
    return new Response(JSON.stringify({
      result: true,
      message: 'æ“ä½œæˆåŠŸï¼',
      code: 200,
      data: data,
      timestamp: Date.now()
    }), {
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Cache-Control': 'public, max-age=60',
        'X-Total-Count': results ? results.length : 0
      }
    });
  } catch (error) {
    console.error('æŸ¥è¯¢å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: 'æŸ¥è¯¢å¤±è´¥: ' + error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// ==================== è¾…åŠ©å‡½æ•° ====================

function getManagePage() {
  const html = `
  <!DOCTYPE html>
  <html>
  <head>
    <title>å¼€å¥–è®°å½•ç®¡ç†</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font-family: Arial, sans-serif; margin: 40px; }
      .tabs { display: flex; background: #f5f5f5; border-radius: 10px; overflow: hidden; margin-bottom: 20px; }
      .tab { flex: 1; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s; }
      .tab:hover { background: #e5e5e5; }
      .tab.active { background: #007bff; color: white; }
      .tab-content { display: none; background: white; border: 1px solid #ddd; border-radius: 10px; padding: 30px; }
      .tab-content.active { display: block; }
      .form-group { margin-bottom: 20px; }
      .form-group label { display: block; margin-bottom: 8px; font-weight: 600; }
      .form-group input, .form-group select, .form-group textarea { 
        width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }
      .btn { display: inline-block; padding: 10px 20px; background: #007bff; color: white; 
             text-decoration: none; border: none; border-radius: 5px; cursor: pointer; }
      .btn:hover { background: #0056b3; }
      .btn-danger { background: #dc3545; }
      .btn-danger:hover { background: #c82333; }
      .result { margin-top: 20px; padding: 15px; border-radius: 5px; }
      .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
      .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
      .records-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
      .records-table th, .records-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
      .records-table th { background: #f5f5f5; }
      .records-table tr:hover { background: #f8f9fa; }
    </style>
  </head>
  <body>
    <h1>å¼€å¥–è®°å½•ç®¡ç†åå°</h1>
    
    <div class="tabs">
      <div class="tab active" data-tab="add">æ·»åŠ è®°å½•</div>
      <div class="tab" data-tab="query">æŸ¥è¯¢è®°å½•</div>
      <div class="tab" data-tab="delete">åˆ é™¤è®°å½•</div>
      <div class="tab" data-tab="stats">ç»Ÿè®¡ä¿¡æ¯</div>
    </div>
    
    <div id="add-tab" class="tab-content active">
      <h2>æ·»åŠ å¼€å¥–è®°å½•</h2>
      <form id="add-form">
        <div class="form-group">
          <label>æœŸå· (å¦‚: 2025128)</label>
          <input type="text" id="expect" required placeholder="2025128">
        </div>
        
        <div class="form-group">
          <label>ç±»å‹</label>
          <select id="type" required>
            <option value="hk">é¦™æ¸¯å…­åˆå½©</option>
            <option value="mo">è€æ¾³21.30</option>
          </select>
        </div>
        
        <div class="form-group">
          <label>å¼€å¥–å·ç  (7ä¸ªæ•°å­—ï¼Œé€—å·åˆ†éš”)</label>
          <input type="text" id="numbers" required placeholder="1,30,25,42,6,5,43">
        </div>
        
        <div class="form-group">
          <label>ç”Ÿè‚– (7ä¸ªç”Ÿè‚–ï¼Œé€—å·åˆ†éš”)</label>
          <input type="text" id="zodiacs" required placeholder="è›‡,é¼ ,è›‡,é¼ ,é¼ ,ç‰›,çŒª">
        </div>
        
        <div class="form-group">
          <label>é¢œè‰² (7ä¸ªé¢œè‰²ï¼Œé€—å·åˆ†éš”)</label>
          <input type="text" id="colors" required placeholder="red,red,blue,blue,green,green,green">
        </div>
        
        <button type="submit" class="btn">æ·»åŠ è®°å½•</button>
      </form>
      <div id="add-result" class="result"></div>
    </div>
    
    <div id="query-tab" class="tab-content">
      <h2>æŸ¥è¯¢å¼€å¥–è®°å½•</h2>
      <form id="query-form">
        <div class="form-group">
          <label>ç±»å‹</label>
          <select id="query-type">
            <option value="">å…¨éƒ¨</option>
            <option value="hk">é¦™æ¸¯å…­åˆå½©</option>
            <option value="mo">è€æ¾³21.30</option>
          </select>
        </div>
        
        <div class="form-group">
          <label>å¹´ä»½</label>
          <input type="number" id="query-year" placeholder="2025" min="2000" max="2030">
        </div>
        
        <div class="form-group">
          <label>å…³é”®è¯ (æœŸå·ã€å·ç ã€ç”Ÿè‚–)</label>
          <input type="text" id="query-keyword" placeholder="æœç´¢å…³é”®è¯">
        </div>
        
        <button type="submit" class="btn">æŸ¥è¯¢è®°å½•</button>
      </form>
      <div id="query-result"></div>
    </div>
    
    <div id="delete-tab" class="tab-content">
      <h2>åˆ é™¤å¼€å¥–è®°å½•</h2>
      <form id="delete-form">
        <div class="form-group">
          <label>æœŸå·</label>
          <input type="text" id="delete-expect" required placeholder="2025128">
        </div>
        
        <div class="form-group">
          <label>ç±»å‹</label>
          <select id="delete-type" required>
            <option value="hk">é¦™æ¸¯å…­åˆå½©</option>
            <option value="mo">è€æ¾³21.30</option>
          </select>
        </div>
        
        <button type="submit" class="btn btn-danger">åˆ é™¤è®°å½•</button>
      </form>
      <div id="delete-result" class="result"></div>
    </div>
    
    <div id="stats-tab" class="tab-content">
      <h2>ç»Ÿè®¡ä¿¡æ¯</h2>
      <div id="stats-content">
        <p>åŠ è½½ä¸­...</p>
      </div>
      <button onclick="loadStats()" class="btn">åˆ·æ–°ç»Ÿè®¡</button>
    </div>
    
    <script>
      // Tabåˆ‡æ¢åŠŸèƒ½
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          // ç§»é™¤æ‰€æœ‰activeç±»
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          
          // æ·»åŠ activeç±»
          tab.classList.add('active');
          const tabId = tab.getAttribute('data-tab');
          document.getElementById(tabId + '-tab').classList.add('active');
        });
      });
      
      // æ·»åŠ è®°å½•è¡¨å•æäº¤
      document.getElementById('add-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const record = {
          expect: document.getElementById('expect').value,
          type: document.getElementById('type').value,
          numbers: document.getElementById('numbers').value,
          zodiacs: document.getElementById('zodiacs').value,
          colors: document.getElementById('colors').value
        };
        
        const resultDiv = document.getElementById('add-result');
        resultDiv.innerHTML = '';
        resultDiv.className = 'result';
        
        try {
          const response = await fetch('/add-record', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(record)
          });
          
          const result = await response.json();
          if (result.result) {
            resultDiv.innerHTML = 'âœ… ' + result.message;
            resultDiv.className = 'result success';
            // æ¸…ç©ºè¡¨å•
            document.getElementById('add-form').reset();
          } else {
            resultDiv.innerHTML = 'âŒ ' + result.message;
            resultDiv.className = 'result error';
          }
        } catch (error) {
          resultDiv.innerHTML = 'âŒ ç½‘ç»œé”™è¯¯: ' + error.message;
          resultDiv.className = 'result error';
        }
      });
      
      // æŸ¥è¯¢è®°å½•è¡¨å•æäº¤
      document.getElementById('query-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const query = {
          type: document.getElementById('query-type').value || '',
          year: document.getElementById('query-year').value || '',
          keyword: document.getElementById('query-keyword').value || ''
        };
        
        const resultDiv = document.getElementById('query-result');
        resultDiv.innerHTML = 'æŸ¥è¯¢ä¸­...';
        
        try {
          const response = await fetch('/search', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(query)
          });
          
          const result = await response.json();
          if (result.result) {
            if (result.data.length === 0) {
              resultDiv.innerHTML = '<p>æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è®°å½•</p>';
            } else {
              let html = '<h3>æŸ¥è¯¢ç»“æœ (' + result.data.length + 'æ¡è®°å½•)</h3>';
              html += '<table class="records-table">';
              html += '<tr><th>æœŸå·</th><th>ç±»å‹</th><th>å¼€å¥–æ—¶é—´</th><th>å·ç </th><th>ç”Ÿè‚–</th></tr>';
              
              result.data.forEach(record => {
                html += '<tr>';
                html += '<td>' + record.expect + '</td>';
                html += '<td>' + (record.type === '8' ? 'é¦™æ¸¯' : 'æ¾³é—¨') + '</td>';
                html += '<td>' + record.openTime + '</td>';
                html += '<td>' + record.openCode + '</td>';
                html += '<td>' + record.zodiac + '</td>';
                html += '</tr>';
              });
              
              html += '</table>';
              resultDiv.innerHTML = html;
            }
          } else {
            resultDiv.innerHTML = '<div class="error">âŒ ' + result.message + '</div>';
          }
        } catch (error) {
          resultDiv.innerHTML = '<div class="error">âŒ æŸ¥è¯¢é”™è¯¯: ' + error.message + '</div>';
        }
      });
      
      // åˆ é™¤è®°å½•è¡¨å•æäº¤
      document.getElementById('delete-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
          return;
        }
        
        const data = {
          expect: document.getElementById('delete-expect').value,
          type: document.getElementById('delete-type').value
        };
        
        const resultDiv = document.getElementById('delete-result');
        resultDiv.innerHTML = '';
        resultDiv.className = 'result';
        
        try {
          const response = await fetch('/delete-record', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
          
          const result = await response.json();
          if (result.result) {
            resultDiv.innerHTML = 'âœ… ' + result.message;
            resultDiv.className = 'result success';
            document.getElementById('delete-form').reset();
          } else {
            resultDiv.innerHTML = 'âŒ ' + result.message;
            resultDiv.className = 'result error';
          }
        } catch (error) {
          resultDiv.innerHTML = 'âŒ ç½‘ç»œé”™è¯¯: ' + error.message;
          resultDiv.className = 'result error';
        }
      });
      
      // åŠ è½½ç»Ÿè®¡ä¿¡æ¯
      async function loadStats() {
        const statsDiv = document.getElementById('stats-content');
        statsDiv.innerHTML = 'åŠ è½½ä¸­...';
        
        try {
          const response = await fetch('/stats');
          const result = await response.json();
          
          if (result.result) {
            let html = '<h3>æ•°æ®ç»Ÿè®¡</h3>';
            
            // æ±‡æ€»ç»Ÿè®¡
            html += '<h4>è®°å½•æ±‡æ€»</h4>';
            html += '<ul>';
            result.data.summary.forEach(item => {
              html += '<li>' + (item.type === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30') + ': ' + item.count + 'æ¡</li>';
            });
            html += '<li>æ€»è®¡: ' + result.data.summary.reduce((sum, item) => sum + item.count, 0) + 'æ¡</li>';
            html += '</ul>';
            
            // æœ€æ–°è®°å½•
            html += '<h4>æœ€æ–°è®°å½•</h4>';
            if (result.data.latest.length > 0) {
              html += '<table class="records-table">';
              html += '<tr><th>æœŸå·</th><th>ç±»å‹</th><th>å¼€å¥–æ—¶é—´</th><th>å·ç </th></tr>';
              
              result.data.latest.forEach(record => {
                html += '<tr>';
                html += '<td>' + record.expect + '</td>';
                html += '<td>' + (record.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨') + '</td>';
                html += '<td>' + record.openTime + '</td>';
                html += '<td>' + record.openCode + '</td>';
                html += '</tr>';
              });
              
              html += '</table>';
            } else {
              html += '<p>æš‚æ— è®°å½•</p>';
            }
            
            statsDiv.innerHTML = html;
          } else {
            statsDiv.innerHTML = '<div class="error">âŒ ' + result.message + '</div>';
          }
        } catch (error) {
          statsDiv.innerHTML = '<div class="error">âŒ åŠ è½½å¤±è´¥: ' + error.message + '</div>';
        }
      }
      
      // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨åŠ è½½ç»Ÿè®¡
      window.addEventListener('DOMContentLoaded', () => {
        loadStats();
      });
    </script>
  </body>
  </html>`;
  
  return new Response(html, {
    headers: { 'Content-Type': 'text/html;charset=utf-8' }
  });
}

async function getStatsForChat(db) {
  try {
    const totalResult = await db.prepare(`
      SELECT type, COUNT(*) as count FROM lottery_records GROUP BY type
    `).all();
    
    const latestResult = await db.prepare(`
      SELECT * FROM lottery_records 
      ORDER BY openTime DESC 
      LIMIT 3
    `).all();
    
    let message = `ğŸ“Š *å¼€å¥–è®°å½•ç»Ÿè®¡*\n\n`;
    
    totalResult.results.forEach(item => {
      message += `*${item.type === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30'}*: ${item.count}æ¡\n`;
    });
    
    const total = totalResult.results.reduce((sum, item) => sum + item.count, 0);
    message += `*æ€»è®¡*: ${total}æ¡\n\n`;
    
    if (latestResult.results.length > 0) {
      message += `*æœ€æ–°è®°å½•:*\n`;
      latestResult.results.forEach(record => {
        message += `â€¢ ${record.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${record.expect}\n`;
      });
    }
    
    return message;
  } catch (error) {
    console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
    return 'è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥';
  }
}

async function getRecordsForChat(db, type, year) {
  try {
    const { results } = await db.prepare(`
      SELECT * FROM lottery_records 
      WHERE type = ? AND year = ?
      ORDER BY openTime DESC
      LIMIT 10
    `).bind(type, year).all();
    
    return results || [];
  } catch (error) {
    console.error('æŸ¥è¯¢å¤±è´¥:', error);
    return [];
  }
}

async function searchRecordsForChat(db, keyword) {
  try {
    const { results } = await db.prepare(`
      SELECT * FROM lottery_records 
      WHERE expect LIKE ? OR openCode LIKE ? OR zodiac LIKE ?
      ORDER BY openTime DESC
      LIMIT 10
    `).bind(`%${keyword}%`, `%${keyword}%`, `%${keyword}%`).all();
    
    return results || [];
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
    return [];
  }
}

async function sendTelegramMessage(botToken, chatId, text, options = {}) {
  try {
    if (!botToken) {
      console.error('Bot Tokenä¸ºç©º');
      return;
    }
    
    const payload = {
      chat_id: chatId,
      text: text,
      parse_mode: options.parse_mode || 'HTML',
      disable_web_page_preview: options.disable_web_page_preview || false
    };
    
    if (options.reply_markup) {
      payload.reply_markup = options.reply_markup;
    }
    
    const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    
    const result = await response.json();
    if (!result.ok) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', result);
    }
    
    return result;
  } catch (error) {
    console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
  }
}

async function editMessage(botToken, chatId, messageId, text) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${botToken}/editMessageText`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: 'Markdown'
      })
    });
    
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('ç¼–è¾‘æ¶ˆæ¯å¤±è´¥:', error);
  }
}

async function answerCallbackQuery(botToken, callbackQueryId) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${botToken}/answerCallbackQuery`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        callback_query_id: callbackQueryId
      })
    });
    
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('å›ç­”å›è°ƒæŸ¥è¯¢å¤±è´¥:', error);
  }
}
