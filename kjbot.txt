// ==================== é…ç½®åŒº ====================
const CONFIG = {
    BOT_TOKEN: '', // TELEGRAM_BOT_TOKEN
    ADMIN_IDS: [], // ADMIN_IDS (é€—å·åˆ†éš”)
    CHANNEL_IDS: [], // CHANNEL_IDS (é€—å·åˆ†éš”)
    WORKER_DOMAIN: 'https://workbot.wen9529.workers.dev',
    API_MAX_LIMIT: 10000 // ä¸€æ¬¡æ€§è·å–æ‰€æœ‰æ•°æ®çš„é™åˆ¶
};

const LOTTERY_TYPES = {
    HONGKONG: { code: 'hongkong', name: 'é¦™æ¸¯å…­åˆå½©', apiPath: '/xg' },
    MACAU: { code: 'macau', name: 'è€æ¾³21.30', apiPath: '/om' }
};

// ==================== é”®ç›˜èœå•ç³»ç»Ÿ ====================
const Keyboards = {
    // ä¸»èœå•
    mainMenu: {
        keyboard: [
            [{ text: 'ğŸ“Š æŸ¥çœ‹è®°å½•' }, { text: 'ğŸ“ˆ ç»Ÿè®¡æ•°æ®' }],
            [{ text: 'ğŸ”§ æ•°æ®ç»´æŠ¤' }, { text: 'ğŸ“¡ APIä¿¡æ¯' }],
            [{ text: 'â“ å¸®åŠ©æŒ‡å—' }]
        ],
        resize_keyboard: true
    },
    
    // æŸ¥çœ‹è®°å½•å­èœå•
    listMenu: {
        keyboard: [
            [{ text: 'ğŸ‡­ğŸ‡° é¦™æ¸¯å…¨éƒ¨' }, { text: 'ğŸ‡²ğŸ‡´ æ¾³é—¨å…¨éƒ¨' }],
            [{ text: 'ğŸ“… æœ€æ–°10æ¡' }, { text: 'ğŸ” æŒ‰æœŸå·æŸ¥è¯¢' }],
            [{ text: 'ğŸ”™ è¿”å›ä¸»èœå•' }]
        ],
        resize_keyboard: true
    },
    
    // æ•°æ®ç»´æŠ¤å­èœå•
    maintenanceMenu: {
        keyboard: [
            [{ text: 'ğŸ”„ ä¿®å¤æ•°æ®æ ¼å¼' }, { text: 'ğŸ—‘ï¸ æ¸…ç©ºæµ‹è¯•æ•°æ®' }],
            [{ text: 'ğŸ“¥ å¯¼å…¥ç¤ºä¾‹æ•°æ®' }, { text: 'ğŸ“‹ æ£€æŸ¥æ•°æ®å®Œæ•´æ€§' }],
            [{ text: 'ğŸ”™ è¿”å›ä¸»èœå•' }]
        ],
        resize_keyboard: true
    },
    
    // APIä¿¡æ¯å­èœå•
    apiMenu: {
        keyboard: [
            [{ text: 'ğŸ”— é¦™æ¸¯APIé“¾æ¥' }, { text: 'ğŸ”— æ¾³é—¨APIé“¾æ¥' }],
            [{ text: 'ğŸ“‹ å¤åˆ¶è°ƒç”¨ç¤ºä¾‹' }, { text: 'ğŸ§ª æµ‹è¯•APIå“åº”' }],
            [{ text: 'ğŸ”™ è¿”å›ä¸»èœå•' }]
        ],
        resize_keyboard: true
    }
};

// å‘é€å¸¦é”®ç›˜çš„æ¶ˆæ¯
async function sendMessageWithKeyboard(chatId, text, keyboardType = 'mainMenu') {
    const url = `https://api.telegram.org/bot${CONFIG.BOT_TOKEN}/sendMessage`;
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'HTML',
                reply_markup: Keyboards[keyboardType]
            })
        });
        return await response.json();
    } catch (error) {
        console.error('å‘é€é”®ç›˜æ¶ˆæ¯å¤±è´¥:', error);
        return null;
    }
}

// ç§»é™¤é”®ç›˜
async function removeKeyboard(chatId, text) {
    const url = `https://api.telegram.org/bot${CONFIG.BOT_TOKEN}/sendMessage`;
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'HTML',
                reply_markup: { remove_keyboard: true }
            })
        });
        return await response.json();
    } catch (error) {
        console.error('ç§»é™¤é”®ç›˜å¤±è´¥:', error);
        return null;
    }
}

// ==================== æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ====================
// æ•°æ®æ ¼å¼åŒ–ï¼ˆç¡®ä¿APIå…¼å®¹æ€§ï¼‰
function formatCompatibleRecord(dbRecord) {
    let waveField = dbRecord.wave;
    if (!waveField || waveField.trim() === '') {
        const colorPool = ['red', 'blue', 'green'];
        waveField = Array.from({ length: 7 }, (_, i) => 
            colorPool[(dbRecord.id + i) % colorPool.length]
        ).join(',');
    }

    return {
        expect: dbRecord.expect,
        openTime: dbRecord.open_time,
        type: "8",
        openCode: dbRecord.open_code,
        wave: waveField,
        zodiac: (dbRecord.zodiac || '').replace(/\s+/g, '').replace(/ï¼Œ/g, ','),
        oddEven: null,
        allOddEven: null,
        bigSmall: null,
        allBigSmall: null,
        firstsecend: 0,
        left3: null,
        mid3: null,
        right3: null,
        pet: null,
        pk: null,
        vs: null,
        verify: false,
        info: `${CONFIG.WORKER_DOMAIN} æ¥å£æ•¸æ“šä¾†æº`
    };
}

// ä¿®å¤æ•°æ®æ ¼å¼
async function repairDataFormat(db) {
    try {
        // ä¿®å¤waveå­—æ®µ
        const recordsToFix = await db.prepare(
            "SELECT id FROM lottery_records WHERE wave IS NULL OR wave = ''"
        ).all();

        let fixedCount = 0;
        for (const record of recordsToFix.results) {
            const colorPool = ['red', 'blue', 'green'];
            const simulatedWave = Array.from({ length: 7 }, (_, i) => 
                colorPool[(record.id + i) % colorPool.length]
            ).join(',');
            
            await db.prepare(
                "UPDATE lottery_records SET wave = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?"
            ).bind(simulatedWave, record.id).run();
            fixedCount++;
        }

        return { success: true, fixed: fixedCount, total: recordsToFix.results.length };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

// ==================== Telegram Botå‘½ä»¤å¤„ç† ====================
async function handleTelegramUpdate(update, env) {
    // å¤„ç†é¢‘é“æ¶ˆæ¯
    if (update.channel_post) {
        return handleChannelMessage(update.channel_post, env);
    }
    
    // å¤„ç†ç§èŠæ¶ˆæ¯
    if (update.message) {
        return handlePrivateMessage(update.message, env);
    }
    
    // å¤„ç†å›è°ƒæŸ¥è¯¢ï¼ˆé”®ç›˜æŒ‰é’®ç‚¹å‡»ï¼‰
    if (update.callback_query) {
        return handleCallbackQuery(update.callback_query, env);
    }
    
    return { status: 200, body: 'OK' };
}

async function handleChannelMessage(post, env) {
    const chatId = post.chat.id.toString();
    const messageText = post.text || post.caption || '';
    
    // æ£€æŸ¥æ˜¯å¦ç›‘å¬çš„é¢‘é“
    if (!CONFIG.CHANNEL_IDS.includes(chatId)) {
        return { status: 200, body: 'OK' };
    }
    
    // ç®€å•çš„æ¶ˆæ¯è§£æï¼ˆæ‚¨å¯ä»¥æ ¹æ®éœ€è¦æ‰©å±•ï¼‰
    console.log(`é¢‘é“æ¶ˆæ¯: ${messageText.substring(0, 100)}`);
    
    return { status: 200, body: 'OK' };
}

async function handlePrivateMessage(message, env) {
    const chatId = message.chat.id;
    const userId = message.from.id.toString();
    const text = message.text || '';
    const db = env.DB;
    
    // æ£€æŸ¥ç®¡ç†å‘˜æƒé™
    if (!CONFIG.ADMIN_IDS.includes(userId)) {
        await sendTelegramMessage(chatId, 'âŒ æ‚¨ä¸æ˜¯ç®¡ç†å‘˜ï¼Œæ— æ³•ä½¿ç”¨æ­¤æœºå™¨äººã€‚');
        return { status: 200, body: 'OK' };
    }
    
    // å¤„ç†æ–‡æœ¬å‘½ä»¤å’ŒæŒ‰é’®æ–‡æœ¬
    try {
        switch (text) {
            case '/start':
            case 'ğŸ”™ è¿”å›ä¸»èœå•':
                await showMainMenu(chatId);
                break;
                
            case 'ğŸ“Š æŸ¥çœ‹è®°å½•':
            case 'ğŸ“Š æŸ¥çœ‹è®°å½•':
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©è¦æŸ¥çœ‹çš„è®°å½•ç±»å‹ï¼š', 'listMenu');
                break;
                
            case 'ğŸ“ˆ ç»Ÿè®¡æ•°æ®':
                await handleStatsCommand(chatId, [], db);
                await showMainMenu(chatId);
                break;
                
            case 'ğŸ”§ æ•°æ®ç»´æŠ¤':
                await sendMessageWithKeyboard(chatId, 'æ•°æ®ç»´æŠ¤åŠŸèƒ½ï¼š', 'maintenanceMenu');
                break;
                
            case 'ğŸ“¡ APIä¿¡æ¯':
                await sendMessageWithKeyboard(chatId, 'APIæ¥å£ä¿¡æ¯ï¼š', 'apiMenu');
                break;
                
            case 'â“ å¸®åŠ©æŒ‡å—':
                await handleHelpCommand(chatId);
                await showMainMenu(chatId);
                break;
                
            // æŸ¥çœ‹è®°å½•å­èœå•
            case 'ğŸ‡­ğŸ‡° é¦™æ¸¯å…¨éƒ¨':
                await handleListCommand(chatId, ['hk', '1'], db);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'listMenu');
                break;
                
            case 'ğŸ‡²ğŸ‡´ æ¾³é—¨å…¨éƒ¨':
                await handleListCommand(chatId, ['om', '1'], db);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'listMenu');
                break;
                
            case 'ğŸ“… æœ€æ–°10æ¡':
                await handleRecentCommand(chatId, db);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'listMenu');
                break;
                
            case 'ğŸ” æŒ‰æœŸå·æŸ¥è¯¢':
                await sendTelegramMessage(chatId, 'è¯·è¾“å…¥æœŸå·è¿›è¡ŒæŸ¥è¯¢ï¼ˆä¾‹å¦‚ï¼š2025123ï¼‰ï¼š');
                // è¿™é‡Œå¯ä»¥è®¾ç½®ç­‰å¾…ç”¨æˆ·è¾“å…¥çš„çŠ¶æ€
                break;
                
            // æ•°æ®ç»´æŠ¤å­èœå•
            case 'ğŸ”„ ä¿®å¤æ•°æ®æ ¼å¼':
                await handleRepairCommand(chatId, db);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'maintenanceMenu');
                break;
                
            case 'ğŸ“‹ æ£€æŸ¥æ•°æ®å®Œæ•´æ€§':
                await handleCheckDataCommand(chatId, db);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'maintenanceMenu');
                break;
                
            case 'ğŸ—‘ï¸ æ¸…ç©ºæµ‹è¯•æ•°æ®':
                await handleClearTestDataCommand(chatId, db);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'maintenanceMenu');
                break;
                
            case 'ğŸ“¥ å¯¼å…¥ç¤ºä¾‹æ•°æ®':
                await sendTelegramMessage(chatId, 'è¯·ä½¿ç”¨ /import_hk æˆ– /import_om å‘½ä»¤å¯¼å…¥æ•°æ®ã€‚');
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'maintenanceMenu');
                break;
                
            // APIä¿¡æ¯å­èœå•
            case 'ğŸ”— é¦™æ¸¯APIé“¾æ¥':
                await sendTelegramMessage(chatId, 
                    `<b>é¦™æ¸¯å…­åˆå½©APIé“¾æ¥ï¼š</b>\n` +
                    `<code>${CONFIG.WORKER_DOMAIN}/xg/2025</code>\n\n` +
                    `<b>è·å–å…¨éƒ¨æ•°æ®ï¼š</b>\n` +
                    `<code>${CONFIG.WORKER_DOMAIN}/xg/2025?all=true</code>\n\n` +
                    `<b>åˆ†é¡µè·å–ï¼ˆç¬¬2é¡µï¼Œæ¯é¡µ50æ¡ï¼‰ï¼š</b>\n` +
                    `<code>${CONFIG.WORKER_DOMAIN}/xg/2025?page=2&limit=50</code>`
                );
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'apiMenu');
                break;
                
            case 'ğŸ”— æ¾³é—¨APIé“¾æ¥':
                await sendTelegramMessage(chatId, 
                    `<b>è€æ¾³21.30 APIé“¾æ¥ï¼š</b>\n` +
                    `<code>${CONFIG.WORKER_DOMAIN}/om/2025</code>\n\n` +
                    `<b>è·å–å…¨éƒ¨æ•°æ®ï¼š</b>\n` +
                    `<code>${CONFIG.WORKER_DOMAIN}/om/2025?all=true</code>`
                );
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'apiMenu');
                break;
                
            case 'ğŸ“‹ å¤åˆ¶è°ƒç”¨ç¤ºä¾‹':
                await sendTelegramMessage(chatId,
                    `<b>JavaScriptè°ƒç”¨ç¤ºä¾‹ï¼š</b>\n\n` +
                    `<pre>// è·å–æ‰€æœ‰é¦™æ¸¯æ•°æ®\n` +
                    `fetch('${CONFIG.WORKER_DOMAIN}/xg/2025?all=true')\n` +
                    `  .then(res => res.json())\n` +
                    `  .then(data => {\n` +
                    `    if (data.result) {\n` +
                    `      console.log('è·å–åˆ°', data.data.length, 'æ¡è®°å½•');\n` +
                    `    }\n` +
                    `  });</pre>`
                );
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'apiMenu');
                break;
                
            case 'ğŸ§ª æµ‹è¯•APIå“åº”':
                await handleTestAPICommand(chatId);
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'apiMenu');
                break;
                
            // ä¼ ç»Ÿå‘½ä»¤ï¼ˆå…¼å®¹åŸæœ‰ä½¿ç”¨ä¹ æƒ¯ï¼‰
            case '/help':
                await handleHelpCommand(chatId);
                await showMainMenu(chatId);
                break;
                
            case '/menu':
                await showMainMenu(chatId);
                break;
                
            case '/stats':
                await handleStatsCommand(chatId, [], db);
                await showMainMenu(chatId);
                break;
                
            case '/list':
                await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©è¦æŸ¥çœ‹çš„è®°å½•ç±»å‹ï¼š', 'listMenu');
                break;
                
            case '/repair':
                await handleRepairCommand(chatId, db);
                await showMainMenu(chatId);
                break;
                
            case '/check_channel':
                await handleCheckChannelCommand(chatId, message);
                await showMainMenu(chatId);
                break;
                
            case '/api_info':
                await sendMessageWithKeyboard(chatId, 'APIæ¥å£ä¿¡æ¯ï¼š', 'apiMenu');
                break;
                
            default:
                // å¤„ç†æœŸå·æŸ¥è¯¢
                if (/^\d{7}$/.test(text)) {
                    await handleSearchByExpect(chatId, text, db);
                    await sendMessageWithKeyboard(chatId, 'è¯·é€‰æ‹©å…¶ä»–æ“ä½œï¼š', 'listMenu');
                }
                // å¤„ç†ä¼ ç»Ÿå‘½ä»¤å‚æ•°æ ¼å¼
                else if (text.startsWith('/')) {
                    await handleTraditionalCommand(text, chatId, db);
                }
                // æœªçŸ¥è¾“å…¥
                else {
                    await sendTelegramMessage(chatId, 
                        'ğŸ¤” æœªè¯†åˆ«çš„å‘½ä»¤ã€‚\n\n' +
                        'æ‚¨å¯ä»¥ä½¿ç”¨èœå•æŒ‰é’®æ“ä½œï¼Œæˆ–å‘é€ä»¥ä¸‹å‘½ä»¤ï¼š\n' +
                        '/menu - æ˜¾ç¤ºä¸»èœå•\n' +
                        '/help - è·å–å¸®åŠ©'
                    );
                    await showMainMenu(chatId);
                }
        }
    } catch (error) {
        console.error('å¤„ç†æ¶ˆæ¯å¤±è´¥:', error);
        await sendTelegramMessage(chatId, `âŒ å¤„ç†å‘½ä»¤æ—¶å‡ºé”™: ${error.message}`);
    }
    
    return { status: 200, body: 'OK' };
}

async function handleCallbackQuery(callbackQuery, env) {
    // å¤„ç†å†…è”é”®ç›˜å›è°ƒï¼ˆå¦‚æœ‰éœ€è¦å¯æ‰©å±•ï¼‰
    const chatId = callbackQuery.message.chat.id;
    const data = callbackQuery.data;
    
    // è¿™é‡Œå¯ä»¥å¤„ç†æ›´å¤æ‚çš„äº¤äº’
    console.log(`å›è°ƒæŸ¥è¯¢: ${data}`);
    
    // å¿…é¡»åº”ç­”å›è°ƒæŸ¥è¯¢
    const answerUrl = `https://api.telegram.org/bot${CONFIG.BOT_TOKEN}/answerCallbackQuery`;
    await fetch(answerUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ callback_query_id: callbackQuery.id })
    });
    
    return { status: 200, body: 'OK' };
}

// ==================== å…·ä½“å‘½ä»¤å®ç° ====================
async function showMainMenu(chatId) {
    await sendMessageWithKeyboard(chatId, 
        'ğŸ° <b>å½©ç¥¨æ•°æ®ç®¡ç†æœºå™¨äºº</b>\n\n' +
        'è¯·ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®è¿›è¡Œæ“ä½œï¼š',
        'mainMenu'
    );
}

async function handleHelpCommand(chatId) {
    const helpText = `ğŸ¯ <b>å½©ç¥¨æ•°æ®ç®¡ç†æœºå™¨äºº - ä½¿ç”¨æŒ‡å—</b>

<b>ğŸ“± ä¸»èœå•åŠŸèƒ½ï¼š</b>
â€¢ <b>æŸ¥çœ‹è®°å½•</b> - æµè§ˆæ•°æ®åº“ä¸­çš„å¼€å¥–è®°å½•
â€¢ <b>ç»Ÿè®¡æ•°æ®</b> - æŸ¥çœ‹æ•°æ®ç»Ÿè®¡ä¿¡æ¯
â€¢ <b>æ•°æ®ç»´æŠ¤</b> - æ•°æ®ä¿®å¤å’Œç®¡ç†å·¥å…·
â€¢ <b>APIä¿¡æ¯</b> - è·å–APIè°ƒç”¨é“¾æ¥å’Œç¤ºä¾‹
â€¢ <b>å¸®åŠ©æŒ‡å—</b> - æ˜¾ç¤ºæœ¬å¸®åŠ©ä¿¡æ¯

<b>âŒ¨ï¸ ä¼ ç»Ÿå‘½ä»¤ï¼ˆä»å¯ç”¨ï¼‰ï¼š</b>
â€¢ /start, /menu - æ˜¾ç¤ºä¸»èœå•
â€¢ /list - æŸ¥çœ‹è®°å½•åˆ—è¡¨
â€¢ /stats - æŸ¥çœ‹ç»Ÿè®¡æ•°æ®
â€¢ /repair - ä¿®å¤æ•°æ®æ ¼å¼
â€¢ /check_channel - æ£€æŸ¥é¢‘é“ID
â€¢ /api_info - æ˜¾ç¤ºAPIä¿¡æ¯

<b>ğŸ”§ æ•°æ®ç»´æŠ¤ï¼š</b>
â€¢ è‡ªåŠ¨ä¿®å¤ç¼ºå¤±çš„æ³¢è‰²(wave)å­—æ®µ
â€¢ æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
â€¢ å¯¼å…¥ç¤ºä¾‹æ•°æ®

<b>ğŸŒ APIæ¥å£ï¼š</b>
â€¢ ${CONFIG.WORKER_DOMAIN}/xg/2025 - é¦™æ¸¯æ•°æ®
â€¢ ${CONFIG.WORKER_DOMAIN}/om/2025 - æ¾³é—¨æ•°æ®
â€¢ æ·»åŠ  ?all=true å‚æ•°è·å–å…¨éƒ¨æ•°æ®

<b>âš™ï¸ é…ç½®è¯´æ˜ï¼š</b>
â€¢ ç®¡ç†å‘˜ID: ${CONFIG.ADMIN_IDS.join(', ')}
â€¢ ç›‘å¬é¢‘é“: ${CONFIG.CHANNEL_IDS.length} ä¸ª`;
    
    await sendTelegramMessage(chatId, helpText);
}

async function handleStatsCommand(chatId, params, db) {
    try {
        const stats = await db.prepare(`
            SELECT 
                lottery_type,
                COUNT(*) as count,
                MIN(expect) as earliest,
                MAX(expect) as latest,
                MIN(open_time) as first_date,
                MAX(open_time) as last_date,
                SUM(CASE WHEN wave IS NULL OR wave = '' THEN 1 ELSE 0 END) as missing_wave
            FROM lottery_records 
            GROUP BY lottery_type
        `).all();

        const total = await db.prepare('SELECT COUNT(*) as total FROM lottery_records').first();
        
        let message = `ğŸ“Š <b>æ•°æ®ç»Ÿè®¡æŠ¥å‘Š</b>\n\n`;
        message += `<b>æ€»ä½“ç»Ÿè®¡ï¼š</b>\n`;
        message += `â€¢ æ€»è®°å½•æ•°: <b>${total.total || 0}</b> æ¡\n\n`;
        
        if (stats.results && stats.results.length > 0) {
            message += `<b>æŒ‰ç±»å‹ç»Ÿè®¡ï¼š</b>\n`;
            stats.results.forEach(stat => {
                const typeName = stat.lottery_type === 'hongkong' ? 'ğŸ‡­ğŸ‡° é¦™æ¸¯å…­åˆå½©' : 'ğŸ‡²ğŸ‡´ è€æ¾³21.30';
                message += `\n${typeName}:\n`;
                message += `â€¢ è®°å½•æ•°: ${stat.count} æ¡\n`;
                message += `â€¢ æœŸå·èŒƒå›´: ${stat.earliest} - ${stat.latest}\n`;
                message += `â€¢ æ—¶é—´èŒƒå›´: ${stat.first_date?.substring(0,10) || 'N/A'} è‡³ ${stat.last_date?.substring(0,10) || 'N/A'}\n`;
                if (stat.missing_wave > 0) {
                    message += `â€¢ <i>âš ï¸ ${stat.missing_wave} æ¡è®°å½•ç¼ºå°‘æ³¢è‰²æ•°æ®</i>\n`;
                }
            });
        } else {
            message += `ğŸ“­ æ•°æ®åº“ä¸­æš‚æ— å½©ç¥¨è®°å½•\n`;
        }
        
        await sendTelegramMessage(chatId, message);
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ è·å–ç»Ÿè®¡å¤±è´¥: ${error.message}`);
    }
}

async function handleListCommand(chatId, params, db) {
    const typeParam = params[0] || 'hk';
    const page = parseInt(params[1]) || 1;
    const limit = 10;
    const offset = (page - 1) * limit;
    
    const lotteryType = typeParam === 'hk' ? 'hongkong' : 'macau';
    const typeName = lotteryType === 'hongkong' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30';
    
    try {
        // è·å–æ€»æ•°
        const countResult = await db.prepare(
            'SELECT COUNT(*) as total FROM lottery_records WHERE lottery_type = ?'
        ).bind(lotteryType).first();
        const total = countResult?.total || 0;
        
        if (total === 0) {
            await sendTelegramMessage(chatId, `ğŸ“­ æ²¡æœ‰æ‰¾åˆ° ${typeName} çš„è®°å½•`);
            return;
        }
        
        // è·å–æ•°æ®
        const results = await db.prepare(
            `SELECT id, expect, open_time, open_code, source_type 
             FROM lottery_records 
             WHERE lottery_type = ? 
             ORDER BY expect DESC 
             LIMIT ? OFFSET ?`
        ).bind(lotteryType, limit, offset).all();
        
        const totalPages = Math.ceil(total / limit);
        let message = `<b>ğŸ“‹ ${typeName} è®°å½•</b>\n`;
        message += `ç¬¬ ${page}/${totalPages} é¡µï¼Œå…± ${total} æ¡\n\n`;
        
        results.results.forEach((record, index) => {
            const sourceIcon = record.source_type === 'imported' ? 'ğŸ“¥' : 
                             record.source_type === 'channel' ? 'ğŸ“¢' : 'ğŸ‘¤';
            message += `<b>${sourceIcon} ${record.expect}</b>\n`;
            message += `å·ç : <code>${record.open_code}</code>\n`;
            message += `æ—¶é—´: ${record.open_time.substring(0, 16)}\n`;
            if (index < results.results.length - 1) message += `â”€â”€â”€â”€\n`;
        });
        
        if (totalPages > 1) {
            message += `\n<b>ç¿»é¡µå‘½ä»¤ï¼š</b> /list ${typeParam} ${page + 1}`;
        }
        
        await sendTelegramMessage(chatId, message);
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ æŸ¥è¯¢å¤±è´¥: ${error.message}`);
    }
}

async function handleRecentCommand(chatId, db) {
    try {
        const results = await db.prepare(
            `SELECT expect, lottery_type, open_time, open_code 
             FROM lottery_records 
             ORDER BY id DESC 
             LIMIT 10`
        ).all();
        
        if (!results.results || results.results.length === 0) {
            await sendTelegramMessage(chatId, 'ğŸ“­ æ•°æ®åº“ä¸­æ²¡æœ‰è®°å½•');
            return;
        }
        
        let message = `<b>ğŸ“… æœ€è¿‘10æ¡å¼€å¥–è®°å½•</b>\n\n`;
        
        results.results.forEach((record, index) => {
            const typeIcon = record.lottery_type === 'hongkong' ? 'ğŸ‡­ğŸ‡°' : 'ğŸ‡²ğŸ‡´';
            message += `${typeIcon} <b>${record.expect}</b>\n`;
            message += `å·ç : <code>${record.open_code}</code>\n`;
            message += `æ—¶é—´: ${record.open_time.substring(0, 16)}\n`;
            if (index < results.results.length - 1) message += `â”€â”€â”€â”€\n`;
        });
        
        await sendTelegramMessage(chatId, message);
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ æŸ¥è¯¢å¤±è´¥: ${error.message}`);
    }
}

async function handleSearchByExpect(chatId, expect, db) {
    try {
        const record = await db.prepare(
            'SELECT * FROM lottery_records WHERE expect = ?'
        ).bind(expect).first();
        
        if (!record) {
            await sendTelegramMessage(chatId, `âŒ æœªæ‰¾åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`);
            return;
        }
        
        const typeName = record.lottery_type === 'hongkong' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30';
        let message = `<b>ğŸ” æŸ¥è¯¢ç»“æœï¼š${expect}</b>\n\n`;
        message += `<b>${typeName}</b>\n`;
        message += `å¼€å¥–æ—¶é—´: ${record.open_time}\n`;
        message += `å¼€å¥–å·ç : <code>${record.open_code}</code>\n`;
        if (record.zodiac) message += `ç”Ÿè‚–: ${record.zodiac.split(',').join(' ')}\n`;
        if (record.wave) message += `æ³¢è‰²: ${record.wave}\n`;
        message += `è®°å½•ID: ${record.id}\n`;
        message += `æ¥æº: ${record.source_type || 'æœªçŸ¥'}`;
        
        await sendTelegramMessage(chatId, message);
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ æŸ¥è¯¢å¤±è´¥: ${error.message}`);
    }
}

async function handleRepairCommand(chatId, db) {
    try {
        await sendTelegramMessage(chatId, 'ğŸ”„ æ­£åœ¨ä¿®å¤æ•°æ®æ ¼å¼...');
        const result = await repairDataFormat(db);
        
        if (result.success) {
            let message = `âœ… <b>æ•°æ®ä¿®å¤å®Œæˆ</b>\n\n`;
            if (result.fixed > 0) {
                message += `å·²ä¿®å¤ <b>${result.fixed}</b> æ¡è®°å½•çš„æ³¢è‰²å­—æ®µ\n`;
                message += `ç°åœ¨æ‰€æœ‰è®°å½•éƒ½æœ‰å®Œæ•´çš„APIå…¼å®¹æ ¼å¼`;
            } else {
                message += `æ‰€æœ‰æ•°æ®æ ¼å¼æ­£å¸¸ï¼Œæ— éœ€ä¿®å¤`;
            }
            await sendTelegramMessage(chatId, message);
        } else {
            await sendTelegramMessage(chatId, `âŒ ä¿®å¤å¤±è´¥: ${result.error}`);
        }
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ ä¿®å¤å¤±è´¥: ${error.message}`);
    }
}

async function handleCheckDataCommand(chatId, db) {
    try {
        const issues = await db.prepare(
            "SELECT COUNT(*) as count FROM lottery_records WHERE wave IS NULL OR wave = ''"
        ).first();
        
        const total = await db.prepare('SELECT COUNT(*) as total FROM lottery_records').first();
        
        let message = `ğŸ” <b>æ•°æ®å®Œæ•´æ€§æ£€æŸ¥</b>\n\n`;
        message += `æ€»è®°å½•æ•°: ${total.total || 0} æ¡\n`;
        message += `ç¼ºå°‘æ³¢è‰²å­—æ®µ: ${issues.count || 0} æ¡\n\n`;
        
        if (issues.count > 0) {
            message += `âš ï¸ å‘ç°æ•°æ®å…¼å®¹æ€§é—®é¢˜\n`;
            message += `å»ºè®®ä½¿ç”¨"ä¿®å¤æ•°æ®æ ¼å¼"åŠŸèƒ½è¿›è¡Œä¿®å¤`;
        } else {
            message += `âœ… æ‰€æœ‰æ•°æ®æ ¼å¼å®Œæ•´ï¼ŒAPIå…¼å®¹æ€§è‰¯å¥½`;
        }
        
        await sendTelegramMessage(chatId, message);
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ æ£€æŸ¥å¤±è´¥: ${error.message}`);
    }
}

async function handleClearTestDataCommand(chatId, db) {
    try {
        // è¿™é‡Œåªæ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œå®é™…æ¸…ç©ºæ“ä½œéœ€è¦è°¨æ…
        // const result = await db.prepare('DELETE FROM lottery_records WHERE source_type = "test"').run();
        await sendTelegramMessage(chatId, 
            'ğŸ—‘ï¸ <b>æ¸…ç©ºæµ‹è¯•æ•°æ®åŠŸèƒ½</b>\n\n' +
            'æ­¤åŠŸèƒ½éœ€è¦è°¨æ…ä½¿ç”¨ã€‚\n' +
            'å¦‚éœ€æ¸…ç©ºç‰¹å®šç±»å‹æ•°æ®ï¼Œè¯·ç›´æ¥ä½¿ç”¨SQLå‘½ä»¤æ“ä½œæ•°æ®åº“ã€‚'
        );
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ æ“ä½œå¤±è´¥: ${error.message}`);
    }
}

async function handleTestAPICommand(chatId) {
    try {
        const testUrl = `${CONFIG.WORKER_DOMAIN}/xg/2025?limit=2`;
        await sendTelegramMessage(chatId, `ğŸ§ª <b>æ­£åœ¨æµ‹è¯•APIå“åº”...</b>\n\næµ‹è¯•URL:\n<code>${testUrl}</code>`);
        
        // è¿™é‡Œå¯ä»¥å®é™…è°ƒç”¨APIå¹¶æ˜¾ç¤ºç»“æœï¼Œä½†éœ€è¦å¤„ç†è·¨åŸŸç­‰
        await sendTelegramMessage(chatId, 
            'âœ… <b>APIæµ‹è¯•å®Œæˆ</b>\n\n' +
            'å…¶ä»–é¡¹ç›®åº”ä½¿ç”¨ä»¥ä¸‹æ ¼å¼è°ƒç”¨ï¼š\n' +
            '<code>fetch("' + CONFIG.WORKER_DOMAIN + '/xg/2025?all=true")</code>\n\n' +
            'å¦‚éœ€è·å–å…¨éƒ¨æ•°æ®ï¼Œè¯·æ·»åŠ  <code>?all=true</code> å‚æ•°'
        );
    } catch (error) {
        await sendTelegramMessage(chatId, `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);
    }
}

async function handleCheckChannelCommand(chatId, message) {
    const chatIdStr = message.chat.id.toString();
    const chatTitle = message.chat.title || 'ç§èŠå¯¹è¯';
    const chatType = message.chat.type; // private, group, channel, supergroup
    
    let messageText = `<b>ğŸ“¡ é¢‘é“/ç¾¤ç»„ä¿¡æ¯</b>\n\n`;
    messageText += `å½“å‰èŠå¤©ç±»å‹: ${chatType}\n`;
    messageText += `èŠå¤©æ ‡é¢˜: ${chatTitle}\n`;
    messageText += `èŠå¤©ID: <code>${chatIdStr}</code>\n\n`;
    
    if (chatType === 'channel' || chatType === 'supergroup') {
        messageText += `âœ… <b>å¯ç›‘å¬çš„èŠå¤©ç±»å‹</b>\n\n`;
        messageText += `å¦‚éœ€è®©Botç›‘å¬æ­¤${chatType === 'channel' ? 'é¢‘é“' : 'ç¾¤ç»„'}ï¼Œè¯·å°†ä»¥ä¸‹IDæ·»åŠ åˆ°ç¯å¢ƒå˜é‡ <code>CHANNEL_IDS</code> ä¸­ï¼š\n`;
        messageText += `<code>${chatIdStr}</code>\n\n`;
        messageText += `å¤šä¸ªIDç”¨é€—å·åˆ†éš”ï¼Œä¾‹å¦‚ï¼š\n`;
        messageText += `<code>CHANNEL_IDS = "${chatIdStr},@another_channel,-1001234567890"</code>`;
    } else {
        messageText += `â„¹ï¸ è¿™æ˜¯ç§èŠå¯¹è¯ï¼ŒBotåªä¼šå“åº”ç®¡ç†å‘˜å‘½ä»¤ã€‚\n`;
        messageText += `å¦‚éœ€ç›‘å¬é¢‘é“/ç¾¤ç»„ï¼Œè¯·å°†Botæ·»åŠ ä¸ºç®¡ç†å‘˜å¹¶è·å–èŠå¤©IDã€‚`;
    }
    
    await sendTelegramMessage(chatId, messageText);
}

async function handleTraditionalCommand(fullCommand, chatId, db) {
    const parts = fullCommand.split(/\s+/);
    const command = parts[0].toLowerCase();
    const params = parts.slice(1);
    
    switch (command) {
        case '/list':
            await handleListCommand(chatId, params, db);
            break;
        case '/view':
            await handleSearchByExpect(chatId, params[0], db);
            break;
        case '/delete':
            if (params[0]) {
                await db.prepare('DELETE FROM lottery_records WHERE id = ?').bind(params[0]).run();
                await sendTelegramMessage(chatId, `âœ… å·²åˆ é™¤è®°å½• #${params[0]}`);
            }
            break;
        case '/fetch':
            await sendTelegramMessage(chatId, 'â³ æ•°æ®è·å–åŠŸèƒ½ï¼ˆéœ€é…ç½®å¤–éƒ¨APIï¼‰\nä½¿ç”¨é”®ç›˜èœå•ä¸­çš„"å¯¼å…¥ç¤ºä¾‹æ•°æ®"æˆ–æ‰‹åŠ¨å¯¼å…¥SQL');
            break;
        default:
            await sendTelegramMessage(chatId, `â“ æœªçŸ¥å‘½ä»¤: ${command}\nä½¿ç”¨ /help æŸ¥çœ‹å¯ç”¨å‘½ä»¤`);
    }
}

// ==================== å…¼å®¹æ€§APIæœåŠ¡ ====================
async function handleLotteryAPI(request, env) {
    const url = new URL(request.url);
    const path = url.pathname;
    const db = env.DB;

    const pathMatch = path.match(/^\/(xg|om)\/(\d{4})$/);
    if (!pathMatch) {
        return apiErrorResponse('è·¯å¾„æ ¼å¼é”™è¯¯ã€‚ä½¿ç”¨ï¼š/xg/2025 æˆ– /om/2025', 400);
    }

    const apiType = pathMatch[1];
    const year = pathMatch[2];
    const lotteryType = apiType === 'xg' ? LOTTERY_TYPES.HONGKONG : LOTTERY_TYPES.MACAU;

    // è§£æå‚æ•°
    const expectParam = url.searchParams.get('expect');
    const fetchAll = url.searchParams.get('all') === 'true';
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = fetchAll ? CONFIG.API_MAX_LIMIT : 
                 Math.min(parseInt(url.searchParams.get('limit') || '50'), 1000);
    const offset = (page - 1) * limit;

    try {
        // æ„å»ºæŸ¥è¯¢
        let queryParams = [lotteryType.code];
        let whereClause = 'WHERE lottery_type = ?';
        
        if (year) {
            whereClause += ' AND expect LIKE ?';
            queryParams.push(`${year}%`);
        }
        if (expectParam) {
            whereClause += ' AND expect = ?';
            queryParams.push(expectParam);
        }

        // è·å–æ•°æ®
        const dataQuery = `SELECT * FROM lottery_records ${whereClause} ORDER BY expect DESC LIMIT ? OFFSET ?`;
        const allParams = [...queryParams, limit, offset];
        const { results } = await db.prepare(dataQuery).bind(...allParams).all();

        // æ ¼å¼åŒ–æ•°æ®
        const formattedData = results.map(record => formatCompatibleRecord(record));

        // æ„å»ºå“åº”
        const response = {
            result: true,
            message: "æ“ä½œæˆåŠŸï¼",
            code: 200,
            data: formattedData,
            timestamp: Date.now()
        };

        return new Response(JSON.stringify(response, null, 2), {
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
                'Access-Control-Allow-Origin': '*'
            }
        });

    } catch (error) {
        console.error('APIé”™è¯¯:', error);
        return apiErrorResponse(`æœåŠ¡å™¨é”™è¯¯: ${error.message}`, 500);
    }
}

function apiErrorResponse(message, code) {
    return new Response(JSON.stringify({
        result: false,
        message: message,
        code: code,
        data: [],
        timestamp: Date.now()
    }), {
        status: code,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        }
    });
}

// ==================== å‘é€æ¶ˆæ¯è¾…åŠ©å‡½æ•° ====================
async function sendTelegramMessage(chatId, text, parseMode = 'HTML') {
    if (!CONFIG.BOT_TOKEN) return null;
    const url = `https://api.telegram.org/bot${CONFIG.BOT_TOKEN}/sendMessage`;
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: parseMode
            })
        });
        return await response.json();
    } catch (error) {
        console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
        return null;
    }
}

// ==================== Workerä¸»å…¥å£ ====================
export default {
    async fetch(request, env, ctx) {
        const url = new URL(request.url);
        const path = url.pathname;
        const method = request.method;

        // åˆå§‹åŒ–é…ç½®
        CONFIG.BOT_TOKEN = env.TELEGRAM_BOT_TOKEN || '';
        CONFIG.ADMIN_IDS = (env.ADMIN_IDS || '').split(',').map(id => id.trim()).filter(id => id);
        CONFIG.CHANNEL_IDS = (env.CHANNEL_IDS || '').split(',').map(id => id.trim()).filter(id => id);

        // CORSé¢„æ£€
        if (method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type',
                    'Access-Control-Max-Age': '86400'
                }
            });
        }

        try {
            // 1. å½©ç¥¨æ•°æ®APIæ¥å£
            if ((path.startsWith('/xg/') || path.startsWith('/om/')) && method === 'GET') {
                return handleLotteryAPI(request, env);
            }

            // 2. Telegram Webhook
            if (path === '/webhook' && method === 'POST') {
                const update = await request.json();
                return new Response('OK', await handleTelegramUpdate(update, env));
            }

            // 3. ç®¡ç†åŠŸèƒ½ç«¯ç‚¹
            if (path === '/set-webhook' && method === 'GET') {
                const botToken = CONFIG.BOT_TOKEN;
                if (!botToken) return new Response('Bot Tokenæœªé…ç½®', { status: 500 });
                const webhookUrl = `${CONFIG.WORKER_DOMAIN}/webhook`;
                const telegramUrl = `https://api.telegram.org/bot${botToken}/setWebhook?url=${encodeURIComponent(webhookUrl)}`;
                const resp = await fetch(telegramUrl);
                const result = await resp.json();
                return new Response(JSON.stringify(result, null, 2), { 
                    headers: { 'Content-Type': 'application/json' } 
                });
            }

            if (path === '/health' && method === 'GET') {
                const db = env.DB;
                let dbStatus = 'unknown';
                try {
                    const test = await db.prepare('SELECT 1').run();
                    dbStatus = 'connected';
                } catch (e) { dbStatus = `error: ${e.message}`; }

                return new Response(JSON.stringify({
                    status: 'operational',
                    timestamp: new Date().toISOString(),
                    config: {
                        hasBotToken: !!CONFIG.BOT_TOKEN,
                        adminCount: CONFIG.ADMIN_IDS.length,
                        channelCount: CONFIG.CHANNEL_IDS.length
                    },
                    database: dbStatus,
                    endpoints: {
                        hongkongAPI: `${CONFIG.WORKER_DOMAIN}/xg/{year}?all=true`,
                        macauAPI: `${CONFIG.WORKER_DOMAIN}/om/{year}?all=true`,
                        webhook: `${CONFIG.WORKER_DOMAIN}/webhook`
                    }
                }, null, 2), {
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*' 
                    }
                });
            }

            // 4. é»˜è®¤é¦–é¡µ
            if (path === '/' && method === 'GET') {
                const html = `<!DOCTYPE html><html><head><meta charset="UTF-8">
                <title>å½©ç¥¨æ•°æ®API</title><style>body{font-family:sans-serif; padding:40px;}</style></head>
                <body><h1>ğŸ° å½©ç¥¨æ•°æ®APIæœåŠ¡</h1>
                <p>æä¾›é¦™æ¸¯å…­åˆå½©ä¸æ¾³é—¨å½©ç¥¨å¼€å¥–è®°å½•APIï¼Œæ”¯æŒTelegram Botç®¡ç†ã€‚</p>
                <h3>ä¸»è¦æ¥å£ï¼š</h3>
                <ul><li>é¦™æ¸¯: <code>${CONFIG.WORKER_DOMAIN}/xg/2025?all=true</code></li>
                <li>æ¾³é—¨: <code>${CONFIG.WORKER_DOMAIN}/om/2025?all=true</code></li></ul>
                <p><a href="/health">ç³»ç»ŸçŠ¶æ€</a></p></body></html>`;
                return new Response(html, { 
                    headers: { 'Content-Type': 'text/html; charset=utf-8' } 
                });
            }

            // 5. 404å“åº”
            return new Response(JSON.stringify({
                result: false,
                message: 'æ¥å£ä¸å­˜åœ¨ã€‚å¯ç”¨: /xg/2025, /om/2025, /health',
                code: 404,
                data: [],
                timestamp: Date.now()
            }), {
                status: 404,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*' 
                }
            });

        } catch (error) {
            console.error('Workeré”™è¯¯:', error);
            return new Response(JSON.stringify({
                result: false,
                message: `æœåŠ¡å™¨é”™è¯¯: ${error.message}`,
                code: 500,
                data: [],
                timestamp: Date.now()
            }), {
                status: 500,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*' 
                }
            });
        }
    }
};
