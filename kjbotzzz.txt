// index.js - å®Œå–„ç‰ˆå¼€å¥–è®°å½•Botï¼ŒåŒ…å«å¯†ç éªŒè¯å’Œé‡å¤è®°å½•å¤„ç†
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const pathname = url.pathname;
    const method = request.method;

    try {
      // ç¡®ä¿æ•°æ®åº“è¿æ¥æ­£å¸¸
      if (!env.DB) {
        return new Response(JSON.stringify({
          result: false,
          message: 'æ•°æ®åº“è¿æ¥æœªé…ç½®',
          code: 500,
          data: null,
          timestamp: Date.now()
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      // å¤„ç†APIæŸ¥è¯¢è¯·æ±‚
      if (method === 'GET') {
        // æ¾³é—¨å¼€å¥–è®°å½• /om/{year}
        if (pathname.match(/^\/om\/\d{4}$/)) {
          const year = pathname.split('/')[2];
          return await getLotteryRecords(env.DB, 'mo', parseInt(year));
        }
        
        // é¦™æ¸¯å¼€å¥–è®°å½• /xg/{year}
        if (pathname.match(/^\/xg\/\d{4}$/)) {
          const year = pathname.split('/')[2];
          return await getLotteryRecords(env.DB, 'hk', parseInt(year));
        }
        
        // è®¾ç½®Webhook
        if (pathname === '/set-webhook') {
          const token = url.searchParams.get('token') || env.TELEGRAM_BOT_TOKEN;
          const webhookUrl = `${url.origin}/webhook`;
          return await setWebhook(token, webhookUrl);
        }
        
        // åˆ é™¤Webhook
        if (pathname === '/delete-webhook') {
          const token = url.searchParams.get('token') || env.TELEGRAM_BOT_TOKEN;
          return await deleteWebhook(token);
        }
        
        // åˆå§‹åŒ–æ•°æ®åº“
        if (pathname === '/init-db') {
          return await initDatabase(env.DB);
        }
        
        // æŸ¥çœ‹æ‰€æœ‰è¡¨
        if (pathname === '/tables') {
          return await listTables(env.DB);
        }
        
        // ç»Ÿè®¡ä¿¡æ¯
        if (pathname === '/stats') {
          return await getStats(env.DB);
        }
        
        // ç®¡ç†ç•Œé¢ - éœ€è¦å¯†ç éªŒè¯
        if (pathname === '/manage') {
          const password = url.searchParams.get('password');
          const adminPassword = env.ADMIN_PASSWORD || 'admin123';
          
          if (password !== adminPassword) {
            return new Response(`
              <!DOCTYPE html>
              <html>
              <head>
                <title>è®¿é—®å—é™</title>
                <meta charset="utf-8">
                <style>
                  body { font-family: Arial, sans-serif; margin: 40px; text-align: center; }
                  .login-box { max-width: 400px; margin: 50px auto; padding: 30px; border: 1px solid #ddd; border-radius: 10px; }
                  input { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; }
                  button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
                </style>
              </head>
              <body>
                <h1>ğŸ”’ ç®¡ç†åå°ç™»å½•</h1>
                <div class="login-box">
                  <p>è¯·è¾“å…¥ç®¡ç†å¯†ç </p>
                  <form method="get">
                    <input type="password" name="password" placeholder="è¯·è¾“å…¥å¯†ç " required>
                    <input type="hidden" name="redirect" value="/manage">
                    <button type="submit">ç™»å½•</button>
                  </form>
                  ${password ? '<p style="color:red;">å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•</p>' : ''}
                </div>
              </body>
              </html>
            `, {
              headers: { 'Content-Type': 'text/html;charset=utf-8' }
            });
          }
          
          return getManagePage();
        }
        
        // æ¸…é™¤é‡å¤è®°å½•
        if (pathname === '/clean-duplicates') {
          const password = url.searchParams.get('password');
          const adminPassword = env.ADMIN_PASSWORD || 'admin123';
          
          if (password !== adminPassword) {
            return new Response('Unauthorized', { status: 401 });
          }
          
          return await cleanDuplicateRecords(env.DB);
        }
        
        // å¥åº·æ£€æŸ¥
        if (pathname === '/health') {
          return await healthCheck(env.DB);
        }
      }
      
      // å¤„ç†POSTè¯·æ±‚
      if (method === 'POST') {
        // Telegram Webhook
        if (pathname === '/webhook') {
          return await handleTelegramWebhook(request, env);
        }
        
        // æ‰‹åŠ¨æ·»åŠ è®°å½•
        if (pathname === '/add-record') {
          const data = await request.json();
          return await addRecordManual(env.DB, data);
        }
        
        // æ‰¹é‡æ·»åŠ è®°å½•
        if (pathname === '/batch-add') {
          const data = await request.json();
          return await batchAddRecords(env.DB, data);
        }
        
        // åˆ é™¤è®°å½•
        if (pathname === '/delete-record') {
          const data = await request.json();
          return await deleteRecordManual(env.DB, data);
        }
        
        // æœç´¢è®°å½•
        if (pathname === '/search') {
          const data = await request.json();
          return await searchRecords(env.DB, data);
        }
      }

      // é»˜è®¤è¿”å›æ¬¢è¿ä¿¡æ¯
      return new Response(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>å¼€å¥–è®°å½•APIæœåŠ¡</title>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font-family: Arial, sans-serif; margin: 40px; }
            .endpoint { background: #f5f5f5; padding: 10px; margin: 10px 0; border-left: 4px solid #007bff; }
            code { background: #f0f0f0; padding: 2px 4px; border-radius: 3px; }
            a { color: #007bff; text-decoration: none; }
            a:hover { text-decoration: underline; }
            .login-link { display: inline-block; margin: 20px 0; padding: 10px 20px; background: #28a745; color: white; border-radius: 5px; }
          </style>
        </head>
        <body>
          <h1>ğŸ° å¼€å¥–è®°å½•APIæœåŠ¡</h1>
          <p>è¿™æ˜¯ä¸€ä¸ªå¼€å¥–è®°å½•ç®¡ç†å’ŒæŸ¥è¯¢æœåŠ¡ï¼Œæ”¯æŒé¦™æ¸¯å…­åˆå½©å’Œè€æ¾³21.30</p>
          
          <h3>APIæ¥å£ï¼š</h3>
          <div class="endpoint">
            <strong>GET /xg/{year}</strong> - è·å–é¦™æ¸¯å¼€å¥–è®°å½•<br>
            ç¤ºä¾‹ï¼š<code>${url.origin}/xg/2025</code><br>
            è¿”å›JSONæ ¼å¼æ•°æ®ï¼ŒåŒ…å«æŒ‡å®šå¹´ä»½çš„æ‰€æœ‰é¦™æ¸¯å¼€å¥–è®°å½•
          </div>
          <div class="endpoint">
            <strong>GET /om/{year}</strong> - è·å–æ¾³é—¨å¼€å¥–è®°å½•<br>
            ç¤ºä¾‹ï¼š<code>${url.origin}/om/2025</code><br>
            è¿”å›JSONæ ¼å¼æ•°æ®ï¼ŒåŒ…å«æŒ‡å®šå¹´ä»½çš„æ‰€æœ‰æ¾³é—¨å¼€å¥–è®°å½•
          </div>
          
          <h3>ç®¡ç†åŠŸèƒ½ï¼š</h3>
          <a href="/manage?password=${env.ADMIN_PASSWORD || 'admin123'}" class="login-link">è¿›å…¥ç®¡ç†åå°</a>
          <p><small>å¯†ç : ${env.ADMIN_PASSWORD ? 'å·²è®¾ç½®' : 'ä½¿ç”¨é»˜è®¤å¯†ç  admin123'}</small></p>
          
          <h3>æ•°æ®åº“ç®¡ç†ï¼š</h3>
          <p><a href="/init-db">åˆå§‹åŒ–æ•°æ®åº“</a> - å¦‚æœè¡¨ä¸å­˜åœ¨åˆ™åˆ›å»º</p>
          <p><a href="/tables">æŸ¥çœ‹æ‰€æœ‰è¡¨</a> - æ˜¾ç¤ºæ•°æ®åº“ä¸­çš„è¡¨ç»“æ„</p>
          <p><a href="/clean-duplicates?password=${env.ADMIN_PASSWORD || 'admin123'}">æ¸…ç†é‡å¤è®°å½•</a> - è‡ªåŠ¨æ¸…ç†é‡å¤çš„å¼€å¥–è®°å½•</p>
          <p><a href="/health">å¥åº·æ£€æŸ¥</a> - æ£€æŸ¥æœåŠ¡çŠ¶æ€</p>
          
          <h3>Telegram Bot:</h3>
          <p>è®¾ç½®Webhook: <code>${url.origin}/set-webhook?token=YOUR_BOT_TOKEN</code></p>
          
          <hr>
          <p>Â© ${new Date().getFullYear()} å¼€å¥–è®°å½•æœåŠ¡ | æ”¯æŒé¦™æ¸¯å…­åˆå½©ã€è€æ¾³21.30</p>
        </body>
        </html>
      `, {
        headers: { 'Content-Type': 'text/html;charset=utf-8' }
      });

    } catch (error) {
      console.error('å¤„ç†è¯·æ±‚æ—¶å‡ºé”™:', error);
      return new Response(JSON.stringify({
        result: false,
        message: error.message,
        code: 500,
        data: null,
        timestamp: Date.now()
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
};

// ==================== æ•°æ®åº“ç›¸å…³å‡½æ•° ====================

async function initDatabase(db) {
  try {
    console.log('å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“...');
    
    // åˆ›å»ºä¸»è¡¨
    const createMainTable = `
      CREATE TABLE IF NOT EXISTS lottery_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        year INTEGER NOT NULL,
        expect TEXT NOT NULL,
        openTime TEXT NOT NULL,
        type TEXT NOT NULL,
        openCode TEXT NOT NULL,
        wave TEXT NOT NULL,
        zodiac TEXT NOT NULL,
        verify BOOLEAN DEFAULT true,
        source TEXT DEFAULT 'è‡ªåŠ¨æŠ“å–',
        channelMessageId TEXT,
        channelChatId TEXT,
        processed BOOLEAN DEFAULT true,
        info TEXT DEFAULT 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com',
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(type, expect)
      )
    `;
    
    await db.prepare(createMainTable).run();
    
    // åˆ›å»ºåˆ é™¤è®°å½•è¡¨
    const createDeletedTable = `
      CREATE TABLE IF NOT EXISTS deleted_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        recordId INTEGER,
        year INTEGER,
        expect TEXT,
        type TEXT,
        openCode TEXT,
        deletedBy TEXT,
        deletedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        reason TEXT
      )
    `;
    
    await db.prepare(createDeletedTable).run();
    
    // åˆ›å»ºæ¶ˆæ¯å»é‡è¡¨
    const createMessagesTable = `
      CREATE TABLE IF NOT EXISTS message_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        messageId INTEGER NOT NULL,
        chatId TEXT NOT NULL,
        expect TEXT NOT NULL,
        type TEXT NOT NULL,
        contentHash TEXT NOT NULL,
        processed BOOLEAN DEFAULT false,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(messageId, chatId)
      )
    `;
    
    await db.prepare(createMessagesTable).run();
    
    return new Response(JSON.stringify({
      result: true,
      message: 'æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ',
      code: 200,
      data: null,
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: `æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function listTables(db) {
  try {
    const result = await db.prepare(`
      SELECT name, sql 
      FROM sqlite_master 
      WHERE type='table' 
      ORDER BY name
    `).all();
    
    let html = '<!DOCTYPE html><html><head><title>æ•°æ®åº“è¡¨ç»“æ„</title><meta charset="utf-8"></head><body>';
    html += '<h1>æ•°æ®åº“è¡¨ç»“æ„</h1>';
    html += `<p>æ€»å…±: ${result.results ? result.results.length : 0} ä¸ªè¡¨</p>`;
    
    if (result.results && result.results.length > 0) {
      result.results.forEach(table => {
        html += `<h2>è¡¨: ${table.name}</h2>`;
        html += `<pre>${table.sql || 'æ²¡æœ‰SQLè¯­å¥'}</pre>`;
        html += '<hr>';
      });
    } else {
      html += '<p>æ²¡æœ‰æ‰¾åˆ°ä»»ä½•è¡¨</p>';
    }
    
    html += '<p><a href="/init-db">åˆå§‹åŒ–æ•°æ®åº“</a> | <a href="/health">å¥åº·æ£€æŸ¥</a> | <a href="/">è¿”å›é¦–é¡µ</a></p>';
    html += '</body></html>';
    
    return new Response(html, {
      headers: { 'Content-Type': 'text/html;charset=utf-8' }
    });
    
  } catch (error) {
    return new Response(JSON.stringify({
      result: false,
      message: `æŸ¥çœ‹è¡¨ç»“æ„å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function getStats(db) {
  try {
    // è·å–æ€»æ•°
    const totalResult = await db.prepare(`
      SELECT type, COUNT(*) as count FROM lottery_records GROUP BY type
    `).all();
    
    // è·å–é‡å¤è®°å½•
    const duplicateResult = await db.prepare(`
      SELECT type, expect, COUNT(*) as count 
      FROM lottery_records 
      GROUP BY type, expect 
      HAVING COUNT(*) > 1
    `).all();
    
    // è·å–æœ€æ–°è®°å½•
    const latestResult = await db.prepare(`
      SELECT * FROM lottery_records 
      ORDER BY openTime DESC 
      LIMIT 5
    `).all();
    
    return new Response(JSON.stringify({
      result: true,
      message: 'ç»Ÿè®¡ä¿¡æ¯',
      code: 200,
      data: {
        summary: totalResult.results || [],
        duplicates: duplicateResult.results || [],
        latest: latestResult.results || [],
        timestamp: new Date().toISOString()
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: `è·å–ç»Ÿè®¡å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function cleanDuplicateRecords(db) {
  try {
    // æŸ¥æ‰¾é‡å¤è®°å½•
    const duplicates = await db.prepare(`
      SELECT type, expect, COUNT(*) as count, GROUP_CONCAT(id) as ids
      FROM lottery_records 
      GROUP BY type, expect 
      HAVING COUNT(*) > 1
    `).all();
    
    let deletedCount = 0;
    let deletedRecords = [];
    
    for (const dup of duplicates.results) {
      const ids = dup.ids.split(',').map(id => parseInt(id));
      // ä¿ç•™ç¬¬ä¸€ä¸ªï¼Œåˆ é™¤å…¶ä»–
      const keepId = ids[0];
      const deleteIds = ids.slice(1);
      
      for (const deleteId of deleteIds) {
        // è·å–è®°å½•ä¿¡æ¯
        const record = await db.prepare(
          'SELECT * FROM lottery_records WHERE id = ?'
        ).bind(deleteId).first();
        
        if (record) {
          // å¤‡ä»½åˆ°åˆ é™¤è¡¨
          await db.prepare(`
            INSERT INTO deleted_records (recordId, year, expect, type, openCode, deletedBy, reason)
            VALUES (?, ?, ?, ?, ?, ?, ?)
          `).bind(
            record.id,
            record.year,
            record.expect,
            record.type,
            record.openCode,
            'system_cleanup',
            'è‡ªåŠ¨æ¸…ç†é‡å¤è®°å½•'
          ).run();
          
          // åˆ é™¤è®°å½•
          await db.prepare('DELETE FROM lottery_records WHERE id = ?').bind(deleteId).run();
          
          deletedCount++;
          deletedRecords.push({
            id: deleteId,
            expect: record.expect,
            type: record.type
          });
        }
      }
    }
    
    return new Response(JSON.stringify({
      result: true,
      message: `æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº† ${deletedCount} æ¡é‡å¤è®°å½•`,
      code: 200,
      data: {
        duplicatesFound: duplicates.results.length,
        deletedCount: deletedCount,
        deletedRecords: deletedRecords
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('æ¸…ç†é‡å¤è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: `æ¸…ç†é‡å¤è®°å½•å¤±è´¥: ${error.message}`,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function healthCheck(db) {
  try {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    const result = await db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
    
    // è·å–è®°å½•æ•°é‡
    const countResult = await db.prepare("SELECT COUNT(*) as total FROM lottery_records").first();
    
    // åˆ†ç±»è¡¨
    const systemTables = result.results.filter(t => t.name.startsWith('_cf_'));
    const userTables = result.results.filter(t => !t.name.startsWith('_cf_'));
    
    return new Response(JSON.stringify({
      status: 'ok',
      database: 'connected',
      total_tables: result.results ? result.results.length : 0,
      system_tables: systemTables.length,
      user_tables: userTables.length,
      user_table_names: userTables.map(t => t.name),
      total_records: countResult ? countResult.total : 0,
      timestamp: new Date().toISOString()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      status: 'error',
      database: 'disconnected',
      error: error.message,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// ==================== Telegram Botç›¸å…³å‡½æ•° ====================

async function setWebhook(botToken, webhookUrl) {
  try {
    if (!botToken) {
      return new Response(JSON.stringify({
        ok: false,
        description: 'Bot Tokenä¸èƒ½ä¸ºç©º'
      }), { status: 400 });
    }
    
    const response = await fetch(`https://api.telegram.org/bot${botToken}/setWebhook`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        url: webhookUrl,
        drop_pending_updates: true
      })
    });
    
    const result = await response.json();
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      ok: false,
      description: error.message
    }), { status: 500 });
  }
}

async function deleteWebhook(botToken) {
  try {
    if (!botToken) {
      return new Response(JSON.stringify({
        ok: false,
        description: 'Bot Tokenä¸èƒ½ä¸ºç©º'
      }), { status: 400 });
    }
    
    const response = await fetch(`https://api.telegram.org/bot${botToken}/deleteWebhook`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    
    const result = await response.json();
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      ok: false,
      description: error.message
    }), { status: 500 });
  }
}

async function handleTelegramWebhook(request, env) {
  try {
    const update = await request.json();
    
    // å¤„ç†é¢‘é“æ¶ˆæ¯
    if (update.channel_post) {
      const post = update.channel_post;
      const text = post.text || post.caption || '';
      const messageId = post.message_id;
      const chatId = post.chat.id;
      
      console.log(`æ”¶åˆ°é¢‘é“æ¶ˆæ¯ [${chatId}:${messageId}]:`, text.substring(0, 100));
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯å…è®¸çš„ç±»å‹
      if (text.includes('é¦™æ¸¯å…­åˆå½©') || text.includes('è€æ¾³21.30')) {
        // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†è¿‡æ­¤æ¶ˆæ¯
        const isProcessed = await checkMessageProcessed(env.DB, messageId, chatId);
        if (!isProcessed) {
          // æ£€æŸ¥æ˜¯å¦é‡å¤è®°å½•
          const isDuplicate = await checkDuplicateInChannel(env.DB, text, env);
          if (isDuplicate) {
            // åˆ é™¤é‡å¤çš„é¢‘é“æ¶ˆæ¯
            await deleteTelegramMessage(env.TELEGRAM_BOT_TOKEN, chatId, messageId);
            console.log(`å·²åˆ é™¤é‡å¤æ¶ˆæ¯ [${chatId}:${messageId}]`);
          } else {
            // å¤„ç†å¼€å¥–æ¶ˆæ¯
            await processLotteryMessage(text, env.DB, env, messageId, chatId);
            // æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
            await markMessageProcessed(env.DB, messageId, chatId, text);
          }
        }
      }
      return new Response('OK');
    }
    
    // å¤„ç†ç§èŠæ¶ˆæ¯
    if (update.message) {
      const message = update.message;
      const chatId = message.chat.id;
      const text = message.text || '';
      
      if (message.chat.type === 'private') {
        await handlePrivateMessage(chatId, text, env);
      }
      return new Response('OK');
    }
    
    return new Response('OK');
  } catch (error) {
    console.error('Webhook error:', error);
    return new Response('ERROR', { status: 500 });
  }
}

// æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²å¤„ç†
async function checkMessageProcessed(db, messageId, chatId) {
  try {
    const result = await db.prepare(
      'SELECT id FROM message_history WHERE messageId = ? AND chatId = ?'
    ).bind(messageId, chatId.toString()).first();
    
    return !!result;
  } catch (error) {
    console.error('æ£€æŸ¥æ¶ˆæ¯å¤„ç†çŠ¶æ€å¤±è´¥:', error);
    return false;
  }
}

// æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
async function markMessageProcessed(db, messageId, chatId, content) {
  try {
    const parsed = parseLotteryMessage(content);
    const contentHash = await createContentHash(content);
    
    await db.prepare(`
      INSERT INTO message_history (messageId, chatId, expect, type, contentHash, processed)
      VALUES (?, ?, ?, ?, ?, true)
    `).bind(
      messageId,
      chatId.toString(),
      parsed?.expect || '',
      parsed?.type || '',
      contentHash
    ).run();
  } catch (error) {
    console.error('æ ‡è®°æ¶ˆæ¯å·²å¤„ç†å¤±è´¥:', error);
  }
}

// åˆ›å»ºå†…å®¹å“ˆå¸Œ
async function createContentHash(content) {
  // ç®€å•çš„å“ˆå¸Œå‡½æ•°
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString(36);
}

// æ£€æŸ¥é¢‘é“ä¸­æ˜¯å¦æœ‰é‡å¤è®°å½•
async function checkDuplicateInChannel(db, text, env) {
  try {
    const parsed = parseLotteryMessage(text);
    if (!parsed) return false;
    
    // æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å·²æœ‰ç›¸åŒè®°å½•
    const existing = await db.prepare(
      'SELECT id FROM lottery_records WHERE type = ? AND expect = ?'
    ).bind(parsed.type, parsed.expect).first();
    
    return !!existing;
  } catch (error) {
    console.error('æ£€æŸ¥é‡å¤è®°å½•å¤±è´¥:', error);
    return false;
  }
}

// åˆ é™¤Telegramæ¶ˆæ¯
async function deleteTelegramMessage(botToken, chatId, messageId) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${botToken}/deleteMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        message_id: messageId
      })
    });
    
    const result = await response.json();
    if (!result.ok) {
      console.error('åˆ é™¤æ¶ˆæ¯å¤±è´¥:', result);
      return false;
    }
    return true;
  } catch (error) {
    console.error('åˆ é™¤æ¶ˆæ¯å¤±è´¥:', error);
    return false;
  }
}

// å¤„ç†ç§èŠæ¶ˆæ¯
async function handlePrivateMessage(chatId, text, env) {
  const botToken = env.TELEGRAM_BOT_TOKEN;
  
  try {
    // å¸®åŠ©å‘½ä»¤
    if (text.startsWith('/start') || text.startsWith('/help')) {
      await sendTelegramMessage(botToken, chatId,
        `ğŸ° *å¼€å¥–è®°å½•ç®¡ç† Bot*\n\n` +
        `*å‘½ä»¤åˆ—è¡¨ï¼š*\n` +
        `ğŸ“ /add - æ‰‹åŠ¨æ·»åŠ å¼€å¥–è®°å½•\n` +
        `ğŸ“‹ /list [ç±»å‹] [å¹´ä»½] - æŸ¥çœ‹å¼€å¥–è®°å½•\n` +
        `ğŸ” /search [å…³é”®è¯] - æœç´¢å¼€å¥–è®°å½•\n` +
        `ğŸ—‘ï¸ /delete [æœŸå·] [ç±»å‹] - åˆ é™¤è®°å½•ï¼ˆç®¡ç†å‘˜ï¼‰\n` +
        `ğŸ§¹ /clean - æ¸…ç†é‡å¤è®°å½•ï¼ˆç®¡ç†å‘˜ï¼‰\n` +
        `â“ /help - æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯\n\n` +
        `*ç±»å‹è¯´æ˜ï¼š*\n` +
        `â€¢ hk - é¦™æ¸¯å…­åˆå½©\n` +
        `â€¢ mo - è€æ¾³21.30\n\n` +
        `*ç¤ºä¾‹ï¼š*\n` +
        `/add 2025128 hk 1,30,25,42,6,5,43 è›‡,é¼ ,è›‡,é¼ ,é¼ ,ç‰›,çŒª red,red,blue,blue,green,green,green\n` +
        `/list hk 2025\n` +
        `/search 202512\n` +
        `/delete 2025128 hk\n\n` +
        `*è‡ªåŠ¨åŠŸèƒ½ï¼š*\n` +
        `â€¢ è‡ªåŠ¨ç›‘æ§é¢‘é“å¼€å¥–ä¿¡æ¯\n` +
        `â€¢ æ™ºèƒ½å»é‡ï¼Œåˆ é™¤é‡å¤æ¶ˆæ¯\n` +
        `â€¢ æ•°æ®è‡ªåŠ¨å»é‡å’Œå­˜å‚¨`,
        { parse_mode: 'Markdown' }
      );
      return;
    }
    
    // æ·»åŠ è®°å½•å‘½ä»¤
    if (text.startsWith('/add')) {
      const args = parseAddCommand(text);
      if (args) {
        const record = {
          expect: args.expect,
          type: args.type,
          numbers: args.numbers.join(','),
          zodiacs: args.zodiacs.join(','),
          colors: args.colors.join(','),
          source: `telegramç§èŠç”¨æˆ·`
        };
        
        // æ£€æŸ¥æ˜¯å¦é‡å¤
        const existing = await env.DB.prepare(
          'SELECT id FROM lottery_records WHERE type = ? AND expect = ?'
        ).bind(record.type, record.expect).first();
        
        if (existing) {
          await sendTelegramMessage(botToken, chatId, `âŒ è®°å½•å·²å­˜åœ¨ï¼æœŸå·: ${record.expect}, ç±»å‹: ${record.type}`);
        } else {
          await addRecordManual(env.DB, record, 'telegram_bot');
          await sendTelegramMessage(botToken, chatId, 'âœ… å¼€å¥–è®°å½•æ·»åŠ æˆåŠŸï¼');
        }
      } else {
        await sendTelegramMessage(botToken, chatId,
          `âŒ æ ¼å¼é”™è¯¯ï¼è¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n\n` +
          `/add [æœŸå·] [ç±»å‹] [å·ç ] [ç”Ÿè‚–] [é¢œè‰²]\n\n` +
          `*ç¤ºä¾‹ï¼š*\n` +
          `/add 2025128 hk 1,30,25,42,6,5,43 è›‡,é¼ ,è›‡,é¼ ,é¼ ,ç‰›,çŒª red,red,blue,blue,green,green,green\n\n` +
          `å·ç ã€ç”Ÿè‚–ã€é¢œè‰²éƒ½éœ€è¦7ä¸ªå€¼ï¼Œç”¨é€—å·åˆ†éš”`,
          { parse_mode: 'Markdown' }
        );
      }
      return;
    }
    
    // æœç´¢å‘½ä»¤
    if (text.startsWith('/search')) {
      const keyword = text.substring(7).trim();
      if (!keyword) {
        await sendTelegramMessage(botToken, chatId, 'âŒ è¯·æä¾›æœç´¢å…³é”®è¯ï¼Œä¾‹å¦‚ï¼š/search 202512');
        return;
      }
      
      const results = await searchRecordsForChat(env.DB, keyword);
      if (results.length === 0) {
        await sendTelegramMessage(botToken, chatId, `æ²¡æœ‰æ‰¾åˆ°åŒ…å« "${keyword}" çš„å¼€å¥–è®°å½•`);
      } else {
        let message = `ğŸ” æœç´¢åˆ° ${results.length} æ¡è®°å½•ï¼š\n\n`;
        results.slice(0, 10).forEach(record => {
          message += `*${record.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}* ${record.expect}\n`;
          message += `å·ç : ${record.openCode}\n`;
          message += `æ—¶é—´: ${record.openTime}\n\n`;
        });
        
        if (results.length > 10) {
          message += `... è¿˜æœ‰ ${results.length - 10} æ¡è®°å½•æœªæ˜¾ç¤º`;
        }
        
        await sendTelegramMessage(botToken, chatId, message, { parse_mode: 'Markdown' });
      }
      return;
    }
    
    // åˆ—è¡¨å‘½ä»¤
    if (text.startsWith('/list')) {
      const args = text.substring(5).trim().split(/\s+/);
      const type = (args[0] || 'hk').toLowerCase();
      const year = args[1] || new Date().getFullYear();
      
      if (type !== 'hk' && type !== 'mo') {
        await sendTelegramMessage(botToken, chatId, 'âŒ ç±»å‹é”™è¯¯ï¼è¯·ä½¿ç”¨ hk æˆ– mo');
        return;
      }
      
      const records = await getRecordsForChat(env.DB, type, parseInt(year));
      if (records.length === 0) {
        await sendTelegramMessage(botToken, chatId, `æ²¡æœ‰æ‰¾åˆ°${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${year}å¹´çš„å¼€å¥–è®°å½•`);
      } else {
        let message = `ğŸ“‹ ${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${year}å¹´å¼€å¥–è®°å½•ï¼ˆæœ€è¿‘${Math.min(records.length, 10)}æ¡ï¼‰ï¼š\n\n`;
        records.slice(0, 10).forEach((record, index) => {
          message += `${index + 1}. *${record.expect}*\n`;
          message += `   å·ç : ${record.openCode}\n`;
          message += `   æ—¶é—´: ${record.openTime}\n`;
          message += '\n';
        });
        
        await sendTelegramMessage(botToken, chatId, message, { 
          parse_mode: 'Markdown',
          disable_web_page_preview: true
        });
      }
      return;
    }
    
    // åˆ é™¤å‘½ä»¤
    if (text.startsWith('/delete')) {
      const adminIds = (env.ADMIN_USER_IDS || '').split(',').map(id => parseInt(id.trim()));
      if (!adminIds.includes(chatId)) {
        await sendTelegramMessage(botToken, chatId, 'âŒ æ‚¨æ²¡æœ‰æƒé™åˆ é™¤è®°å½•');
        return;
      }
      
      const args = text.substring(7).trim().split(/\s+/);
      if (args.length < 2) {
        await sendTelegramMessage(botToken, chatId, 'âŒ å‚æ•°é”™è¯¯ï¼è¯·ä½¿ç”¨ï¼š/delete [æœŸå·] [ç±»å‹]');
        return;
      }
      
      const data = {
        expect: args[0],
        type: args[1]
      };
      
      await deleteRecordManual(env.DB, data, `telegram_${chatId}`);
      await sendTelegramMessage(botToken, chatId, 'âœ… è®°å½•åˆ é™¤æˆåŠŸï¼');
      return;
    }
    
    // æ¸…ç†å‘½ä»¤
    if (text.startsWith('/clean')) {
      const adminIds = (env.ADMIN_USER_IDS || '').split(',').map(id => parseInt(id.trim()));
      if (!adminIds.includes(chatId)) {
        await sendTelegramMessage(botToken, chatId, 'âŒ æ‚¨æ²¡æœ‰æƒé™æ¸…ç†è®°å½•');
        return;
      }
      
      const result = await cleanDuplicateRecords(env.DB);
      const resultData = await result.json();
      await sendTelegramMessage(botToken, chatId, `ğŸ§¹ æ¸…ç†å®Œæˆï¼š${resultData.message}`);
      return;
    }
    
    // å¤„ç†ç›´æ¥å‘é€çš„å¼€å¥–æ¶ˆæ¯æ ¼å¼
    if (text.includes('ç¬¬:') && (text.includes('å¼€å¥–ç»“æœ:') || text.includes('å¼€å¥–ç»“æœï¼š'))) {
      await processLotteryMessage(text, env.DB, env, null, null, true);
      await sendTelegramMessage(botToken, chatId, 'âœ… å·²å¤„ç†å¼€å¥–æ¶ˆæ¯ï¼Œæ­£åœ¨è§£æå¹¶å­˜å‚¨...');
      return;
    }
    
    // å¤„ç†å…¶ä»–æ¶ˆæ¯
    if (text) {
      await sendTelegramMessage(botToken, chatId,
        `ğŸ¤– æ¬¢è¿ä½¿ç”¨å¼€å¥–è®°å½•ç®¡ç† Botï¼\n\n` +
        `æˆ‘å¯ä»¥å¸®æ‚¨ï¼š\n` +
        `â€¢ è‡ªåŠ¨è®°å½•å¼€å¥–ä¿¡æ¯\n` +
        `â€¢ æ‰‹åŠ¨æ·»åŠ å¼€å¥–è®°å½•\n` +
        `â€¢ æŸ¥è¯¢å†å²å¼€å¥–æ•°æ®\n` +
        `â€¢ ç®¡ç†å¼€å¥–è®°å½•\n` +
        `â€¢ è‡ªåŠ¨åˆ é™¤é‡å¤æ¶ˆæ¯\n\n` +
        `å‘é€ /help æŸ¥çœ‹è¯¦ç»†å‘½ä»¤è¯´æ˜\n\n` +
        `æ‚¨ä¹Ÿå¯ä»¥ç›´æ¥å‘é€å¼€å¥–æ¶ˆæ¯æ ¼å¼çš„æ–‡æœ¬ï¼Œæˆ‘ä¼šè‡ªåŠ¨è§£æå¹¶å­˜å‚¨ã€‚`
      );
    }
    
  } catch (error) {
    console.error('å¤„ç†ç§èŠæ¶ˆæ¯å¤±è´¥:', error);
    await sendTelegramMessage(botToken, chatId, `âŒ æ“ä½œå¤±è´¥ï¼š${error.message}`);
  }
}

// è§£ææ·»åŠ å‘½ä»¤
function parseAddCommand(text) {
  try {
    // ç§»é™¤ /add å‘½ä»¤éƒ¨åˆ†
    const content = text.substring(5).trim();
    
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
    const match = content.match(/^(\d+)\s+(hk|mo)\s+([\d,]+)\s+([\u4e00-\u9fa5,]+)\s+([\w,]+)$/);
    if (!match) return null;
    
    const [, expect, type, numbersStr, zodiacsStr, colorsStr] = match;
    
    // éªŒè¯æ•°æ®
    const numbers = numbersStr.split(',').map(n => parseInt(n.trim()));
    const zodiacs = zodiacsStr.split(',').map(z => z.trim());
    const colors = colorsStr.split(',').map(c => c.trim());
    
    if (numbers.length !== 7 || zodiacs.length !== 7 || colors.length !== 7) {
      return null;
    }
    
    return {
      expect,
      type,
      numbers,
      zodiacs,
      colors
    };
  } catch (error) {
    console.error('è§£ææ·»åŠ å‘½ä»¤å¤±è´¥:', error);
    return null;
  }
}

// ==================== å¼€å¥–æ¶ˆæ¯å¤„ç† ====================

async function processLotteryMessage(text, db, env, messageId = null, chatId = null, fromPrivate = false) {
  const parsed = parseLotteryMessage(text);
  if (!parsed) {
    console.log('æ— æ³•è§£ææ¶ˆæ¯:', text.substring(0, 100));
    return false;
  }
  
  try {
    // æå–å¹´ä»½
    let year;
    if (parsed.expect.length >= 4) {
      year = parseInt(parsed.expect.substring(0, 4));
    } else {
      year = new Date().getFullYear();
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await db.prepare(
      'SELECT id FROM lottery_records WHERE type = ? AND expect = ?'
    ).bind(parsed.type, parsed.expect).first();
    
    if (existing) {
      console.log(`è®°å½•å·²å­˜åœ¨: ${parsed.type} ${parsed.expect}`);
      return false;
    }
    
    const record = {
      year: year,
      expect: parsed.expect,
      openTime: parsed.openTime,
      type: parsed.type,
      openCode: parsed.numbers.join(','),
      wave: parsed.colors.join(','),
      zodiac: parsed.zodiacs.join(','),
      source: fromPrivate ? 'telegramç§èŠ' : 'telegramé¢‘é“',
      channelMessageId: messageId,
      channelChatId: chatId
    };
    
    await insertRecord(db, record);
    console.log(`âœ… å­˜å‚¨æˆåŠŸï¼š${parsed.type} ${parsed.expect} (${year}å¹´)`);
    
    // å‘é€é€šçŸ¥ç»™ç®¡ç†å‘˜
    if (env.ADMIN_USER_IDS) {
      const adminIds = env.ADMIN_USER_IDS.split(',').map(id => parseInt(id.trim()));
      const message = `âœ… *${fromPrivate ? 'ç§èŠ' : 'é¢‘é“'}å¼€å¥–è®°å½•å­˜å‚¨æˆåŠŸ*\n\n` +
        `*ç±»å‹:* ${parsed.type === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30'}\n` +
        `*æœŸå·:* ${parsed.expect}\n` +
        `*å·ç :* ${parsed.numbers.join(' ')}\n` +
        `*æ—¶é—´:* ${parsed.openTime}`;
      
      for (const adminId of adminIds) {
        try {
          await sendTelegramMessage(env.TELEGRAM_BOT_TOKEN, adminId, message, { parse_mode: 'Markdown' });
        } catch (error) {
          console.error('å‘é€é€šçŸ¥å¤±è´¥:', error);
        }
      }
    }
    
    return true;
  } catch (error) {
    console.error('å­˜å‚¨å¼€å¥–æ¶ˆæ¯å¤±è´¥:', error);
    return false;
  }
}

// è§£æå¼€å¥–æ¶ˆæ¯
function parseLotteryMessage(text) {
  try {
    // æ£€æŸ¥æ¶ˆæ¯ç±»å‹
    let type = null;
    if (text.includes('é¦™æ¸¯å…­åˆå½©')) {
      type = 'hk';
    } else if (text.includes('è€æ¾³21.30')) {
      type = 'mo';
    } else {
      // å¦‚æœæ²¡æœ‰æ˜ç¡®ç±»å‹ï¼Œå°è¯•æ ¹æ®å†…å®¹åˆ¤æ–­
      if (text.includes('ç¬¬:') && text.includes('å¼€å¥–ç»“æœ')) {
        // é»˜è®¤ä¸ºé¦™æ¸¯å…­åˆå½©ï¼Œæˆ–è€…æ ¹æ®å…¶ä»–ç‰¹å¾åˆ¤æ–­
        type = 'hk';
      } else {
        return null;
      }
    }
    
    // æå–æœŸå·
    const expectMatch = text.match(/ç¬¬[:ï¼š]\s*(\d+)/);
    if (!expectMatch) return null;
    
    const expect = expectMatch[1];
    
    // æå–å·ç ï¼ˆæ‰¾7ä¸ªæ•°å­—ï¼‰
    const numbers = [];
    const lines = text.split('\n');
    
    // æ–¹æ³•1ï¼šæŸ¥æ‰¾åŒ…å«7ä¸ªæ•°å­—çš„è¡Œ
    for (const line of lines) {
      const numMatches = line.match(/\b\d{1,2}\b/g);
      if (numMatches && numMatches.length >= 7) {
        for (let i = 0; i < 7; i++) {
          numbers.push(parseInt(numMatches[i]));
        }
        break;
      }
    }
    
    // æ–¹æ³•2ï¼šå¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•æŸ¥æ‰¾æ‰€æœ‰æ•°å­—
    if (numbers.length !== 7) {
      const allNumbers = text.match(/\b\d{1,2}\b/g);
      if (allNumbers && allNumbers.length >= 7) {
        for (let i = 0; i < 7; i++) {
          numbers.push(parseInt(allNumbers[i]));
        }
      }
    }
    
    if (numbers.length !== 7) return null;
    
    // æå–ç”Ÿè‚–ï¼ˆæ‰¾7ä¸ªä¸­æ–‡å­—ç¬¦ï¼‰
    const zodiacs = [];
    const allZodiacs = text.match(/[\u4e00-\u9fa5]/g);
    if (allZodiacs && allZodiacs.length >= 7) {
      for (let i = 0; i < 7; i++) {
        zodiacs.push(allZodiacs[i]);
      }
    }
    
    if (zodiacs.length !== 7) {
      // å°è¯•å…¶ä»–æ ¼å¼
      for (const line of lines) {
        const chineseChars = line.match(/[\u4e00-\u9fa5]/g);
        if (chineseChars && chineseChars.length >= 7) {
          zodiacs.length = 0;
          for (let i = 0; i < 7; i++) {
            zodiacs.push(chineseChars[i]);
          }
          break;
        }
      }
    }
    
    if (zodiacs.length !== 7) return null;
    
    // æå–é¢œè‰²ï¼ˆemojiæˆ–æ–‡å­—ï¼‰
    const colors = [];
    const colorMap = {
      'ğŸ”µ': 'blue', 'ğŸ”´': 'red', 'ğŸŸ¢': 'green', 'ğŸ”¶': 'orange', 'ğŸŸ¡': 'yellow',
      'è“': 'blue', 'çº¢': 'red', 'ç»¿': 'green', 'æ©™': 'orange', 'é»„': 'yellow',
      'blue': 'blue', 'red': 'red', 'green': 'green'
    };
    
    // å…ˆæ‰¾emoji
    const emojis = text.match(/[ğŸ”µğŸ”´ğŸŸ¢ğŸ”¶ğŸŸ¡]/g) || [];
    if (emojis.length >= 7) {
      for (let i = 0; i < 7; i++) {
        colors.push(colorMap[emojis[i]] || 'unknown');
      }
    } else {
      // æ‰¾æ–‡å­—é¢œè‰²
      const colorTexts = text.match(/è“|çº¢|ç»¿|æ©™|é»„|blue|red|green/g) || [];
      if (colorTexts.length >= 7) {
        for (let i = 0; i < 7; i++) {
          colors.push(colorMap[colorTexts[i]] || 'unknown');
        }
      } else {
        // é»˜è®¤é¢œè‰²
        for (let i = 0; i < 7; i++) {
          colors.push('unknown');
        }
      }
    }
    
    // ç”Ÿæˆå¼€å¥–æ—¶é—´ï¼ˆä»æ¶ˆæ¯ä¸­æå–æˆ–ä½¿ç”¨å½“å‰æ—¶é—´ï¼‰
    let openTime;
    const timeMatch = text.match(/(\d{4}\/\d{1,2}\/\d{1,2}[\s\d:]+)/);
    if (timeMatch) {
      openTime = timeMatch[1].replace(/\//g, '-');
    } else {
      const now = new Date();
      openTime = now.toISOString().replace('T', ' ').substring(0, 19);
    }
    
    return {
      type,
      expect,
      openTime,
      numbers,
      zodiacs,
      colors
    };
  } catch (error) {
    console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
    return null;
  }
}

// ==================== æ•°æ®æ“ä½œå‡½æ•° ====================

async function insertRecord(db, record) {
  try {
    await db.prepare(`
      INSERT INTO lottery_records (year, expect, openTime, type, openCode, wave, zodiac, source, channelMessageId, channelChatId)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      record.year,
      record.expect,
      record.openTime,
      record.type,
      record.openCode,
      record.wave,
      record.zodiac,
      record.source || 'è‡ªåŠ¨æŠ“å–',
      record.channelMessageId || null,
      record.channelChatId || null
    ).run();
  } catch (error) {
    console.error('æ’å…¥è®°å½•å¤±è´¥:', error);
    throw error;
  }
}

async function addRecordManual(db, data, source = 'web') {
  try {
    if (!data.expect || !data.numbers || !data.zodiacs || !data.colors) {
      throw new Error('ç¼ºå°‘å¿…è¦å‚æ•°');
    }
    
    // æå–å¹´ä»½
    let year;
    if (data.expect && data.expect.length >= 4) {
      year = parseInt(data.expect.substring(0, 4));
    } else {
      year = new Date().getFullYear();
    }
    
    // éªŒè¯ç±»å‹
    if (data.type !== 'hk' && data.type !== 'mo') {
      throw new Error('ç±»å‹å¿…é¡»æ˜¯ hk æˆ– mo');
    }
    
    // éªŒè¯æ•°æ®æ ¼å¼
    const numbers = data.numbers.split(',').map(n => parseInt(n.trim()));
    const zodiacs = data.zodiacs.split(',').map(z => z.trim());
    const colors = data.colors.split(',').map(c => c.trim());
    
    if (numbers.length !== 7 || zodiacs.length !== 7 || colors.length !== 7) {
      throw new Error('å·ç ã€ç”Ÿè‚–ã€é¢œè‰²éƒ½å¿…é¡»æœ‰7ä¸ªå€¼');
    }
    
    const record = {
      year: year,
      expect: data.expect.trim(),
      openTime: data.openTime || new Date().toISOString().replace('T', ' ').substring(0, 19),
      type: data.type,
      openCode: data.numbers,
      wave: data.colors,
      zodiac: data.zodiacs,
      verify: data.verify !== false,
      source: data.source || source,
      info: data.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    };
    
    await insertRecord(db, record);
    
    return new Response(JSON.stringify({
      result: true,
      message: 'è®°å½•æ·»åŠ æˆåŠŸ',
      code: 200,
      data: { 
        id: record.expect, 
        type: record.type,
        year: record.year
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('æ·»åŠ è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function batchAddRecords(db, data) {
  try {
    const records = data.records || [];
    const results = [];
    
    for (const recordData of records) {
      try {
        const result = await addRecordManual(db, recordData, 'batch');
        results.push({
          expect: recordData.expect,
          type: recordData.type,
          success: true
        });
      } catch (error) {
        results.push({
          expect: recordData.expect,
          type: recordData.type,
          success: false,
          error: error.message
        });
      }
    }
    
    return new Response(JSON.stringify({
      result: true,
      message: `æ‰¹é‡æ·»åŠ å®Œæˆï¼ŒæˆåŠŸ ${results.filter(r => r.success).length}/${records.length}`,
      code: 200,
      data: results,
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('æ‰¹é‡æ·»åŠ å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function deleteRecordManual(db, data, deletedBy = 'web_admin') {
  try {
    if (!data.expect || !data.type) {
      throw new Error('ç¼ºå°‘æœŸå·æˆ–ç±»å‹');
    }
    
    // éªŒè¯ç±»å‹
    if (data.type !== 'hk' && data.type !== 'mo') {
      throw new Error('ç±»å‹å¿…é¡»æ˜¯ hk æˆ– mo');
    }
    
    // å…ˆå¤‡ä»½
    const record = await db.prepare(
      'SELECT * FROM lottery_records WHERE expect = ? AND type = ?'
    ).bind(data.expect, data.type).first();
    
    if (!record) {
      throw new Error('è®°å½•ä¸å­˜åœ¨');
    }
    
    await db.prepare(`
      INSERT INTO deleted_records (recordId, year, expect, type, openCode, deletedBy, reason)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      record.id,
      record.year,
      record.expect,
      record.type,
      record.openCode,
      deletedBy,
      data.reason || 'æ‰‹åŠ¨åˆ é™¤'
    ).run();
    
    // åˆ é™¤è®°å½•
    await db.prepare(
      'DELETE FROM lottery_records WHERE expect = ? AND type = ?'
    ).bind(data.expect, data.type).run();
    
    return new Response(JSON.stringify({
      result: true,
      message: 'è®°å½•åˆ é™¤æˆåŠŸ',
      code: 200,
      data: { 
        deleted: true,
        expect: data.expect,
        type: data.type
      },
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('åˆ é™¤è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function searchRecords(db, data) {
  try {
    const keyword = data.keyword || '';
    const type = data.type || '';
    const year = data.year || '';
    
    let query = 'SELECT * FROM lottery_records WHERE 1=1';
    const params = [];
    
    if (keyword) {
      query += ' AND (expect LIKE ? OR openCode LIKE ? OR zodiac LIKE ?)';
      params.push(`%${keyword}%`, `%${keyword}%`, `%${keyword}%`);
    }
    
    if (type) {
      query += ' AND type = ?';
      params.push(type);
    }
    
    if (year) {
      query += ' AND year = ?';
      params.push(year);
    }
    
    query += ' ORDER BY openTime DESC LIMIT 100';
    
    const { results } = await db.prepare(query).bind(...params).all();
    
    const responseData = results.map(record => ({
      expect: record.expect,
      openTime: record.openTime,
      type: record.type === 'hk' ? '8' : '7',
      openCode: record.openCode,
      wave: record.wave,
      zodiac: record.zodiac,
      oddEven: null,
      allOddEven: null,
      bigSmall: null,
      allBigSmall: null,
      firstsecend: 0,
      left3: null,
      mid3: null,
      right3: null,
      pet: null,
      pk: null,
      vs: null,
      verify: record.verify === 1,
      info: record.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    }));
    
    return new Response(JSON.stringify({
      result: true,
      message: 'æœç´¢æˆåŠŸ',
      code: 200,
      data: responseData,
      timestamp: Date.now()
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('æœç´¢è®°å½•å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

async function getLotteryRecords(db, type, year) {
  try {
    // å…ˆæ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    const tableExists = await db.prepare(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='lottery_records'"
    ).first();
    
    if (!tableExists) {
      return new Response(JSON.stringify({
        result: false,
        message: 'lottery_recordsè¡¨ä¸å­˜åœ¨ï¼Œè¯·å…ˆè®¿é—® /init-db åˆå§‹åŒ–æ•°æ®åº“',
        code: 404,
        data: [],
        timestamp: Date.now()
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    const { results } = await db.prepare(`
      SELECT * FROM lottery_records 
      WHERE type = ? AND year = ?
      ORDER BY openTime DESC
    `).bind(type, year).all();
    
    const data = (results || []).map(record => ({
      expect: record.expect || '',
      openTime: record.openTime || '',
      type: type === 'hk' ? '8' : '7',
      openCode: record.openCode || '',
      wave: record.wave || '',
      zodiac: record.zodiac || '',
      oddEven: null,
      allOddEven: null,
      bigSmall: null,
      allBigSmall: null,
      firstsecend: 0,
      left3: null,
      mid3: null,
      right3: null,
      pet: null,
      pk: null,
      vs: null,
      verify: record.verify === 1,
      info: record.info || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    }));
    
    return new Response(JSON.stringify({
      result: true,
      message: 'æ“ä½œæˆåŠŸï¼',
      code: 200,
      data: data,
      timestamp: Date.now()
    }), {
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Cache-Control': 'public, max-age=60',
        'X-Total-Count': results ? results.length : 0
      }
    });
  } catch (error) {
    console.error('æŸ¥è¯¢å¤±è´¥:', error);
    return new Response(JSON.stringify({
      result: false,
      message: 'æŸ¥è¯¢å¤±è´¥: ' + error.message,
      code: 500,
      data: null,
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// ==================== è¾…åŠ©å‡½æ•° ====================

function getManagePage() {
  return new Response(`
  <!DOCTYPE html>
  <html>
  <head>
    <title>å¼€å¥–è®°å½•ç®¡ç†</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font-family: Arial, sans-serif; margin: 40px; }
      .tabs { display: flex; background: #f5f5f5; border-radius: 10px; overflow: hidden; margin-bottom: 20px; }
      .tab { flex: 1; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s; }
      .tab:hover { background: #e5e5e5; }
      .tab.active { background: #007bff; color: white; }
      .tab-content { display: none; background: white; border: 1px solid #ddd; border-radius: 10px; padding: 30px; }
      .tab-content.active { display: block; }
      .form-group { margin-bottom: 20px; }
      .form-group label { display: block; margin-bottom: 8px; font-weight: 600; }
      .form-group input, .form-group select, .form-group textarea { 
        width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }
      .btn { display: inline-block; padding: 10px 20px; background: #007bff; color: white; 
             text-decoration: none; border: none; border-radius: 5px; cursor: pointer; }
      .btn:hover { background: #0056b3; }
      .btn-danger { background: #dc3545; }
      .btn-danger:hover { background: #c82333; }
      .result { margin-top: 20px; padding: 15px; border-radius: 5px; }
      .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
      .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
      .records-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
      .records-table th, .records-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
      .records-table th { background: #f5f5f5; }
      .records-table tr:hover { background: #f8f9fa; }
    </style>
  </head>
  <body>
    <h1>å¼€å¥–è®°å½•ç®¡ç†åå°</h1>
    
    <div class="tabs">
      <div class="tab active" data-tab="add">æ·»åŠ è®°å½•</div>
      <div class="tab" data-tab="query">æŸ¥è¯¢è®°å½•</div>
      <div class="tab" data-tab="delete">åˆ é™¤è®°å½•</div>
      <div class="tab" data-tab="stats">ç»Ÿè®¡ä¿¡æ¯</div>
    </div>
    
    <div id="add-tab" class="tab-content active">
      <h2>æ·»åŠ å¼€å¥–è®°å½•</h2>
      <form id="add-form">
        <div class="form-group">
          <label>æœŸå· (å¦‚: 2025128)</label>
          <input type="text" id="expect" required placeholder="2025128">
        </div>
        
        <div class="form-group">
          <label>ç±»å‹</label>
          <select id="type" required>
            <option value="hk">é¦™æ¸¯å…­åˆå½©</option>
            <option value="mo">è€æ¾³21.30</option>
          </select>
        </div>
        
        <div class="form-group">
          <label>å¼€å¥–å·ç  (7ä¸ªæ•°å­—ï¼Œé€—å·åˆ†éš”)</label>
          <input type="text" id="numbers" required placeholder="1,30,25,42,6,5,43">
        </div>
        
        <div class="form-group">
          <label>ç”Ÿè‚– (7ä¸ªç”Ÿè‚–ï¼Œé€—å·åˆ†éš”)</label>
          <input type="text" id="zodiacs" required placeholder="è›‡,é¼ ,è›‡,é¼ ,é¼ ,ç‰›,çŒª">
        </div>
        
        <div class="form-group">
          <label>é¢œè‰² (7ä¸ªé¢œè‰²ï¼Œé€—å·åˆ†éš”)</label>
          <input type="text" id="colors" required placeholder="red,red,blue,blue,green,green,green">
        </div>
        
        <button type="submit" class="btn">æ·»åŠ è®°å½•</button>
      </form>
      <div id="add-result" class="result"></div>
    </div>
    
    <div id="query-tab" class="tab-content">
      <h2>æŸ¥è¯¢å¼€å¥–è®°å½•</h2>
      <form id="query-form">
        <div class="form-group">
          <label>ç±»å‹</label>
          <select id="query-type">
            <option value="">å…¨éƒ¨</option>
            <option value="hk">é¦™æ¸¯å…­åˆå½©</option>
            <option value="mo">è€æ¾³21.30</option>
          </select>
        </div>
        
        <div class="form-group">
          <label>å¹´ä»½</label>
          <input type="number" id="query-year" placeholder="2025" min="2000" max="2030">
        </div>
        
        <div class="form-group">
          <label>å…³é”®è¯ (æœŸå·ã€å·ç ã€ç”Ÿè‚–)</label>
          <input type="text" id="query-keyword" placeholder="æœç´¢å…³é”®è¯">
        </div>
        
        <button type="submit" class="btn">æŸ¥è¯¢è®°å½•</button>
      </form>
      <div id="query-result"></div>
    </div>
    
    <div id="delete-tab" class="tab-content">
      <h2>åˆ é™¤å¼€å¥–è®°å½•</h2>
      <form id="delete-form">
        <div class="form-group">
          <label>æœŸå·</label>
          <input type="text" id="delete-expect" required placeholder="2025128">
        </div>
        
        <div class="form-group">
          <label>ç±»å‹</label>
          <select id="delete-type" required>
            <option value="hk">é¦™æ¸¯å…­åˆå½©</option>
            <option value="mo">è€æ¾³21.30</option>
          </select>
        </div>
        
        <button type="submit" class="btn btn-danger">åˆ é™¤è®°å½•</button>
      </form>
      <div id="delete-result" class="result"></div>
    </div>
    
    <div id="stats-tab" class="tab-content">
      <h2>ç»Ÿè®¡ä¿¡æ¯</h2>
      <div id="stats-content">
        <p>åŠ è½½ä¸­...</p>
      </div>
      <button onclick="loadStats()" class="btn">åˆ·æ–°ç»Ÿè®¡</button>
    </div>
    
    <script>
      // Tabåˆ‡æ¢åŠŸèƒ½
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          // ç§»é™¤æ‰€æœ‰activeç±»
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          
          // æ·»åŠ activeç±»
          tab.classList.add('active');
          const tabId = tab.getAttribute('data-tab');
          document.getElementById(tabId + '-tab').classList.add('active');
        });
      });
      
      // æ·»åŠ è®°å½•è¡¨å•æäº¤
      document.getElementById('add-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const record = {
          expect: document.getElementById('expect').value,
          type: document.getElementById('type').value,
          numbers: document.getElementById('numbers').value,
          zodiacs: document.getElementById('zodiacs').value,
          colors: document.getElementById('colors').value
        };
        
        const resultDiv = document.getElementById('add-result');
        resultDiv.innerHTML = '';
        resultDiv.className = 'result';
        
        try {
          const response = await fetch('/add-record', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(record)
          });
          
          const result = await response.json();
          if (result.result) {
            resultDiv.innerHTML = 'âœ… ' + result.message;
            resultDiv.className = 'result success';
            // æ¸…ç©ºè¡¨å•
            document.getElementById('add-form').reset();
          } else {
            resultDiv.innerHTML = 'âŒ ' + result.message;
            resultDiv.className = 'result error';
          }
        } catch (error) {
          resultDiv.innerHTML = 'âŒ ç½‘ç»œé”™è¯¯: ' + error.message;
          resultDiv.className = 'result error';
        }
      });
      
      // æŸ¥è¯¢è®°å½•è¡¨å•æäº¤
      document.getElementById('query-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const query = {
          type: document.getElementById('query-type').value || '',
          year: document.getElementById('query-year').value || '',
          keyword: document.getElementById('query-keyword').value || ''
        };
        
        const resultDiv = document.getElementById('query-result');
        resultDiv.innerHTML = 'æŸ¥è¯¢ä¸­...';
        
        try {
          const response = await fetch('/search', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(query)
          });
          
          const result = await response.json();
          if (result.result) {
            if (result.data.length === 0) {
              resultDiv.innerHTML = '<p>æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è®°å½•</p>';
            } else {
              let html = '<h3>æŸ¥è¯¢ç»“æœ (' + result.data.length + 'æ¡è®°å½•)</h3>';
              html += '<table class="records-table">';
              html += '<tr><th>æœŸå·</th><th>ç±»å‹</th><th>å¼€å¥–æ—¶é—´</th><th>å·ç </th><th>ç”Ÿè‚–</th></tr>';
              
              result.data.forEach(record => {
                html += '<tr>';
                html += '<td>' + record.expect + '</td>';
                html += '<td>' + (record.type === '8' ? 'é¦™æ¸¯' : 'æ¾³é—¨') + '</td>';
                html += '<td>' + record.openTime + '</td>';
                html += '<td>' + record.openCode + '</td>';
                html += '<td>' + record.zodiac + '</td>';
                html += '</tr>';
              });
              
              html += '</table>';
              resultDiv.innerHTML = html;
            }
          } else {
            resultDiv.innerHTML = '<div class="error">âŒ ' + result.message + '</div>';
          }
        } catch (error) {
          resultDiv.innerHTML = '<div class="error">âŒ æŸ¥è¯¢é”™è¯¯: ' + error.message + '</div>';
        }
      });
      
      // åˆ é™¤è®°å½•è¡¨å•æäº¤
      document.getElementById('delete-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
          return;
        }
        
        const data = {
          expect: document.getElementById('delete-expect').value,
          type: document.getElementById('delete-type').value
        };
        
        const resultDiv = document.getElementById('delete-result');
        resultDiv.innerHTML = '';
        resultDiv.className = 'result';
        
        try {
          const response = await fetch('/delete-record', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
          
          const result = await response.json();
          if (result.result) {
            resultDiv.innerHTML = 'âœ… ' + result.message;
            resultDiv.className = 'result success';
            document.getElementById('delete-form').reset();
          } else {
            resultDiv.innerHTML = 'âŒ ' + result.message;
            resultDiv.className = 'result error';
          }
        } catch (error) {
          resultDiv.innerHTML = 'âŒ ç½‘ç»œé”™è¯¯: ' + error.message;
          resultDiv.className = 'result error';
        }
      });
      
      // åŠ è½½ç»Ÿè®¡ä¿¡æ¯
      async function loadStats() {
        const statsDiv = document.getElementById('stats-content');
        statsDiv.innerHTML = 'åŠ è½½ä¸­...';
        
        try {
          const response = await fetch('/stats');
          const result = await response.json();
          
          if (result.result) {
            let html = '<h3>æ•°æ®ç»Ÿè®¡</h3>';
            
            // æ±‡æ€»ç»Ÿè®¡
            html += '<h4>è®°å½•æ±‡æ€»</h4>';
            html += '<ul>';
            result.data.summary.forEach(item => {
              html += '<li>' + (item.type === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30') + ': ' + item.count + 'æ¡</li>';
            });
            html += '<li>æ€»è®¡: ' + result.data.summary.reduce((sum, item) => sum + item.count, 0) + 'æ¡</li>';
            html += '</ul>';
            
            // é‡å¤è®°å½•
            if (result.data.duplicates && result.data.duplicates.length > 0) {
              html += '<h4>é‡å¤è®°å½• (' + result.data.duplicates.length + 'ç»„)</h4>';
              html += '<ul>';
              result.data.duplicates.forEach(dup => {
                html += '<li>' + (dup.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨') + ' ' + dup.expect + ': ' + dup.count + 'æ¬¡</li>';
              });
              html += '</ul>';
            }
            
            // æœ€æ–°è®°å½•
            html += '<h4>æœ€æ–°è®°å½•</h4>';
            if (result.data.latest.length > 0) {
              html += '<table class="records-table">';
              html += '<tr><th>æœŸå·</th><th>ç±»å‹</th><th>å¼€å¥–æ—¶é—´</th><th>å·ç </th></tr>';
              
              result.data.latest.forEach(record => {
                html += '<tr>';
                html += '<td>' + record.expect + '</td>';
                html += '<td>' + (record.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨') + '</td>';
                html += '<td>' + record.openTime + '</td>';
                html += '<td>' + record.openCode + '</td>';
                html += '</tr>';
              });
              
              html += '</table>';
            } else {
              html += '<p>æš‚æ— è®°å½•</p>';
            }
            
            statsDiv.innerHTML = html;
          } else {
            statsDiv.innerHTML = '<div class="error">âŒ ' + result.message + '</div>';
          }
        } catch (error) {
          statsDiv.innerHTML = '<div class="error">âŒ åŠ è½½å¤±è´¥: ' + error.message + '</div>';
        }
      }
      
      // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨åŠ è½½ç»Ÿè®¡
      window.addEventListener('DOMContentLoaded', () => {
        loadStats();
      });
    </script>
  </body>
  </html>`, {
    headers: { 'Content-Type': 'text/html;charset=utf-8' }
  });
}

async function getStatsForChat(db) {
  try {
    const totalResult = await db.prepare(`
      SELECT type, COUNT(*) as count FROM lottery_records GROUP BY type
    `).all();
    
    const duplicateResult = await db.prepare(`
      SELECT type, expect, COUNT(*) as count 
      FROM lottery_records 
      GROUP BY type, expect 
      HAVING COUNT(*) > 1
    `).all();
    
    const latestResult = await db.prepare(`
      SELECT * FROM lottery_records 
      ORDER BY openTime DESC 
      LIMIT 3
    `).all();
    
    let message = `ğŸ“Š *å¼€å¥–è®°å½•ç»Ÿè®¡*\n\n`;
    
    totalResult.results.forEach(item => {
      message += `*${item.type === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'è€æ¾³21.30'}*: ${item.count}æ¡\n`;
    });
    
    const total = totalResult.results.reduce((sum, item) => sum + item.count, 0);
    message += `*æ€»è®¡*: ${total}æ¡\n\n`;
    
    if (duplicateResult.results.length > 0) {
      message += `*é‡å¤è®°å½•*: ${duplicateResult.results.length}ç»„\n`;
      duplicateResult.results.slice(0, 3).forEach(dup => {
        message += `â€¢ ${dup.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${dup.expect}: ${dup.count}æ¬¡\n`;
      });
      message += `\n`;
    }
    
    if (latestResult.results.length > 0) {
      message += `*æœ€æ–°è®°å½•:*\n`;
      latestResult.results.forEach(record => {
        message += `â€¢ ${record.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ${record.expect}\n`;
      });
    }
    
    return message;
  } catch (error) {
    console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
    return 'è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥';
  }
}

async function getRecordsForChat(db, type, year) {
  try {
    const { results } = await db.prepare(`
      SELECT * FROM lottery_records 
      WHERE type = ? AND year = ?
      ORDER BY openTime DESC
      LIMIT 10
    `).bind(type, year).all();
    
    return results || [];
  } catch (error) {
    console.error('æŸ¥è¯¢å¤±è´¥:', error);
    return [];
  }
}

async function searchRecordsForChat(db, keyword) {
  try {
    const { results } = await db.prepare(`
      SELECT * FROM lottery_records 
      WHERE expect LIKE ? OR openCode LIKE ? OR zodiac LIKE ?
      ORDER BY openTime DESC
      LIMIT 10
    `).bind(`%${keyword}%`, `%${keyword}%`, `%${keyword}%`).all();
    
    return results || [];
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
    return [];
  }
}

async function sendTelegramMessage(botToken, chatId, text, options = {}) {
  try {
    if (!botToken) {
      console.error('Bot Tokenä¸ºç©º');
      return;
    }
    
    const payload = {
      chat_id: chatId,
      text: text,
      parse_mode: options.parse_mode || 'HTML',
      disable_web_page_preview: options.disable_web_page_preview || false
    };
    
    if (options.reply_markup) {
      payload.reply_markup = options.reply_markup;
    }
    
    const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    
    const result = await response.json();
    if (!result.ok) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', result);
    }
    
    return result;
  } catch (error) {
    console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
  }
}
