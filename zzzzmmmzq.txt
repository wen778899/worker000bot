/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V13.0 å¢å¼ºKNNç®—æ³•ç‰ˆ
 * 
 * ä¸»è¦æ›´æ–°:
 * 1. ç§»é™¤è’™ç‰¹å¡æ´›æ¨¡æ‹ŸåŠŸèƒ½
 * 2. ç§»é™¤æ‰‹åŠ¨è®¾ç½®å®šæ—¶ä»»åŠ¡åŠŸèƒ½
 * 3. æ·»åŠ åŒ—äº¬æ—¶é—´21:45è‡ªåŠ¨åŒæ­¥æ•°æ®
 * 4. æ·»åŠ åŒ—äº¬æ—¶é—´21:30è‡ªåŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“
 * 5. æ·»åŠ å¢å¼ºKNNç®—æ³•ï¼Œé›†æˆå¤šç§è§„å¾‹ç»Ÿè®¡
 * 6. ä¿ç•™æ‰‹åŠ¨åŒæ­¥å’Œæ‰‹åŠ¨æ¨é€åŠŸèƒ½
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ¾³å…­é¢„æµ‹",
    VERSION: "V13.0 å¢å¼ºKNNç®—æ³•ç‰ˆ",
    TIMEZONE_OFFSET: 8,
    CHANNEL_ID: null,
    ADMIN_ID: null,
    HISTORY_LIMIT: 2000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    
    // å›ºå®šæ—¶é—´è®¾ç½®ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
    DAILY_SYNC_TIME: { hour: 21, minute: 45 },  // 21:45åŒæ­¥æ•°æ®
    DAILY_PUSH_TIME: { hour: 21, minute: 30 },  // 21:30æ¨é€é¢„æµ‹
    
    // KNNç®—æ³•é…ç½®
    KNN_K_VALUE: 15,
    KNN_WEIGHTS: {
      zodiac_transfer_weight: 3.0,      // ç”Ÿè‚–è½¬ç§»æƒé‡
      color_transfer_weight: 2.0,       // æ³¢è‰²è½¬ç§»æƒé‡
      tail_relation_weight: 2.5,        // å°¾æ•°å…³è”æƒé‡
      normal_tail_to_special_weight: 3.0, // å¹³ç å°¾æ•°->ç‰¹ç å°¾æ•°æƒé‡
      special_tail_to_normal_weight: 2.0, // ç‰¹ç å°¾æ•°->å¹³ç å°¾æ•°æƒé‡
      same_zodiac_weight: 1.5,          // ç›¸åŒç”Ÿè‚–æƒé‡
      same_color_weight: 1.5,           // ç›¸åŒæ³¢è‰²æƒé‡
      big_small_relation_weight: 1.8,   // å¤§å°å…³ç³»æƒé‡
      odd_even_relation_weight: 1.8,    // å•åŒå…³ç³»æƒé‡
      special_frequency_weight: 1.0,    // ç‰¹ç é¢‘ç‡æƒé‡
      normal_frequency_weight: 1.0,     // å¹³ç é¢‘ç‡æƒé‡
      gap_relation_weight: 2.0,         // é—´éš”æœŸæ•°æƒé‡
      zodiac_gap_weight: 2.2,           // ç”Ÿè‚–é—´éš”æƒé‡
      color_gap_weight: 2.2,            // æ³¢è‰²é—´éš”æƒé‡
      tail_gap_weight: 2.2,             // å°¾æ•°é—´éš”æƒé‡
      hot_cold_weight: 2.5              // å†·çƒ­å·ç æƒé‡
    }
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 3.0,
    w_color_transfer: 2.5,
    w_tail_relation: 3.0,
    w_frequency_analysis: 2.0,
    w_pattern_recognition: 3.5,
    w_knn: 4.0,
    _version: "13.0"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    home: "ğŸ ",
    trash: "ğŸ—‘ï¸",
    warning: "âš ï¸",
    database: "ğŸ’¾",
    clock: "â°",
    check: "âœ”ï¸",
    speed: "âš¡",
    fix: "ğŸ”§",
    bell: "ğŸ””",
    star: "â­",
    rocket: "ğŸš€",
    refresh: "ğŸ”„",
    eye: "ğŸ‘ï¸",
    lock: "ğŸ”’",
    dice: "ğŸ²",
    calendar: "ğŸ“…",
    hourglass: "â³",
    money: "ğŸ’°",
    target: "ğŸ¯",
    brain: "ğŸ§ ",
    science: "ğŸ”¬",
    chart_up: "ğŸ“ˆ",
    clock2: "ğŸ•’",
    alarm: "â°",
    repeat: "ğŸ”",
    progress: "ğŸ“ˆ",
    batch: "ğŸ”¢",
    history: "ğŸ“œ",
    memory: "ğŸ’¾",
    cpu: "âš™ï¸",
    algorithm: "ğŸ§®",
    knn: "ğŸ“",
    sync: "ğŸ”",
    push: "ğŸ“¤",
    auto: "ğŸ¤–",
    pattern: "ğŸ§©",
    statistics: "ğŸ“ˆ",
    magic: "ğŸ©",
    search: "ğŸ”",
    key: "ğŸ”‘",
    puzzle: "ğŸ§©",
    analysis: "ğŸ”",
    timing: "âŒš"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    PREDICT: "prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_CONFIRM: "delete_confirm",
    DELETE_RESULT: "delete_result",
    PATTERN_ANALYSIS: "pattern_analysis",
    STATISTICS: "statistics"
  }
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•°
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
  
  static debug(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [DEBUG] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.debug] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
      }
      
      let zodiac = "æœªçŸ¥";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "æœªçŸ¥";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatBeijingTime(date = new Date()) {
    try {
      const beijingOffset = 8 * 60; // åŒ—äº¬æ—¶é—´UTC+8
      const localDate = new Date(date.getTime() + (beijingOffset - date.getTimezoneOffset()) * 60000);
      
      const pad = n => n.toString().padStart(2, '0');
      return `${localDate.getFullYear()}-${pad(localDate.getMonth()+1)}-${pad(localDate.getDate())} ${pad(localDate.getHours())}:${pad(localDate.getMinutes())}:${pad(localDate.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(2) + 'äº¿';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }

  static getRandomElement(array) {
    try {
      if (!array || !Array.isArray(array) || array.length === 0) return null;
      return array[Math.floor(Math.random() * array.length)];
    } catch (error) {
      return null;
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static formatDuration(ms) {
    try {
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms/1000).toFixed(2)}ç§’`;
      if (ms < 3600000) return `${Math.floor(ms/60000)}åˆ†${Math.floor((ms%60000)/1000)}ç§’`;
      return `${Math.floor(ms/3600000)}å°æ—¶${Math.floor((ms%3600000)/60000)}åˆ†`;
    } catch (error) {
      return `${ms}ms`;
    }
  }

  static isBeijingTimeInRange(targetHour, targetMinute, currentDate = new Date()) {
    try {
      const beijingOffset = 8 * 60; // åŒ—äº¬æ—¶é—´UTC+8
      const localDate = new Date(currentDate.getTime() + (beijingOffset - currentDate.getTimezoneOffset()) * 60000);
      
      const currentHour = localDate.getHours();
      const currentMinute = localDate.getMinutes();
      
      return currentHour === targetHour && currentMinute === targetMinute;
    } catch (error) {
      return false;
    }
  }

  static getBeijingTime(currentDate = new Date()) {
    try {
      const beijingOffset = 8 * 60; // åŒ—äº¬æ—¶é—´UTC+8
      const localDate = new Date(currentDate.getTime() + (beijingOffset - currentDate.getTimezoneOffset()) * 60000);
      
      return {
        year: localDate.getFullYear(),
        month: localDate.getMonth() + 1,
        date: localDate.getDate(),
        hour: localDate.getHours(),
        minute: localDate.getMinutes(),
        second: localDate.getSeconds(),
        dayOfWeek: localDate.getDay()
      };
    } catch (error) {
      return null;
    }
  }
}

// ==============================================================================
// 3. æ¶ˆæ¯ç®¡ç†å™¨
// ==============================================================================

class MessageManager {
  static userMessages = new Map();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static deleteUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.delete(messageType);
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
  
  static cleanupOldMessages(chatId, keepCount = 10) {
    try {
      this.initUser(chatId);
      const userMap = this.userMessages.get(chatId);
      
      if (userMap.size <= keepCount) {
        return 0;
      }
      
      const entries = Array.from(userMap.entries());
      const toRemove = entries.slice(0, entries.length - keepCount);
      
      let removed = 0;
      for (const [key, _] of toRemove) {
        if (userMap.delete(key)) {
          removed++;
        }
      }
      
      Logger.info("MessageManager", `æ¸…ç†äº† ${removed} æ¡æ—§æ¶ˆæ¯`, { chatId });
      return removed;
    } catch (error) {
      Logger.error("MessageManager", "æ¸…ç†æ—§æ¶ˆæ¯å¤±è´¥", error);
      return 0;
    }
  }
}

// ==============================================================================
// 4. ç¼“å­˜ç®¡ç†å™¨
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "è®¾ç½®ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 5. æ•°æ®åº“æ“ä½œå±‚
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  checkExpectExists: async function(env, expect) {
    try {
      if (!expect) return false;
      
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(Formatter.safeString(expect)).first();
      
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code &&
          Formatter.isValidExpect(record.expect.toString())
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          weights = { ...defaultWeights, ...parsed };
        } catch (parseError) {
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0",
        "LAST_AUTO_SYNC": "",
        "LAST_AUTO_PUSH": "",
        "TOTAL_AUTO_SYNCS": "0",
        "TOTAL_AUTO_PUSHES": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  }
};

// ==============================================================================
// 6. å¢å¼ºKNNç®—æ³•å®ç°ï¼ˆé›†æˆå¤šç§è§„å¾‹ç»Ÿè®¡ï¼‰
// ==============================================================================

class EnhancedKNNAlgorithm {
  static distanceCache = new Map();
  static patternCache = new Map();
  
  static analyzePatternsFromHistory(history) {
    try {
      const cacheKey = `patterns_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.patternCache.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      if (!history || history.length < 10) {
        return this.createEmptyPatterns();
      }
      
      const patterns = this.createEmptyPatterns();
      const maxRecords = Math.min(history.length, 500);
      const historySlice = history.slice(0, maxRecords);
      
      // é¢„å¤„ç†å†å²æ•°æ®
      const processedHistory = [];
      for (let i = 0; i < historySlice.length; i++) {
        const record = historySlice[i];
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          if (nums.length >= 7) {
            const special = nums[6] || 1;
            const normals = nums.slice(0, 6);
            const attr = Formatter.getAttributes(special);
            
            processedHistory.push({
              expect: record.expect,
              numbers: nums,
              special: special,
              normals: normals,
              zodiac: attr.zodiac,
              color: attr.color,
              tail: special % 10,
              normalTails: normals.map(n => n % 10),
              isBig: special >= 25,
              isOdd: special % 2 !== 0,
              normalBigs: normals.map(n => n >= 25),
              normalOdds: normals.map(n => n % 2 !== 0)
            });
          }
        }
      }
      
      if (processedHistory.length < 2) {
        return patterns;
      }
      
      // åˆ†æå„ç§è§„å¾‹
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        // 1. ç”Ÿè‚–è½¬ç§»ç»Ÿè®¡
        if (current.zodiac && next.zodiac) {
          if (!patterns.zodiacTransfer[current.zodiac]) {
            patterns.zodiacTransfer[current.zodiac] = {};
          }
          patterns.zodiacTransfer[current.zodiac][next.zodiac] = 
            (patterns.zodiacTransfer[current.zodiac][next.zodiac] || 0) + 1;
        }
        
        // 2. æ³¢è‰²è½¬ç§»ç»Ÿè®¡
        if (current.color && next.color) {
          if (!patterns.colorTransfer[current.color]) {
            patterns.colorTransfer[current.color] = {};
          }
          patterns.colorTransfer[current.color][next.color] = 
            (patterns.colorTransfer[current.color][next.color] || 0) + 1;
        }
        
        // 3. å°¾æ•°å…³è”ç»Ÿè®¡ï¼ˆå¹³ç å°¾æ•°->ç‰¹ç å°¾æ•°ï¼‰
        current.normalTails.forEach(tail => {
          if (!patterns.normalTailToSpecialTail[tail]) {
            patterns.normalTailToSpecialTail[tail] = {};
          }
          patterns.normalTailToSpecialTail[tail][next.tail] = 
            (patterns.normalTailToSpecialTail[tail][next.tail] || 0) + 1;
        });
        
        // 4. ç‰¹ç å°¾æ•°->å¹³ç å°¾æ•°ç»Ÿè®¡
        if (!patterns.specialTailToNormalTail[current.tail]) {
          patterns.specialTailToNormalTail[current.tail] = {};
        }
        next.normalTails.forEach(tail => {
          patterns.specialTailToNormalTail[current.tail][tail] = 
            (patterns.specialTailToNormalTail[current.tail][tail] || 0) + 1;
        });
        
        // 5. å¤§å°å…³ç³»è½¬ç§»
        const currentBigSmall = current.isBig ? "å¤§" : "å°";
        const nextBigSmall = next.isBig ? "å¤§" : "å°";
        if (!patterns.bigSmallTransfer[currentBigSmall]) {
          patterns.bigSmallTransfer[currentBigSmall] = {};
        }
        patterns.bigSmallTransfer[currentBigSmall][nextBigSmall] = 
          (patterns.bigSmallTransfer[currentBigSmall][nextBigSmall] || 0) + 1;
        
        // 6. å•åŒå…³ç³»è½¬ç§»
        const currentOddEven = current.isOdd ? "å•" : "åŒ";
        const nextOddEven = next.isOdd ? "å•" : "åŒ";
        if (!patterns.oddEvenTransfer[currentOddEven]) {
          patterns.oddEvenTransfer[currentOddEven] = {};
        }
        patterns.oddEvenTransfer[currentOddEven][nextOddEven] = 
          (patterns.oddEvenTransfer[currentOddEven][nextOddEven] || 0) + 1;
        
        // 7. ç‰¹ç é¢‘ç‡ç»Ÿè®¡
        patterns.specialFrequency[next.special] = 
          (patterns.specialFrequency[next.special] || 0) + 1;
        
        // 8. å¹³ç é¢‘ç‡ç»Ÿè®¡
        next.normals.forEach(num => {
          patterns.normalFrequency[num] = (patterns.normalFrequency[num] || 0) + 1;
        });
        
        // 9. ç”Ÿè‚–é—´éš”ç»Ÿè®¡ï¼ˆæŸ¥æ‰¾å¼€é¾™ä¹‹åå¼€é¸¡çš„é—´éš”ï¼‰
        const zodiacGapKey = `${current.zodiac}_${next.zodiac}`;
        if (!patterns.zodiacGapPatterns[zodiacGapKey]) {
          patterns.zodiacGapPatterns[zodiacGapKey] = {
            count: 0,
            gaps: []
          };
        }
        patterns.zodiacGapPatterns[zodiacGapKey].count++;
        
        // æŸ¥æ‰¾ä¸Šä¸€æ¬¡ç›¸åŒç”Ÿè‚–è½¬ç§»çš„é—´éš”
        for (let j = i - 1; j >= 0; j--) {
          const prev = processedHistory[j];
          const prevNext = processedHistory[j + 1];
          if (prev.zodiac === current.zodiac && prevNext.zodiac === next.zodiac) {
            const gap = i - j;
            patterns.zodiacGapPatterns[zodiacGapKey].gaps.push(gap);
            break;
          }
        }
        
        // 10. æ³¢è‰²é—´éš”ç»Ÿè®¡
        const colorGapKey = `${current.color}_${next.color}`;
        if (!patterns.colorGapPatterns[colorGapKey]) {
          patterns.colorGapPatterns[colorGapKey] = {
            count: 0,
            gaps: []
          };
        }
        patterns.colorGapPatterns[colorGapKey].count++;
        
        // 11. å°¾æ•°é—´éš”ç»Ÿè®¡
        const tailGapKey = `${current.tail}_${next.tail}`;
        if (!patterns.tailGapPatterns[tailGapKey]) {
          patterns.tailGapPatterns[tailGapKey] = {
            count: 0,
            gaps: []
          };
        }
        patterns.tailGapPatterns[tailGapKey].count++;
        
        // 12. ç›¸åŒç”Ÿè‚–è¿ç»­å‡ºç°ç»Ÿè®¡
        if (current.zodiac === next.zodiac) {
          patterns.sameZodiacContinuity[current.zodiac] = 
            (patterns.sameZodiacContinuity[current.zodiac] || 0) + 1;
        }
        
        // 13. ç›¸åŒæ³¢è‰²è¿ç»­å‡ºç°ç»Ÿè®¡
        if (current.color === next.color) {
          patterns.sameColorContinuity[current.color] = 
            (patterns.sameColorContinuity[current.color] || 0) + 1;
        }
        
        // 14. å·ç å†·çƒ­åˆ†æï¼ˆåŸºäºæœ€è¿‘NæœŸï¼‰
        const recentPeriods = 50;
        if (i < processedHistory.length - recentPeriods) {
          // è®¡ç®—å·ç åœ¨æœ€è¿‘NæœŸçš„å‡ºç°é¢‘ç‡
          const recentHistory = processedHistory.slice(i + 1, i + 1 + recentPeriods);
          const hotNumbers = new Set();
          recentHistory.forEach(record => {
            hotNumbers.add(record.special);
            record.normals.forEach(n => hotNumbers.add(n));
          });
          
          // æ ‡è®°å†·å·ç ï¼ˆæœ€è¿‘NæœŸæ²¡å‡ºç°ï¼‰
          for (let num = 1; num <= 49; num++) {
            if (!hotNumbers.has(num)) {
              patterns.coldNumbers[num] = (patterns.coldNumbers[num] || 0) + 1;
            }
          }
        }
      }
      
      // å½’ä¸€åŒ–ç»Ÿè®¡
      this.normalizePatterns(patterns, processedHistory.length);
      
      // è®¡ç®—å¹³å‡é—´éš”
      this.calculateAverageGaps(patterns);
      
      patterns.totalRecords = processedHistory.length;
      patterns.lastExpect = processedHistory[0]?.expect;
      patterns.firstExpect = processedHistory[processedHistory.length - 1]?.expect;
      
      this.patternCache.set(cacheKey, patterns);
      return patterns;
      
    } catch (error) {
      Logger.error("EnhancedKNN", "åˆ†æå†å²è§„å¾‹å¤±è´¥", error);
      return this.createEmptyPatterns();
    }
  }
  
  static createEmptyPatterns() {
    return {
      totalRecords: 0,
      zodiacTransfer: {},
      colorTransfer: {},
      normalTailToSpecialTail: {},
      specialTailToNormalTail: {},
      bigSmallTransfer: {},
      oddEvenTransfer: {},
      specialFrequency: {},
      normalFrequency: {},
      zodiacGapPatterns: {},
      colorGapPatterns: {},
      tailGapPatterns: {},
      sameZodiacContinuity: {},
      sameColorContinuity: {},
      coldNumbers: {},
      lastExpect: null,
      firstExpect: null
    };
  }
  
  static normalizePatterns(patterns, totalRecords) {
    try {
      // å½’ä¸€åŒ–è½¬ç§»æ¦‚ç‡
      const normalizeTransfer = (transferObj) => {
        Object.keys(transferObj).forEach(key1 => {
          const total = Object.values(transferObj[key1]).reduce((a, b) => a + b, 0);
          if (total > 0) {
            Object.keys(transferObj[key1]).forEach(key2 => {
              transferObj[key1][key2] = transferObj[key1][key2] / total;
            });
          }
        });
      };
      
      normalizeTransfer(patterns.zodiacTransfer);
      normalizeTransfer(patterns.colorTransfer);
      normalizeTransfer(patterns.normalTailToSpecialTail);
      normalizeTransfer(patterns.specialTailToNormalTail);
      normalizeTransfer(patterns.bigSmallTransfer);
      normalizeTransfer(patterns.oddEvenTransfer);
      
      // å½’ä¸€åŒ–é¢‘ç‡ï¼ˆè½¬æ¢ä¸ºå‡ºç°æ¦‚ç‡ï¼‰
      Object.keys(patterns.specialFrequency).forEach(num => {
        patterns.specialFrequency[num] = patterns.specialFrequency[num] / totalRecords;
      });
      
      Object.keys(patterns.normalFrequency).forEach(num => {
        patterns.normalFrequency[num] = patterns.normalFrequency[num] / totalRecords;
      });
      
      // å½’ä¸€åŒ–è¿ç»­å‡ºç°æ¬¡æ•°
      const totalSameZodiac = Object.values(patterns.sameZodiacContinuity).reduce((a, b) => a + b, 0);
      if (totalSameZodiac > 0) {
        Object.keys(patterns.sameZodiacContinuity).forEach(zodiac => {
          patterns.sameZodiacContinuity[zodiac] = patterns.sameZodiacContinuity[zodiac] / totalSameZodiac;
        });
      }
      
      const totalSameColor = Object.values(patterns.sameColorContinuity).reduce((a, b) => a + b, 0);
      if (totalSameColor > 0) {
        Object.keys(patterns.sameColorContinuity).forEach(color => {
          patterns.sameColorContinuity[color] = patterns.sameColorContinuity[color] / totalSameColor;
        });
      }
      
    } catch (error) {
      Logger.error("EnhancedKNN", "å½’ä¸€åŒ–è§„å¾‹å¤±è´¥", error);
    }
  }
  
  static calculateAverageGaps(patterns) {
    try {
      // è®¡ç®—ç”Ÿè‚–é—´éš”å¹³å‡å€¼
      Object.keys(patterns.zodiacGapPatterns).forEach(key => {
        const pattern = patterns.zodiacGapPatterns[key];
        if (pattern.gaps.length > 0) {
          const sum = pattern.gaps.reduce((a, b) => a + b, 0);
          pattern.averageGap = sum / pattern.gaps.length;
        } else {
          pattern.averageGap = 0;
        }
      });
      
      // è®¡ç®—æ³¢è‰²é—´éš”å¹³å‡å€¼
      Object.keys(patterns.colorGapPatterns).forEach(key => {
        const pattern = patterns.colorGapPatterns[key];
        if (pattern.gaps.length > 0) {
          const sum = pattern.gaps.reduce((a, b) => a + b, 0);
          pattern.averageGap = sum / pattern.gaps.length;
        } else {
          pattern.averageGap = 0;
        }
      });
      
      // è®¡ç®—å°¾æ•°é—´éš”å¹³å‡å€¼
      Object.keys(patterns.tailGapPatterns).forEach(key => {
        const pattern = patterns.tailGapPatterns[key];
        if (pattern.gaps.length > 0) {
          const sum = pattern.gaps.reduce((a, b) => a + b, 0);
          pattern.averageGap = sum / pattern.gaps.length;
        } else {
          pattern.averageGap = 0;
        }
      });
      
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—å¹³å‡é—´éš”å¤±è´¥", error);
    }
  }
  
  static calculateDistance(currentRecord, historyRecord, patterns, weights) {
    try {
      const cacheKey = `${currentRecord.special}_${historyRecord.special}_${currentRecord.zodiac}_${historyRecord.zodiac}`;
      const cached = this.distanceCache.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      let totalDistance = 0;
      let weightSum = 0;
      
      // 1. ç”Ÿè‚–è½¬ç§»è·ç¦»
      if (currentRecord.zodiac && historyRecord.zodiac && 
          patterns.zodiacTransfer[currentRecord.zodiac] &&
          patterns.zodiacTransfer[currentRecord.zodiac][historyRecord.zodiac]) {
        const zodiacProb = patterns.zodiacTransfer[currentRecord.zodiac][historyRecord.zodiac];
        totalDistance += (1 - zodiacProb) * weights.zodiac_transfer_weight;
        weightSum += weights.zodiac_transfer_weight;
      }
      
      // 2. æ³¢è‰²è½¬ç§»è·ç¦»
      if (currentRecord.color && historyRecord.color && 
          patterns.colorTransfer[currentRecord.color] &&
          patterns.colorTransfer[currentRecord.color][historyRecord.color]) {
        const colorProb = patterns.colorTransfer[currentRecord.color][historyRecord.color];
        totalDistance += (1 - colorProb) * weights.color_transfer_weight;
        weightSum += weights.color_transfer_weight;
      }
      
      // 3. å°¾æ•°å…³è”è·ç¦»ï¼ˆå¹³ç å°¾æ•°->ç‰¹ç å°¾æ•°ï¼‰
      let tailMatchCount = 0;
      currentRecord.normalTails.forEach(tail => {
        if (patterns.normalTailToSpecialTail[tail] &&
            patterns.normalTailToSpecialTail[tail][historyRecord.tail]) {
          const prob = patterns.normalTailToSpecialTail[tail][historyRecord.tail];
          totalDistance += (1 - prob) * (weights.tail_relation_weight / currentRecord.normalTails.length);
        }
      });
      weightSum += weights.tail_relation_weight;
      
      // 4. ç‰¹ç å°¾æ•°->å¹³ç å°¾æ•°è·ç¦»
      if (patterns.specialTailToNormalTail[currentRecord.tail]) {
        let normalTailMatchScore = 0;
        historyRecord.normalTails.forEach(tail => {
          if (patterns.specialTailToNormalTail[currentRecord.tail][tail]) {
            const prob = patterns.specialTailToNormalTail[currentRecord.tail][tail];
            normalTailMatchScore += prob;
          }
        });
        if (historyRecord.normalTails.length > 0) {
          normalTailMatchScore /= historyRecord.normalTails.length;
          totalDistance += (1 - normalTailMatchScore) * weights.special_tail_to_normal_weight;
          weightSum += weights.special_tail_to_normal_weight;
        }
      }
      
      // 5. ç›¸åŒç”Ÿè‚–è·ç¦»
      if (currentRecord.zodiac === historyRecord.zodiac) {
        const sameZodiacProb = patterns.sameZodiacContinuity[currentRecord.zodiac] || 0;
        totalDistance += (1 - sameZodiacProb) * weights.same_zodiac_weight;
        weightSum += weights.same_zodiac_weight;
      }
      
      // 6. ç›¸åŒæ³¢è‰²è·ç¦»
      if (currentRecord.color === historyRecord.color) {
        const sameColorProb = patterns.sameColorContinuity[currentRecord.color] || 0;
        totalDistance += (1 - sameColorProb) * weights.same_color_weight;
        weightSum += weights.same_color_weight;
      }
      
      // 7. å¤§å°å…³ç³»è·ç¦»
      const currentBigSmall = currentRecord.isBig ? "å¤§" : "å°";
      const historyBigSmall = historyRecord.isBig ? "å¤§" : "å°";
      if (patterns.bigSmallTransfer[currentBigSmall] &&
          patterns.bigSmallTransfer[currentBigSmall][historyBigSmall]) {
        const prob = patterns.bigSmallTransfer[currentBigSmall][historyBigSmall];
        totalDistance += (1 - prob) * weights.big_small_relation_weight;
        weightSum += weights.big_small_relation_weight;
      }
      
      // 8. å•åŒå…³ç³»è·ç¦»
      const currentOddEven = currentRecord.isOdd ? "å•" : "åŒ";
      const historyOddEven = historyRecord.isOdd ? "å•" : "åŒ";
      if (patterns.oddEvenTransfer[currentOddEven] &&
          patterns.oddEvenTransfer[currentOddEven][historyOddEven]) {
        const prob = patterns.oddEvenTransfer[currentOddEven][historyOddEven];
        totalDistance += (1 - prob) * weights.odd_even_relation_weight;
        weightSum += weights.odd_even_relation_weight;
      }
      
      // 9. ç‰¹ç é¢‘ç‡è·ç¦»
      const specialFreq = patterns.specialFrequency[historyRecord.special] || 0;
      totalDistance += (1 - specialFreq) * weights.special_frequency_weight;
      weightSum += weights.special_frequency_weight;
      
      // 10. å¹³ç é¢‘ç‡è·ç¦»ï¼ˆå¹³å‡ï¼‰
      let normalFreqScore = 0;
      historyRecord.normals.forEach(num => {
        normalFreqScore += patterns.normalFrequency[num] || 0;
      });
      if (historyRecord.normals.length > 0) {
        normalFreqScore /= historyRecord.normals.length;
        totalDistance += (1 - normalFreqScore) * weights.normal_frequency_weight;
        weightSum += weights.normal_frequency_weight;
      }
      
      // 11. é—´éš”å…³ç³»è·ç¦»ï¼ˆç”Ÿè‚–é—´éš”ï¼‰
      const zodiacGapKey = `${currentRecord.zodiac}_${historyRecord.zodiac}`;
      if (patterns.zodiacGapPatterns[zodiacGapKey]) {
        const pattern = patterns.zodiacGapPatterns[zodiacGapKey];
        const gapProbability = pattern.count / patterns.totalRecords;
        totalDistance += (1 - gapProbability) * weights.gap_relation_weight * 0.5;
        weightSum += weights.gap_relation_weight * 0.5;
      }
      
      // 12. é—´éš”å…³ç³»è·ç¦»ï¼ˆæ³¢è‰²é—´éš”ï¼‰
      const colorGapKey = `${currentRecord.color}_${historyRecord.color}`;
      if (patterns.colorGapPatterns[colorGapKey]) {
        const pattern = patterns.colorGapPatterns[colorGapKey];
        const gapProbability = pattern.count / patterns.totalRecords;
        totalDistance += (1 - gapProbability) * weights.gap_relation_weight * 0.3;
        weightSum += weights.gap_relation_weight * 0.3;
      }
      
      // 13. é—´éš”å…³ç³»è·ç¦»ï¼ˆå°¾æ•°é—´éš”ï¼‰
      const tailGapKey = `${currentRecord.tail}_${historyRecord.tail}`;
      if (patterns.tailGapPatterns[tailGapKey]) {
        const pattern = patterns.tailGapPatterns[tailGapKey];
        const gapProbability = pattern.count / patterns.totalRecords;
        totalDistance += (1 - gapProbability) * weights.gap_relation_weight * 0.2;
        weightSum += weights.gap_relation_weight * 0.2;
      }
      
      // 14. å†·çƒ­å·ç è·ç¦»
      const isColdNumber = patterns.coldNumbers[historyRecord.special] > 0;
      if (isColdNumber) {
        const coldScore = Math.min(1, patterns.coldNumbers[historyRecord.special] / 10);
        totalDistance += coldScore * weights.hot_cold_weight;
        weightSum += weights.hot_cold_weight;
      }
      
      // è®¡ç®—åŠ æƒå¹³å‡è·ç¦»
      const finalDistance = weightSum > 0 ? totalDistance / weightSum : 1.0;
      
      this.distanceCache.set(cacheKey, finalDistance);
      return finalDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—è·ç¦»å¤±è´¥", error);
      return 1.0; // è¿”å›æœ€å¤§è·ç¦»
    }
  }
  
  static findKNearestNeighbors(currentRecord, processedHistory, patterns, k = CONFIG.SYSTEM.KNN_K_VALUE) {
    try {
      if (!processedHistory || processedHistory.length < k) {
        return [];
      }
      
      const distances = [];
      const weights = CONFIG.SYSTEM.KNN_WEIGHTS;
      
      for (let i = 0; i < processedHistory.length; i++) {
        const historyRecord = processedHistory[i];
        
        // ç¡®ä¿æœ‰ä¸‹ä¸€æœŸæ•°æ®
        if (!historyRecord.nextSpecial) {
          continue;
        }
        
        const distance = this.calculateDistance(currentRecord, historyRecord, patterns, weights);
        distances.push({
          index: i,
          distance: distance,
          nextSpecial: historyRecord.nextSpecial,
          nextNormals: historyRecord.nextNormals || [],
          nextZodiac: historyRecord.nextZodiac,
          nextColor: historyRecord.nextColor,
          nextTail: historyRecord.nextTail,
          nextIsBig: historyRecord.nextIsBig,
          nextIsOdd: historyRecord.nextIsOdd
        });
      }
      
      // æŒ‰è·ç¦»æ’åºï¼ˆè·ç¦»è¶Šå°è¶Šç›¸ä¼¼ï¼‰
      distances.sort((a, b) => a.distance - b.distance);
      
      // è¿”å›æœ€è¿‘çš„kä¸ªé‚»å±…
      return distances.slice(0, Math.min(k, distances.length));
    } catch (error) {
      Logger.error("EnhancedKNN", "æŸ¥æ‰¾æœ€è¿‘é‚»å¤±è´¥", error);
      return [];
    }
  }
  
  static predictNextNumbers(currentRecord, processedHistory, patterns, k = CONFIG.SYSTEM.KNN_K_VALUE) {
    try {
      const neighbors = this.findKNearestNeighbors(currentRecord, processedHistory, patterns, k);
      
      if (neighbors.length === 0) {
        return {
          special: null,
          normals: [],
          confidence: 0
        };
      }
      
      // ç»Ÿè®¡é‚»å±…çš„ä¸‹ä¸€æœŸç‰¹ç 
      const specialFrequency = {};
      const specialWeights = {}; // åŠ æƒç»Ÿè®¡ï¼ˆè·ç¦»è¶Šè¿‘æƒé‡è¶Šé«˜ï¼‰
      
      for (const neighbor of neighbors) {
        const special = neighbor.nextSpecial;
        const weight = 1.0 / (1.0 + neighbor.distance); // è·ç¦»è¶Šå°æƒé‡è¶Šå¤§
        
        specialFrequency[special] = (specialFrequency[special] || 0) + 1;
        specialWeights[special] = (specialWeights[special] || 0) + weight;
      }
      
      // æ‰¾å‡ºæœ€é¢‘ç¹çš„ç‰¹ç ï¼ˆè€ƒè™‘æƒé‡ï¼‰
      let predictedSpecial = null;
      let maxWeightedFrequency = 0;
      for (const [special, frequency] of Object.entries(specialFrequency)) {
        const weightedFreq = specialWeights[special] || frequency;
        if (weightedFreq > maxWeightedFrequency) {
          maxWeightedFrequency = weightedFreq;
          predictedSpecial = parseInt(special);
        }
      }
      
      // ç»Ÿè®¡é‚»å±…çš„ä¸‹ä¸€æœŸå¹³ç ï¼ˆåŠ æƒï¼‰
      const normalWeights = {};
      for (const neighbor of neighbors) {
        const weight = 1.0 / (1.0 + neighbor.distance);
        
        if (neighbor.nextNormals && Array.isArray(neighbor.nextNormals)) {
          for (const normal of neighbor.nextNormals) {
            normalWeights[normal] = (normalWeights[normal] || 0) + weight;
          }
        }
      }
      
      // è·å–æƒé‡æœ€é«˜çš„6ä¸ªå¹³ç 
      const predictedNormals = Object.entries(normalWeights)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6)
        .map(([num, _]) => parseInt(num));
      
      // è®¡ç®—ç½®ä¿¡åº¦
      const confidence = Math.min(95, Math.round((maxWeightedFrequency / neighbors.length) * 100 * 1.5));
      
      // ç»Ÿè®¡é‚»å±…çš„ä¸‹ä¸€æœŸç”Ÿè‚–ã€æ³¢è‰²ç­‰
      const zodiacFrequency = {};
      const colorFrequency = {};
      const tailFrequency = {};
      const bigSmallFrequency = { "å¤§": 0, "å°": 0 };
      const oddEvenFrequency = { "å•": 0, "åŒ": 0 };
      
      for (const neighbor of neighbors) {
        if (neighbor.nextZodiac) {
          zodiacFrequency[neighbor.nextZodiac] = (zodiacFrequency[neighbor.nextZodiac] || 0) + 1;
        }
        if (neighbor.nextColor) {
          colorFrequency[neighbor.nextColor] = (colorFrequency[neighbor.nextColor] || 0) + 1;
        }
        if (neighbor.nextTail !== undefined) {
          tailFrequency[neighbor.nextTail] = (tailFrequency[neighbor.nextTail] || 0) + 1;
        }
        if (neighbor.nextIsBig !== undefined) {
          bigSmallFrequency[neighbor.nextIsBig ? "å¤§" : "å°"]++;
        }
        if (neighbor.nextIsOdd !== undefined) {
          oddEvenFrequency[neighbor.nextIsOdd ? "å•" : "åŒ"]++;
        }
      }
      
      // æ‰¾å‡ºæœ€å¯èƒ½çš„ç”Ÿè‚–ã€æ³¢è‰²ç­‰
      const predictedZodiac = Object.entries(zodiacFrequency)
        .sort((a, b) => b[1] - a[1])
        .map(([zodiac, _]) => zodiac)
        .slice(0, 3);
      
      const predictedColor = Object.entries(colorFrequency)
        .sort((a, b) => b[1] - a[1])
        .map(([color, _]) => color)
        .slice(0, 2);
      
      const predictedTail = Object.entries(tailFrequency)
        .sort((a, b) => b[1] - a[1])
        .map(([tail, _]) => parseInt(tail))
        .slice(0, 3);
      
      const predictedBigSmall = Object.entries(bigSmallFrequency)
        .sort((a, b) => b[1] - a[1])
        .map(([type, _]) => type)[0] || "å¤§";
      
      const predictedOddEven = Object.entries(oddEvenFrequency)
        .sort((a, b) => b[1] - a[1])
        .map(([type, _]) => type)[0] || "å•";
      
      return {
        special: predictedSpecial,
        normals: predictedNormals,
        zodiac: predictedZodiac,
        color: predictedColor,
        tail: predictedTail,
        bigSmall: predictedBigSmall,
        oddEven: predictedOddEven,
        confidence: confidence,
        neighborCount: neighbors.length,
        patternsUsed: Object.keys(patterns).length - 2 // å‡å»totalRecordså’ŒæœŸæœ›å­—æ®µ
      };
    } catch (error) {
      Logger.error("EnhancedKNN", "é¢„æµ‹ä¸‹ä¸€æœŸå·ç å¤±è´¥", error);
      return {
        special: null,
        normals: [],
        zodiac: [],
        color: [],
        tail: [],
        bigSmall: "å¤§",
        oddEven: "å•",
        confidence: 0,
        neighborCount: 0,
        patternsUsed: 0
      };
    }
  }
  
  static clearCache() {
    try {
      this.distanceCache.clear();
      this.patternCache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 7. è‡ªåŠ¨ä»»åŠ¡è°ƒåº¦å™¨ï¼ˆå›ºå®šæ—¶é—´ï¼‰
// ==============================================================================

class AutoScheduler {
  static async checkAndRunScheduledTasks(env) {
    try {
      const beijingTime = Formatter.getBeijingTime();
      if (!beijingTime) {
        return { runSync: false, runPush: false };
      }
      
      let runSync = false;
      let runPush = false;
      
      // æ£€æŸ¥æ˜¯å¦åˆ°21:45ï¼ˆåŒæ­¥æ•°æ®ï¼‰
      if (beijingTime.hour === CONFIG.SYSTEM.DAILY_SYNC_TIME.hour && 
          beijingTime.minute === CONFIG.SYSTEM.DAILY_SYNC_TIME.minute) {
        runSync = true;
      }
      
      // æ£€æŸ¥æ˜¯å¦åˆ°21:30ï¼ˆæ¨é€é¢„æµ‹ï¼‰
      if (beijingTime.hour === CONFIG.SYSTEM.DAILY_PUSH_TIME.hour && 
          beijingTime.minute === CONFIG.SYSTEM.DAILY_PUSH_TIME.minute) {
        runPush = true;
      }
      
      const results = {};
      
      if (runSync) {
        Logger.info("AutoScheduler", "æ‰§è¡Œè‡ªåŠ¨åŒæ­¥ä»»åŠ¡", beijingTime);
        results.sync = await this.runAutoSync(env);
      }
      
      if (runPush) {
        Logger.info("AutoScheduler", "æ‰§è¡Œè‡ªåŠ¨æ¨é€ä»»åŠ¡", beijingTime);
        results.push = await this.runAutoPush(env);
      }
      
      if (runSync || runPush) {
        Logger.info("AutoScheduler", "è‡ªåŠ¨ä»»åŠ¡æ‰§è¡Œå®Œæˆ", results);
      }
      
      return {
        runSync,
        runPush,
        results,
        beijingTime: `${beijingTime.hour}:${beijingTime.minute}:${beijingTime.second}`
      };
    } catch (error) {
      Logger.error("AutoScheduler", "æ£€æŸ¥å¹¶æ‰§è¡Œè‡ªåŠ¨ä»»åŠ¡å¤±è´¥", error);
      return { runSync: false, runPush: false, error: error.message };
    }
  }
  
  static async runAutoSync(env) {
    try {
      // æ£€æŸ¥ä¸Šä¸€æ¬¡è‡ªåŠ¨åŒæ­¥æ—¶é—´
      const lastAutoSync = await DB.getSetting(env, "LAST_AUTO_SYNC", "");
      const currentTime = Formatter.formatBeijingTime();
      
      // å¦‚æœæ˜¯åŒä¸€å¤©å·²ç»åŒæ­¥è¿‡ï¼Œè·³è¿‡
      if (lastAutoSync && lastAutoSync.startsWith(currentTime.substring(0, 10))) {
        Logger.info("AutoScheduler", "ä»Šå¤©å·²ç»åŒæ­¥è¿‡æ•°æ®ï¼Œè·³è¿‡");
        return { 
          success: true, 
          skipped: true, 
          reason: "ä»Šå¤©å·²ç»åŒæ­¥è¿‡",
          lastSync: lastAutoSync 
        };
      }
      
      // æ‰§è¡ŒåŒæ­¥
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      if (result.success) {
        // ä¿å­˜åŒæ­¥è®°å½•
        await DB.saveSetting(env, "LAST_AUTO_SYNC", currentTime);
        const totalAutoSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_AUTO_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_AUTO_SYNCS", totalAutoSyncs.toString());
        
        Logger.info("AutoScheduler", "è‡ªåŠ¨åŒæ­¥å®Œæˆ", {
          added: result.added,
          skipped: result.skipped,
          totalAutoSyncs: totalAutoSyncs
        });
      }
      
      return {
        success: result.success,
        added: result.added || 0,
        skipped: result.skipped || 0,
        total: result.total || 0,
        timestamp: currentTime
      };
    } catch (error) {
      Logger.error("AutoScheduler", "è‡ªåŠ¨åŒæ­¥å¤±è´¥", error);
      return { success: false, error: error.message };
    }
  }
  
  static async runAutoPush(env) {
    try {
      // æ£€æŸ¥é¢‘é“ID
      if (!env.TG_CHANNEL_ID) {
        Logger.warn("AutoScheduler", "é¢‘é“IDæœªé…ç½®ï¼Œæ— æ³•è‡ªåŠ¨æ¨é€");
        return { success: false, error: "é¢‘é“IDæœªé…ç½®" };
      }
      
      // æ£€æŸ¥ä¸Šä¸€æ¬¡è‡ªåŠ¨æ¨é€æ—¶é—´
      const lastAutoPush = await DB.getSetting(env, "LAST_AUTO_PUSH", "");
      const currentTime = Formatter.formatBeijingTime();
      
      // å¦‚æœæ˜¯åŒä¸€å¤©å·²ç»æ¨é€è¿‡ï¼Œè·³è¿‡
      if (lastAutoPush && lastAutoPush.startsWith(currentTime.substring(0, 10))) {
        Logger.info("AutoScheduler", "ä»Šå¤©å·²ç»æ¨é€è¿‡é¢„æµ‹ï¼Œè·³è¿‡");
        return { 
          success: true, 
          skipped: true, 
          reason: "ä»Šå¤©å·²ç»æ¨é€è¿‡",
          lastPush: lastAutoPush 
        };
      }
      
      // è·å–å†å²æ•°æ®
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        Logger.warn("AutoScheduler", "æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆé¢„æµ‹");
        return { success: false, error: "æ— å†å²æ•°æ®" };
      }
      
      // ç”Ÿæˆé¢„æµ‹
      const weights = await DB.getWeights(env);
      const prediction = await EnhancedPredictionEngine.generate(env, history, weights, true);
      
      if (!prediction) {
        return { success: false, error: "ç”Ÿæˆé¢„æµ‹å¤±è´¥" };
      }
      
      // æ¨é€åˆ°é¢‘é“
      const message = MessageRenderer.renderPrediction(prediction);
      const sendResult = await ExternalService.sendMessage(env, env.TG_CHANNEL_ID, message);
      
      if (sendResult && sendResult.ok) {
        // ä¿å­˜æ¨é€è®°å½•
        await DB.saveSetting(env, "LAST_AUTO_PUSH", currentTime);
        const totalAutoPushes = Formatter.safeInt(await DB.getSetting(env, "TOTAL_AUTO_PUSHES", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_AUTO_PUSHES", totalAutoPushes.toString());
        
        Logger.info("AutoScheduler", "è‡ªåŠ¨æ¨é€å®Œæˆ", {
          expect: prediction.nextExpect,
          confidence: prediction.confidence,
          channelId: env.TG_CHANNEL_ID,
          totalAutoPushes: totalAutoPushes
        });
        
        return {
          success: true,
          expect: prediction.nextExpect,
          confidence: prediction.confidence,
          timestamp: currentTime
        };
      } else {
        Logger.error("AutoScheduler", "æ¨é€åˆ°é¢‘é“å¤±è´¥", sendResult);
        return { success: false, error: "æ¨é€å¤±è´¥" };
      }
    } catch (error) {
      Logger.error("AutoScheduler", "è‡ªåŠ¨æ¨é€å¤±è´¥", error);
      return { success: false, error: error.message };
    }
  }
}

// ==============================================================================
// 8. å¢å¼ºé¢„æµ‹å¼•æ“ï¼ˆåŸºäºKNNç®—æ³•ï¼‰
// ==============================================================================

class EnhancedPredictionEngine {
  static predictionCache = new Map();
  static patternCache = new Map();
  
  static async generate(env, history, weights, useEnhancedKNN = true) {
    try {
      if (!history || history.length < 2) {
        return this.generateStaticFallback();
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      // è®¡ç®—ä¸‹ä¸€æœŸæœŸå·
      let nextExpect = "2025001";
      const latestExpect = lastRecord.expect;
      if (latestExpect && Formatter.isValidExpect(latestExpect)) {
        const latestNum = Formatter.safeInt(latestExpect, 2025000);
        nextExpect = (latestNum + 1).toString();
      }
      
      const cacheKey = `prediction_${lastSpecial}_${history.length}_${weights._version || '1.0'}_${useEnhancedKNN}`;
      const cached = this.predictionCache.get(cacheKey);
      
      if (cached) {
        cached.nextExpect = nextExpect;
        return cached;
      }
      
      // é¢„å¤„ç†å†å²æ•°æ®
      const processedHistory = this.preprocessHistory(history);
      
      if (processedHistory.length < 2) {
        return this.generateStaticFallback();
      }
      
      // è·å–å½“å‰è®°å½•ï¼ˆæœ€æ–°ä¸€æœŸï¼‰
      const currentRecord = processedHistory[0];
      
      // åˆ†æå†å²è§„å¾‹
      const patterns = EnhancedKNNAlgorithm.analyzePatternsFromHistory(history);
      
      let prediction;
      if (useEnhancedKNN && processedHistory.length >= CONFIG.SYSTEM.KNN_K_VALUE) {
        // ä½¿ç”¨å¢å¼ºKNNç®—æ³•
        prediction = EnhancedKNNAlgorithm.predictNextNumbers(
          currentRecord, 
          processedHistory, 
          patterns, 
          CONFIG.SYSTEM.KNN_K_VALUE
        );
      } else {
        // ä½¿ç”¨ä¼ ç»Ÿç®—æ³•
        prediction = this.generateTraditionalPrediction(currentRecord, processedHistory, patterns);
      }
      
      // å¦‚æœé¢„æµ‹å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿç®—æ³•
      if (!prediction.special || prediction.confidence < 20) {
        prediction = this.generateTraditionalPrediction(currentRecord, processedHistory, patterns);
      }
      
      // ç¡®ä¿ç‰¹ç æœ‰æ•ˆ
      if (prediction.special < 1 || prediction.special > 49) {
        prediction.special = Math.floor(Math.random() * 49) + 1;
      }
      
      // ç¡®ä¿å¹³ç æœ‰æ•ˆä¸”ä¸é‡å¤
      const normals = [...new Set(prediction.normals.filter(n => n >= 1 && n <= 49 && n !== prediction.special))];
      while (normals.length < 6) {
        let num;
        do {
          num = Math.floor(Math.random() * 49) + 1;
        } while (normals.includes(num) || num === prediction.special);
        normals.push(num);
      }
      prediction.normals = normals.slice(0, 6);
      
      // è·å–å±æ€§
      const attr = Formatter.getAttributes(prediction.special);
      const isBig = prediction.special >= 25;
      const isOdd = prediction.special % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(prediction.special / 10);
      
      // æ ¼å¼åŒ–å¹³ç 
      const formattedNormals = prediction.normals.map(num => {
        const normalAttr = Formatter.getAttributes(num);
        return {
          number: num,
          zodiac: normalAttr.zodiac,
          color: normalAttr.color,
          isBig: num >= 25,
          isOdd: num % 2 !== 0
        };
      });
      
      // ç”Ÿæˆç‰¹ç æ¨èï¼ˆåŸºäºè§„å¾‹ï¼‰
      const specialRecommendations = this.generateSpecialRecommendations(currentRecord, patterns, 5);
      
      const finalPrediction = {
        nextExpect: nextExpect,
        specialNumbers: specialRecommendations,
        normalNumbers: formattedNormals,
        zodiac: {
          main: Array.isArray(prediction.zodiac) ? prediction.zodiac.slice(0, 3) : [],
          guard: Array.isArray(prediction.zodiac) ? prediction.zodiac.slice(3, 6) : []
        },
        color: {
          main: Array.isArray(prediction.color) ? prediction.color[0] : "red",
          guard: Array.isArray(prediction.color) ? prediction.color[1] : "blue"
        },
        tail: {
          main: Array.isArray(prediction.tail) ? prediction.tail.slice(0, 3) : [],
          guard: Array.isArray(prediction.tail) ? prediction.tail.slice(3, 6) : []
        },
        head: `${head}å¤´`,
        shape: shape,
        confidence: Math.min(95, Math.max(25, prediction.confidence)),
        analysisBased: true,
        enhancedKNNUsed: useEnhancedKNN,
        totalHistoryRecords: patterns.totalRecords || 0,
        patternsAnalyzed: prediction.patternsUsed || 0,
        basedOnLastRecord: {
          expect: lastRecord.expect || "æœªçŸ¥",
          openCode: lastOpenCode,
          special: lastSpecial,
          zodiac: attr.zodiac,
          color: attr.color
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V13.0-EnhancedKNN"
      };
      
      this.predictionCache.set(cacheKey, finalPrediction);
      return finalPrediction;
    } catch (error) {
      Logger.error("EnhancedPredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback();
    }
  }
  
  static preprocessHistory(history) {
    try {
      const processed = [];
      
      // å°†å†å²è®°å½•æŒ‰expectå‡åºæ’åˆ—ï¼ˆä»æ—§åˆ°æ–°ï¼‰
      const sortedHistory = [...history].sort((a, b) => 
        Formatter.compareExpect(a.expect, b.expect)
      );
      
      for (let i = 0; i < sortedHistory.length - 1; i++) {
        const currentRecord = sortedHistory[i];
        const nextRecord = sortedHistory[i + 1];
        
        if (currentRecord && currentRecord.open_code && nextRecord && nextRecord.open_code) {
          const currentNums = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const nextNums = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          
          if (currentNums.length >= 7 && nextNums.length >= 7) {
            const currentSpecial = currentNums[6] || 1;
            const nextSpecial = nextNums[6] || 1;
            const nextNormals = nextNums.slice(0, 6);
            
            const currentAttr = Formatter.getAttributes(currentSpecial);
            const nextAttr = Formatter.getAttributes(nextSpecial);
            
            processed.push({
              expect: currentRecord.expect,
              numbers: currentNums,
              special: currentSpecial,
              normals: currentNums.slice(0, 6),
              zodiac: currentAttr.zodiac,
              color: currentAttr.color,
              tail: currentSpecial % 10,
              normalTails: currentNums.slice(0, 6).map(n => n % 10),
              isBig: currentSpecial >= 25,
              isOdd: currentSpecial % 2 !== 0,
              nextExpect: nextRecord.expect,
              nextSpecial: nextSpecial,
              nextNormals: nextNormals,
              nextZodiac: nextAttr.zodiac,
              nextColor: nextAttr.color,
              nextTail: nextSpecial % 10,
              nextIsBig: nextSpecial >= 25,
              nextIsOdd: nextSpecial % 2 !== 0
            });
          }
        }
      }
      
      // åè½¬ï¼Œä½¿æœ€æ–°çš„åœ¨æœ€å‰é¢
      processed.reverse();
      
      return processed;
    } catch (error) {
      Logger.error("EnhancedPredictionEngine", "é¢„å¤„ç†å†å²æ•°æ®å¤±è´¥", error);
      return [];
    }
  }
  
  static generateTraditionalPrediction(currentRecord, processedHistory, patterns) {
    try {
      const result = {
        special: 0,
        normals: [],
        zodiac: [],
        color: [],
        tail: [],
        bigSmall: "å¤§",
        oddEven: "å•",
        confidence: 30,
        neighborCount: 0,
        patternsUsed: 0
      };
      
      if (!currentRecord || processedHistory.length === 0) {
        return this.generateRandomPrediction();
      }
      
      // åŸºäºç”Ÿè‚–è½¬ç§»æ¦‚ç‡
      const zodiacCandidates = [];
      if (currentRecord.zodiac && patterns.zodiacTransfer[currentRecord.zodiac]) {
        const zodiacProbs = patterns.zodiacTransfer[currentRecord.zodiac];
        const sortedZodiacs = Object.entries(zodiacProbs)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([zodiac, _]) => zodiac);
        
        result.zodiac = sortedZodiacs;
        
        // ä»æ¦‚ç‡æœ€é«˜çš„ç”Ÿè‚–ä¸­é€‰å·ç 
        for (const zodiac of sortedZodiacs) {
          const numbers = CONFIG.ZODIAC_MAP[zodiac] || [];
          zodiacCandidates.push(...numbers);
        }
      }
      
      // åŸºäºæ³¢è‰²è½¬ç§»æ¦‚ç‡
      const colorCandidates = [];
      if (currentRecord.color && patterns.colorTransfer[currentRecord.color]) {
        const colorProbs = patterns.colorTransfer[currentRecord.color];
        const sortedColors = Object.entries(colorProbs)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 2)
          .map(([color, _]) => color);
        
        result.color = sortedColors;
        
        // ä»æ¦‚ç‡æœ€é«˜çš„æ³¢è‰²ä¸­é€‰å·ç 
        for (const color of sortedColors) {
          const numbers = CONFIG.COLORS[color] || [];
          colorCandidates.push(...numbers);
        }
      }
      
      // åŸºäºå¹³ç å°¾æ•°->ç‰¹ç å°¾æ•°
      const tailCandidates = [];
      currentRecord.normalTails.forEach(tail => {
        if (patterns.normalTailToSpecialTail[tail]) {
          const tailProbs = patterns.normalTailToSpecialTail[tail];
          const sortedTails = Object.entries(tailProbs)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 2)
            .map(([tailNum, _]) => parseInt(tailNum));
          
          result.tail.push(...sortedTails);
          
          // ç”Ÿæˆå°¾æ•°å¯¹åº”çš„å·ç å€™é€‰
          for (const tailNum of sortedTails) {
            for (let num = tailNum; num <= 49; num += 10) {
              if (num >= 1 && num <= 49) {
                tailCandidates.push(num);
              }
            }
          }
        }
      });
      
      // åˆå¹¶æ‰€æœ‰å€™é€‰å·ç 
      const allCandidates = [...new Set([...zodiacCandidates, ...colorCandidates, ...tailCandidates])];
      
      // å¦‚æœæ²¡æœ‰å€™é€‰å·ç ï¼Œéšæœºç”Ÿæˆ
      if (allCandidates.length === 0) {
        return this.generateRandomPrediction();
      }
      
      // æ ¹æ®é¢‘ç‡æ’åºå€™é€‰å·ç 
      const scoredCandidates = allCandidates.map(num => {
        const freq = patterns.specialFrequency[num] || 0;
        const zodiacScore = result.zodiac.includes(Formatter.getAttributes(num).zodiac) ? 0.2 : 0;
        const colorScore = result.color.includes(Formatter.getAttributes(num).color) ? 0.15 : 0;
        const tailScore = result.tail.includes(num % 10) ? 0.1 : 0;
        
        return {
          number: num,
          score: freq + zodiacScore + colorScore + tailScore + Math.random() * 0.05
        };
      });
      
      scoredCandidates.sort((a, b) => b.score - a.score);
      
      // é€‰æ‹©ç‰¹ç 
      result.special = scoredCandidates[0]?.number || Math.floor(Math.random() * 49) + 1;
      
      // ç”Ÿæˆå¹³ç ï¼ˆæ’é™¤ç‰¹ç ï¼‰
      const usedNumbers = new Set([result.special]);
      result.normals = [];
      
      for (let i = 0; i < scoredCandidates.length && result.normals.length < 6; i++) {
        const candidate = scoredCandidates[i].number;
        if (!usedNumbers.has(candidate)) {
          result.normals.push(candidate);
          usedNumbers.add(candidate);
        }
      }
      
      // å¦‚æœå¹³ç ä¸è¶³ï¼Œè¡¥å……éšæœºå·ç 
      while (result.normals.length < 6) {
        let num;
        do {
          num = Math.floor(Math.random() * 49) + 1;
        } while (usedNumbers.has(num));
        
        result.normals.push(num);
        usedNumbers.add(num);
      }
      
      // ç¡®å®šå¤§å°å•åŒ
      result.bigSmall = result.special >= 25 ? "å¤§" : "å°";
      result.oddEven = result.special % 2 !== 0 ? "å•" : "åŒ";
      
      // è®¡ç®—ç½®ä¿¡åº¦
      const topCandidateScore = scoredCandidates[0]?.score || 0;
      const secondCandidateScore = scoredCandidates[1]?.score || 0;
      const scoreDifference = topCandidateScore - secondCandidateScore;
      
      result.confidence = 30 + Math.min(40, scoreDifference * 50);
      result.confidence = Math.min(85, result.confidence);
      
      return result;
    } catch (error) {
      Logger.error("EnhancedPredictionEngine", "ä¼ ç»Ÿé¢„æµ‹ç”Ÿæˆå¤±è´¥", error);
      return this.generateRandomPrediction();
    }
  }
  
  static generateSpecialRecommendations(currentRecord, patterns, count = 5) {
    try {
      const recommendations = [];
      const scores = {};
      
      // ä¸ºæ¯ä¸ªå·ç è¯„åˆ†
      for (let num = 1; num <= 49; num++) {
        let score = 0;
        const attr = Formatter.getAttributes(num);
        
        // 1. ç”Ÿè‚–è½¬ç§»æ¦‚ç‡
        if (currentRecord.zodiac && patterns.zodiacTransfer[currentRecord.zodiac]) {
          const zodiacProb = patterns.zodiacTransfer[currentRecord.zodiac][attr.zodiac] || 0;
          score += zodiacProb * 100;
        }
        
        // 2. æ³¢è‰²è½¬ç§»æ¦‚ç‡
        if (currentRecord.color && patterns.colorTransfer[currentRecord.color]) {
          const colorProb = patterns.colorTransfer[currentRecord.color][attr.color] || 0;
          score += colorProb * 80;
        }
        
        // 3. å¹³ç å°¾æ•°->ç‰¹ç å°¾æ•°æ¦‚ç‡
        currentRecord.normalTails.forEach(tail => {
          if (patterns.normalTailToSpecialTail[tail]) {
            const tailProb = patterns.normalTailToSpecialTail[tail][num % 10] || 0;
            score += tailProb * 60;
          }
        });
        
        // 4. ç‰¹ç é¢‘ç‡
        const freq = patterns.specialFrequency[num] || 0;
        score += freq * 40;
        
        // 5. å†·çƒ­å·ç è°ƒæ•´ï¼ˆå†·å·ç åŠ åˆ†ï¼‰
        if (patterns.coldNumbers[num] > 0) {
          const coldBonus = Math.min(30, patterns.coldNumbers[num] * 5);
          score += coldBonus;
        }
        
        // 6. éšæœºæ‰°åŠ¨
        score += Math.random() * 10;
        
        scores[num] = score;
      }
      
      // æ’åºå¹¶é€‰æ‹©å‰Nä¸ª
      const sortedNumbers = Object.entries(scores)
        .sort((a, b) => b[1] - a[1])
        .slice(0, count)
        .map(([num, score]) => {
          const numInt = parseInt(num);
          const attr = Formatter.getAttributes(numInt);
          return {
            number: numInt,
            score: Math.round(score),
            probability: (score / 300) * 100, // ç²—ç•¥ä¼°è®¡æ¦‚ç‡
            zodiac: attr.zodiac,
            color: attr.color,
            isBig: numInt >= 25,
            isOdd: numInt % 2 !== 0
          };
        });
      
      return sortedNumbers;
    } catch (error) {
      Logger.error("EnhancedPredictionEngine", "ç”Ÿæˆç‰¹ç æ¨èå¤±è´¥", error);
      return [];
    }
  }
  
  static generateRandomPrediction() {
    const result = {
      special: Math.floor(Math.random() * 49) + 1,
      normals: [],
      zodiac: [],
      color: [],
      tail: [],
      bigSmall: "å¤§",
      oddEven: "å•",
      confidence: 20,
      neighborCount: 0,
      patternsUsed: 0
    };
    
    // ç”Ÿæˆä¸é‡å¤çš„å¹³ç 
    const used = new Set([result.special]);
    while (result.normals.length < 6) {
      const num = Math.floor(Math.random() * 49) + 1;
      if (!used.has(num)) {
        result.normals.push(num);
        used.add(num);
      }
    }
    
    // éšæœºé€‰æ‹©ç”Ÿè‚–å’Œæ³¢è‰²
    const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
    const allColors = Object.keys(CONFIG.COLORS);
    
    result.zodiac = [
      allZodiacs[Math.floor(Math.random() * allZodiacs.length)],
      allZodiacs[Math.floor(Math.random() * allZodiacs.length)]
    ];
    
    result.color = [
      allColors[Math.floor(Math.random() * allColors.length)],
      allColors[Math.floor(Math.random() * allColors.length)]
    ];
    
    result.bigSmall = result.special >= 25 ? "å¤§" : "å°";
    result.oddEven = result.special % 2 !== 0 ? "å•" : "åŒ";
    
    return result;
  }
  
  static generateStaticFallback() {
    try {
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = Math.floor(Math.random() * allZodiacs.length);
      const colorIndex = Math.floor(Math.random() * colors.length);
      
      const mainZodiac = allZodiacs[zodiacIndex] || "é¼ ";
      const mainColor = colors[colorIndex] || "red";
      
      // ç”Ÿæˆç‰¹ç 
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        const num = Math.floor(Math.random() * 49) + 1;
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 100),
          probability: Math.random() * 0.1,
          zodiac: attr.zodiac,
          color: attr.color,
          isBig: num >= 25,
          isOdd: num % 2 !== 0
        });
      }
      
      // ç”Ÿæˆå¹³ç 
      const normalNumbers = [];
      const usedNumbers = new Set(specialNumbers.map(item => item.number));
      
      for (let i = 0; i < 6; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((usedNumbers.has(num) || num === specialNumbers[0]?.number) && attempts < 20);
        
        if (!usedNumbers.has(num)) {
          const attr = Formatter.getAttributes(num);
          normalNumbers.push({
            number: num,
            zodiac: attr.zodiac,
            color: attr.color,
            isBig: num >= 25,
            isOdd: num % 2 !== 0
          });
          usedNumbers.add(num);
        }
      }
      
      const bestSpecial = specialNumbers[0]?.number || 1;
      const isBig = bestSpecial >= 25;
      const isOdd = bestSpecial % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestSpecial / 10);
      
      return {
        nextExpect: "2025001",
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        zodiac: {
          main: [mainZodiac, allZodiacs[(zodiacIndex + 1) % allZodiacs.length]],
          guard: [allZodiacs[(zodiacIndex + 2) % allZodiacs.length]]
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length]
        },
        head: `${head}å¤´`,
        shape: shape,
        confidence: 20,
        analysisBased: false,
        enhancedKNNUsed: false,
        totalHistoryRecords: 0,
        patternsAnalyzed: 0,
        basedOnLastRecord: {
          expect: "æœªçŸ¥",
          special: 1,
          zodiac: "é¼ ",
          color: "red"
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V13.0-StaticFallback"
      };
    } catch (error) {
      Logger.error("EnhancedPredictionEngine", "ç”Ÿæˆé™æ€å›é€€å¤±è´¥", error);
      
      return {
        nextExpect: "2025001",
        specialNumbers: [],
        normalNumbers: [],
        zodiac: { main: [], guard: [] },
        color: { main: "red", guard: "blue" },
        head: "0å¤´",
        shape: "å°å•",
        confidence: 15,
        analysisBased: false,
        enhancedKNNUsed: false,
        totalHistoryRecords: 0,
        patternsAnalyzed: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V13.0-Error"
      };
    }
  }
  
  static clearCache() {
    try {
      this.predictionCache.clear();
      this.patternCache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 9. æ¶ˆæ¯æ¸²æŸ“å™¨
// ==============================================================================

class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME} - å‘½ä»¤æ¨¡æ¿</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `${CONFIG.EMOJI.refresh} <i>é˜²åˆ·å±æ¨¡å¼ï¼Œæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</i>\n\n`;
      
      message += `<b>ğŸ“‹ ä¸»è¦å‘½ä»¤ï¼š</b>\n`;
      message += `<code>/predict</code> - ç”Ÿæˆ/æ›´æ–°é¢„æµ‹ç»“æœ\n`;
      message += `<code>/history [é¡µç ]</code> - æŸ¥çœ‹å†å²è®°å½•\n`;
      message += `<code>/ccc</code> - æ˜¾ç¤ºæ­¤å‘½ä»¤æ¨¡æ¿\n`;
      message += `<code>/pattern</code> - æŸ¥çœ‹å½“å‰è§„å¾‹åˆ†æ\n`;
      message += `<code>/stats</code> - æŸ¥çœ‹ç³»ç»Ÿç»Ÿè®¡\n`;
      
      if (isAdmin) {
        message += `\n<b>ğŸ”§ ç®¡ç†å‘˜å‘½ä»¤ï¼š</b>\n`;
        message += `<code>/sync</code> - æ‰‹åŠ¨åŒæ­¥å†å²æ•°æ®\n`;
        message += `<code>/push</code> - æ‰‹åŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
        message += `<code>/delete [æœŸå·]</code> - åˆ é™¤å•æœŸè®°å½•\n`;
      }
      
      message += `\n<b>â° è‡ªåŠ¨ä»»åŠ¡ï¼š</b>\n`;
      message += `â€¢ æ¯å¤©21:45è‡ªåŠ¨åŒæ­¥æ•°æ®\n`;
      message += `â€¢ æ¯å¤©21:30è‡ªåŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
      message += `â€¢ æ— éœ€æ‰‹åŠ¨è®¾ç½®å®šæ—¶ä»»åŠ¡\n`;
      
      message += `\n<b>ğŸ§  å¢å¼ºç®—æ³•ï¼š</b>\n`;
      message += `â€¢ åŸºäºKNNç®—æ³•çš„å¢å¼ºé¢„æµ‹\n`;
      message += `â€¢ é›†æˆå¤šç§è§„å¾‹ç»Ÿè®¡åˆ†æ\n`;
      message += `â€¢ ç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°å¤šç»´åº¦åˆ†æ\n`;
      message += `â€¢ å¹³ç å°¾æ•°ä¸ç‰¹ç å°¾æ•°å…³è”åˆ†æ\n`;
      message += `â€¢ å†·çƒ­å·ç è¯†åˆ«\n`;
      
      message += `\n${CONFIG.EMOJI.refresh} <b>é˜²åˆ·å±ç‰¹æ€§ï¼š</b>\n`;
      message += `â€¢ æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `â€¢ å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `â€¢ ä¿æŒèŠå¤©ç•Œé¢æ•´æ´\n`;
      message += `â€¢ é˜²æ­¢æ¶ˆæ¯å †ç§¯\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å‘½ä»¤æ¨¡æ¿å¤±è´¥", error);
      return `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME}</b>\n\nä½¿ç”¨ /ccc æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨ã€‚`;
    }
  }

  static renderWelcomeMessage(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.home} <b>æ¬¢è¿ä½¿ç”¨ ${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `${CONFIG.EMOJI.refresh} <b>é˜²åˆ·å±æ¨¡å¼å·²å¯ç”¨</b>\n\n`;
      message += `æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `å‘é€ç›¸åŒå‘½ä»¤ä¼šè‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `\n${CONFIG.EMOJI.auto} <b>è‡ªåŠ¨ä»»åŠ¡å·²é…ç½®ï¼š</b>\n`;
      message += `â€¢ æ¯å¤©21:45è‡ªåŠ¨åŒæ­¥æ•°æ®\n`;
      message += `â€¢ æ¯å¤©21:30è‡ªåŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
      message += `\n${CONFIG.EMOJI.knn} <b>å¢å¼ºKNNç®—æ³•ï¼š</b>\n`;
      message += `â€¢ åŸºäºå†å²è§„å¾‹çš„å¤šç»´åº¦åˆ†æ\n`;
      message += `â€¢ é›†æˆç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ç­‰è§„å¾‹\n`;
      message += `\nä½¿ç”¨ <code>/ccc</code> æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨\n`;
      message += `ä½¿ç”¨ <code>/predict</code> ç”Ÿæˆæ–°é¢„æµ‹\n`;
      message += `ä½¿ç”¨ <code>/pattern</code> æŸ¥çœ‹è§„å¾‹åˆ†æ\n`;
      message += `\n${CONFIG.EMOJI.check} <b>ä¿æŒèŠå¤©ç•Œé¢æ•´æ´</b>\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¬¢è¿æ¶ˆæ¯å¤±è´¥", error);
      return `${CONFIG.EMOJI.home} <b>${CONFIG.SYSTEM.NAME}</b>\n\nç³»ç»Ÿè¿è¡Œæ­£å¸¸ã€‚`;
    }
  }

  static renderPrediction(prediction) {
    try {
      if (!prediction) {
        return `${CONFIG.EMOJI.warning} é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚`;
      }
      
      const nextExpect = Formatter.safeString(prediction.nextExpect, "æœªçŸ¥");
      const confidence = Formatter.safeInt(prediction.confidence, 0);
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const basedOnLastRecord = prediction.basedOnLastRecord || {};
      const analysisBased = prediction.analysisBased || false;
      const enhancedKNNUsed = prediction.enhancedKNNUsed || false;
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      const patternsAnalyzed = Formatter.safeInt(prediction.patternsAnalyzed, 0);
      const zodiac = prediction.zodiac || { main: [], guard: [] };
      const color = prediction.color || { main: "red", guard: "blue" };
      const head = Formatter.safeString(prediction.head, "æœªçŸ¥");
      const shape = Formatter.safeString(prediction.shape, "æœªçŸ¥");
      
      // ç®—æ³•æ ‡è¯†
      let algorithmInfo = "";
      if (enhancedKNNUsed) {
        algorithmInfo = `${CONFIG.EMOJI.knn} <b>å¢å¼ºKNNç®—æ³•é¢„æµ‹</b>\n`;
      } else {
        algorithmInfo = `${CONFIG.EMOJI.brain} <b>ä¼ ç»Ÿç®—æ³•é¢„æµ‹</b>\n`;
      }
      
      let dataSource = "";
      if (analysisBased && totalHistoryRecords > 0) {
        dataSource = `ğŸ“Š åŸºäº ${totalHistoryRecords} æœŸå†å²æ•°æ®åˆ†æ\n`;
        if (patternsAnalyzed > 0) {
          dataSource += `ğŸ§© åˆ†æäº† ${patternsAnalyzed} ç§è§„å¾‹æ¨¡å¼\n`;
        }
      } else {
        dataSource = `âš ï¸ åŸºäºé™æ€ç®—æ³•ç”Ÿæˆ\n`;
      }
      
      let basedOnInfo = "";
      if (basedOnLastRecord.expect) {
        const { expect, special, zodiac, color } = basedOnLastRecord;
        basedOnInfo = `ğŸ“ åŸºäº: ç¬¬ ${expect} æœŸ (ç‰¹ç ${special} | ${zodiac}${CONFIG.EMOJI[color]})\n`;
      }
      
      // æ ¼å¼åŒ–å¹³ç æ˜¾ç¤º
      let normalDisplay = "æš‚æ— æ•°æ®";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // æ ¼å¼åŒ–ç‰¹ç æ˜¾ç¤ºï¼ˆå¸¦æ¦‚ç‡ï¼‰
      let specialDisplay = "æš‚æ— æ•°æ®";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.slice(0, 5).map((num, index) => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.probability ? `(${(num.probability).toFixed(1)}%)` : "";
          const rank = index + 1;
          
          return `${rank}. ${numStr}(${zodiacStr}${colorEmoji})${prob}`;
        }).join("\n");
      }
      
      const zodiacMain = Array.isArray(zodiac.main) ? zodiac.main : [];
      const zodiacGuard = Array.isArray(zodiac.guard) ? zodiac.guard : [];
      
      const content = `
${CONFIG.EMOJI.fire} <b>${CONFIG.SYSTEM.NAME} - å¢å¼ºé¢„æµ‹</b>
${algorithmInfo}ç¬¬ <b>${nextExpect}</b> æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${basedOnInfo}
${CONFIG.EMOJI.star} <b>ç”Ÿè‚–æ¨è</b>
ä¸»æ¨: ${zodiacMain.join(" ") || "æš‚æ— "}
é˜²å®ˆ: ${zodiacGuard.join(" ") || "æš‚æ— "}

${CONFIG.EMOJI.diamond} <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[color.main] || ""} / é˜²${CONFIG.EMOJI[color.guard] || ""}

${CONFIG.EMOJI.rocket} <b>ç‰¹ç å‚è€ƒ (æ¦‚ç‡)</b>
${specialDisplay}

<b>ç²¾é€‰å¹³ç </b>
${normalDisplay}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>å½¢æ€åˆ†æ</b>
å¤´æ•°: ${head} | å½¢æ€: ${shape}

<b>ç½®ä¿¡åº¦</b>: ${confidence}%
<b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ç®—æ³•ç‰ˆæœ¬</b>: ${prediction.algorithmVersion || "V13.0"}
<b>å¢å¼ºKNN</b>: ${enhancedKNNUsed ? "å·²ä½¿ç”¨" : "æœªä½¿ç”¨"}
<b>æ¶ˆæ¯æ¨¡å¼</b>: ${CONFIG.EMOJI.refresh} æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯
<b>å†å²æ•°æ®</b>: ${totalHistoryRecords} æœŸ
<b>è§„å¾‹æ¨¡å¼</b>: ${patternsAnalyzed} ç§
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„æµ‹æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderPatternAnalysis(patterns) {
    try {
      if (!patterns || patterns.totalRecords === 0) {
        return `${CONFIG.EMOJI.warning} æš‚æ— è§„å¾‹åˆ†ææ•°æ®ï¼Œè¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚`;
      }
      
      let message = `${CONFIG.EMOJI.pattern} <b>å†å²è§„å¾‹åˆ†ææŠ¥å‘Š</b>\n\n`;
      message += `åˆ†æè®°å½•æ•°: ${patterns.totalRecords || 0} æœŸ\n`;
      message += `åˆ†ææ—¶é—´èŒƒå›´: ${patterns.firstExpect || "æœªçŸ¥"} ~ ${patterns.lastExpect || "æœªçŸ¥"}\n`;
      message += `è§„å¾‹æ¨¡å¼æ•°é‡: ${Object.keys(patterns).length - 2} ç§\n\n`;
      
      message += `<b>ğŸ“Š ç»Ÿè®¡æ¦‚è§ˆï¼š</b>\n`;
      
      // æ‰¾å‡ºæœ€å¸¸è§çš„ç”Ÿè‚–è½¬ç§»
      let topZodiacTransfer = "";
      let maxZodiacCount = 0;
      Object.keys(patterns.zodiacTransfer || {}).forEach(zodiac1 => {
        Object.keys(patterns.zodiacTransfer[zodiac1] || {}).forEach(zodiac2 => {
          const count = patterns.zodiacTransfer[zodiac1][zodiac2] * patterns.totalRecords;
          if (count > maxZodiacCount) {
            maxZodiacCount = count;
            topZodiacTransfer = `${zodiac1}â†’${zodiac2} (${count}æ¬¡)`;
          }
        });
      });
      
      if (topZodiacTransfer) {
        message += `æœ€å¸¸è§ç”Ÿè‚–è½¬ç§»: ${topZodiacTransfer}\n`;
      }
      
      // æ‰¾å‡ºæœ€å¸¸è§çš„æ³¢è‰²è½¬ç§»
      let topColorTransfer = "";
      let maxColorCount = 0;
      Object.keys(patterns.colorTransfer || {}).forEach(color1 => {
        Object.keys(patterns.colorTransfer[color1] || {}).forEach(color2 => {
          const count = patterns.colorTransfer[color1][color2] * patterns.totalRecords;
          if (count > maxColorCount) {
            maxColorCount = count;
            topColorTransfer = `${color1}â†’${color2} (${count}æ¬¡)`;
          }
        });
      });
      
      if (topColorTransfer) {
        message += `æœ€å¸¸è§æ³¢è‰²è½¬ç§»: ${topColorTransfer}\n`;
      }
      
      // å¹³ç å°¾æ•°->ç‰¹ç å°¾æ•°å…³è”
      if (Object.keys(patterns.normalTailToSpecialTail || {}).length > 0) {
        message += `\n<b>ğŸ”¢ å¹³ç å°¾æ•°â†’ç‰¹ç å°¾æ•°å…³è”ï¼š</b>\n`;
        
        const tailStats = [];
        Object.keys(patterns.normalTailToSpecialTail || {}).forEach(tail => {
          const total = Object.values(patterns.normalTailToSpecialTail[tail] || {}).reduce((a, b) => a + b, 0);
          if (total > 0.1) { // è‡³å°‘10%çš„ç›¸å…³æ€§
            const mostCommon = Object.entries(patterns.normalTailToSpecialTail[tail] || {})
              .sort((a, b) => b[1] - a[1])[0];
            
            if (mostCommon && mostCommon[1] > 0.2) { // è‡³å°‘20%çš„æ¦‚ç‡
              tailStats.push(`å°¾${tail}â†’å°¾${mostCommon[0]} (${(mostCommon[1] * 100).toFixed(1)}%)`);
            }
          }
        });
        
        if (tailStats.length > 0) {
          message += tailStats.slice(0, 5).join(" | ") + "\n";
        } else {
          message += "æš‚æ— æ˜¾è‘—å…³è”\n";
        }
      }
      
      // å†·çƒ­å·ç åˆ†æ
      const coldNumbers = Object.entries(patterns.coldNumbers || {})
        .filter(([_, count]) => count > 5) // è¿ç»­5æœŸä»¥ä¸Šæœªå‡ºç°
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([num, count]) => `${num}(${count}æœŸ)`);
      
      if (coldNumbers.length > 0) {
        message += `\n<b>ğŸ§Š å†·å·ç  (é•¿æœŸæœªå‡º)ï¼š</b>\n`;
        message += coldNumbers.join(" ") + "\n";
      }
      
      // ç›¸åŒç”Ÿè‚–è¿ç»­å‡ºç°ç»Ÿè®¡
      const continuousZodiacs = Object.entries(patterns.sameZodiacContinuity || {})
        .filter(([_, prob]) => prob > 0.05) // è‡³å°‘5%çš„æ¦‚ç‡è¿ç»­å‡ºç°
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      if (continuousZodiacs.length > 0) {
        message += `\n<b>ğŸ”„ æ˜“è¿ç»­å‡ºç°çš„ç”Ÿè‚–ï¼š</b>\n`;
        continuousZodiacs.forEach(([zodiac, prob]) => {
          message += `${zodiac}: ${(prob * 100).toFixed(1)}% | `;
        });
        message += "\n";
      }
      
      // å¤§å°å•åŒè½¬ç§»
      message += `\n<b>âš–ï¸ å¤§å°å•åŒè½¬ç§»æ¦‚ç‡ï¼š</b>\n`;
      if (patterns.bigSmallTransfer && patterns.bigSmallTransfer["å¤§"] && patterns.bigSmallTransfer["å°"]) {
        message += `å¤§â†’å¤§: ${((patterns.bigSmallTransfer["å¤§"]["å¤§"] || 0) * 100).toFixed(1)}% | `;
        message += `å¤§â†’å°: ${((patterns.bigSmallTransfer["å¤§"]["å°"] || 0) * 100).toFixed(1)}%\n`;
        message += `å°â†’å°: ${((patterns.bigSmallTransfer["å°"]["å°"] || 0) * 100).toFixed(1)}% | `;
        message += `å°â†’å¤§: ${((patterns.bigSmallTransfer["å°"]["å¤§"] || 0) * 100).toFixed(1)}%\n`;
      }
      
      if (patterns.oddEvenTransfer && patterns.oddEvenTransfer["å•"] && patterns.oddEvenTransfer["åŒ"]) {
        message += `å•â†’å•: ${((patterns.oddEvenTransfer["å•"]["å•"] || 0) * 100).toFixed(1)}% | `;
        message += `å•â†’åŒ: ${((patterns.oddEvenTransfer["å•"]["åŒ"] || 0) * 100).toFixed(1)}%\n`;
        message += `åŒâ†’åŒ: ${((patterns.oddEvenTransfer["åŒ"]["åŒ"] || 0) * 100).toFixed(1)}% | `;
        message += `åŒâ†’å•: ${((patterns.oddEvenTransfer["åŒ"]["å•"] || 0) * 100).toFixed(1)}%\n`;
      }
      
      message += `\n${CONFIG.EMOJI.info} <i>ä»¥ä¸Šåˆ†æåŸºäºå†å²æ•°æ®ç»Ÿè®¡ï¼Œä»…ä¾›å‚è€ƒ</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“è§„å¾‹åˆ†æå¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} æ¸²æŸ“è§„å¾‹åˆ†ææ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderSystemStats(env, historyCount) {
    try {
      // è¿™äº›æ•°æ®éœ€è¦åœ¨è°ƒç”¨æ—¶ä»æ•°æ®åº“è·å–
      const lastSync = "éœ€è¦ä»æ•°æ®åº“è·å–"; // å®é™…åº”ä»DB.getSettingè·å–
      const lastAutoSync = "éœ€è¦ä»æ•°æ®åº“è·å–";
      const lastAutoPush = "éœ€è¦ä»æ•°æ®åº“è·å–";
      const totalSyncs = "éœ€è¦ä»æ•°æ®åº“è·å–";
      const totalAutoSyncs = "éœ€è¦ä»æ•°æ®åº“è·å–";
      const totalAutoPushes = "éœ€è¦ä»æ•°æ®åº“è·å–";
      
      let message = `${CONFIG.EMOJI.chart} <b>ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯</b>\n\n`;
      
      message += `<b>ğŸ“ˆ æ•°æ®ç»Ÿè®¡ï¼š</b>\n`;
      message += `å†å²è®°å½•æ€»æ•°: ${historyCount || 0} æœŸ\n`;
      message += `æœ€è¿‘åŒæ­¥æ—¶é—´: ${lastSync || "ä»æœªåŒæ­¥"}\n`;
      message += `æ€»åŒæ­¥æ¬¡æ•°: ${totalSyncs || 0} æ¬¡\n\n`;
      
      message += `<b>ğŸ¤– è‡ªåŠ¨ä»»åŠ¡ç»Ÿè®¡ï¼š</b>\n`;
      message += `æœ€è¿‘è‡ªåŠ¨åŒæ­¥: ${lastAutoSync || "ä»æœªæ‰§è¡Œ"}\n`;
      message += `æœ€è¿‘è‡ªåŠ¨æ¨é€: ${lastAutoPush || "ä»æœªæ‰§è¡Œ"}\n`;
      message += `è‡ªåŠ¨åŒæ­¥æ¬¡æ•°: ${totalAutoSyncs || 0} æ¬¡\n`;
      message += `è‡ªåŠ¨æ¨é€æ¬¡æ•°: ${totalAutoPushes || 0} æ¬¡\n\n`;
      
      message += `<b>â° è‡ªåŠ¨ä»»åŠ¡æ—¶é—´ï¼š</b>\n`;
      message += `æ•°æ®åŒæ­¥: æ¯å¤© ${CONFIG.SYSTEM.DAILY_SYNC_TIME.hour}:${CONFIG.SYSTEM.DAILY_SYNC_TIME.minute} (åŒ—äº¬æ—¶é—´)\n`;
      message += `é¢„æµ‹æ¨é€: æ¯å¤© ${CONFIG.SYSTEM.DAILY_PUSH_TIME.hour}:${CONFIG.SYSTEM.DAILY_PUSH_TIME.minute} (åŒ—äº¬æ—¶é—´)\n\n`;
      
      message += `<b>ğŸ§  ç®—æ³•é…ç½®ï¼š</b>\n`;
      message += `KNNé‚»å±…æ•°é‡: ${CONFIG.SYSTEM.KNN_K_VALUE}\n`;
      message += `å†å²è®°å½•é™åˆ¶: ${CONFIG.SYSTEM.HISTORY_LIMIT} æœŸ\n`;
      message += `ç¼“å­˜æœ‰æ•ˆæœŸ: ${CONFIG.SYSTEM.CACHE_TTL / 1000} ç§’\n\n`;
      
      message += `${CONFIG.EMOJI.info} <i>ç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œè‡ªåŠ¨ä»»åŠ¡å·²é…ç½®</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“ç³»ç»Ÿç»Ÿè®¡å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} æ¸²æŸ“ç³»ç»Ÿç»Ÿè®¡æ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.database} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      message += `\nä½¿ç”¨ <code>/history ${page + 1}</code> æŸ¥çœ‹ä¸‹ä¸€é¡µ`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /history å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.database} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\nğŸ“ <b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
        
        // å¦‚æœæ˜¯è‡ªåŠ¨åŒæ­¥ï¼Œæ˜¾ç¤ºæ—¶é—´
        if (result.timestamp) {
          message += `\nğŸ•’ åŒæ­¥æ—¶é—´: ${result.timestamp}\n`;
        }
      } else {
        message += `âŒ <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /sync å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderPushResult(success, prediction, isAuto = false) {
    try {
      let message = `${CONFIG.EMOJI.fire} <b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `âœ… <b>æ¨é€æˆåŠŸ</b>\n`;
        if (isAuto) {
          message += `ğŸ“… <i>è‡ªåŠ¨æ¨é€ä»»åŠ¡</i>\n`;
        }
        message += `æœŸå·: ${prediction?.nextExpect || "æœªçŸ¥"}\n`;
        message += `ç½®ä¿¡åº¦: ${prediction?.confidence || 0}%\n`;
        message += `ç®—æ³•: ${prediction?.algorithmVersion || "V13.0"}\n`;
        
        if (isAuto) {
          message += `\nâ° ä¸‹æ¬¡è‡ªåŠ¨æ¨é€: æ¯å¤© ${CONFIG.SYSTEM.DAILY_PUSH_TIME.hour}:${CONFIG.SYSTEM.DAILY_PUSH_TIME.minute} (åŒ—äº¬æ—¶é—´)`;
        }
      } else {
        message += `âŒ <b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      if (!isAuto) {
        message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /push å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      }
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteConfirmation(expectRange, impactInfo) {
    try {
      const { toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤</b>\n\n`;
      
      if (expectRange.includes('-')) {
        const [start, end] = expectRange.split('-');
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(start)}</b> æœŸåˆ°ç¬¬ <b>${Formatter.safeString(end)}</b> æœŸçš„è®°å½•\n`;
      } else {
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(expectRange)}</b> æœŸçš„è®°å½•\n`;
      }
      
      message += `æ¶‰åŠ <b>${toDeleteCount || 0}</b> æ¡å†å²è®°å½•\n\n`;
      
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        message += `åˆ é™¤åï¼Œæœ€æ–°è®°å½•ä¸º:\n`;
        message += `ç¬¬ <b>${latestAfterDelete.expect || "æœªçŸ¥"}</b> æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
      } else {
        message += `åˆ é™¤åå°†æ— å†å²è®°å½•\n`;
      }
      
      message += `\n${CONFIG.EMOJI.warning} <b>è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼</b>\n\n`;
      message += `è¯·å›å¤ <code>ç¡®è®¤åˆ é™¤ ${Formatter.safeString(expectRange)}</code> ä»¥ç¡®è®¤åˆ é™¤ã€‚`;
      
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç¡®è®¤å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤å¤±è´¥</b>\n\næ— æ³•ç”Ÿæˆç¡®è®¤ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `âœ… <b>åˆ é™¤æˆåŠŸ</b>\n`;
        message += `åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
        message += `åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
        
        if (result.total !== undefined) {
          message += `èŒƒå›´å†…è®°å½•æ•°: ${result.total} æ¡\n`;
        }
        
        // æ˜¾ç¤ºåˆ é™¤åçš„æœ€æ–°è®°å½•
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          message += `\n${CONFIG.EMOJI.check} <b>åˆ é™¤åæœ€æ–°è®°å½•</b>\n`;
          message += `ç¬¬ ${latestAfterDelete.expect} æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `âŒ <b>åˆ é™¤å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\næ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\nå¤„ç†åˆ é™¤ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }
}

// ==============================================================================
// 10. å¤–éƒ¨æ¥å£å°è£…
// ==============================================================================

class ExternalService {
  static async sendMessage(env, chatId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  static async editMessage(env, chatId, messageId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  static async deleteMessage(env, chatId, messageId) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage?chat_id=${chatId}&message_id=${messageId}`;

      const response = await fetch(url, {
        method: "POST"
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.warn("Telegram", `deleteMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "deleteMessage network error", error);
      return null;
    }
  }

  static async sendAndDeleteOldMessage(env, chatId, messageType, text) {
    try {
      const oldMessageId = MessageManager.getUserMessage(chatId, messageType);
      
      if (oldMessageId) {
        this.deleteMessage(env, chatId, oldMessageId).then(result => {
          if (result && result.ok) {
            Logger.info("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          } else {
            Logger.warn("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¤±è´¥æˆ–æ¶ˆæ¯å·²ä¸å­˜åœ¨: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          }
        }).catch(error => {
          Logger.error("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¼‚å¸¸: chatId=${chatId}, type=${messageType}`, error);
        });
      }
      
      const sendResult = await this.sendMessage(env, chatId, text);
      
      if (sendResult && sendResult.ok && sendResult.result) {
        const newMessageId = sendResult.result.message_id;
        
        MessageManager.setUserMessage(chatId, messageType, newMessageId);
        
        MessageManager.cleanupOldMessages(chatId, 10);
        
        Logger.info("Telegram", `å‘é€æ–°æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${newMessageId}, æ—§æ¶ˆæ¯ID=${oldMessageId || 'æ— '}`);
        
        return { 
          success: true, 
          messageId: newMessageId, 
          oldMessageId: oldMessageId,
          message: oldMessageId ? "å·²åˆ é™¤æ—§æ¶ˆæ¯å¹¶å‘é€æ–°æ¶ˆæ¯" : "å‘é€æ–°æ¶ˆæ¯"
        };
      }
      
      return { 
        success: false, 
        error: "æ¶ˆæ¯å‘é€å¤±è´¥",
        oldMessageId: oldMessageId
      };
    } catch (error) {
      Logger.error("Telegram", "sendAndDeleteOldMessageå¤±è´¥", error);
      return { 
        success: false, 
        error: error.message,
        method: "error"
      };
    }
  }

  static async sendTemporaryMessage(env, chatId, text, parseMode = "HTML") {
    return await this.sendMessage(env, chatId, text, parseMode);
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/13.0',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        
        // æ¸…é™¤ç¼“å­˜
        CacheManager.clear();
        EnhancedKNNAlgorithm.clearCache();
        EnhancedPredictionEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 11. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨
// ==============================================================================

class Controller {
  static pendingDeletions = new Map();

  // å¤„ç†å¼€å§‹å‘½ä»¤
  static async handleStart(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†startå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  // å¤„ç†å‘½ä»¤æ¨¡æ¿
  static async handleCommandTemplate(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†cccå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  // å¤„ç†é¢„æµ‹
  static async handlePredict(env, chatId) {
    try {
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await EnhancedPredictionEngine.generate(env, history, weights, true);
      
      const message = MessageRenderer.renderPrediction(prediction);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†predictå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>ç”Ÿæˆé¢„æµ‹å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†è§„å¾‹åˆ†æ
  static async handlePatternAnalysis(env, chatId) {
    try {
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•åˆ†æè§„å¾‹ã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PATTERN_ANALYSIS, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const patterns = EnhancedKNNAlgorithm.analyzePatternsFromHistory(history);
      const message = MessageRenderer.renderPatternAnalysis(patterns);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PATTERN_ANALYSIS, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†patternå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>è§„å¾‹åˆ†æå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PATTERN_ANALYSIS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†ç³»ç»Ÿç»Ÿè®¡
  static async handleStatistics(env, chatId) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const message = MessageRenderer.renderSystemStats(env, historyCount);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATISTICS, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†statså‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATISTICS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†å†å²è®°å½•
  static async handleHistory(env, chatId, pageStr = "1") {
    try {
      const page = Math.max(1, Formatter.safeInt(pageStr, 1));
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†historyå‘½ä»¤å¤±è´¥", error);
      const errorMessage = "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†åŒæ­¥
  static async handleSync(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åŒæ­¥æ•°æ®ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.database} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      const message = MessageRenderer.renderSyncResult(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†æ¨é€
  static async handlePush(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥æ¨é€é¢„æµ‹ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    if (!env.TG_CHANNEL_ID) {
      const message = "âŒ <b>é¢‘é“IDæœªé…ç½®</b>\n\næ— æ³•æ¨é€åˆ°é¢‘é“ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.fire} <b>æ­£åœ¨ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆæ¨é€ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await EnhancedPredictionEngine.generate(env, history, weights, true);
      
      if (!prediction) {
        const message = "âŒ <b>ç”Ÿæˆé¢„æµ‹å¤±è´¥</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      // æ¨é€åˆ°é¢‘é“
      const channelMessage = MessageRenderer.renderPrediction(prediction);
      const sendResult = await ExternalService.sendTemporaryMessage(env, env.TG_CHANNEL_ID, channelMessage);
      
      let success = false;
      if (sendResult && sendResult.ok) {
        success = true;
        Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${prediction.nextExpect}`);
      } else {
        Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", sendResult);
      }
      
      const message = MessageRenderer.renderPushResult(success, prediction, false);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
    } catch (error) {
      Logger.error("Push", "æ¨é€å¤„ç†å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†åˆ é™¤
  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åˆ é™¤è®°å½•ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        const message = `âŒ <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        const message = "âŒ <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        const message = `âš ï¸ <b>æœªæ‰¾åˆ°è®°å½•</b>\n\nåœ¨ ${expectRange} èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å†å²è®°å½•ã€‚`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, confirmMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, confirmMessage);
      }
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // ç¡®è®¤åˆ é™¤
  static async confirmDelete(env, chatId, userId, confirmText) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const pendingDeletion = this.pendingDeletions.get(deletionKey);
      
      if (!pendingDeletion) {
        const message = "âŒ <b>åˆ é™¤æ“ä½œå·²è¿‡æœŸæˆ–æ— æ•ˆ</b>\n\nè¯·é‡æ–°å‘èµ·åˆ é™¤å‘½ä»¤ã€‚";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectedConfirm = `ç¡®è®¤åˆ é™¤ ${pendingDeletion.expectRange}`;
      if (confirmText !== expectedConfirm) {
        const message = `âŒ <b>ç¡®è®¤æ–‡æœ¬ä¸æ­£ç¡®</b>\n\nè¯·å›å¤: <code>${expectedConfirm}</code>`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      this.pendingDeletions.delete(deletionKey);
      
      const processingMessage = `${CONFIG.EMOJI.trash} <b>æ­£åœ¨åˆ é™¤è®°å½•...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await DB.deleteHistoryByRange(
        env, 
        pendingDeletion.start, 
        pendingDeletion.end,
        Formatter.safeString(userId),
        "æ‰‹åŠ¨åˆ é™¤"
      );
      
      if (!result.success) {
        const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange);
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        return;
      }
      
      CacheManager.clear();
      EnhancedKNNAlgorithm.clearCache();
      EnhancedPredictionEngine.clearCache();
      
      const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange, pendingDeletion.impactInfo);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå®Œæˆ: ${pendingDeletion.expectRange}, åˆ é™¤è®°å½•æ•°: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "ç¡®è®¤åˆ é™¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>åˆ é™¤æ“ä½œå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
}

// ==============================================================================
// 12. äº‹ä»¶å¤„ç†å™¨
// ==============================================================================

async function handleUpdate(env, payload) {
  try {
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId, isAdmin });
    
    // å¤„ç†ç¡®è®¤åˆ é™¤
    if (text.startsWith('ç¡®è®¤åˆ é™¤ ')) {
      if (isAdmin) {
        await Controller.confirmDelete(env, chatId, userId, text);
      } else {
        const message = "âŒ <b>æƒé™ä¸è¶³</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, "permission_error", message
        );
      }
      return;
    }
    
    // å¤„ç†å‘½ä»¤
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
          
        case '/predict':
        case '/p':
          await Controller.handlePredict(env, chatId);
          break;
          
        case '/pattern':
        case '/analysis':
          await Controller.handlePatternAnalysis(env, chatId);
          break;
          
        case '/stats':
        case '/statistics':
          await Controller.handleStatistics(env, chatId);
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        default:
          // æœªçŸ¥å‘½ä»¤ï¼Œæ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
      }
    } else {
      // éå‘½ä»¤æ¶ˆæ¯ï¼Œæ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿
      await Controller.handleCommandTemplate(env, chatId, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}

// ==============================================================================
// 13. Worker å…¥å£ç‚¹
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "YOUR_CHANNEL_ID_HERE";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "YOUR_ADMIN_ID_HERE";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response("Database Initialization Failed. Please check D1 binding.", { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      // è‡ªåŠ¨ä»»åŠ¡è§¦å‘å™¨ï¼ˆæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼‰
      if (url.pathname === "/cron" || url.pathname === "/auto") {
        try {
          const result = await AutoScheduler.checkAndRunScheduledTasks(env);
          
          return new Response(JSON.stringify({
            status: "OK",
            runSync: result.runSync || false,
            runPush: result.runPush || false,
            beijingTime: result.beijingTime,
            results: result.results || {},
            timestamp: new Date().toISOString()
          }, null, 2), {
            headers: { 
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
        } catch (error) {
          Logger.error("Cron", "è‡ªåŠ¨ä»»åŠ¡æ‰§è¡Œå¤±è´¥", error);
          return new Response(JSON.stringify({
            status: "ERROR",
            error: error.message,
            timestamp: new Date().toISOString()
          }, null, 2), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
      
      // å¥åº·æ£€æŸ¥
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const beijingTime = Formatter.getBeijingTime();
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              beijingTime: beijingTime ? `${beijingTime.hour}:${beijingTime.minute}:${beijingTime.second}` : "æœªçŸ¥",
              timestamp: new Date().toISOString(),
              database: {
                historyCount: historyCount
              },
              config: {
                dailySyncTime: `${CONFIG.SYSTEM.DAILY_SYNC_TIME.hour}:${CONFIG.SYSTEM.DAILY_SYNC_TIME.minute}`,
                dailyPushTime: `${CONFIG.SYSTEM.DAILY_PUSH_TIME.hour}:${CONFIG.SYSTEM.DAILY_PUSH_TIME.minute}`,
                knnKValue: CONFIG.SYSTEM.KNN_K_VALUE,
                historyLimit: CONFIG.SYSTEM.HISTORY_LIMIT
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            EnhancedKNNAlgorithm.clearCache();
            EnhancedPredictionEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤"
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/test-knn") {
          try {
            const startTime = Date.now();
            const history = await DB.getAllHistory(env);
            
            if (history.length === 0) {
              return new Response(JSON.stringify({
                status: "ERROR",
                message: "æ— å†å²æ•°æ®"
              }, null, 2), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
              });
            }
            
            const patterns = EnhancedKNNAlgorithm.analyzePatternsFromHistory(history);
            const duration = Date.now() - startTime;
            
            return new Response(JSON.stringify({
              status: "OK",
              duration: `${duration}ms`,
              historyCount: history.length,
              patternCount: Object.keys(patterns).length - 2,
              zodiacTransferCount: Object.keys(patterns.zodiacTransfer || {}).length,
              colorTransferCount: Object.keys(patterns.colorTransfer || {}).length,
              normalTailToSpecialTailCount: Object.keys(patterns.normalTailToSpecialTail || {}).length,
              coldNumbersCount: Object.keys(patterns.coldNumbers || {}).length,
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/auto-info") {
          try {
            const beijingTime = Formatter.getBeijingTime();
            const beijingTimeStr = beijingTime ? `${beijingTime.hour}:${beijingTime.minute}:${beijingTime.second}` : "æœªçŸ¥";
            
            const nextSyncTime = `${CONFIG.SYSTEM.DAILY_SYNC_TIME.hour}:${CONFIG.SYSTEM.DAILY_SYNC_TIME.minute}`;
            const nextPushTime = `${CONFIG.SYSTEM.DAILY_PUSH_TIME.hour}:${CONFIG.SYSTEM.DAILY_PUSH_TIME.minute}`;
            
            return new Response(JSON.stringify({
              status: "OK",
              beijingTime: beijingTimeStr,
              dailySyncTime: nextSyncTime,
              dailyPushTime: nextPushTime,
              syncHour: CONFIG.SYSTEM.DAILY_SYNC_TIME.hour,
              syncMinute: CONFIG.SYSTEM.DAILY_SYNC_TIME.minute,
              pushHour: CONFIG.SYSTEM.DAILY_PUSH_TIME.hour,
              pushMinute: CONFIG.SYSTEM.DAILY_PUSH_TIME.minute,
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // ä¸»é¡µæ˜¾ç¤º
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .feature-list {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .feature-item {
                  margin-bottom: 10px;
                  color: #2d3748;
                }
                .feature-item:before {
                  content: "âœ… ";
                  margin-right: 8px;
                }
                .command-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .command {
                  margin-bottom: 8px;
                  color: #276749;
                  font-family: monospace;
                  background: #e6fffa;
                  padding: 5px 10px;
                  border-radius: 5px;
                  display: inline-block;
                }
                .auto-task {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .algorithm-info {
                  background: #fffaf0;
                  border: 1px solid #ed8936;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #dd6b20;
                }
                .anti-spam {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .api-endpoints {
                  background: #f7fafc;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #2d3748;
                }
                .api-endpoint {
                  font-family: monospace;
                  background: #edf2f7;
                  padding: 3px 8px;
                  border-radius: 3px;
                  margin: 2px 0;
                  display: inline-block;
                }
                .enhanced {
                  background: linear-gradient(45deg, #667eea, #764ba2);
                  color: white;
                  padding: 5px 10px;
                  border-radius: 5px;
                  font-weight: bold;
                  display: inline-block;
                  margin: 5px 0;
                }
                .knn-badge {
                  background: linear-gradient(45deg, #f56565, #ed8936);
                  color: white;
                  padding: 3px 8px;
                  border-radius: 4px;
                  font-size: 0.8em;
                  margin-left: 5px;
                  display: inline-block;
                }
                .timing {
                  background: linear-gradient(45deg, #38b2ac, #319795);
                  color: white;
                  padding: 3px 8px;
                  border-radius: 4px;
                  font-size: 0.9em;
                  margin-left: 5px;
                  display: inline-block;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION}</div>
                
                <div class="feature-list">
                  <h3>ç³»ç»Ÿç‰¹æ€§</h3>
                  <div class="feature-item">é˜²åˆ·å±æ¨¡å¼ï¼šæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</div>
                  <div class="feature-item"><span class="enhanced">å¢å¼ºKNNç®—æ³•</span>ï¼šé›†æˆå¤šç§è§„å¾‹ç»Ÿè®¡åˆ†æ</div>
                  <div class="feature-item"><span class="timing">å›ºå®šæ—¶é—´è‡ªåŠ¨ä»»åŠ¡</span>ï¼šæ¯å¤©21:45åŒæ­¥ï¼Œ21:30æ¨é€</div>
                  <div class="feature-item">ç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°å¤šç»´åº¦åˆ†æ</div>
                  <div class="feature-item">å¹³ç å°¾æ•°ä¸ç‰¹ç å°¾æ•°å…³è”åˆ†æ</div>
                  <div class="feature-item">å†·çƒ­å·ç è¯†åˆ«å’Œé—´éš”è§„å¾‹ç»Ÿè®¡</div>
                  <div class="feature-item">å¤§å°å•åŒè½¬ç§»æ¦‚ç‡åˆ†æ</div>
                  <div class="feature-item">å³æ—¶é¢„æµ‹ï¼Œæ— éœ€ç­‰å¾…</div>
                  <div class="feature-item">åŸºäºå…¨éƒ¨å†å²æ•°æ®åˆ†æ</div>
                  <div class="feature-item">çº¯æ–‡æœ¬å‘½ä»¤äº¤äº’</div>
                </div>
                
                <div class="command-list">
                  <h3>ä¸»è¦å‘½ä»¤</h3>
                  <div class="command">/start - æ¬¢è¿ä¿¡æ¯</div>
                  <div class="command">/ccc - æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿</div>
                  <div class="command">/predict - ç”Ÿæˆé¢„æµ‹</div>
                  <div class="command">/pattern - æŸ¥çœ‹è§„å¾‹åˆ†æ</div>
                  <div class="command">/stats - æŸ¥çœ‹ç³»ç»Ÿç»Ÿè®¡</div>
                  <div class="command">/history [é¡µç ] - æŸ¥çœ‹å†å²</div>
                  <div class="command">/sync - æ‰‹åŠ¨åŒæ­¥æ•°æ®(ç®¡ç†å‘˜)</div>
                  <div class="command">/push - æ‰‹åŠ¨æ¨é€é¢„æµ‹(ç®¡ç†å‘˜)</div>
                  <div class="command">/delete [æœŸå·] - åˆ é™¤è®°å½•(ç®¡ç†å‘˜)</div>
                </div>
                
                <div class="auto-task">
                  <strong>${CONFIG.EMOJI.timing} è‡ªåŠ¨ä»»åŠ¡é…ç½®ï¼š</strong><br>
                  â€¢ æ•°æ®åŒæ­¥: <b>æ¯å¤© ${CONFIG.SYSTEM.DAILY_SYNC_TIME.hour}:${CONFIG.SYSTEM.DAILY_SYNC_TIME.minute} (åŒ—äº¬æ—¶é—´)</b><br>
                  â€¢ é¢„æµ‹æ¨é€: <b>æ¯å¤© ${CONFIG.SYSTEM.DAILY_PUSH_TIME.hour}:${CONFIG.SYSTEM.DAILY_PUSH_TIME.minute} (åŒ—äº¬æ—¶é—´)</b><br>
                  â€¢ æ— éœ€æ‰‹åŠ¨è®¾ç½®å®šæ—¶ä»»åŠ¡<br>
                  â€¢ è‡ªåŠ¨æ£€æŸ¥å¹¶æ‰§è¡Œ<br>
                  â€¢ æ¯æ—¥åªæ‰§è¡Œä¸€æ¬¡
                </div>
                
                <div class="algorithm-info">
                  <strong>${CONFIG.EMOJI.knn} å¢å¼ºKNNç®—æ³•ï¼š</strong><br>
                  â€¢ åŸºäºå…¨éƒ¨å†å²è®°å½•åˆ†æ<br>
                  â€¢ é›†æˆ15ç§è§„å¾‹æ¨¡å¼ç»Ÿè®¡<br>
                  â€¢ ç”Ÿè‚–è½¬ç§»æ¦‚ç‡åˆ†æ<br>
                  â€¢ æ³¢è‰²è½¬ç§»æ¦‚ç‡åˆ†æ<br>
                  â€¢ å¹³ç å°¾æ•°â†’ç‰¹ç å°¾æ•°å…³è”<br>
                  â€¢ ç‰¹ç å°¾æ•°â†’å¹³ç å°¾æ•°å…³è”<br>
                  â€¢ å¤§å°å•åŒè½¬ç§»åˆ†æ<br>
                  â€¢ å†·çƒ­å·ç è¯†åˆ«<br>
                  â€¢ é—´éš”è§„å¾‹ç»Ÿè®¡ï¼ˆç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ï¼‰<br>
                  â€¢ ç›¸åŒç”Ÿè‚–/æ³¢è‰²è¿ç»­å‡ºç°åˆ†æ
                </div>
                
                <div class="anti-spam">
                  <strong>${CONFIG.EMOJI.refresh} é˜²åˆ·å±ç‰¹æ€§ï¼š</strong><br>
                  â€¢ æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯<br>
                  â€¢ å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯<br>
                  â€¢ ä¿æŒèŠå¤©ç•Œé¢æ•´æ´ï¼Œé˜²æ­¢æ¶ˆæ¯å †ç§¯<br>
                  â€¢ ç”¨æˆ·æ¯ä¸ªå‘½ä»¤ç±»å‹æœ€å¤šä¿ç•™10æ¡æœ€æ–°æ¶ˆæ¯
                </div>
                
                <div class="api-endpoints">
                  <strong>APIç«¯ç‚¹ï¼š</strong><br>
                  <div class="api-endpoint">GET /health - ç³»ç»Ÿå¥åº·æ£€æŸ¥</div>
                  <div class="api-endpoint">GET /reset-cache - é‡ç½®ç¼“å­˜</div>
                  <div class="api-endpoint">GET /test-knn - æµ‹è¯•KNNç®—æ³•</div>
                  <div class="api-endpoint">GET /auto-info - è‡ªåŠ¨ä»»åŠ¡ä¿¡æ¯</div>
                  <div class="api-endpoint">GET /cron - è§¦å‘è‡ªåŠ¨ä»»åŠ¡</div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 8px;">
                  <strong>æ›´æ–°å†…å®¹ï¼š</strong><br>
                  â€¢ ç§»é™¤è’™ç‰¹å¡æ´›æ¨¡æ‹ŸåŠŸèƒ½<br>
                  â€¢ ç§»é™¤æ‰‹åŠ¨è®¾ç½®å®šæ—¶ä»»åŠ¡åŠŸèƒ½<br>
                  â€¢ æ·»åŠ åŒ—äº¬æ—¶é—´21:45è‡ªåŠ¨åŒæ­¥æ•°æ®<br>
                  â€¢ æ·»åŠ åŒ—äº¬æ—¶é—´21:30è‡ªåŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“<br>
                  â€¢ æ·»åŠ å¢å¼ºKNNç®—æ³•ï¼Œé›†æˆå¤šç§è§„å¾‹ç»Ÿè®¡<br>
                  â€¢ ä¿ç•™æ‰‹åŠ¨åŒæ­¥å’Œæ‰‹åŠ¨æ¨é€åŠŸèƒ½<br>
                  â€¢ ä¼˜åŒ–ç®—æ³•æƒé‡é…ç½®
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response("Internal Server Error", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};
