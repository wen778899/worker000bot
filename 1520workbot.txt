export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const pathname = url.pathname;
    const method = request.method;
    
    console.log(`[${new Date().toISOString()}] ${method} ${pathname}`);
    
    // å¤„ç† CORS é¢„æ£€è¯·æ±‚
    if (method === 'OPTIONS') {
      return handleCORS();
    }
    
    // è·¯ç”±åŒ¹é…
    const routes = {
      // åˆå§‹åŒ–å’Œç®¡ç†
      'GET:/init-db': () => handleInitDB(env),
      'GET:/test-db': () => testDBConnection(env),
      'GET:/health': () => handleHealthCheck(env),
      'GET:/status': () => handleHealthCheck(env),
      'GET:/test': () => handleTest(),
      'GET:/ping': () => handleTest(),
      
      // Telegram Webhook
      'POST:/telegram-webhook': () => handleTelegramWebhook(request, env),
      
      // å†å²æ•°æ® API - æŒ‰ç±»å‹å’Œå¹´ä»½
      // GET /xg/2025 - é¦™æ¸¯å…­åˆå½©2025å¹´æ•°æ®
      // GET /om/2025 - è€æ¾³21:30 2025å¹´æ•°æ®
      // æ”¯æŒæ­£åˆ™è·¯ç”±åŒ¹é…
      'GET:/xg': () => handleLotteryData(env, 'xg', url),
      'GET:/om': () => handleLotteryData(env, 'om', url),
      'GET:/xg/:year': (params) => handleLotteryData(env, 'xg', url, params.year),
      'GET:/om/:year': (params) => handleLotteryData(env, 'om', url, params.year),
      
      // ç®¡ç†å‘˜æ¥å£
      'POST:/admin/import': () => handleAdminImport(request, env),
      'GET:/admin/records': () => handleListRecords(request, env),
      'GET:/admin/record/:expect': (params) => handleGetRecord(request, env, params),
      'PUT:/admin/record/:expect': (params) => handleUpdateRecord(request, env, params),
      'DELETE:/admin/record/:expect': (params) => handleDeleteRecord(request, env, params),
      'GET:/admin/stats': () => handleAdminStats(env),
      'POST:/admin/batch-delete': () => handleBatchDelete(request, env),
    };
    
    // åŠ¨æ€è·¯ç”±åŒ¹é…
    for (const [routePattern, handler] of Object.entries(routes)) {
      const [routeMethod, routePath] = routePattern.split(':');
      
      if (method === routeMethod) {
        const match = matchRoute(routePath, pathname);
        if (match) {
          return await handler(match.params);
        }
      }
    }
    
    // å¤„ç†åŠ¨æ€å½©ç¥¨ç±»å‹è·¯ç”±
    const dynamicMatch = pathname.match(/^\/([a-z]+)\/(\d{4})$/);
    if (dynamicMatch && method === 'GET') {
      const [, type, year] = dynamicMatch;
      return await handleLotteryData(env, type, url, year);
    }
    
    // å¤„ç†åŠ¨æ€å½©ç¥¨ç±»å‹æ ¹è·¯ç”±ï¼ˆè·å–æœ€æ–°æ•°æ®ï¼‰
    const typeMatch = pathname.match(/^\/([a-z]+)$/);
    if (typeMatch && method === 'GET') {
      const [, type] = typeMatch;
      return await handleLotteryData(env, type, url);
    }
    
    // æ ¹è·¯å¾„è¿”å› API æ–‡æ¡£
    return handleAPIDocs();
  }
};

// ==================== è·¯ç”±åŒ¹é…å‡½æ•° ====================
function matchRoute(routePath, requestPath) {
  const routeParts = routePath.split('/').filter(Boolean);
  const requestParts = requestPath.split('/').filter(Boolean);
  
  if (routeParts.length !== requestParts.length) {
    return null;
  }
  
  const params = {};
  
  for (let i = 0; i < routeParts.length; i++) {
    const routePart = routeParts[i];
    const requestPart = requestParts[i];
    
    if (routePart.startsWith(':')) {
      const paramName = routePart.slice(1);
      params[paramName] = requestPart;
    } else if (routePart !== requestPart) {
      return null;
    }
  }
  
  return { params };
}

// ==================== å½©ç¥¨ç±»å‹é…ç½® ====================
const LOTTERY_CONFIG = {
  // é¦™æ¸¯å…­åˆå½©
  xg: {
    name: 'é¦™æ¸¯å…­åˆå½©',
    displayName: 'é¦™æ¸¯å…­åˆå½©',
    pattern: 'é¦™æ¸¯å…­åˆå½©ç¬¬:',
    description: 'é¦™æ¸¯å…­åˆå½©å¼€å¥–è®°å½•',
    defaultInfo: 'é¦™æ¸¯èµ›é©¬ä¼šå®˜æ–¹å¼€å¥–'
  },
  
  // è€æ¾³21:30
  om: {
    name: 'è€æ¾³21.30',
    displayName: 'è€æ¾³21:30',
    pattern: 'è€æ¾³21.30ç¬¬:',
    description: 'è€æ¾³21:30å¼€å¥–è®°å½•',
    defaultInfo: 'æ¾³é—¨å½©ç¥¨æœ‰é™å…¬å¸'
  }
  
  // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šå½©ç¥¨ç±»å‹
  // ajc: { name: 'æ¾³åŸºæœƒ', pattern: 'æ¾³åŸºæœƒç¬¬:' },
  // twbg: { name: 'å°ç£è³“æœ', pattern: 'å°ç£è³“æœç¬¬:' }
};

// ==================== å·¥å…·å‡½æ•° ====================
function handleCORS() {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, X-API-Key, Authorization, X-Lottery-Type',
      'Access-Control-Max-Age': '86400'
    }
  });
}

function jsonResponse(data, status = 200, headers = {}) {
  const defaultHeaders = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Cache-Control': 'public, max-age=300'
  };
  
  return new Response(JSON.stringify(data, null, 2), {
    status,
    headers: { ...defaultHeaders, ...headers }
  });
}

function validateApiKey(request, env) {
  const apiKey = request.headers.get('X-API-Key');
  
  if (!env.ADMIN_API_KEY) {
    return { valid: false, message: 'æœåŠ¡å™¨æœªé…ç½®APIå¯†é’¥' };
  }
  if (!apiKey) {
    return { valid: false, message: 'ç¼ºå°‘APIå¯†é’¥' };
  }
  if (apiKey !== env.ADMIN_API_KEY) {
    return { valid: false, message: 'æ— æ•ˆçš„APIå¯†é’¥' };
  }
  
  return { valid: true };
}

// ==================== API æ–‡æ¡£ ====================
function handleAPIDocs() {
  const currentYear = new Date().getFullYear();
  
  return jsonResponse({
    result: true,
    message: 'å½©ç¥¨å¼€å¥–è®°å½• API - æŒ‰ç±»å‹åˆ†ç±»å­˜å‚¨',
    timestamp: new Date().toISOString(),
    endpoints: {
      // å…¬å¼€API
      health_check: '/health (GET, å¥åº·æ£€æŸ¥)',
      test: '/test (GET, æµ‹è¯•Worker)',
      
      // å½©ç¥¨æ•°æ®API
      hk_lottery: `/xg/${currentYear} (GET, é¦™æ¸¯å…­åˆå½©${currentYear}å¹´æ•°æ®)`,
      macau_lottery: `/om/${currentYear} (GET, è€æ¾³21:30 ${currentYear}å¹´æ•°æ®)`,
      lottery_by_type: '/{type}/{year} (GET, æŒ‰ç±»å‹å’Œå¹´ä»½è·å–æ•°æ®)',
      latest_data: '/{type} (GET, è·å–æŒ‡å®šç±»å‹çš„æœ€æ–°æ•°æ®)',
      
      // ç®¡ç†å‘˜API
      admin_import: '/admin/import (POST, éœ€è¦APIå¯†é’¥)',
      admin_list: '/admin/records (GET, éœ€è¦APIå¯†é’¥)',
      admin_stats: '/admin/stats (GET, éœ€è¦APIå¯†é’¥)',
      admin_get: '/admin/record/{expect} (GET, éœ€è¦APIå¯†é’¥)',
      admin_update: '/admin/record/{expect} (PUT, éœ€è¦APIå¯†é’¥)',
      admin_delete: '/admin/record/{expect} (DELETE, éœ€è¦APIå¯†é’¥)',
      admin_batch_delete: '/admin/batch-delete (POST, éœ€è¦APIå¯†é’¥)'
    },
    available_types: Object.entries(LOTTERY_CONFIG).map(([code, config]) => ({
      code,
      name: config.displayName,
      pattern: config.pattern,
      example: `/${code}/${currentYear}`
    })),
    examples: {
      hk_2025: '/xg/2025',
      macau_2025: '/om/2025',
      latest_hk: '/xg',
      latest_macau: '/om'
    }
  });
}

function handleTest() {
  return jsonResponse({
    status: 'ok',
    message: 'Worker is running',
    timestamp: new Date().toISOString()
  });
}

// ==================== æ•°æ®åº“åˆå§‹åŒ– ====================
async function handleInitDB(env) {
  console.log('å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“...');
  
  try {
    if (!env.DB) {
      return jsonResponse({
        result: false,
        message: 'æ•°æ®åº“ç»‘å®šä¸å­˜åœ¨',
        solution: 'è¯·åœ¨Workerè®¾ç½®ä¸­æ·»åŠ DBå˜é‡ç»‘å®šåˆ°D1æ•°æ®åº“'
      }, 500);
    }
    
    // æ£€æŸ¥è¡¨æ˜¯å¦å·²å­˜åœ¨
    const existingTable = await env.DB.prepare(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='lottery_records'"
    ).first();
    
    if (existingTable) {
      console.log('è¡¨å·²å­˜åœ¨ï¼Œæ£€æŸ¥è¡¨ç»“æ„...');
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ lottery_type å­—æ®µ
      const tableInfo = await env.DB.prepare('PRAGMA table_info(lottery_records)').all();
      const hasTypeField = tableInfo.results.some(col => col.name === 'lottery_type');
      
      if (!hasTypeField) {
        console.log('æ·»åŠ  lottery_type å­—æ®µ...');
        await env.DB.prepare('ALTER TABLE lottery_records ADD COLUMN lottery_type TEXT DEFAULT \'unknown\'').run();
      }
      
      return jsonResponse({
        result: true,
        message: 'è¡¨å·²å­˜åœ¨ï¼Œè¡¨ç»“æ„å·²æ›´æ–°',
        existing: true
      });
    }
    
    // åˆ›å»ºæ–°è¡¨
    const createTableSQL = `
      CREATE TABLE lottery_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        expect TEXT NOT NULL,
        lottery_type TEXT NOT NULL,
        open_time TEXT NOT NULL,
        open_code TEXT NOT NULL,
        zodiac TEXT,
        emojis TEXT,
        verify INTEGER DEFAULT 0,
        info TEXT,
        source_message TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(expect, lottery_type)
      )
    `;
    
    console.log('åˆ›å»ºè¡¨...');
    await env.DB.prepare(createTableSQL).run();
    
    // åˆ›å»ºç´¢å¼•
    const indexes = [
      'CREATE INDEX idx_lottery_type ON lottery_records(lottery_type)',
      'CREATE INDEX idx_expect ON lottery_records(expect)',
      'CREATE INDEX idx_open_time ON lottery_records(open_time)',
      'CREATE INDEX idx_type_expect ON lottery_records(lottery_type, expect)',
      'CREATE INDEX idx_type_year ON lottery_records(lottery_type, strftime(\'%Y\', open_time))'
    ];
    
    for (const sql of indexes) {
      try {
        await env.DB.prepare(sql).run();
      } catch (error) {
        console.warn(`åˆ›å»ºç´¢å¼•å¤±è´¥: ${error.message}`);
      }
    }
    
    // æ’å…¥æµ‹è¯•æ•°æ®
    const testTypes = Object.keys(LOTTERY_CONFIG);
    for (const type of testTypes) {
      try {
        const testData = {
          expect: `TEST${Date.now().toString().slice(-6)}`,
          lottery_type: type,
          open_time: new Date().toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, ''),
          open_code: '01,02,03,04,05,06,07',
          zodiac: 'é¼ ,ç‰›,è™,å…”,é¾,è›‡,é¦¬',
          info: LOTTERY_CONFIG[type].defaultInfo || 'æµ‹è¯•æ•°æ®'
        };
        
        await env.DB.prepare(`
          INSERT INTO lottery_records (expect, lottery_type, open_time, open_code, zodiac, info)
          VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
          testData.expect,
          testData.lottery_type,
          testData.open_time,
          testData.open_code,
          testData.zodiac,
          testData.info
        ).run();
      } catch (error) {
        console.warn(`æ’å…¥${type}æµ‹è¯•æ•°æ®å¤±è´¥:`, error.message);
      }
    }
    
    return jsonResponse({
      result: true,
      message: 'æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ',
      tables: ['lottery_records'],
      indexes: indexes.length,
      test_data: testTypes
    });
    
  } catch (error) {
    console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
    return jsonResponse({
      result: false,
      message: 'æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥',
      error: error.message
    }, 500);
  }
}

// ==================== å¥åº·æ£€æŸ¥ ====================
async function handleHealthCheck(env) {
  try {
    let dbStatus = 'unknown';
    let dbError = null;
    let tableCount = 0;
    
    if (env.DB) {
      try {
        const result = await env.DB.prepare('SELECT 1 as test').first();
        dbStatus = result ? 'connected' : 'error';
        
        // è·å–è¡¨ä¿¡æ¯
        const tables = await env.DB.prepare(
          "SELECT name FROM sqlite_master WHERE type='table'"
        ).all();
        tableCount = tables.results ? tables.results.length : 0;
        
      } catch (error) {
        dbStatus = 'error';
        dbError = error.message;
      }
    } else {
      dbStatus = 'no-binding';
    }
    
    return jsonResponse({
      status: 'ok',
      timestamp: new Date().toISOString(),
      services: {
        worker: 'running',
        database: dbStatus,
        telegram: env.TELEGRAM_BOT_TOKEN ? 'configured' : 'not-configured'
      },
      statistics: {
        tables: tableCount,
        lottery_types: Object.keys(LOTTERY_CONFIG).length
      },
      environment: {
        hasDB: !!env.DB,
        hasTelegramToken: !!env.TELEGRAM_BOT_TOKEN,
        hasAdminId: !!env.TELEGRAM_ADMIN_ID,
        hasApiKey: !!env.ADMIN_API_KEY
      },
      error: dbError
    });
  } catch (error) {
    return jsonResponse({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    }, 500);
  }
}

// ==================== æ•°æ®åº“è¿æ¥æµ‹è¯• ====================
async function testDBConnection(env) {
  try {
    if (!env.DB) {
      return jsonResponse({
        result: false,
        message: 'æ•°æ®åº“ç»‘å®šä¸å­˜åœ¨'
      }, 500);
    }
    
    // æµ‹è¯•åŸºæœ¬æŸ¥è¯¢
    const test1 = await env.DB.prepare('SELECT 1 as test_value').first();
    
    // è·å–æ‰€æœ‰è¡¨
    const tablesResult = await env.DB.prepare(
      "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
    ).all();
    
    // æ£€æŸ¥å½©ç¥¨è®°å½•è¡¨ç»“æ„
    let tableStructure = null;
    if (tablesResult.results.some(t => t.name === 'lottery_records')) {
      tableStructure = await env.DB.prepare('PRAGMA table_info(lottery_records)').all();
    }
    
    // ç»Ÿè®¡å„ç±»å‹æ•°æ®é‡
    let typeStats = [];
    if (tableStructure) {
      try {
        const statsResult = await env.DB.prepare(`
          SELECT lottery_type, COUNT(*) as count 
          FROM lottery_records 
          GROUP BY lottery_type 
          ORDER BY count DESC
        `).all();
        
        typeStats = statsResult.results || [];
      } catch (error) {
        console.warn('è·å–ç±»å‹ç»Ÿè®¡å¤±è´¥:', error.message);
      }
    }
    
    return jsonResponse({
      result: true,
      message: 'æ•°æ®åº“è¿æ¥æµ‹è¯•å®Œæˆ',
      database: {
        basic_query: test1 ? 'æˆåŠŸ' : 'å¤±è´¥',
        tables: tablesResult.results ? tablesResult.results.map(t => t.name) : [],
        lottery_table_structure: tableStructure ? tableStructure.results : null
      },
      statistics: {
        by_type: typeStats,
        total_records: typeStats.reduce((sum, stat) => sum + stat.count, 0)
      },
      supported_types: Object.keys(LOTTERY_CONFIG)
    });
  } catch (error) {
    console.error('æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥:', error);
    return jsonResponse({
      result: false,
      message: 'æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥',
      error: error.message
    }, 500);
  }
}

// ==================== Telegram Webhook å¤„ç† ====================
async function handleTelegramWebhook(request, env) {
  try {
    const update = await request.json();
    console.log('æ”¶åˆ°Telegramæ¶ˆæ¯:', JSON.stringify(update, null, 2));
    
    // å¤„ç†é¢‘é“æ¶ˆæ¯
    if (update.channel_post) {
      const message = update.channel_post;
      await processLotteryMessage(message, env);
    }
    
    // å¤„ç†ç®¡ç†å‘˜ç§èŠ
    if (update.message && update.message.from.id.toString() === env.TELEGRAM_ADMIN_ID) {
      await processAdminMessage(update.message, env);
    }
    
    return new Response('OK');
  } catch (error) {
    console.error('Telegram webhooké”™è¯¯:', error);
    return new Response('Error', { status: 500 });
  }
}

async function processLotteryMessage(message, env) {
  try {
    const text = message.text || '';
    const messageId = message.message_id;
    
    console.log(`å¤„ç†æ¶ˆæ¯ #${messageId}:`, text.substring(0, 100) + '...');
    
    const lines = text.split('\n').map(line => line.trim()).filter(line => line);
    
    if (lines.length < 3) {
      console.log('æ¶ˆæ¯æ ¼å¼æ— æ•ˆ');
      return;
    }
    
    // è¯†åˆ«å½©ç¥¨ç±»å‹
    const firstLine = lines[0];
    let lotteryType = null;
    
    for (const [typeCode, config] of Object.entries(LOTTERY_CONFIG)) {
      if (firstLine.includes(config.pattern)) {
        lotteryType = typeCode;
        break;
      }
    }
    
    if (!lotteryType) {
      console.log('æœªçŸ¥çš„å½©ç¥¨ç±»å‹ï¼Œè·³è¿‡å¤„ç†');
      return;
    }
    
    console.log(`è¯†åˆ«åˆ°å½©ç¥¨ç±»å‹: ${lotteryType} (${LOTTERY_CONFIG[lotteryType].displayName})`);
    
    // è§£ææœŸå· - æ”¯æŒä¸åŒæ ¼å¼
    let expect = null;
    const expectMatch = firstLine.match(/:?(\d{6,7})æœŸ/);
    if (expectMatch) {
      expect = expectMatch[1];
    } else {
      // å°è¯•å…¶ä»–æ ¼å¼
      const altMatch = firstLine.match(/\d{6,7}/);
      if (altMatch) {
        expect = altMatch[0];
      }
    }
    
    if (!expect) {
      console.log('æœªæ‰¾åˆ°æœŸå·');
      return;
    }
    
    console.log('æœŸå·:', expect);
    
    // è§£æå¼€å¥–å·ç ï¼ˆç¬¬äºŒè¡Œï¼‰
    const numbersLine = lines[1];
    const numbers = numbersLine.trim().split(/\s+/).map(num => {
      return num.padStart(2, '0');
    });
    
    if (numbers.length < 6 || numbers.length > 7) {
      console.log('å·ç æ•°é‡æ— æ•ˆ:', numbers.length);
      return;
    }
    
    const openCode = numbers.join(',');
    console.log('å¼€å¥–å·ç :', openCode);
    
    // è§£æç”Ÿè‚–ï¼ˆç¬¬ä¸‰è¡Œï¼‰
    const zodiacLine = lines[2];
    const zodiacs = zodiacLine.trim().split(/\s+/);
    const zodiac = zodiacs.join(',');
    console.log('ç”Ÿè‚–:', zodiac);
    
    // è§£æè¡¨æƒ…ç¬¦å·ï¼ˆç¬¬å››è¡Œï¼Œå¦‚æœæœ‰ï¼‰
    let emojis = null;
    if (lines.length >= 4) {
      const emojiLine = lines[3];
      emojis = emojiLine.trim().replace(/\s+/g, ',');
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await env.DB.prepare(
      'SELECT id FROM lottery_records WHERE expect = ? AND lottery_type = ?'
    ).bind(expect, lotteryType).first();
    
    if (existing) {
      console.log('è®°å½•å·²å­˜åœ¨:', lotteryType, expect);
      return;
    }
    
    // å¼€å¥–æ—¶é—´
    const openTime = new Date(message.date * 1000).toISOString()
      .replace('T', ' ')
      .replace(/\.\d{3}Z$/, '');
    
    // è·å–å½©ç¥¨é…ç½®
    const config = LOTTERY_CONFIG[lotteryType];
    
    // æ’å…¥æ•°æ®åº“
    await env.DB.prepare(`
      INSERT INTO lottery_records 
      (expect, lottery_type, open_time, open_code, zodiac, emojis, verify, info, source_message)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      expect,
      lotteryType,
      openTime,
      openCode,
      zodiac,
      emojis,
      0,
      config.defaultInfo || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com',
      text.substring(0, 500) // ä¿å­˜åŸå§‹æ¶ˆæ¯å‰500å­—ç¬¦
    ).run();
    
    console.log(`è®°å½•ä¿å­˜æˆåŠŸ: ${lotteryType} - ${expect}`);
    
    // å‘é€ç¡®è®¤æ¶ˆæ¯ç»™ç®¡ç†å‘˜
    if (env.TELEGRAM_ADMIN_ID && env.TELEGRAM_BOT_TOKEN) {
      const botResponse = `âœ… ä¿å­˜å¼€å¥–è®°å½•æˆåŠŸ\nç±»å‹ï¼š${config.displayName}\næœŸå·ï¼š${expect}\nå·ç ï¼š${openCode}\næ—¶é—´ï¼š${openTime}`;
      await sendTelegramMessage(env.TELEGRAM_ADMIN_ID, botResponse, env.TELEGRAM_BOT_TOKEN);
    }
    
  } catch (error) {
    console.error('å¤„ç†å½©ç¥¨æ¶ˆæ¯é”™è¯¯:', error);
  }
}

async function processAdminMessage(message, env) {
  const text = message.text.trim();
  const chatId = message.chat.id;
  
  const commands = {
    '/start': `ğŸ° å½©ç¥¨å¼€å¥–è®°å½•ç®¡ç† Bot\n\næ”¯æŒçš„ç±»å‹:\n${Object.entries(LOTTERY_CONFIG).map(([code, config]) => `  /${code} - ${config.displayName}`).join('\n')}\n\nå¯ç”¨å‘½ä»¤:\n/list - æŸ¥çœ‹æœ€æ–°è®°å½•\n/stats - ç»Ÿè®¡æ•°æ®\n/types - æŸ¥çœ‹æ”¯æŒçš„å½©ç¥¨ç±»å‹\n/delete [ç±»å‹] [æœŸå·] - åˆ é™¤è®°å½•\n/help - å¸®åŠ©ä¿¡æ¯`,
    
    '/xg': async () => await getLatestRecords(env, 'xg', chatId),
    '/om': async () => await getLatestRecords(env, 'om', chatId),
    
    '/types': () => {
      let response = 'ğŸ“‹ æ”¯æŒçš„å½©ç¥¨ç±»å‹:\n\n';
      for (const [code, config] of Object.entries(LOTTERY_CONFIG)) {
        response += `/${code} - ${config.displayName}\n`;
        response += `  æ ¼å¼: ${config.pattern}...\n\n`;
      }
      return response;
    },
    
    '/list': async () => {
      try {
        const records = await env.DB.prepare(`
          SELECT lottery_type, expect, open_time, open_code 
          FROM lottery_records 
          ORDER BY open_time DESC 
          LIMIT 10
        `).all();
        
        if (!records.results || records.results.length === 0) {
          return 'æš‚æ— å¼€å¥–è®°å½•';
        }
        
        let response = 'ğŸ“‹ æœ€æ–°10æœŸå¼€å¥–è®°å½•:\n\n';
        records.results.forEach((record, index) => {
          const typeName = LOTTERY_CONFIG[record.lottery_type]?.displayName || record.lottery_type;
          response += `${index + 1}. ${typeName}\n`;
          response += `   æœŸå·ï¼š${record.expect}\n`;
          response += `   æ—¶é—´ï¼š${record.open_time}\n`;
          response += `   å·ç ï¼š${record.open_code}\n\n`;
        });
        
        return response;
      } catch (error) {
        return `âŒ è·å–è®°å½•å¤±è´¥: ${error.message}`;
      }
    },
    
    '/stats': async () => {
      try {
        // è·å–æ€»ä½“ç»Ÿè®¡
        const total = await env.DB.prepare('SELECT COUNT(*) as count FROM lottery_records').first();
        
        // æŒ‰ç±»å‹ç»Ÿè®¡
        const byType = await env.DB.prepare(`
          SELECT lottery_type, COUNT(*) as count 
          FROM lottery_records 
          GROUP BY lottery_type 
          ORDER BY count DESC
        `).all();
        
        // æŒ‰å¹´ä»½ç»Ÿè®¡
        const byYear = await env.DB.prepare(`
          SELECT 
            lottery_type,
            strftime('%Y', open_time) as year,
            COUNT(*) as count
          FROM lottery_records 
          GROUP BY lottery_type, year
          ORDER BY lottery_type, year DESC
        `).all();
        
        // æœ€æ–°è®°å½•
        const latest = await env.DB.prepare(`
          SELECT lottery_type, expect, open_time 
          FROM lottery_records 
          ORDER BY open_time DESC 
          LIMIT 3
        `).all();
        
        let response = 'ğŸ“Š æ•°æ®ç»Ÿè®¡\n\n';
        response += `æ€»è®°å½•æ•°ï¼š${total ? total.count : 0}\n\n`;
        
        if (byType.results && byType.results.length > 0) {
          response += 'æŒ‰ç±»å‹ç»Ÿè®¡:\n';
          byType.results.forEach(stat => {
            const typeName = LOTTERY_CONFIG[stat.lottery_type]?.displayName || stat.lottery_type;
            response += `  ${typeName}: ${stat.count}æœŸ\n`;
          });
          response += '\n';
        }
        
        if (byYear.results && byYear.results.length > 0) {
          response += 'æŒ‰å¹´ä»½ç»Ÿè®¡:\n';
          let currentType = '';
          byYear.results.forEach(stat => {
            if (stat.lottery_type !== currentType) {
              currentType = stat.lottery_type;
              const typeName = LOTTERY_CONFIG[currentType]?.displayName || currentType;
              response += `  ${typeName}:\n`;
            }
            response += `    ${stat.year}å¹´: ${stat.count}æœŸ\n`;
          });
        }
        
        if (latest.results && latest.results.length > 0) {
          response += '\næœ€æ–°å¼€å¥–:\n';
          latest.results.forEach((record, index) => {
            const typeName = LOTTERY_CONFIG[record.lottery_type]?.displayName || record.lottery_type;
            response += `  ${index + 1}. ${typeName} ${record.expect}æœŸ\n`;
          });
        }
        
        return response;
      } catch (error) {
        return `âŒ è·å–ç»Ÿè®¡å¤±è´¥: ${error.message}`;
      }
    },
    
    '/delete': async (args) => {
      if (!args || args.length < 2) {
        return 'è¯·æä¾›å½©ç¥¨ç±»å‹å’ŒæœŸå·ï¼Œä¾‹å¦‚: /delete xg 2025127';
      }
      
      const [type, expect] = args;
      
      if (!LOTTERY_CONFIG[type]) {
        return `âŒ æœªçŸ¥çš„å½©ç¥¨ç±»å‹: ${type}`;
      }
      
      try {
        // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
        const record = await env.DB.prepare(
          'SELECT id FROM lottery_records WHERE lottery_type = ? AND expect = ?'
        ).bind(type, expect).first();
        
        if (!record) {
          return `âŒ æ‰¾ä¸åˆ° ${LOTTERY_CONFIG[type].displayName} æœŸå·ä¸º ${expect} çš„è®°å½•`;
        }
        
        // åˆ é™¤è®°å½•
        const result = await env.DB.prepare(
          'DELETE FROM lottery_records WHERE lottery_type = ? AND expect = ?'
        ).bind(type, expect).run();
        
        if (result.success) {
          return `âœ… æˆåŠŸåˆ é™¤ ${LOTTERY_CONFIG[type].displayName} æœŸå· ${expect} çš„è®°å½•`;
        } else {
          return `âŒ åˆ é™¤è®°å½•å¤±è´¥`;
        }
      } catch (error) {
        return `âŒ åˆ é™¤è®°å½•æ—¶å‡ºé”™: ${error.message}`;
      }
    },
    
    '/help': `ğŸ° å¯ç”¨å‘½ä»¤:\n\nğŸ“Š æ•°æ®æŸ¥çœ‹:\n/list - æŸ¥çœ‹æœ€æ–°è®°å½•\n/stats - ç»Ÿè®¡æ•°æ®\n/types - æŸ¥çœ‹æ”¯æŒçš„å½©ç¥¨ç±»å‹\n/xg - æŸ¥çœ‹é¦™æ¸¯å…­åˆå½©æœ€æ–°è®°å½•\n/om - æŸ¥çœ‹è€æ¾³21:30æœ€æ–°è®°å½•\n\nğŸ”§ ç®¡ç†æ“ä½œ:\n/delete [ç±»å‹] [æœŸå·] - åˆ é™¤è®°å½•\n\nğŸ“± Web API:\n/${Object.keys(LOTTERY_CONFIG).map(code => `${code}/2025`).join('\n/')}`
  };
  
  // æŸ¥æ‰¾åŒ¹é…çš„å‘½ä»¤
  for (const [command, handler] of Object.entries(commands)) {
    if (text.startsWith(command)) {
      try {
        let response;
        const args = text.substring(command.length).trim().split(/\s+/);
        
        if (typeof handler === 'function') {
          response = await handler(args);
        } else {
          response = handler;
        }
        
        await sendTelegramMessage(chatId, response, env.TELEGRAM_BOT_TOKEN);
      } catch (error) {
        console.error('å‘½ä»¤æ‰§è¡Œé”™è¯¯:', error);
        await sendTelegramMessage(chatId, 'å‘½ä»¤æ‰§è¡Œå‡ºé”™: ' + error.message, env.TELEGRAM_BOT_TOKEN);
      }
      break;
    }
  }
}

async function getLatestRecords(env, type, chatId) {
  try {
    if (!LOTTERY_CONFIG[type]) {
      return `âŒ æœªçŸ¥çš„å½©ç¥¨ç±»å‹: ${type}`;
    }
    
    const records = await env.DB.prepare(`
      SELECT expect, open_time, open_code 
      FROM lottery_records 
      WHERE lottery_type = ? 
      ORDER BY open_time DESC 
      LIMIT 5
    `).bind(type).all();
    
    if (!records.results || records.results.length === 0) {
      return `${LOTTERY_CONFIG[type].displayName} æš‚æ— å¼€å¥–è®°å½•`;
    }
    
    let response = `ğŸ“‹ ${LOTTERY_CONFIG[type].displayName} æœ€æ–°5æœŸ:\n\n`;
    records.results.forEach((record, index) => {
      response += `${index + 1}. æœŸå·ï¼š${record.expect}\n`;
      response += `   æ—¶é—´ï¼š${record.open_time}\n`;
      response += `   å·ç ï¼š${record.open_code}\n\n`;
    });
    
    return response;
  } catch (error) {
    return `âŒ è·å–è®°å½•å¤±è´¥: ${error.message}`;
  }
}

// ==================== å½©ç¥¨æ•°æ®API ====================
async function handleLotteryData(env, type, url, year = null) {
  try {
    // éªŒè¯å½©ç¥¨ç±»å‹
    if (!LOTTERY_CONFIG[type]) {
      return jsonResponse({
        result: false,
        message: 'ä¸æ”¯æŒçš„å½©ç¥¨ç±»å‹',
        supported_types: Object.keys(LOTTERY_CONFIG)
      }, 400);
    }
    
    const config = LOTTERY_CONFIG[type];
    
    // æ„å»ºæŸ¥è¯¢
    let query;
    let params = [type];
    
    if (year) {
      // éªŒè¯å¹´ä»½æ ¼å¼
      if (!/^\d{4}$/.test(year)) {
        return jsonResponse({
          result: false,
          message: 'å¹´ä»½æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º4ä½æ•°å­—'
        }, 400);
      }
      
      query = `
        SELECT 
          expect,
          open_time as openTime,
          open_code as openCode,
          zodiac,
          emojis,
          verify,
          info
        FROM lottery_records 
        WHERE lottery_type = ? AND strftime('%Y', open_time) = ?
        ORDER BY expect DESC
      `;
      params.push(year);
    } else {
      // è·å–æœ€æ–°æ•°æ®ï¼ˆé»˜è®¤æœ€è¿‘30æ¡ï¼‰
      query = `
        SELECT 
          expect,
          open_time as openTime,
          open_code as openCode,
          zodiac,
          emojis,
          verify,
          info
        FROM lottery_records 
        WHERE lottery_type = ?
        ORDER BY expect DESC
        LIMIT 30
      `;
    }
    
    const records = await env.DB.prepare(query).bind(...params).all();
    
    // æ ¼å¼åŒ–è¿”å›æ•°æ®
    const formattedData = (records.results || []).map(record => ({
      expect: record.expect,
      openTime: record.openTime,
      type: type,
      openCode: record.openCode,
      zodiac: record.zodiac || '',
      emojis: record.emojis || '',
      verify: record.verify || 0,
      info: record.info || config.defaultInfo || 'macaujc.com æ¥å£æ•¸æ“šä¾†æºã€é‚®ä»¶æŠ€è¡“æ”¯æŒï¼šservice@macaujc.com'
    }));
    
    return jsonResponse({
      result: true,
      message: `${config.displayName} ${year ? year + 'å¹´' : 'æœ€æ–°'}å¼€å¥–è®°å½•`,
      code: 200,
      data: formattedData,
      metadata: {
        type: type,
        name: config.displayName,
        year: year,
        count: formattedData.length,
        timestamp: Date.now()
      }
    });
    
  } catch (error) {
    console.error('å½©ç¥¨æ•°æ®APIé”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      code: 500,
      error: error.message
    }, 500);
  }
}

// ==================== ç®¡ç†å‘˜æ¥å£ ====================
async function handleAdminImport(request, env) {
  try {
    // éªŒè¯ API å¯†é’¥
    const validation = validateApiKey(request, env);
    if (!validation.valid) {
      return jsonResponse({
        result: false,
        message: validation.message,
        code: 401
      }, 401);
    }
    
    const data = await request.json();
    
    if (!Array.isArray(data)) {
      return jsonResponse({
        result: false,
        message: 'æ•°æ®æ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºæ•°ç»„',
        code: 400
      }, 400);
    }
    
    let successCount = 0;
    let errorCount = 0;
    const errors = [];
    
    for (const record of data) {
      try {
        // éªŒè¯å¿…è¦å­—æ®µ
        if (!record.expect || !record.openCode || !record.lottery_type) {
          errorCount++;
          errors.push(`è®°å½•ç¼ºå°‘å¿…è¦å­—æ®µ: ${JSON.stringify(record)}`);
          continue;
        }
        
        // éªŒè¯å½©ç¥¨ç±»å‹
        if (!LOTTERY_CONFIG[record.lottery_type]) {
          errorCount++;
          errors.push(`æœªçŸ¥çš„å½©ç¥¨ç±»å‹: ${record.lottery_type}`);
          continue;
        }
        
        await env.DB.prepare(`
          INSERT OR REPLACE INTO lottery_records 
          (expect, lottery_type, open_time, open_code, zodiac, emojis, verify, info)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
          record.expect,
          record.lottery_type,
          record.open_time || new Date().toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, ''),
          record.openCode,
          record.zodiac || '',
          record.emojis || '',
          record.verify ? 1 : 0,
          record.info || LOTTERY_CONFIG[record.lottery_type].defaultInfo
        ).run();
        
        successCount++;
      } catch (error) {
        errorCount++;
        errors.push(`${record.lottery_type} ${record.expect}: ${error.message}`);
      }
    }
    
    return jsonResponse({
      result: true,
      message: `æ•°æ®å¯¼å…¥å®Œæˆï¼ŒæˆåŠŸï¼š${successCount}ï¼Œå¤±è´¥ï¼š${errorCount}`,
      code: 200,
      summary: {
        total: data.length,
        success: successCount,
        error: errorCount
      },
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('å¯¼å…¥APIé”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'å¯¼å…¥å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

async function handleListRecords(request, env) {
  try {
    const validation = validateApiKey(request, env);
    if (!validation.valid) {
      return jsonResponse({
        result: false,
        message: validation.message,
        code: 401
      }, 401);
    }
    
    const url = new URL(request.url);
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const type = url.searchParams.get('type');
    const year = url.searchParams.get('year');
    const offset = (page - 1) * limit;
    
    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    let whereClause = '1=1';
    const params = [];
    
    if (type) {
      whereClause += ' AND lottery_type = ?';
      params.push(type);
    }
    
    if (year) {
      whereClause += ' AND strftime(\'%Y\', open_time) = ?';
      params.push(year);
    }
    
    // è·å–æ€»è®°å½•æ•°
    const countQuery = `SELECT COUNT(*) as total FROM lottery_records WHERE ${whereClause}`;
    const countResult = await env.DB.prepare(countQuery).bind(...params).first();
    const total = countResult ? countResult.total : 0;
    
    // è·å–è®°å½•
    params.push(limit, offset);
    const records = await env.DB.prepare(`
      SELECT 
        id,
        expect,
        lottery_type,
        strftime('%Y-%m-%d %H:%M:%S', open_time) as open_time,
        open_code,
        zodiac,
        emojis,
        verify,
        info,
        strftime('%Y-%m-%d %H:%M:%S', created_at) as created_at,
        strftime('%Y-%m-%d %H:%M:%S', updated_at) as updated_at
      FROM lottery_records 
      WHERE ${whereClause}
      ORDER BY open_time DESC
      LIMIT ? OFFSET ?
    `).bind(...params).all();
    
    return jsonResponse({
      result: true,
      message: 'è·å–è®°å½•åˆ—è¡¨æˆåŠŸ',
      code: 200,
      data: {
        records: records.results || [],
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        },
        filters: {
          type,
          year
        }
      }
    });
    
  } catch (error) {
    console.error('è·å–è®°å½•åˆ—è¡¨é”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'è·å–è®°å½•åˆ—è¡¨å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

async function handleGetRecord(request, env, params) {
  try {
    const validation = validateApiKey(request, env);
    if (!validation.valid) {
      return jsonResponse({
        result: false,
        message: validation.message,
        code: 401
      }, 401);
    }
    
    const expect = params.expect;
    
    if (!expect) {
      return jsonResponse({
        result: false,
        message: 'è¯·æä¾›æœŸå·',
        code: 400
      }, 400);
    }
    
    // æŸ¥è¯¢è®°å½•
    const record = await env.DB.prepare(`
      SELECT 
        id,
        expect,
        lottery_type,
        strftime('%Y-%m-%d %H:%M:%S', open_time) as open_time,
        open_code,
        zodiac,
        emojis,
        verify,
        info,
        source_message,
        strftime('%Y-%m-%d %H:%M:%S', created_at) as created_at,
        strftime('%Y-%m-%d %H:%M:%S', updated_at) as updated_at
      FROM lottery_records 
      WHERE expect = ?
    `).bind(expect).first();
    
    if (!record) {
      return jsonResponse({
        result: false,
        message: `æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`,
        code: 404
      }, 404);
    }
    
    return jsonResponse({
      result: true,
      message: 'è·å–è®°å½•æˆåŠŸ',
      code: 200,
      data: record
    });
    
  } catch (error) {
    console.error('è·å–è®°å½•é”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'è·å–è®°å½•å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

async function handleUpdateRecord(request, env, params) {
  try {
    const validation = validateApiKey(request, env);
    if (!validation.valid) {
      return jsonResponse({
        result: false,
        message: validation.message,
        code: 401
      }, 401);
    }
    
    const expect = params.expect;
    
    if (!expect) {
      return jsonResponse({
        result: false,
        message: 'è¯·æä¾›æœŸå·',
        code: 400
      }, 400);
    }
    
    const data = await request.json();
    
    // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
    const existing = await env.DB.prepare(
      'SELECT id, lottery_type FROM lottery_records WHERE expect = ?'
    ).bind(expect).first();
    
    if (!existing) {
      return jsonResponse({
        result: false,
        message: `æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`,
        code: 404
      }, 404);
    }
    
    // æ„å»ºæ›´æ–°å­—æ®µ
    const updates = [];
    const values = [];
    
    if (data.lottery_type !== undefined) {
      if (!LOTTERY_CONFIG[data.lottery_type]) {
        return jsonResponse({
          result: false,
          message: `æœªçŸ¥çš„å½©ç¥¨ç±»å‹: ${data.lottery_type}`,
          code: 400
        }, 400);
      }
      updates.push('lottery_type = ?');
      values.push(data.lottery_type);
    }
    
    if (data.open_time !== undefined) {
      updates.push('open_time = ?');
      values.push(data.open_time);
    }
    
    if (data.open_code !== undefined) {
      updates.push('open_code = ?');
      values.push(data.open_code);
    }
    
    if (data.zodiac !== undefined) {
      updates.push('zodiac = ?');
      values.push(data.zodiac);
    }
    
    if (data.emojis !== undefined) {
      updates.push('emojis = ?');
      values.push(data.emojis);
    }
    
    if (data.verify !== undefined) {
      updates.push('verify = ?');
      values.push(data.verify ? 1 : 0);
    }
    
    if (data.info !== undefined) {
      updates.push('info = ?');
      values.push(data.info);
    }
    
    if (updates.length === 0) {
      return jsonResponse({
        result: false,
        message: 'æ²¡æœ‰æä¾›è¦æ›´æ–°çš„å­—æ®µ',
        code: 400
      }, 400);
    }
    
    // æ·»åŠ æ›´æ–°æ—¶é—´å’ŒWHEREæ¡ä»¶
    updates.push('updated_at = CURRENT_TIMESTAMP');
    values.push(expect);
    
    const sql = `UPDATE lottery_records SET ${updates.join(', ')} WHERE expect = ?`;
    const result = await env.DB.prepare(sql).bind(...values).run();
    
    if (result.success) {
      // è·å–æ›´æ–°åçš„è®°å½•
      const updatedRecord = await env.DB.prepare(`
        SELECT * FROM lottery_records WHERE expect = ?
      `).bind(expect).first();
      
      return jsonResponse({
        result: true,
        message: 'æ›´æ–°è®°å½•æˆåŠŸ',
        code: 200,
        data: updatedRecord
      });
    } else {
      return jsonResponse({
        result: false,
        message: 'æ›´æ–°è®°å½•å¤±è´¥',
        code: 500
      }, 500);
    }
    
  } catch (error) {
    console.error('æ›´æ–°è®°å½•é”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'æ›´æ–°è®°å½•å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

async function handleDeleteRecord(request, env, params) {
  try {
    const validation = validateApiKey(request, env);
    if (!validation.valid) {
      return jsonResponse({
        result: false,
        message: validation.message,
        code: 401
      }, 401);
    }
    
    const expect = params.expect;
    
    if (!expect) {
      return jsonResponse({
        result: false,
        message: 'è¯·æä¾›æœŸå·',
        code: 400
      }, 400);
    }
    
    // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
    const existing = await env.DB.prepare(
      'SELECT id, lottery_type, expect, open_time FROM lottery_records WHERE expect = ?'
    ).bind(expect).first();
    
    if (!existing) {
      return jsonResponse({
        result: false,
        message: `æ‰¾ä¸åˆ°æœŸå·ä¸º ${expect} çš„è®°å½•`,
        code: 404
      }, 404);
    }
    
    // æ‰§è¡Œåˆ é™¤
    const result = await env.DB.prepare(
      'DELETE FROM lottery_records WHERE expect = ?'
    ).bind(expect).run();
    
    if (result.success) {
      return jsonResponse({
        result: true,
        message: `æˆåŠŸåˆ é™¤æœŸå·ä¸º ${expect} çš„è®°å½•`,
        code: 200,
        deletedRecord: existing
      });
    } else {
      return jsonResponse({
        result: false,
        message: 'åˆ é™¤è®°å½•å¤±è´¥',
        code: 500
      }, 500);
    }
    
  } catch (error) {
    console.error('åˆ é™¤è®°å½•é”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'åˆ é™¤è®°å½•å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

async function handleAdminStats(env) {
  try {
    // æ€»ä½“ç»Ÿè®¡
    const total = await env.DB.prepare('SELECT COUNT(*) as total FROM lottery_records').first();
    
    // æŒ‰ç±»å‹ç»Ÿè®¡
    const byType = await env.DB.prepare(`
      SELECT 
        lottery_type,
        COUNT(*) as count,
        MIN(open_time) as earliest,
        MAX(open_time) as latest
      FROM lottery_records 
      GROUP BY lottery_type 
      ORDER BY count DESC
    `).all();
    
    // æŒ‰å¹´ä»½ç»Ÿè®¡
    const byYear = await env.DB.prepare(`
      SELECT 
        strftime('%Y', open_time) as year,
        COUNT(*) as count,
        GROUP_CONCAT(DISTINCT lottery_type) as types
      FROM lottery_records 
      GROUP BY year
      ORDER BY year DESC
    `).all();
    
    // æœ€è¿‘æ´»è·ƒ
    const recent = await env.DB.prepare(`
      SELECT 
        lottery_type,
        expect,
        open_time
      FROM lottery_records 
      ORDER BY open_time DESC
      LIMIT 5
    `).all();
    
    // æ•°æ®åº“å¤§å°
    const dbInfo = await env.DB.prepare('PRAGMA page_count').first();
    
    return jsonResponse({
      result: true,
      message: 'ç»Ÿè®¡ä¿¡æ¯è·å–æˆåŠŸ',
      code: 200,
      data: {
        total: total.total || 0,
        by_type: byType.results || [],
        by_year: byYear.results || [],
        recent: recent.results || [],
        database: {
          page_count: dbInfo ? dbInfo.page_count : 0
        },
        supported_types: Object.keys(LOTTERY_CONFIG)
      }
    });
    
  } catch (error) {
    console.error('è·å–ç»Ÿè®¡ä¿¡æ¯é”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

async function handleBatchDelete(request, env) {
  try {
    const validation = validateApiKey(request, env);
    if (!validation.valid) {
      return jsonResponse({
        result: false,
        message: validation.message,
        code: 401
      }, 401);
    }
    
    const data = await request.json();
    const { records, type, year } = data;
    
    if (!records && !type && !year) {
      return jsonResponse({
        result: false,
        message: 'è¯·æä¾›è¦åˆ é™¤çš„è®°å½•ã€ç±»å‹æˆ–å¹´ä»½',
        code: 400
      }, 400);
    }
    
    let result;
    let message;
    
    if (records && Array.isArray(records)) {
      // æ‰¹é‡åˆ é™¤æŒ‡å®šæœŸå·
      let deleted = 0;
      for (const record of records) {
        const { lottery_type, expect } = record;
        if (lottery_type && expect) {
          await env.DB.prepare(
            'DELETE FROM lottery_records WHERE lottery_type = ? AND expect = ?'
          ).bind(lottery_type, expect).run();
          deleted++;
        }
      }
      message = `æ‰¹é‡åˆ é™¤ ${deleted} æ¡è®°å½•æˆåŠŸ`;
    } else if (type && year) {
      // åˆ é™¤æŒ‡å®šç±»å‹å’Œå¹´ä»½çš„æ‰€æœ‰è®°å½•
      result = await env.DB.prepare(`
        DELETE FROM lottery_records 
        WHERE lottery_type = ? AND strftime('%Y', open_time) = ?
      `).bind(type, year).run();
      message = `åˆ é™¤ ${type} ${year}å¹´ æ‰€æœ‰è®°å½•æˆåŠŸ`;
    } else if (type) {
      // åˆ é™¤æŒ‡å®šç±»å‹çš„æ‰€æœ‰è®°å½•
      result = await env.DB.prepare(
        'DELETE FROM lottery_records WHERE lottery_type = ?'
      ).bind(type).run();
      message = `åˆ é™¤ ${type} æ‰€æœ‰è®°å½•æˆåŠŸ`;
    } else if (year) {
      // åˆ é™¤æŒ‡å®šå¹´ä»½çš„æ‰€æœ‰è®°å½•
      result = await env.DB.prepare(`
        DELETE FROM lottery_records WHERE strftime('%Y', open_time) = ?
      `).bind(year).run();
      message = `åˆ é™¤ ${year}å¹´ æ‰€æœ‰è®°å½•æˆåŠŸ`;
    }
    
    return jsonResponse({
      result: true,
      message,
      code: 200
    });
    
  } catch (error) {
    console.error('æ‰¹é‡åˆ é™¤é”™è¯¯:', error);
    return jsonResponse({
      result: false,
      message: 'æ‰¹é‡åˆ é™¤å¤±è´¥',
      code: 500,
      error: error.message
    }, 500);
  }
}

// ==================== Telegram æ¶ˆæ¯å‘é€ ====================
async function sendTelegramMessage(chatId, text, botToken) {
  try {
    const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
    
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        text: text,
        parse_mode: 'HTML'
      })
    });
  } catch (error) {
    console.error('å‘é€Telegramæ¶ˆæ¯é”™è¯¯:', error);
  }
}
