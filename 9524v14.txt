/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V14.0 å¢å¼ºé¢„æµ‹ç‰ˆ
 * 
 * ä¸»è¦æ›´æ–°:
 * 1. ç§»é™¤å®šæ—¶åŒæ­¥æ•°æ®å’Œæ¨é€åŠŸèƒ½
 * 2. ä¿ç•™æ‰‹åŠ¨åŒæ­¥å’Œæ‰‹åŠ¨æ¨é€åŠŸèƒ½
 * 3. å¢å¼ºKNNç®—æ³•å’Œæ¨¡å¼åˆ†æ
 * 4. ä¼˜åŒ–é¢„æµ‹é€»è¾‘ï¼Œæé«˜å‡†ç¡®æ€§
 * 5. å®Œå–„ç”¨æˆ·äº¤äº’ç•Œé¢
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ¾³å…­é¢„æµ‹",
    VERSION: "V14.0 å¢å¼ºé¢„æµ‹ç‰ˆ",
    TIMEZONE_OFFSET: 8,
    CHANNEL_ID: null,
    ADMIN_ID: null,
    HISTORY_LIMIT: 3000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    KNN_K_VALUE: 20,
    MAX_PATTERNS_TO_ANALYZE: 150,
    PATTERN_MIN_CONFIDENCE: 0.65,
    ANALYSIS_DEPTH: 80,
    FEATURE_WEIGHTS: {
      special_weight: 3.2,
      zodiac_weight: 2.8,
      color_weight: 2.3,
      tail_weight: 2.4,
      size_weight: 2.0,
      parity_weight: 2.0,
      head_weight: 1.7,
      normal_tail_weight: 2.0,
      normal_zodiac_weight: 1.8,
      normal_color_weight: 1.6,
      sequence_weight: 1.9,
      period_weight: 1.7,
      frequency_weight: 1.5,
      pattern_weight: 2.3,
      trend_weight: 1.8,
      cluster_weight: 1.6
    }
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.8,
    w_zodiac_relation: 2.5,
    w_color_transfer: 2.3,
    w_tail_correlation: 2.1,
    w_size_pattern: 1.9,
    w_parity_pattern: 1.9,
    w_head_pattern: 1.6,
    w_normal_tail_pattern: 1.9,
    w_frequency_analysis: 1.7,
    w_sequence_analysis: 2.1,
    w_period_analysis: 1.6,
    w_knn: 3.2,
    w_pattern_analysis: 2.5,
    w_trend_analysis: 1.9,
    _version: "14.0"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    home: "ğŸ ",
    trash: "ğŸ—‘ï¸",
    warning: "âš ï¸",
    database: "ğŸ’¾",
    clock: "â°",
    check: "âœ”ï¸",
    speed: "âš¡",
    fix: "ğŸ”§",
    bell: "ğŸ””",
    star: "â­",
    rocket: "ğŸš€",
    refresh: "ğŸ”„",
    eye: "ğŸ‘ï¸",
    lock: "ğŸ”’",
    dice: "ğŸ²",
    calendar: "ğŸ“…",
    hourglass: "â³",
    money: "ğŸ’°",
    target: "ğŸ¯",
    brain: "ğŸ§ ",
    science: "ğŸ”¬",
    chart_up: "ğŸ“ˆ",
    clock2: "ğŸ•’",
    alarm: "â°",
    repeat: "ğŸ”",
    progress: "ğŸ“ˆ",
    batch: "ğŸ”¢",
    history: "ğŸ“œ",
    memory: "ğŸ’¾",
    cpu: "âš™ï¸",
    algorithm: "ğŸ§®",
    knn: "ğŸ“",
    pattern: "ğŸ”",
    analysis: "ğŸ“Š",
    stats: "ğŸ“ˆ",
    trend: "ğŸ“‰",
    loop: "ğŸ”„",
    time: "â±ï¸",
    search: "ğŸ”",
    magic: "âœ¨",
    brain_circuit: "ğŸ§©",
    ai: "ğŸ¤–",
    crystal_ball: "ğŸ”®",
    lightning: "âš¡",
    compass: "ğŸ§­",
    microscope: "ğŸ”¬",
    abacus: "ğŸ§®",
    magnet: "ğŸ§²",
    link: "ğŸ”—",
    gear: "âš™ï¸",
    bar_chart: "ğŸ“Š",
    calculator: "ğŸ§®",
    puzzle: "ğŸ§©",
    rocket2: "ğŸš€",
    atom: "âš›ï¸",
    satellite: "ğŸ›°ï¸",
    radar: "ğŸ“¡",
    brain2: "ğŸ§ ",
    neuron: "ğŸ¦ ",
    dna: "ğŸ§¬",
    lab: "ğŸ§ª",
    telescope: "ğŸ”­",
    key: "ğŸ”‘"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    PREDICT: "prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_CONFIRM: "delete_confirm",
    DELETE_RESULT: "delete_result",
    STATS: "stats",
    CLEAR_CACHE: "clear_cache"
  }
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•°
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
  
  static debug(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [DEBUG] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.debug] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { 
          zodiac: "æœªçŸ¥", 
          color: "æœªçŸ¥",
          size: "æœªçŸ¥",
          parity: "æœªçŸ¥",
          head: "æœªçŸ¥",
          tail: "æœªçŸ¥"
        };
      }
      
      let zodiac = "æœªçŸ¥";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "æœªçŸ¥";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      const size = num >= 25 ? "å¤§" : "å°";
      const parity = num % 2 === 0 ? "åŒ" : "å•";
      const head = Math.floor(num / 10);
      const tail = num % 10;
      
      return { zodiac, color, size, parity, head, tail };
    } catch (error) {
      return { 
        zodiac: "æœªçŸ¥", 
        color: "æœªçŸ¥",
        size: "æœªçŸ¥",
        parity: "æœªçŸ¥",
        head: "æœªçŸ¥",
        tail: "æœªçŸ¥"
      };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static formatLargeNumber(num) {
    try {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(2) + 'äº¿';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      } else {
        return num.toString();
      }
    } catch (error) {
      return "0";
    }
  }

  static isValidExpect(expect) {
    try {
      if (!expect || typeof expect !== 'string') return false;
      return /^\d{7}$/.test(expect);
    } catch (error) {
      return false;
    }
  }

  static compareExpect(expect1, expect2) {
    try {
      const num1 = this.safeInt(expect1, 0);
      const num2 = this.safeInt(expect2, 0);
      return num1 - num2;
    } catch (error) {
      return 0;
    }
  }

  static getRandomElement(array) {
    try {
      if (!array || !Array.isArray(array) || array.length === 0) return null;
      return array[Math.floor(Math.random() * array.length)];
    } catch (error) {
      return null;
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static formatDuration(ms) {
    try {
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms/1000).toFixed(2)}ç§’`;
      if (ms < 3600000) return `${Math.floor(ms/60000)}åˆ†${Math.floor((ms%60000)/1000)}ç§’`;
      return `${Math.floor(ms/3600000)}å°æ—¶${Math.floor((ms%3600000)/60000)}åˆ†`;
    } catch (error) {
      return `${ms}ms`;
    }
  }

  static formatProgress(current, total) {
    try {
      const percent = total > 0 ? ((current / total) * 100).toFixed(1) : 0;
      const progressBarLength = 20;
      const filled = Math.round((current / total) * progressBarLength);
      const empty = progressBarLength - filled;
      const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
      return `${bar} ${percent}% (${current}/${total})`;
    } catch (error) {
      return `${current}/${total}`;
    }
  }

  static getTail(number) {
    try {
      return parseInt(number) % 10;
    } catch (error) {
      return 0;
    }
  }

  static getHead(number) {
    try {
      return Math.floor(parseInt(number) / 10);
    } catch (error) {
      return 0;
    }
  }

  static isBig(number) {
    try {
      return parseInt(number) >= 25;
    } catch (error) {
      return false;
    }
  }

  static isOdd(number) {
    try {
      return parseInt(number) % 2 !== 0;
    } catch (error) {
      return false;
    }
  }

  static getColorEmoji(color) {
    try {
      return CONFIG.EMOJI[color] || "";
    } catch (error) {
      return "";
    }
  }

  static calculateBeijingTime() {
    try {
      const now = new Date();
      const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
      const beijingTime = new Date(utc + (3600000 * CONFIG.SYSTEM.TIMEZONE_OFFSET));
      return beijingTime;
    } catch (error) {
      return new Date();
    }
  }
}

// ==============================================================================
// 3. æ¶ˆæ¯ç®¡ç†å™¨
// ==============================================================================

class MessageManager {
  static userMessages = new Map();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static deleteUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.delete(messageType);
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
  
  static cleanupOldMessages(chatId, keepCount = 10) {
    try {
      this.initUser(chatId);
      const userMap = this.userMessages.get(chatId);
      
      if (userMap.size <= keepCount) {
        return 0;
      }
      
      const entries = Array.from(userMap.entries());
      const toRemove = entries.slice(0, entries.length - keepCount);
      
      let removed = 0;
      for (const [key, _] of toRemove) {
        if (userMap.delete(key)) {
          removed++;
        }
      }
      
      Logger.info("MessageManager", `æ¸…ç†äº† ${removed} æ¡æ—§æ¶ˆæ¯`, { chatId });
      return removed;
    } catch (error) {
      Logger.error("MessageManager", "æ¸…ç†æ—§æ¶ˆæ¯å¤±è´¥", error);
      return 0;
    }
  }
}

// ==============================================================================
// 4. ç¼“å­˜ç®¡ç†å™¨
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "è®¾ç½®ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 5. æ•°æ®åº“æ“ä½œå±‚
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS system_stats (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          stat_key TEXT,
          stat_value TEXT,
          stat_type TEXT,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_stats_key ON system_stats (stat_key)`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  checkExpectExists: async function(env, expect) {
    try {
      if (!expect) return false;
      
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect = ?"
      ).bind(Formatter.safeString(expect)).first();
      
      return result ? result.count > 0 : false;
    } catch (e) {
      Logger.error("DB", "checkExpectExists failed", e);
      return false;
    }
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code &&
          Formatter.isValidExpect(record.expect.toString())
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStats(env, "total_records", totalAdded, "increment");
      await this.updateStats(env, "last_sync", new Date().toISOString(), "set");
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          weights = { ...defaultWeights, ...parsed };
        } catch (parseError) {
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0",
        "TOTAL_PUSHES": "0",
        "TOTAL_PREDICTIONS": "0",
        "TOTAL_ANALYSIS": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  },

  updateStats: async function(env, key, value, type = "set") {
    try {
      const existing = await env.DB.prepare(
        "SELECT * FROM system_stats WHERE stat_key = ?"
      ).bind(key).first();
      
      if (existing) {
        let newValue = value;
        if (type === "increment") {
          const current = Formatter.safeInt(existing.stat_value, 0);
          newValue = (current + Formatter.safeInt(value, 0)).toString();
        }
        
        await env.DB.prepare(
          "UPDATE system_stats SET stat_value = ?, updated_at = CURRENT_TIMESTAMP WHERE stat_key = ?"
        ).bind(newValue, key).run();
      } else {
        await env.DB.prepare(
          "INSERT INTO system_stats (stat_key, stat_value, stat_type) VALUES (?, ?, ?)"
        ).bind(key, value.toString(), type).run();
      }
      
      return true;
    } catch (e) {
      Logger.error("DB", "updateStats failed", e);
      return false;
    }
  },

  getStats: async function(env) {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM system_stats ORDER BY stat_key"
      ).all();
      
      const stats = {};
      if (results) {
        results.forEach(row => {
          stats[row.stat_key] = {
            value: row.stat_value,
            type: row.stat_type,
            updated: row.updated_at
          };
        });
      }
      
      return stats;
    } catch (e) {
      Logger.error("DB", "getStats failed", e);
      return {};
    }
  },

  incrementPredictionCount: async function(env) {
    try {
      const totalPredictions = Formatter.safeInt(await this.getSetting(env, "TOTAL_PREDICTIONS", "0"), 0) + 1;
      await this.saveSetting(env, "TOTAL_PREDICTIONS", totalPredictions.toString());
      return totalPredictions;
    } catch (e) {
      Logger.error("DB", "incrementPredictionCount failed", e);
      return 0;
    }
  },

  incrementAnalysisCount: async function(env) {
    try {
      const totalAnalysis = Formatter.safeInt(await this.getSetting(env, "TOTAL_ANALYSIS", "0"), 0) + 1;
      await this.saveSetting(env, "TOTAL_ANALYSIS", totalAnalysis.toString());
      return totalAnalysis;
    } catch (e) {
      Logger.error("DB", "incrementAnalysisCount failed", e);
      return 0;
    }
  }
};

// ==============================================================================
// 6. å¢å¼ºæ¨¡å¼åˆ†æå¼•æ“ï¼ˆæŸ¥æ‰¾å„ç§è§„å¾‹ï¼‰
// ==============================================================================

class PatternAnalysisEngine {
  static patternsCache = new Map();
  
  static analyzeHistoricalPatterns(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 10) {
        return this.createEmptyPatterns();
      }
      
      const cacheKey = `patterns_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.patternsCache.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const startTime = Date.now();
      
      const patterns = {
        tailPatterns: this.analyzeTailPatterns(history),
        zodiacPatterns: this.analyzeZodiacPatterns(history),
        colorPatterns: this.analyzeColorPatterns(history),
        sizePatterns: this.analyzeSizePatterns(history),
        parityPatterns: this.analyzeParityPatterns(history),
        headPatterns: this.analyzeHeadPatterns(history),
        sequencePatterns: this.analyzeSequencePatterns(history),
        periodPatterns: this.analyzePeriodPatterns(history),
        normalTailPatterns: this.analyzeNormalTailPatterns(history),
        normalZodiacPatterns: this.analyzeNormalZodiacPatterns(history),
        normalColorPatterns: this.analyzeNormalColorPatterns(history),
        frequencyPatterns: this.analyzeFrequencyPatterns(history),
        combinationPatterns: this.analyzeCombinationPatterns(history),
        specialPatterns: this.analyzeSpecialPatterns(history),
        trendPatterns: this.analyzeTrendPatterns(history),
        clusterPatterns: this.analyzeClusterPatterns(history)
      };
      
      patterns.confidence = this.calculateOverallConfidence(patterns);
      patterns.totalRecords = history.length;
      patterns.analysisTime = new Date().toISOString();
      patterns.analysisDuration = Date.now() - startTime;
      
      this.patternsCache.set(cacheKey, patterns);
      
      Logger.info("PatternAnalysis", `æ¨¡å¼åˆ†æå®Œæˆï¼Œå…±åˆ†æ ${history.length} æ¡è®°å½•ï¼Œè€—æ—¶ ${patterns.analysisDuration}ms`);
      return patterns;
      
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå†å²æ¨¡å¼å¤±è´¥", error);
      return this.createEmptyPatterns();
    }
  }
  
  static analyzeTailPatterns(history) {
    try {
      const patterns = {
        specialTailSequence: {},      // ç‰¹ç å°¾æ•°åºåˆ—
        normalTailToSpecial: {},      // å¹³ç å°¾æ•° -> ç‰¹ç å°¾æ•°
        tailFrequency: {},            // å°¾æ•°å‡ºç°é¢‘ç‡
        tailGap: {},                  // å°¾æ•°é—´éš”
        tailCombinations: {},         // å°¾æ•°ç»„åˆ
        tailTrends: {},               // å°¾æ•°è¶‹åŠ¿
        tailClusters: {}              // å°¾æ•°èšç±»
      };
      
      // åˆå§‹åŒ–
      for (let i = 0; i <= 9; i++) {
        patterns.tailFrequency[i] = 0;
        patterns.tailGap[i] = [];
        patterns.tailTrends[i] = { up: 0, down: 0, stable: 0 };
      }
      
      // åˆ†ææ¯æ¡è®°å½•
      const tailHistory = [];
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialTail = Formatter.getTail(special);
        const normals = numbers.slice(0, 6);
        const normalTails = normals.map(n => Formatter.getTail(n));
        
        tailHistory.push(specialTail);
        
        // ç‰¹ç å°¾æ•°åºåˆ—
        if (i < history.length - 1) {
          const nextRecord = history[i + 1];
          if (nextRecord && nextRecord.open_code) {
            const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            if (nextNumbers.length >= 7) {
              const nextSpecial = nextNumbers[6];
              const nextSpecialTail = Formatter.getTail(nextSpecial);
              
              const key = `${specialTail}->${nextSpecialTail}`;
              patterns.specialTailSequence[key] = (patterns.specialTailSequence[key] || 0) + 1;
              
              // è¶‹åŠ¿åˆ†æ
              if (nextSpecialTail > specialTail) {
                patterns.tailTrends[specialTail].up++;
              } else if (nextSpecialTail < specialTail) {
                patterns.tailTrends[specialTail].down++;
              } else {
                patterns.tailTrends[specialTail].stable++;
              }
            }
          }
        }
        
        // å¹³ç å°¾æ•° -> ç‰¹ç å°¾æ•°
        normalTails.forEach(normalTail => {
          const key = `${normalTail}->${specialTail}`;
          patterns.normalTailToSpecial[key] = (patterns.normalTailToSpecial[key] || 0) + 1;
        });
        
        // å°¾æ•°é¢‘ç‡
        patterns.tailFrequency[specialTail]++;
        
        // å°¾æ•°ç»„åˆ
        const allTails = [...normalTails, specialTail].sort((a, b) => a - b);
        const tailKey = allTails.join(",");
        patterns.tailCombinations[tailKey] = (patterns.tailCombinations[tailKey] || 0) + 1;
      }
      
      // è®¡ç®—å°¾æ•°é—´éš”
      const lastSeen = {};
      for (let i = 0; i < tailHistory.length; i++) {
        const tail = tailHistory[i];
        
        if (lastSeen[tail] !== undefined) {
          const gap = i - lastSeen[tail];
          patterns.tailGap[tail].push(gap);
        }
        
        lastSeen[tail] = i;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºç»å¸¸ä¸€èµ·å‡ºç°çš„å°¾æ•°
      const tailPairs = {};
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialTail = Formatter.getTail(special);
        const normals = numbers.slice(0, 6);
        const normalTails = normals.map(n => Formatter.getTail(n));
        
        // ç‰¹ç å°¾æ•°ä¸å¹³ç å°¾æ•°çš„å…³è”
        normalTails.forEach(normalTail => {
          const key = `${Math.min(specialTail, normalTail)}-${Math.max(specialTail, normalTail)}`;
          tailPairs[key] = (tailPairs[key] || 0) + 1;
        });
      }
      
      // æ‰¾å‡ºå¼ºå…³è”çš„å°¾æ•°å¯¹
      patterns.tailClusters = Object.entries(tailPairs)
        .filter(([_, count]) => count > history.length * 0.05) // å‡ºç°é¢‘ç‡è¶…è¿‡5%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .reduce((obj, [key, value]) => {
          obj[key] = value;
          return obj;
        }, {});
      
      // è®¡ç®—å°¾æ•°ç»Ÿè®¡æ•°æ®
      const tailStats = {};
      for (let i = 0; i <= 9; i++) {
        if (patterns.tailGap[i].length > 0) {
          const sum = patterns.tailGap[i].reduce((a, b) => a + b, 0);
          const gaps = patterns.tailGap[i];
          tailStats[i] = {
            frequency: patterns.tailFrequency[i],
            avgGap: sum / gaps.length,
            maxGap: Math.max(...gaps),
            minGap: Math.min(...gaps),
            stdDev: this.calculateStdDev(gaps),
            gapHistory: gaps,
            trend: patterns.tailTrends[i],
            overdue: gaps.length > 0 ? gaps[gaps.length - 1] : 0,
            probability: patterns.tailFrequency[i] / history.length
          };
        } else {
          tailStats[i] = {
            frequency: patterns.tailFrequency[i],
            avgGap: 0,
            maxGap: 0,
            minGap: 0,
            stdDev: 0,
            gapHistory: [],
            trend: patterns.tailTrends[i],
            overdue: history.length,
            probability: patterns.tailFrequency[i] / history.length
          };
        }
      }
      
      patterns.tailStats = tailStats;
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå°¾æ•°æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeZodiacPatterns(history) {
    try {
      const patterns = {
        zodiacSequence: {},           // ç”Ÿè‚–åºåˆ—
        zodiacGap: {},                // ç”Ÿè‚–é—´éš”
        zodiacFrequency: {},          // ç”Ÿè‚–é¢‘ç‡
        zodiacRelations: {},          // ç”Ÿè‚–å…³ç³»
        zodiacCombinations: {},       // ç”Ÿè‚–ç»„åˆ
        zodiacClusters: {}            // ç”Ÿè‚–èšç±»
      };
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      
      // åˆå§‹åŒ–
      allZodiacs.forEach(zodiac => {
        patterns.zodiacFrequency[zodiac] = 0;
        patterns.zodiacGap[zodiac] = [];
      });
      
      // åˆ†ææ¯æ¡è®°å½•
      const zodiacHistory = [];
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialZodiac = specialAttr.zodiac;
        
        zodiacHistory.push(specialZodiac);
        
        // ç”Ÿè‚–é¢‘ç‡
        patterns.zodiacFrequency[specialZodiac]++;
        
        // ç”Ÿè‚–åºåˆ—
        if (i < history.length - 1) {
          const nextRecord = history[i + 1];
          if (nextRecord && nextRecord.open_code) {
            const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            if (nextNumbers.length >= 7) {
              const nextSpecial = nextNumbers[6];
              const nextSpecialAttr = Formatter.getAttributes(nextSpecial);
              const nextSpecialZodiac = nextSpecialAttr.zodiac;
              
              const key = `${specialZodiac}->${nextSpecialZodiac}`;
              patterns.zodiacSequence[key] = (patterns.zodiacSequence[key] || 0) + 1;
              
              // ç”Ÿè‚–å…³ç³»
              if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[specialZodiac] === nextSpecialZodiac) {
                patterns.zodiacRelations.sixHarmony = (patterns.zodiacRelations.sixHarmony || 0) + 1;
              }
              
              const threeHarmony = CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[specialZodiac];
              if (threeHarmony && threeHarmony.includes(nextSpecialZodiac)) {
                patterns.zodiacRelations.threeHarmony = (patterns.zodiacRelations.threeHarmony || 0) + 1;
              }
            }
          }
        }
      }
      
      // è®¡ç®—ç”Ÿè‚–é—´éš”
      const lastSeen = {};
      for (let i = 0; i < zodiacHistory.length; i++) {
        const zodiac = zodiacHistory[i];
        
        if (lastSeen[zodiac] !== undefined) {
          const gap = i - lastSeen[zodiac];
          patterns.zodiacGap[zodiac].push(gap);
        }
        
        lastSeen[zodiac] = i;
      }
      
      // è®¡ç®—ç”Ÿè‚–ç»„åˆ
      for (let i = 0; i < zodiacHistory.length - 1; i++) {
        const zodiac1 = zodiacHistory[i];
        const zodiac2 = zodiacHistory[i + 1];
        const key = `${zodiac1}+${zodiac2}`;
        patterns.zodiacCombinations[key] = (patterns.zodiacCombinations[key] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºç»å¸¸ä¸€èµ·å‡ºç°çš„ç”Ÿè‚–
      const zodiacPairs = {};
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialZodiac = specialAttr.zodiac;
        const normals = numbers.slice(0, 6);
        
        // ç‰¹ç ç”Ÿè‚–ä¸å¹³ç ç”Ÿè‚–çš„å…³è”
        normals.forEach(number => {
          const attr = Formatter.getAttributes(number);
          const normalZodiac = attr.zodiac;
          const key = [specialZodiac, normalZodiac].sort().join("-");
          zodiacPairs[key] = (zodiacPairs[key] || 0) + 1;
        });
      }
      
      patterns.zodiacClusters = Object.entries(zodiacPairs)
        .filter(([_, count]) => count > history.length * 0.03) // å‡ºç°é¢‘ç‡è¶…è¿‡3%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15)
        .reduce((obj, [key, value]) => {
          obj[key] = value;
          return obj;
        }, {});
      
      // è®¡ç®—ç”Ÿè‚–ç»Ÿè®¡æ•°æ®
      const zodiacStats = {};
      allZodiacs.forEach(zodiac => {
        if (patterns.zodiacGap[zodiac].length > 0) {
          const sum = patterns.zodiacGap[zodiac].reduce((a, b) => a + b, 0);
          const gaps = patterns.zodiacGap[zodiac];
          zodiacStats[zodiac] = {
            frequency: patterns.zodiacFrequency[zodiac],
            avgGap: sum / gaps.length,
            maxGap: Math.max(...gaps),
            minGap: Math.min(...gaps),
            stdDev: this.calculateStdDev(gaps),
            gapHistory: gaps,
            overdue: gaps.length > 0 ? gaps[gaps.length - 1] : 0,
            probability: patterns.zodiacFrequency[zodiac] / history.length
          };
        } else {
          zodiacStats[zodiac] = {
            frequency: patterns.zodiacFrequency[zodiac],
            avgGap: 0,
            maxGap: 0,
            minGap: 0,
            stdDev: 0,
            gapHistory: [],
            overdue: history.length,
            probability: patterns.zodiacFrequency[zodiac] / history.length
          };
        }
      });
      
      patterns.zodiacStats = zodiacStats;
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æç”Ÿè‚–æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeColorPatterns(history) {
    try {
      const patterns = {
        colorSequence: {},            // é¢œè‰²åºåˆ—
        colorFrequency: {},           // é¢œè‰²é¢‘ç‡
        colorGap: {},                 // é¢œè‰²é—´éš”
        colorCombinations: {},        // é¢œè‰²ç»„åˆ
        colorClusters: {}             // é¢œè‰²èšç±»
      };
      
      const colors = ['red', 'blue', 'green'];
      
      // åˆå§‹åŒ–
      colors.forEach(color => {
        patterns.colorFrequency[color] = 0;
        patterns.colorGap[color] = [];
      });
      
      // åˆ†ææ¯æ¡è®°å½•
      const colorHistory = [];
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialColor = specialAttr.color;
        
        colorHistory.push(specialColor);
        
        // é¢œè‰²é¢‘ç‡
        patterns.colorFrequency[specialColor]++;
        
        // é¢œè‰²åºåˆ—
        if (i < history.length - 1) {
          const nextRecord = history[i + 1];
          if (nextRecord && nextRecord.open_code) {
            const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            if (nextNumbers.length >= 7) {
              const nextSpecial = nextNumbers[6];
              const nextSpecialAttr = Formatter.getAttributes(nextSpecial);
              const nextSpecialColor = nextSpecialAttr.color;
              
              const key = `${specialColor}->${nextSpecialColor}`;
              patterns.colorSequence[key] = (patterns.colorSequence[key] || 0) + 1;
            }
          }
        }
      }
      
      // è®¡ç®—é¢œè‰²é—´éš”
      const lastSeen = {};
      for (let i = 0; i < colorHistory.length; i++) {
        const color = colorHistory[i];
        
        if (lastSeen[color] !== undefined) {
          const gap = i - lastSeen[color];
          patterns.colorGap[color].push(gap);
        }
        
        lastSeen[color] = i;
      }
      
      // è®¡ç®—é¢œè‰²ç»„åˆ
      for (let i = 0; i < colorHistory.length - 2; i++) {
        const color1 = colorHistory[i];
        const color2 = colorHistory[i + 1];
        const color3 = colorHistory[i + 2];
        const key = `${color1}+${color2}+${color3}`;
        patterns.colorCombinations[key] = (patterns.colorCombinations[key] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºé¢œè‰²ç»„åˆæ¨¡å¼
      const colorPatterns = {};
      for (let i = 0; i < colorHistory.length - 2; i++) {
        const pattern = colorHistory.slice(i, i + 3).join("->");
        colorPatterns[pattern] = (colorPatterns[pattern] || 0) + 1;
      }
      
      patterns.colorClusters = Object.entries(colorPatterns)
        .filter(([_, count]) => count > history.length * 0.02) // å‡ºç°é¢‘ç‡è¶…è¿‡2%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .reduce((obj, [key, value]) => {
          obj[key] = value;
          return obj;
        }, {});
      
      // è®¡ç®—é¢œè‰²ç»Ÿè®¡æ•°æ®
      const colorStats = {};
      colors.forEach(color => {
        if (patterns.colorGap[color].length > 0) {
          const sum = patterns.colorGap[color].reduce((a, b) => a + b, 0);
          const gaps = patterns.colorGap[color];
          colorStats[color] = {
            frequency: patterns.colorFrequency[color],
            avgGap: sum / gaps.length,
            maxGap: Math.max(...gaps),
            minGap: Math.min(...gaps),
            stdDev: this.calculateStdDev(gaps),
            gapHistory: gaps,
            overdue: gaps.length > 0 ? gaps[gaps.length - 1] : 0,
            probability: patterns.colorFrequency[color] / history.length
          };
        } else {
          colorStats[color] = {
            frequency: patterns.colorFrequency[color],
            avgGap: 0,
            maxGap: 0,
            minGap: 0,
            stdDev: 0,
            gapHistory: [],
            overdue: history.length,
            probability: patterns.colorFrequency[color] / history.length
          };
        }
      });
      
      patterns.colorStats = colorStats;
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æé¢œè‰²æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeSizePatterns(history) {
    try {
      const patterns = {
        sizeSequence: {},             // å¤§å°åºåˆ—
        sizeFrequency: {},            // å¤§å°é¢‘ç‡
        sizeGap: {},                  // å¤§å°é—´éš”
        sizeCombinations: {},         // å¤§å°ç»„åˆ
        sizeClusters: {}              // å¤§å°èšç±»
      };
      
      const sizes = ['å¤§', 'å°'];
      
      // åˆå§‹åŒ–
      sizes.forEach(size => {
        patterns.sizeFrequency[size] = 0;
        patterns.sizeGap[size] = [];
      });
      
      // åˆ†ææ¯æ¡è®°å½•
      const sizeHistory = [];
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialSize = specialAttr.size;
        
        sizeHistory.push(specialSize);
        
        // å¤§å°é¢‘ç‡
        patterns.sizeFrequency[specialSize]++;
        
        // å¤§å°åºåˆ—
        if (i < history.length - 1) {
          const nextRecord = history[i + 1];
          if (nextRecord && nextRecord.open_code) {
            const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            if (nextNumbers.length >= 7) {
              const nextSpecial = nextNumbers[6];
              const nextSpecialAttr = Formatter.getAttributes(nextSpecial);
              const nextSpecialSize = nextSpecialAttr.size;
              
              const key = `${specialSize}->${nextSpecialSize}`;
              patterns.sizeSequence[key] = (patterns.sizeSequence[key] || 0) + 1;
            }
          }
        }
      }
      
      // è®¡ç®—å¤§å°é—´éš”
      const lastSeen = {};
      for (let i = 0; i < sizeHistory.length; i++) {
        const size = sizeHistory[i];
        
        if (lastSeen[size] !== undefined) {
          const gap = i - lastSeen[size];
          patterns.sizeGap[size].push(gap);
        }
        
        lastSeen[size] = i;
      }
      
      // è®¡ç®—å¤§å°ç»„åˆ
      for (let i = 0; i < sizeHistory.length - 3; i++) {
        const size1 = sizeHistory[i];
        const size2 = sizeHistory[i + 1];
        const size3 = sizeHistory[i + 2];
        const key = `${size1}${size2}${size3}`;
        patterns.sizeCombinations[key] = (patterns.sizeCombinations[key] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºå¤§å°ç»„åˆæ¨¡å¼
      const sizePatterns = {};
      for (let i = 0; i < sizeHistory.length - 2; i++) {
        const pattern = sizeHistory.slice(i, i + 3).join("");
        sizePatterns[pattern] = (sizePatterns[pattern] || 0) + 1;
      }
      
      patterns.sizeClusters = Object.entries(sizePatterns)
        .filter(([_, count]) => count > history.length * 0.05) // å‡ºç°é¢‘ç‡è¶…è¿‡5%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8)
        .reduce((obj, [key, value]) => {
          obj[key] = value;
          return obj;
        }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå¤§å°æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeParityPatterns(history) {
    try {
      const patterns = {
        paritySequence: {},           // å•åŒåºåˆ—
        parityFrequency: {},          // å•åŒé¢‘ç‡
        parityGap: {},                // å•åŒé—´éš”
        parityCombinations: {},       // å•åŒç»„åˆ
        parityClusters: {}            // å•åŒèšç±»
      };
      
      const parities = ['å•', 'åŒ'];
      
      // åˆå§‹åŒ–
      parities.forEach(parity => {
        patterns.parityFrequency[parity] = 0;
        patterns.parityGap[parity] = [];
      });
      
      // åˆ†ææ¯æ¡è®°å½•
      const parityHistory = [];
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialParity = specialAttr.parity;
        
        parityHistory.push(specialParity);
        
        // å•åŒé¢‘ç‡
        patterns.parityFrequency[specialParity]++;
        
        // å•åŒåºåˆ—
        if (i < history.length - 1) {
          const nextRecord = history[i + 1];
          if (nextRecord && nextRecord.open_code) {
            const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            if (nextNumbers.length >= 7) {
              const nextSpecial = nextNumbers[6];
              const nextSpecialAttr = Formatter.getAttributes(nextSpecial);
              const nextSpecialParity = nextSpecialAttr.parity;
              
              const key = `${specialParity}->${nextSpecialParity}`;
              patterns.paritySequence[key] = (patterns.paritySequence[key] || 0) + 1;
            }
          }
        }
      }
      
      // è®¡ç®—å•åŒé—´éš”
      const lastSeen = {};
      for (let i = 0; i < parityHistory.length; i++) {
        const parity = parityHistory[i];
        
        if (lastSeen[parity] !== undefined) {
          const gap = i - lastSeen[parity];
          patterns.parityGap[parity].push(gap);
        }
        
        lastSeen[parity] = i;
      }
      
      // è®¡ç®—å•åŒç»„åˆ
      for (let i = 0; i < parityHistory.length - 4; i++) {
        const parity1 = parityHistory[i];
        const parity2 = parityHistory[i + 1];
        const parity3 = parityHistory[i + 2];
        const parity4 = parityHistory[i + 3];
        const key = `${parity1}${parity2}${parity3}${parity4}`;
        patterns.parityCombinations[key] = (patterns.parityCombinations[key] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºå•åŒç»„åˆæ¨¡å¼
      const parityPatterns = {};
      for (let i = 0; i < parityHistory.length - 3; i++) {
        const pattern = parityHistory.slice(i, i + 4).join("");
        parityPatterns[pattern] = (parityPatterns[pattern] || 0) + 1;
      }
      
      patterns.parityClusters = Object.entries(parityPatterns)
        .filter(([_, count]) => count > history.length * 0.04) // å‡ºç°é¢‘ç‡è¶…è¿‡4%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6)
        .reduce((obj, [key, value]) => {
          obj[key] = value;
          return obj;
        }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå•åŒæ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeHeadPatterns(history) {
    try {
      const patterns = {
        headSequence: {},             // å¤´æ•°åºåˆ—
        headFrequency: {},            // å¤´æ•°é¢‘ç‡
        headGap: {},                  // å¤´æ•°é—´éš”
        headCombinations: {},         // å¤´æ•°ç»„åˆ
        headClusters: {}              // å¤´æ•°èšç±»
      };
      
      // åˆå§‹åŒ–å¤´æ•°ï¼ˆ0-4ï¼‰
      for (let i = 0; i <= 4; i++) {
        patterns.headFrequency[i] = 0;
        patterns.headGap[i] = [];
      }
      
      // åˆ†ææ¯æ¡è®°å½•
      const headHistory = [];
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialHead = Formatter.getHead(special);
        
        headHistory.push(specialHead);
        
        // å¤´æ•°é¢‘ç‡
        patterns.headFrequency[specialHead]++;
        
        // å¤´æ•°åºåˆ—
        if (i < history.length - 1) {
          const nextRecord = history[i + 1];
          if (nextRecord && nextRecord.open_code) {
            const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
            if (nextNumbers.length >= 7) {
              const nextSpecial = nextNumbers[6];
              const nextSpecialHead = Formatter.getHead(nextSpecial);
              
              const key = `${specialHead}->${nextSpecialHead}`;
              patterns.headSequence[key] = (patterns.headSequence[key] || 0) + 1;
            }
          }
        }
      }
      
      // è®¡ç®—å¤´æ•°é—´éš”
      const lastSeen = {};
      for (let i = 0; i < headHistory.length; i++) {
        const head = headHistory[i];
        
        if (lastSeen[head] !== undefined) {
          const gap = i - lastSeen[head];
          patterns.headGap[head].push(gap);
        }
        
        lastSeen[head] = i;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºå¤´æ•°ç»„åˆ
      const headPairs = {};
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialHead = Formatter.getHead(special);
        const normals = numbers.slice(0, 6);
        
        // ç‰¹ç å¤´æ•°ä¸å¹³ç å¤´æ•°çš„å…³è”
        normals.forEach(number => {
          const normalHead = Formatter.getHead(number);
          const key = `${Math.min(specialHead, normalHead)}-${Math.max(specialHead, normalHead)}`;
          headPairs[key] = (headPairs[key] || 0) + 1;
        });
      }
      
      patterns.headClusters = Object.entries(headPairs)
        .filter(([_, count]) => count > history.length * 0.03) // å‡ºç°é¢‘ç‡è¶…è¿‡3%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8)
        .reduce((obj, [key, value]) => {
          obj[key] = value;
          return obj;
        }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå¤´æ•°æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeNormalTailPatterns(history) {
    try {
      const patterns = {
        normalTailDistribution: {},   // å¹³ç å°¾æ•°åˆ†å¸ƒ
        normalTailToSpecial: {},      // å¹³ç å°¾æ•°åˆ°ç‰¹ç 
        normalTailCombinations: {},   // å¹³ç å°¾æ•°ç»„åˆ
        normalTailClusters: {}        // å¹³ç å°¾æ•°èšç±»
      };
      
      // åˆå§‹åŒ–å°¾æ•°ï¼ˆ0-9ï¼‰
      for (let i = 0; i <= 9; i++) {
        patterns.normalTailDistribution[i] = 0;
      }
      
      // åˆ†ææ¯æ¡è®°å½•
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialTail = Formatter.getTail(special);
        const normals = numbers.slice(0, 6);
        const normalTails = normals.map(n => Formatter.getTail(n));
        
        // å¹³ç å°¾æ•°åˆ†å¸ƒ
        normalTails.forEach(tail => {
          patterns.normalTailDistribution[tail]++;
        });
        
        // å¹³ç å°¾æ•°åˆ°ç‰¹ç 
        normalTails.forEach(normalTail => {
          const key = `${normalTail}->${specialTail}`;
          patterns.normalTailToSpecial[key] = (patterns.normalTailToSpecial[key] || 0) + 1;
        });
        
        // å¹³ç å°¾æ•°ç»„åˆ
        const sortedTails = [...normalTails].sort((a, b) => a - b);
        const tailKey = sortedTails.join(",");
        patterns.normalTailCombinations[tailKey] = (patterns.normalTailCombinations[tailKey] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºå¹³ç å°¾æ•°ç»„åˆæ¨¡å¼
      const topCombinations = Object.entries(patterns.normalTailCombinations)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15);
      
      patterns.normalTailClusters = topCombinations.reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå¹³ç å°¾æ•°æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeNormalZodiacPatterns(history) {
    try {
      const patterns = {
        normalZodiacDistribution: {}, // å¹³ç ç”Ÿè‚–åˆ†å¸ƒ
        normalZodiacToSpecial: {},    // å¹³ç ç”Ÿè‚–åˆ°ç‰¹ç 
        normalZodiacCombinations: {}, // å¹³ç ç”Ÿè‚–ç»„åˆ
        normalZodiacClusters: {}      // å¹³ç ç”Ÿè‚–èšç±»
      };
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      
      // åˆå§‹åŒ–ç”Ÿè‚–
      allZodiacs.forEach(zodiac => {
        patterns.normalZodiacDistribution[zodiac] = 0;
      });
      
      // åˆ†ææ¯æ¡è®°å½•
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialZodiac = specialAttr.zodiac;
        const normals = numbers.slice(0, 6);
        
        // å¹³ç ç”Ÿè‚–åˆ†å¸ƒ
        normals.forEach(number => {
          const attr = Formatter.getAttributes(number);
          patterns.normalZodiacDistribution[attr.zodiac]++;
        });
        
        // å¹³ç ç”Ÿè‚–åˆ°ç‰¹ç 
        normals.forEach(number => {
          const attr = Formatter.getAttributes(number);
          const key = `${attr.zodiac}->${specialZodiac}`;
          patterns.normalZodiacToSpecial[key] = (patterns.normalZodiacToSpecial[key] || 0) + 1;
        });
        
        // å¹³ç ç”Ÿè‚–ç»„åˆ
        const normalZodiacs = normals.map(n => Formatter.getAttributes(n).zodiac).sort();
        const zodiacKey = normalZodiacs.join(",");
        patterns.normalZodiacCombinations[zodiacKey] = (patterns.normalZodiacCombinations[zodiacKey] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºå¹³ç ç”Ÿè‚–ç»„åˆæ¨¡å¼
      const topCombinations = Object.entries(patterns.normalZodiacCombinations)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
      
      patterns.normalZodiacClusters = topCombinations.reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå¹³ç ç”Ÿè‚–æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeNormalColorPatterns(history) {
    try {
      const patterns = {
        normalColorDistribution: {},  // å¹³ç é¢œè‰²åˆ†å¸ƒ
        normalColorToSpecial: {},     // å¹³ç é¢œè‰²åˆ°ç‰¹ç 
        normalColorCombinations: {},  // å¹³ç é¢œè‰²ç»„åˆ
        normalColorClusters: {}       // å¹³ç é¢œè‰²èšç±»
      };
      
      const colors = ['red', 'blue', 'green'];
      
      // åˆå§‹åŒ–é¢œè‰²
      colors.forEach(color => {
        patterns.normalColorDistribution[color] = 0;
      });
      
      // åˆ†ææ¯æ¡è®°å½•
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const specialAttr = Formatter.getAttributes(special);
        const specialColor = specialAttr.color;
        const normals = numbers.slice(0, 6);
        
        // å¹³ç é¢œè‰²åˆ†å¸ƒ
        normals.forEach(number => {
          const attr = Formatter.getAttributes(number);
          patterns.normalColorDistribution[attr.color]++;
        });
        
        // å¹³ç é¢œè‰²åˆ°ç‰¹ç 
        normals.forEach(number => {
          const attr = Formatter.getAttributes(number);
          const key = `${attr.color}->${specialColor}`;
          patterns.normalColorToSpecial[key] = (patterns.normalColorToSpecial[key] || 0) + 1;
        });
        
        // å¹³ç é¢œè‰²ç»„åˆ
        const normalColors = normals.map(n => Formatter.getAttributes(n).color).sort();
        const colorCount = {
          red: normalColors.filter(c => c === 'red').length,
          blue: normalColors.filter(c => c === 'blue').length,
          green: normalColors.filter(c => c === 'green').length
        };
        const colorKey = `R${colorCount.red}B${colorCount.blue}G${colorCount.green}`;
        patterns.normalColorCombinations[colorKey] = (patterns.normalColorCombinations[colorKey] || 0) + 1;
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºå¹³ç é¢œè‰²ç»„åˆæ¨¡å¼
      const topCombinations = Object.entries(patterns.normalColorCombinations)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      patterns.normalColorClusters = topCombinations.reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå¹³ç é¢œè‰²æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeSequencePatterns(history) {
    try {
      const patterns = {
        numberSequences: {},          // æ•°å­—åºåˆ—
        tailSequences: {},            // å°¾æ•°åºåˆ—
        zodiacSequences: {},          // ç”Ÿè‚–åºåˆ—
        colorSequences: {},           // é¢œè‰²åºåˆ—
        sizeSequences: {},            // å¤§å°åºåˆ—
        paritySequences: {},          // å•åŒåºåˆ—
        headSequences: {},            // å¤´æ•°åºåˆ—
        sequenceClusters: {}          // åºåˆ—èšç±»
      };
      
      // åˆ†æè¿ç»­å‡ æœŸçš„æ¨¡å¼
      const sequenceLength = 3;
      
      for (let i = 0; i < history.length - sequenceLength; i++) {
        const sequence = history.slice(i, i + sequenceLength);
        
        // æ£€æŸ¥åºåˆ—æ˜¯å¦å®Œæ•´
        let validSequence = true;
        for (const record of sequence) {
          if (!record || !record.open_code) {
            validSequence = false;
            break;
          }
        }
        
        if (!validSequence) continue;
        
        // æå–åºåˆ—ç‰¹å¾
        const features = this.extractSequenceFeatures(sequence);
        
        // æ•°å­—åºåˆ—
        const numberKey = features.numbers.join("->");
        patterns.numberSequences[numberKey] = (patterns.numberSequences[numberKey] || 0) + 1;
        
        // å°¾æ•°åºåˆ—
        const tailKey = features.tails.join("->");
        patterns.tailSequences[tailKey] = (patterns.tailSequences[tailKey] || 0) + 1;
        
        // ç”Ÿè‚–åºåˆ—
        const zodiacKey = features.zodiacs.join("->");
        patterns.zodiacSequences[zodiacKey] = (patterns.zodiacSequences[zodiacKey] || 0) + 1;
        
        // é¢œè‰²åºåˆ—
        const colorKey = features.colors.join("->");
        patterns.colorSequences[colorKey] = (patterns.colorSequences[colorKey] || 0) + 1;
        
        // å¤§å°åºåˆ—
        const sizeKey = features.sizes.join("->");
        patterns.sizeSequences[sizeKey] = (patterns.sizeSequences[sizeKey] || 0) + 1;
        
        // å•åŒåºåˆ—
        const parityKey = features.parities.join("->");
        patterns.paritySequences[parityKey] = (patterns.paritySequences[parityKey] || 0) + 1;
        
        // å¤´æ•°åºåˆ—
        const headKey = features.heads.join("->");
        patterns.headSequences[headKey] = (patterns.headSequences[headKey] || 0) + 1;
      }
      
      // æ‰¾å‡ºæœ€å¸¸è§çš„åºåˆ—æ¨¡å¼
      const allSequences = [
        ...Object.entries(patterns.numberSequences),
        ...Object.entries(patterns.tailSequences),
        ...Object.entries(patterns.zodiacSequences),
        ...Object.entries(patterns.colorSequences)
      ];
      
      const topSequences = allSequences
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
      
      patterns.sequenceClusters = topSequences.reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æåºåˆ—æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static extractSequenceFeatures(sequence) {
    const features = {
      numbers: [],
      tails: [],
      zodiacs: [],
      colors: [],
      sizes: [],
      parities: [],
      heads: []
    };
    
    for (const record of sequence) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (numbers.length < 7) continue;
      
      const special = numbers[6];
      const attr = Formatter.getAttributes(special);
      
      features.numbers.push(special);
      features.tails.push(Formatter.getTail(special));
      features.zodiacs.push(attr.zodiac);
      features.colors.push(attr.color);
      features.sizes.push(attr.size);
      features.parities.push(attr.parity);
      features.heads.push(attr.head);
    }
    
    return features;
  }
  
  static analyzePeriodPatterns(history) {
    try {
      const patterns = {
        period3: {},  // 3æœŸå‘¨æœŸ
        period5: {},  // 5æœŸå‘¨æœŸ
        period7: {},  // 7æœŸå‘¨æœŸ
        period10: {}, // 10æœŸå‘¨æœŸ
        period14: {}, // 14æœŸå‘¨æœŸ
        period21: {}, // 21æœŸå‘¨æœŸ
        periodClusters: {} // å‘¨æœŸèšç±»
      };
      
      const periods = [3, 5, 7, 10, 14, 21];
      
      for (const period of periods) {
        for (let i = 0; i < history.length - period; i++) {
          const current = history[i];
          const next = history[i + period];
          
          if (!current || !current.open_code || !next || !next.open_code) continue;
          
          const currentNumbers = current.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const nextNumbers = next.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          
          if (currentNumbers.length < 7 || nextNumbers.length < 7) continue;
          
          const currentSpecial = currentNumbers[6];
          const nextSpecial = nextNumbers[6];
          const currentAttr = Formatter.getAttributes(currentSpecial);
          const nextAttr = Formatter.getAttributes(nextSpecial);
          
          // æ•°å­—å‘¨æœŸ
          const numberKey = `${currentSpecial}->${nextSpecial}`;
          patterns[`period${period}`][numberKey] = (patterns[`period${period}`][numberKey] || 0) + 1;
          
          // ç”Ÿè‚–å‘¨æœŸ
          const zodiacKey = `${currentAttr.zodiac}->${nextAttr.zodiac}`;
          patterns[`period${period}`][`zodiac_${zodiacKey}`] = (patterns[`period${period}`][`zodiac_${zodiacKey}`] || 0) + 1;
          
          // é¢œè‰²å‘¨æœŸ
          const colorKey = `${currentAttr.color}->${nextAttr.color}`;
          patterns[`period${period}`][`color_${colorKey}`] = (patterns[`period${period}`][`color_${colorKey}`] || 0) + 1;
          
          // å°¾æ•°å‘¨æœŸ
          const currentTail = Formatter.getTail(currentSpecial);
          const nextTail = Formatter.getTail(nextSpecial);
          const tailKey = `${currentTail}->${nextTail}`;
          patterns[`period${period}`][`tail_${tailKey}`] = (patterns[`period${period}`][`tail_${tailKey}`] || 0) + 1;
        }
      }
      
      // æ‰¾å‡ºæœ€å¼ºçš„å‘¨æœŸæ¨¡å¼
      const allPeriods = [];
      for (const period of periods) {
        const periodKey = `period${period}`;
        const periodPatterns = patterns[periodKey];
        
        for (const [pattern, count] of Object.entries(periodPatterns)) {
          allPeriods.push({
            period: period,
            pattern: pattern,
            count: count,
            strength: count / (history.length / period)
          });
        }
      }
      
      const topPeriods = allPeriods
        .sort((a, b) => b.strength - a.strength)
        .slice(0, 15);
      
      patterns.periodClusters = topPeriods.reduce((obj, item) => {
        obj[`${item.period}æœŸ:${item.pattern}`] = {
          count: item.count,
          strength: item.strength
        };
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æå‘¨æœŸæ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeFrequencyPatterns(history) {
    try {
      const patterns = {
        numberFrequency: {},      // æ•°å­—é¢‘ç‡
        tailFrequency: {},        // å°¾æ•°é¢‘ç‡
        zodiacFrequency: {},      // ç”Ÿè‚–é¢‘ç‡
        colorFrequency: {},       // é¢œè‰²é¢‘ç‡
        hotNumbers: [],           // çƒ­å·
        coldNumbers: [],          // å†·å·
        overdueNumbers: [],       // é—æ¼å·ç 
        frequencyClusters: {}     // é¢‘ç‡èšç±»
      };
      
      // åˆå§‹åŒ–é¢‘ç‡ç»Ÿè®¡
      for (let i = 1; i <= 49; i++) {
        patterns.numberFrequency[i] = 0;
      }
      
      for (let i = 0; i <= 9; i++) {
        patterns.tailFrequency[i] = 0;
      }
      
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        patterns.zodiacFrequency[zodiac] = 0;
      });
      
      ['red', 'blue', 'green'].forEach(color => {
        patterns.colorFrequency[color] = 0;
      });
      
      // ç»Ÿè®¡é¢‘ç‡
      const lastSeen = {};
      for (let i = 0; i < history.length; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        const attr = Formatter.getAttributes(special);
        
        // æ•°å­—é¢‘ç‡
        patterns.numberFrequency[special]++;
        
        // å°¾æ•°é¢‘ç‡
        const tail = Formatter.getTail(special);
        patterns.tailFrequency[tail]++;
        
        // ç”Ÿè‚–é¢‘ç‡
        patterns.zodiacFrequency[attr.zodiac]++;
        
        // é¢œè‰²é¢‘ç‡
        patterns.colorFrequency[attr.color]++;
        
        // è®°å½•æœ€åå‡ºç°ä½ç½®
        lastSeen[special] = i;
      }
      
      // è®¡ç®—çƒ­å·ï¼ˆæœ€è¿‘20æœŸå‡ºç°æ¬¡æ•°æœ€å¤šçš„ï¼‰
      const recentHistory = history.slice(0, Math.min(20, history.length));
      const recentFrequency = {};
      
      for (const record of recentHistory) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        recentFrequency[special] = (recentFrequency[special] || 0) + 1;
      }
      
      patterns.hotNumbers = Object.entries(recentFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8)
        .map(([num, count]) => ({
          number: parseInt(num),
          frequency: count,
          heat: count / Math.min(20, history.length)
        }));
      
      // è®¡ç®—å†·å·å’Œé—æ¼å·ç 
      const allNumbers = Array.from({length: 49}, (_, i) => i + 1);
      
      // é—æ¼å·ç ï¼ˆä»æœªå‡ºç°è¿‡çš„ï¼‰
      patterns.overdueNumbers = allNumbers
        .filter(num => patterns.numberFrequency[num] === 0)
        .map(num => ({
          number: num,
          overdue: history.length
        }));
      
      // å†·å·ï¼ˆå‡ºç°é¢‘ç‡æœ€ä½çš„ï¼‰
      patterns.coldNumbers = Object.entries(patterns.numberFrequency)
        .filter(([_, freq]) => freq > 0)
        .map(([num, freq]) => ({
          number: parseInt(num),
          frequency: freq,
          coldness: 1 - (freq / history.length)
        }))
        .sort((a, b) => a.frequency - b.frequency)
        .slice(0, 10);
      
      // é¢‘ç‡èšç±»ï¼šæ‰¾å‡ºé¢‘ç‡åˆ†å¸ƒçš„æ¨¡å¼
      const frequencyRanges = {
        veryHigh: [], // å‰10%
        high: [],     // 10-30%
        medium: [],   // 30-70%
        low: [],      // 70-90%
        veryLow: []   // å10%
      };
      
      const sortedNumbers = Object.entries(patterns.numberFrequency)
        .sort((a, b) => b[1] - a[1]);
      
      const total = sortedNumbers.length;
      sortedNumbers.forEach(([num, freq], index) => {
        const percentile = (index + 1) / total;
        const numberObj = {
          number: parseInt(num),
          frequency: freq,
          percentile: percentile
        };
        
        if (percentile <= 0.1) {
          frequencyRanges.veryHigh.push(numberObj);
        } else if (percentile <= 0.3) {
          frequencyRanges.high.push(numberObj);
        } else if (percentile <= 0.7) {
          frequencyRanges.medium.push(numberObj);
        } else if (percentile <= 0.9) {
          frequencyRanges.low.push(numberObj);
        } else {
          frequencyRanges.veryLow.push(numberObj);
        }
      });
      
      patterns.frequencyClusters = frequencyRanges;
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æé¢‘ç‡æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeCombinationPatterns(history) {
    try {
      const patterns = {
        numberPairs: {},          // æ•°å­—å¯¹
        zodiacPairs: {},          // ç”Ÿè‚–å¯¹
        colorPairs: {},           // é¢œè‰²å¯¹
        sizeParityCombos: {},     // å¤§å°å•åŒç»„åˆ
        tailHeadCombos: {},       // å°¾æ•°å¤´æ•°ç»„åˆ
        combinationClusters: {}   // ç»„åˆèšç±»
      };
      
      // åˆ†æè¿ç»­ä¸¤æœŸçš„ç»„åˆ
      for (let i = 0; i < history.length - 1; i++) {
        const current = history[i];
        const next = history[i + 1];
        
        if (!current || !current.open_code || !next || !next.open_code) continue;
        
        const currentNumbers = current.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNumbers = next.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNumbers.length < 7 || nextNumbers.length < 7) continue;
        
        const currentSpecial = currentNumbers[6];
        const nextSpecial = nextNumbers[6];
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        // æ•°å­—å¯¹
        const numberPair = `${currentSpecial},${nextSpecial}`;
        patterns.numberPairs[numberPair] = (patterns.numberPairs[numberPair] || 0) + 1;
        
        // ç”Ÿè‚–å¯¹
        const zodiacPair = `${currentAttr.zodiac},${nextAttr.zodiac}`;
        patterns.zodiacPairs[zodiacPair] = (patterns.zodiacPairs[zodiacPair] || 0) + 1;
        
        // é¢œè‰²å¯¹
        const colorPair = `${currentAttr.color},${nextAttr.color}`;
        patterns.colorPairs[colorPair] = (patterns.colorPairs[colorPair] || 0) + 1;
        
        // å¤§å°å•åŒç»„åˆ
        const sizeParityCombo = `${currentAttr.size}${currentAttr.parity}->${nextAttr.size}${nextAttr.parity}`;
        patterns.sizeParityCombos[sizeParityCombo] = (patterns.sizeParityCombos[sizeParityCombo] || 0) + 1;
        
        // å°¾æ•°å¤´æ•°ç»„åˆ
        const currentTail = Formatter.getTail(currentSpecial);
        const currentHead = Formatter.getHead(currentSpecial);
        const nextTail = Formatter.getTail(nextSpecial);
        const nextHead = Formatter.getHead(nextSpecial);
        
        const tailHeadCombo = `T${currentTail}H${currentHead}->T${nextTail}H${nextHead}`;
        patterns.tailHeadCombos[tailHeadCombo] = (patterns.tailHeadCombos[tailHeadCombo] || 0) + 1;
      }
      
      // æ‰¾å‡ºæœ€å¼ºçš„ç»„åˆæ¨¡å¼
      const allCombinations = [
        ...Object.entries(patterns.numberPairs).map(([key, value]) => ({ type: 'number', key, value })),
        ...Object.entries(patterns.zodiacPairs).map(([key, value]) => ({ type: 'zodiac', key, value })),
        ...Object.entries(patterns.colorPairs).map(([key, value]) => ({ type: 'color', key, value })),
        ...Object.entries(patterns.sizeParityCombos).map(([key, value]) => ({ type: 'sizeParity', key, value }))
      ];
      
      const topCombinations = allCombinations
        .sort((a, b) => b.value - a.value)
        .slice(0, 20);
      
      patterns.combinationClusters = topCombinations.reduce((obj, item) => {
        obj[`${item.type}:${item.key}`] = item.value;
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æç»„åˆæ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeSpecialPatterns(history) {
    try {
      const patterns = {
        repeatingNumbers: [],      // é‡å¤å‡ºç°çš„æ•°å­—
        alternatingPatterns: {},   // äº¤æ›¿æ¨¡å¼
        trendPatterns: {},         // è¶‹åŠ¿æ¨¡å¼
        clusterPatterns: {},       // èšç±»æ¨¡å¼
        specialClusters: {}        // ç‰¹æ®Šæ¨¡å¼èšç±»
      };
      
      // åˆ†æé‡å¤æ•°å­—
      const numberCount = {};
      for (const record of history) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6];
        numberCount[special] = (numberCount[special] || 0) + 1;
      }
      
      patterns.repeatingNumbers = Object.entries(numberCount)
        .filter(([_, count]) => count > 1)
        .map(([num, count]) => ({
          number: parseInt(num),
          count: count,
          repeatRate: count / history.length
        }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);
      
      // åˆ†æäº¤æ›¿æ¨¡å¼ï¼ˆå¦‚å¤§å°äº¤æ›¿ã€å•åŒäº¤æ›¿ï¼‰
      for (let i = 0; i < history.length - 2; i++) {
        const records = history.slice(i, i + 3);
        
        let valid = true;
        for (const record of records) {
          if (!record || !record.open_code) {
            valid = false;
            break;
          }
        }
        
        if (!valid) continue;
        
        const attributes = records.map(record => {
          const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const special = numbers[6];
          return Formatter.getAttributes(special);
        });
        
        // å¤§å°äº¤æ›¿æ¨¡å¼
        const sizePattern = attributes.map(attr => attr.size).join("");
        patterns.alternatingPatterns[`size_${sizePattern}`] = 
          (patterns.alternatingPatterns[`size_${sizePattern}`] || 0) + 1;
        
        // å•åŒäº¤æ›¿æ¨¡å¼
        const parityPattern = attributes.map(attr => attr.parity).join("");
        patterns.alternatingPatterns[`parity_${parityPattern}`] = 
          (patterns.alternatingPatterns[`parity_${parityPattern}`] || 0) + 1;
        
        // é¢œè‰²äº¤æ›¿æ¨¡å¼
        const colorPattern = attributes.map(attr => attr.color).join("->");
        patterns.alternatingPatterns[`color_${colorPattern}`] = 
          (patterns.alternatingPatterns[`color_${colorPattern}`] || 0) + 1;
        
        // ç”Ÿè‚–äº¤æ›¿æ¨¡å¼
        const zodiacPattern = attributes.map(attr => attr.zodiac).join("->");
        patterns.alternatingPatterns[`zodiac_${zodiacPattern}`] = 
          (patterns.alternatingPatterns[`zodiac_${zodiacPattern}`] || 0) + 1;
      }
      
      // åˆ†æè¶‹åŠ¿æ¨¡å¼ï¼ˆæ•°å­—ä¸Šå‡/ä¸‹é™è¶‹åŠ¿ï¼‰
      const specialNumbers = [];
      for (const record of history.slice(0, Math.min(15, history.length))) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length >= 7) {
          specialNumbers.push(numbers[6]);
        }
      }
      
      if (specialNumbers.length >= 3) {
        let increasing = 0;
        let decreasing = 0;
        let stable = 0;
        
        for (let i = 0; i < specialNumbers.length - 1; i++) {
          if (specialNumbers[i] < specialNumbers[i + 1]) {
            increasing++;
          } else if (specialNumbers[i] > specialNumbers[i + 1]) {
            decreasing++;
          } else {
            stable++;
          }
        }
        
        patterns.trendPatterns = {
          increasing: increasing,
          decreasing: decreasing,
          stable: stable,
          total: specialNumbers.length - 1,
          trend: increasing > decreasing ? "ä¸Šå‡" : decreasing > increasing ? "ä¸‹é™" : "å¹³ç¨³",
          strength: Math.abs(increasing - decreasing) / (specialNumbers.length - 1)
        };
      }
      
      // èšç±»åˆ†æï¼šæ‰¾å‡ºç‰¹æ®Šæ¨¡å¼
      const specialPatterns = Object.entries(patterns.alternatingPatterns)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      patterns.specialClusters = specialPatterns.reduce((obj, [key, value]) => {
        obj[key] = {
          count: value,
          frequency: value / history.length
        };
        return obj;
      }, {});
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æç‰¹æ®Šæ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeTrendPatterns(history) {
    try {
      const patterns = {
        numberTrends: {},      // æ•°å­—è¶‹åŠ¿
        tailTrends: {},        // å°¾æ•°è¶‹åŠ¿
        zodiacTrends: {},      // ç”Ÿè‚–è¶‹åŠ¿
        colorTrends: {},       // é¢œè‰²è¶‹åŠ¿
        trendClusters: {}      // è¶‹åŠ¿èšç±»
      };
      
      // åˆ†ææ•°å­—è¶‹åŠ¿ï¼ˆä¸Šå‡ã€ä¸‹é™ã€å¹³ç¨³ï¼‰
      const numberSequences = [];
      for (let i = 0; i < history.length - 1; i++) {
        const current = history[i];
        const next = history[i + 1];
        
        if (!current || !current.open_code || !next || !next.open_code) continue;
        
        const currentNumbers = current.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNumbers = next.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNumbers.length < 7 || nextNumbers.length < 7) continue;
        
        const currentSpecial = currentNumbers[6];
        const nextSpecial = nextNumbers[6];
        
        const trend = currentSpecial < nextSpecial ? "up" : 
                     currentSpecial > nextSpecial ? "down" : "stable";
        
        patterns.numberTrends[trend] = (patterns.numberTrends[trend] || 0) + 1;
      }
      
      // åˆ†æè¿ç»­è¶‹åŠ¿
      let currentTrend = null;
      let trendLength = 0;
      const trendSegments = [];
      
      for (let i = 0; i < history.length - 1; i++) {
        const current = history[i];
        const next = history[i + 1];
        
        if (!current || !current.open_code || !next || !next.open_code) continue;
        
        const currentNumbers = current.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNumbers = next.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNumbers.length < 7 || nextNumbers.length < 7) continue;
        
        const currentSpecial = currentNumbers[6];
        const nextSpecial = nextNumbers[6];
        
        const trend = currentSpecial < nextSpecial ? "up" : 
                     currentSpecial > nextSpecial ? "down" : "stable";
        
        if (trend === currentTrend) {
          trendLength++;
        } else {
          if (currentTrend && trendLength > 0) {
            trendSegments.push({
              trend: currentTrend,
              length: trendLength,
              start: i - trendLength,
              end: i
            });
          }
          currentTrend = trend;
          trendLength = 1;
        }
      }
      
      // æ‰¾å‡ºæœ€é•¿çš„è¶‹åŠ¿æ®µ
      const longTrends = trendSegments
        .sort((a, b) => b.length - a.length)
        .slice(0, 5);
      
      patterns.trendClusters = {
        overall: patterns.numberTrends,
        segments: longTrends,
        avgSegmentLength: trendSegments.length > 0 ? 
          trendSegments.reduce((sum, seg) => sum + seg.length, 0) / trendSegments.length : 0
      };
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æè¶‹åŠ¿æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static analyzeClusterPatterns(history) {
    try {
      const patterns = {
        numberClusters: {},    // æ•°å­—èšç±»
        tailClusters: {},      // å°¾æ•°èšç±»
        zodiacClusters: {},    // ç”Ÿè‚–èšç±»
        colorClusters: {},     // é¢œè‰²èšç±»
        clusterAnalysis: {}    // èšç±»åˆ†æ
      };
      
      // ä½¿ç”¨ç®€å•çš„èšç±»ç®—æ³•ï¼šæ‰¾å‡ºç»å¸¸ä¸€èµ·å‡ºç°çš„æ•°å­—
      const numberPairs = {};
      const numberGroups = {};
      
      // åˆ†ææ¯æœŸå¼€å¥–å·ç ä¸­çš„æ•°å­—å…³ç³»
      for (const record of history) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        // æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬å¹³ç å’Œç‰¹ç ï¼‰
        const allNumbers = [...numbers];
        
        // è®°å½•æ•°å­—å¯¹
        for (let i = 0; i < allNumbers.length; i++) {
          for (let j = i + 1; j < allNumbers.length; j++) {
            const num1 = allNumbers[i];
            const num2 = allNumbers[j];
            const key = `${Math.min(num1, num2)}-${Math.max(num1, num2)}`;
            numberPairs[key] = (numberPairs[key] || 0) + 1;
          }
        }
        
        // è®°å½•æ•°å­—ç»„
        const sortedNumbers = [...allNumbers].sort((a, b) => a - b);
        const groupKey = sortedNumbers.join(",");
        numberGroups[groupKey] = (numberGroups[groupKey] || 0) + 1;
      }
      
      // æ‰¾å‡ºå¼ºå…³è”çš„æ•°å­—å¯¹
      const strongPairs = Object.entries(numberPairs)
        .filter(([_, count]) => count > history.length * 0.02) // å‡ºç°é¢‘ç‡è¶…è¿‡2%
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
      
      patterns.numberClusters = strongPairs.reduce((obj, [key, value]) => {
        obj[key] = {
          count: value,
          strength: value / history.length
        };
        return obj;
      }, {});
      
      // æ‰¾å‡ºå¸¸è§çš„æ•°å­—ç»„
      const commonGroups = Object.entries(numberGroups)
        .filter(([_, count]) => count > 1)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      patterns.clusterAnalysis = {
        totalPairs: Object.keys(numberPairs).length,
        totalGroups: Object.keys(numberGroups).length,
        commonPairs: strongPairs.length,
        commonGroups: commonGroups.length,
        mostCommonGroup: commonGroups[0] || null,
        pairDensity: Object.keys(numberPairs).length / (49 * 48 / 2) // æ•°å­—å¯¹å¯†åº¦
      };
      
      return patterns;
    } catch (error) {
      Logger.error("PatternAnalysis", "åˆ†æèšç±»æ¨¡å¼å¤±è´¥", error);
      return {};
    }
  }
  
  static calculateStdDev(numbers) {
    try {
      if (numbers.length === 0) return 0;
      
      const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
      const variance = numbers.reduce((sum, num) => sum + Math.pow(num - mean, 2), 0) / numbers.length;
      return Math.sqrt(variance);
    } catch (error) {
      return 0;
    }
  }
  
  static calculateOverallConfidence(patterns) {
    try {
      let confidence = 35; // åŸºç¡€ç½®ä¿¡åº¦
      
      // æ ¹æ®æ¨¡å¼æ•°é‡å’Œè´¨é‡è°ƒæ•´ç½®ä¿¡åº¦
      const patternCount = Object.keys(patterns).length;
      confidence += Math.min(25, patternCount * 2);
      
      // å¦‚æœæœ‰æ˜¾è‘—çš„å°¾æ•°æ¨¡å¼
      if (patterns.tailPatterns && patterns.tailPatterns.tailStats) {
        const tailStats = patterns.tailPatterns.tailStats;
        const hasStrongPatterns = Object.values(tailStats).some(stat => 
          stat.stdDev < stat.avgGap * 0.5 // æ ‡å‡†å·®å°äºå¹³å‡é—´éš”çš„ä¸€åŠï¼Œè¯´æ˜è§„å¾‹æ€§å¼º
        );
        
        if (hasStrongPatterns) {
          confidence += 8;
        }
      }
      
      // å¦‚æœæœ‰æ˜¾è‘—çš„ç”Ÿè‚–æ¨¡å¼
      if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacStats) {
        const zodiacStats = patterns.zodiacPatterns.zodiacStats;
        const zodiacVariety = Object.keys(zodiacStats).length;
        confidence += Math.min(7, zodiacVariety / 2);
      }
      
      // å¦‚æœæœ‰æ˜¾è‘—çš„é¢œè‰²æ¨¡å¼
      if (patterns.colorPatterns && patterns.colorPatterns.colorStats) {
        const colorStats = patterns.colorPatterns.colorStats;
        const colorBalance = Math.max(
          colorStats.red?.frequency || 0,
          colorStats.blue?.frequency || 0,
          colorStats.green?.frequency || 0
        ) / (patterns.totalRecords || 1);
        
        // å¦‚æœæŸç§é¢œè‰²å‡ºç°é¢‘ç‡æ˜æ˜¾é«˜äºå…¶ä»–ï¼Œè¯´æ˜æœ‰è§„å¾‹
        if (colorBalance > 0.4) {
          confidence += 5;
        }
      }
      
      // å¦‚æœæœ‰æ˜¾è‘—çš„é¢‘ç‡æ¨¡å¼
      if (patterns.frequencyPatterns && patterns.frequencyPatterns.hotNumbers) {
        const hotNumbers = patterns.frequencyPatterns.hotNumbers;
        if (hotNumbers.length >= 3) {
          confidence += 6;
        }
      }
      
      // å¦‚æœæœ‰æ˜¾è‘—çš„ç»„åˆæ¨¡å¼
      if (patterns.combinationPatterns && patterns.combinationPatterns.combinationClusters) {
        const combinationCount = Object.keys(patterns.combinationPatterns.combinationClusters).length;
        confidence += Math.min(5, combinationCount / 2);
      }
      
      // æ ¹æ®å†å²è®°å½•æ•°é‡è°ƒæ•´ç½®ä¿¡åº¦
      if (patterns.totalRecords > 100) {
        confidence += Math.min(10, Math.log10(patterns.totalRecords) * 3);
      }
      
      // é™åˆ¶ç½®ä¿¡åº¦èŒƒå›´
      confidence = Math.min(98, Math.max(30, confidence));
      
      return Math.round(confidence);
    } catch (error) {
      return 35;
    }
  }
  
  static createEmptyPatterns() {
    return {
      tailPatterns: {},
      zodiacPatterns: {},
      colorPatterns: {},
      sizePatterns: {},
      parityPatterns: {},
      headPatterns: {},
      sequencePatterns: {},
      periodPatterns: {},
      normalTailPatterns: {},
      normalZodiacPatterns: {},
      normalColorPatterns: {},
      frequencyPatterns: {},
      combinationPatterns: {},
      specialPatterns: {},
      trendPatterns: {},
      clusterPatterns: {},
      confidence: 30,
      totalRecords: 0,
      analysisTime: new Date().toISOString(),
      analysisDuration: 0
    };
  }
  
  static clearCache() {
    try {
      this.patternsCache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 7. å¢å¼ºKNNç®—æ³•ï¼ˆæ•´åˆå„ç§è§„å¾‹åˆ†æï¼‰
// ==============================================================================

class EnhancedKNNAgorithm {
  static distanceCache = new Map();
  static patternCache = new Map();
  
  static calculateDistance(currentRecord, historyRecord, patterns) {
    try {
      const cacheKey = `${currentRecord.special}_${historyRecord.special}_${JSON.stringify(patterns).substring(0, 50)}`;
      const cached = this.distanceCache.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const weights = CONFIG.SYSTEM.FEATURE_WEIGHTS;
      let totalDistance = 0;
      let weightSum = 0;
      
      // 1. ç‰¹ç æ•°å­—è·ç¦»ï¼ˆç»å¯¹å·®å€¼ï¼Œå½’ä¸€åŒ–åˆ°0-1ï¼‰
      const specialDiff = Math.abs(currentRecord.special - historyRecord.special);
      const specialDistance = specialDiff / 49;
      totalDistance += specialDistance * weights.special_weight;
      weightSum += weights.special_weight;
      
      // 2. ç”Ÿè‚–è·ç¦»ï¼ˆæ˜¯å¦ç›¸åŒï¼‰
      const zodiacDistance = currentRecord.zodiac === historyRecord.zodiac ? 0 : 1;
      totalDistance += zodiacDistance * weights.zodiac_weight;
      weightSum += weights.zodiac_weight;
      
      // 3. æ³¢è‰²è·ç¦»ï¼ˆæ˜¯å¦ç›¸åŒï¼‰
      const colorDistance = currentRecord.color === historyRecord.color ? 0 : 1;
      totalDistance += colorDistance * weights.color_weight;
      weightSum += weights.color_weight;
      
      // 4. å°¾æ•°è·ç¦»ï¼ˆç¯å½¢è·ç¦»ï¼Œ0-4ä¸ºè¿‘ï¼Œ5-9ä¸ºè¿œï¼‰
      const currentTail = currentRecord.tail;
      const historyTail = historyRecord.tail;
      const tailDiff = Math.min(
        Math.abs(currentTail - historyTail),
        10 - Math.abs(currentTail - historyTail)
      );
      const tailDistance = tailDiff / 5; // å½’ä¸€åŒ–åˆ°0-1
      totalDistance += tailDistance * weights.tail_weight;
      weightSum += weights.tail_weight;
      
      // 5. å¤§å°è·ç¦»ï¼ˆæ˜¯å¦ç›¸åŒï¼‰
      const sizeDistance = currentRecord.size === historyRecord.size ? 0 : 1;
      totalDistance += sizeDistance * weights.size_weight;
      weightSum += weights.size_weight;
      
      // 6. å•åŒè·ç¦»ï¼ˆæ˜¯å¦ç›¸åŒï¼‰
      const parityDistance = currentRecord.parity === historyRecord.parity ? 0 : 1;
      totalDistance += parityDistance * weights.parity_weight;
      weightSum += weights.parity_weight;
      
      // 7. å¤´æ•°è·ç¦»ï¼ˆç»å¯¹å·®å€¼ï¼‰
      const headDiff = Math.abs(currentRecord.head - historyRecord.head);
      const headDistance = headDiff / 5; // å½’ä¸€åŒ–åˆ°0-1ï¼ˆå¤´æ•°èŒƒå›´0-4ï¼‰
      totalDistance += headDistance * weights.head_weight;
      weightSum += weights.head_weight;
      
      // 8. å¹³ç Jaccardè·ç¦»ï¼ˆåŸºäºæ•°å­—ï¼‰
      const currentNormals = new Set(currentRecord.normals || []);
      const historyNormals = new Set(historyRecord.normals || []);
      const intersection = new Set([...currentNormals].filter(x => historyNormals.has(x)));
      const union = new Set([...currentNormals, ...historyNormals]);
      const jaccardDistance = union.size === 0 ? 1 : 1 - (intersection.size / union.size);
      
      // 9. å¹³ç å°¾æ•°è·ç¦»ï¼ˆåŸºäºå°¾æ•°åˆ†å¸ƒï¼‰
      const currentNormalTails = (currentRecord.normals || []).map(n => Formatter.getTail(n));
      const historyNormalTails = (historyRecord.normals || []).map(n => Formatter.getTail(n));
      
      let normalTailDistance = 0;
      if (currentNormalTails.length > 0 && historyNormalTails.length > 0) {
        const tailCount = {};
        for (let i = 0; i <= 9; i++) tailCount[i] = 0;
        
        currentNormalTails.forEach(tail => tailCount[tail]++);
        historyNormalTails.forEach(tail => tailCount[tail]--);
        
        const diff = Object.values(tailCount).reduce((sum, val) => sum + Math.abs(val), 0);
        normalTailDistance = diff / (currentNormalTails.length + historyNormalTails.length);
      }
      totalDistance += normalTailDistance * weights.normal_tail_weight;
      weightSum += weights.normal_tail_weight;
      
      // 10. å¹³ç ç”Ÿè‚–è·ç¦»ï¼ˆåŸºäºç”Ÿè‚–åˆ†å¸ƒï¼‰
      const currentNormalZodiacs = (currentRecord.normals || []).map(n => Formatter.getAttributes(n).zodiac);
      const historyNormalZodiacs = (historyRecord.normals || []).map(n => Formatter.getAttributes(n).zodiac);
      
      let normalZodiacDistance = 0;
      if (currentNormalZodiacs.length > 0 && historyNormalZodiacs.length > 0) {
        const zodiacCount = {};
        Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => zodiacCount[zodiac] = 0);
        
        currentNormalZodiacs.forEach(zodiac => zodiacCount[zodiac]++);
        historyNormalZodiacs.forEach(zodiac => zodiacCount[zodiac]--);
        
        const diff = Object.values(zodiacCount).reduce((sum, val) => sum + Math.abs(val), 0);
        normalZodiacDistance = diff / (currentNormalZodiacs.length + historyNormalZodiacs.length);
      }
      totalDistance += normalZodiacDistance * weights.normal_zodiac_weight;
      weightSum += weights.normal_zodiac_weight;
      
      // 11. å¹³ç é¢œè‰²è·ç¦»ï¼ˆåŸºäºé¢œè‰²åˆ†å¸ƒï¼‰
      const currentNormalColors = (currentRecord.normals || []).map(n => Formatter.getAttributes(n).color);
      const historyNormalColors = (historyRecord.normals || []).map(n => Formatter.getAttributes(n).color);
      
      let normalColorDistance = 0;
      if (currentNormalColors.length > 0 && historyNormalColors.length > 0) {
        const colorCount = { red: 0, blue: 0, green: 0 };
        
        currentNormalColors.forEach(color => colorCount[color]++);
        historyNormalColors.forEach(color => colorCount[color]--);
        
        const diff = Object.values(colorCount).reduce((sum, val) => sum + Math.abs(val), 0);
        normalColorDistance = diff / (currentNormalColors.length + historyNormalColors.length);
      }
      totalDistance += normalColorDistance * weights.normal_color_weight;
      weightSum += weights.normal_color_weight;
      
      // 12. åºåˆ—æ¨¡å¼è·ç¦»ï¼ˆåŸºäºå†å²è§„å¾‹ï¼‰
      let sequenceDistance = 0;
      if (patterns && patterns.sequencePatterns) {
        // æ£€æŸ¥å½“å‰è®°å½•æ˜¯å¦åŒ¹é…å·²çŸ¥åºåˆ—æ¨¡å¼
        const currentFeatures = {
          tail: currentRecord.tail,
          zodiac: currentRecord.zodiac,
          color: currentRecord.color,
          size: currentRecord.size,
          parity: currentRecord.parity,
          head: currentRecord.head
        };
        
        const historyFeatures = {
          tail: historyRecord.tail,
          zodiac: historyRecord.zodiac,
          color: historyRecord.color,
          size: historyRecord.size,
          parity: historyRecord.parity,
          head: historyRecord.head
        };
        
        // è®¡ç®—ç‰¹å¾åŒ¹é…åº¦
        let matchCount = 0;
        let totalFeatures = 0;
        
        for (const [key, value] of Object.entries(currentFeatures)) {
          if (historyFeatures[key] === value) {
            matchCount++;
          }
          totalFeatures++;
        }
        
        sequenceDistance = 1 - (matchCount / totalFeatures);
      }
      totalDistance += sequenceDistance * weights.sequence_weight;
      weightSum += weights.sequence_weight;
      
      // 13. å‘¨æœŸæ¨¡å¼è·ç¦»
      let periodDistance = 0;
      if (patterns && patterns.periodPatterns) {
        // æ£€æŸ¥æ˜¯å¦ç¬¦åˆå·²çŸ¥å‘¨æœŸæ¨¡å¼
        periodDistance = this.calculatePeriodMatch(currentRecord, historyRecord, patterns);
      }
      totalDistance += periodDistance * weights.period_weight;
      weightSum += weights.period_weight;
      
      // 14. é¢‘ç‡æ¨¡å¼è·ç¦»
      let frequencyDistance = 0;
      if (patterns && patterns.frequencyPatterns) {
        // æ ¹æ®é¢‘ç‡æ¨¡å¼è°ƒæ•´è·ç¦»
        frequencyDistance = this.calculateFrequencyMatch(currentRecord, historyRecord, patterns);
      }
      totalDistance += frequencyDistance * weights.frequency_weight;
      weightSum += weights.frequency_weight;
      
      // 15. æ¨¡å¼åŒ¹é…è·ç¦»ï¼ˆåŸºäºæ‰€æœ‰æ¨¡å¼ï¼‰
      let patternDistance = 0;
      if (patterns) {
        // ç»¼åˆè¯„ä¼°æ¨¡å¼åŒ¹é…åº¦
        patternDistance = this.calculatePatternMatchDistance(currentRecord, historyRecord, patterns);
      }
      totalDistance += patternDistance * weights.pattern_weight;
      weightSum += weights.pattern_weight;
      
      // 16. è¶‹åŠ¿æ¨¡å¼è·ç¦»
      let trendDistance = 0;
      if (patterns && patterns.trendPatterns) {
        trendDistance = this.calculateTrendMatch(currentRecord, historyRecord, patterns);
      }
      totalDistance += trendDistance * weights.trend_weight;
      weightSum += weights.trend_weight;
      
      // 17. èšç±»æ¨¡å¼è·ç¦»
      let clusterDistance = 0;
      if (patterns && patterns.clusterPatterns) {
        clusterDistance = this.calculateClusterMatch(currentRecord, historyRecord, patterns);
      }
      totalDistance += clusterDistance * weights.cluster_weight;
      weightSum += weights.cluster_weight;
      
      // è®¡ç®—åŠ æƒå¹³å‡è·ç¦»
      const finalDistance = weightSum > 0 ? totalDistance / weightSum : 1;
      
      this.distanceCache.set(cacheKey, finalDistance);
      return finalDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—è·ç¦»å¤±è´¥", error);
      return 1; // è¿”å›æœ€å¤§è·ç¦»å€¼
    }
  }
  
  static calculatePeriodMatch(currentRecord, historyRecord, patterns) {
    try {
      let matchScore = 0;
      let totalChecks = 0;
      
      // æ£€æŸ¥å„ç§å‘¨æœŸæ¨¡å¼
      const periods = [3, 5, 7, 10, 14, 21];
      for (const period of periods) {
        const periodKey = `period${period}`;
        if (patterns.periodPatterns[periodKey]) {
          const periodPatterns = patterns.periodPatterns[periodKey];
          
          // æ£€æŸ¥æ•°å­—å‘¨æœŸ
          const numberKey = `${currentRecord.special}->${historyRecord.special}`;
          if (periodPatterns[numberKey]) {
            matchScore += periodPatterns[numberKey] / patterns.totalRecords;
            totalChecks++;
          }
          
          // æ£€æŸ¥ç”Ÿè‚–å‘¨æœŸ
          const zodiacKey = `zodiac_${currentRecord.zodiac}->${historyRecord.zodiac}`;
          if (periodPatterns[zodiacKey]) {
            matchScore += periodPatterns[zodiacKey] / patterns.totalRecords;
            totalChecks++;
          }
          
          // æ£€æŸ¥é¢œè‰²å‘¨æœŸ
          const colorKey = `color_${currentRecord.color}->${historyRecord.color}`;
          if (periodPatterns[colorKey]) {
            matchScore += periodPatterns[colorKey] / patterns.totalRecords;
            totalChecks++;
          }
        }
      }
      
      // å°†åŒ¹é…åˆ†æ•°è½¬æ¢ä¸ºè·ç¦»ï¼ˆåŒ¹é…åº¦è¶Šé«˜ï¼Œè·ç¦»è¶Šå°ï¼‰
      const periodMatch = totalChecks > 0 ? matchScore / totalChecks : 0;
      const periodDistance = 1 - periodMatch;
      
      return periodDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—å‘¨æœŸåŒ¹é…å¤±è´¥", error);
      return 0.5;
    }
  }
  
  static calculateFrequencyMatch(currentRecord, historyRecord, patterns) {
    try {
      let frequencyDistance = 0.5; // é»˜è®¤ä¸­ç­‰è·ç¦»
      
      if (patterns.frequencyPatterns) {
        const hotNumbers = patterns.frequencyPatterns.hotNumbers || [];
        const coldNumbers = patterns.frequencyPatterns.coldNumbers || [];
        const overdueNumbers = patterns.frequencyPatterns.overdueNumbers || [];
        
        const isCurrentHot = hotNumbers.some(item => item.number === currentRecord.special);
        const isHistoryHot = hotNumbers.some(item => item.number === historyRecord.special);
        const isCurrentCold = coldNumbers.some(item => item.number === currentRecord.special);
        const isHistoryCold = coldNumbers.some(item => item.number === historyRecord.special);
        const isCurrentOverdue = overdueNumbers.some(item => item.number === currentRecord.special);
        const isHistoryOverdue = overdueNumbers.some(item => item.number === historyRecord.special);
        
        // è®¡ç®—é¢‘ç‡åŒ¹é…åº¦
        if (isCurrentHot && isHistoryHot) {
          frequencyDistance = 0.2; // éƒ½æ˜¯çƒ­å·ï¼Œè·ç¦»è¾ƒå°
        } else if (isCurrentHot || isHistoryHot) {
          frequencyDistance = 0.4; // ä¸€ä¸ªæ˜¯çƒ­å·ï¼Œè·ç¦»ä¸­ç­‰
        } else if (isCurrentCold && isHistoryCold) {
          frequencyDistance = 0.8; // éƒ½æ˜¯å†·å·ï¼Œè·ç¦»è¾ƒå¤§
        } else if (isCurrentOverdue && isHistoryOverdue) {
          frequencyDistance = 0.9; // éƒ½æ˜¯é—æ¼å·ï¼Œè·ç¦»å¾ˆå¤§
        } else {
          frequencyDistance = 0.6; // å…¶ä»–æƒ…å†µï¼Œä¸­ç­‰åå¤§
        }
      }
      
      return frequencyDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—é¢‘ç‡åŒ¹é…å¤±è´¥", error);
      return 0.5;
    }
  }
  
  static calculatePatternMatchDistance(currentRecord, historyRecord, patterns) {
    try {
      let matchScore = 0;
      let totalPatterns = 0;
      
      // 1. æ£€æŸ¥å°¾æ•°æ¨¡å¼åŒ¹é…
      if (patterns.tailPatterns && patterns.tailPatterns.normalTailToSpecial) {
        const currentTail = currentRecord.tail;
        const historyTail = historyRecord.tail;
        
        // æ£€æŸ¥å¹³ç å°¾æ•°åˆ°ç‰¹ç å°¾æ•°çš„æ¨¡å¼
        for (const [pattern, count] of Object.entries(patterns.tailPatterns.normalTailToSpecial)) {
          const [normalTail, specialTail] = pattern.split("->").map(Number);
          if (currentTail === normalTail && historyTail === specialTail) {
            matchScore += Math.min(1, count / 10); // æ ¹æ®å‡ºç°æ¬¡æ•°å¢åŠ åŒ¹é…åˆ†
            totalPatterns++;
          }
        }
      }
      
      // 2. æ£€æŸ¥ç”Ÿè‚–æ¨¡å¼åŒ¹é…
      if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacSequence) {
        const currentZodiac = currentRecord.zodiac;
        const historyZodiac = historyRecord.zodiac;
        
        for (const [pattern, count] of Object.entries(patterns.zodiacPatterns.zodiacSequence)) {
          const [zodiac1, zodiac2] = pattern.split("->");
          if (currentZodiac === zodiac1 && historyZodiac === zodiac2) {
            matchScore += Math.min(1, count / 8);
            totalPatterns++;
          }
        }
      }
      
      // 3. æ£€æŸ¥é¢œè‰²æ¨¡å¼åŒ¹é…
      if (patterns.colorPatterns && patterns.colorPatterns.colorSequence) {
        const currentColor = currentRecord.color;
        const historyColor = historyRecord.color;
        
        for (const [pattern, count] of Object.entries(patterns.colorPatterns.colorSequence)) {
          const [color1, color2] = pattern.split("->");
          if (currentColor === color1 && historyColor === color2) {
            matchScore += Math.min(1, count / 6);
            totalPatterns++;
          }
        }
      }
      
      // 4. æ£€æŸ¥å¤§å°æ¨¡å¼åŒ¹é…
      if (patterns.sizePatterns && patterns.sizePatterns.sizeSequence) {
        const currentSize = currentRecord.size;
        const historySize = historyRecord.size;
        
        for (const [pattern, count] of Object.entries(patterns.sizePatterns.sizeSequence)) {
          const [size1, size2] = pattern.split("->");
          if (currentSize === size1 && historySize === size2) {
            matchScore += Math.min(1, count / 5);
            totalPatterns++;
          }
        }
      }
      
      // 5. æ£€æŸ¥å•åŒæ¨¡å¼åŒ¹é…
      if (patterns.parityPatterns && patterns.parityPatterns.paritySequence) {
        const currentParity = currentRecord.parity;
        const historyParity = historyRecord.parity;
        
        for (const [pattern, count] of Object.entries(patterns.parityPatterns.paritySequence)) {
          const [parity1, parity2] = pattern.split("->");
          if (currentParity === parity1 && historyParity === parity2) {
            matchScore += Math.min(1, count / 5);
            totalPatterns++;
          }
        }
      }
      
      // 6. æ£€æŸ¥ç»„åˆæ¨¡å¼åŒ¹é…
      if (patterns.combinationPatterns) {
        const numberPair = `${currentRecord.special},${historyRecord.special}`;
        if (patterns.combinationPatterns.numberPairs && patterns.combinationPatterns.numberPairs[numberPair]) {
          matchScore += Math.min(1, patterns.combinationPatterns.numberPairs[numberPair] / 5);
          totalPatterns++;
        }
        
        const zodiacPair = `${currentRecord.zodiac},${historyRecord.zodiac}`;
        if (patterns.combinationPatterns.zodiacPairs && patterns.combinationPatterns.zodiacPairs[zodiacPair]) {
          matchScore += Math.min(1, patterns.combinationPatterns.zodiacPairs[zodiacPair] / 4);
          totalPatterns++;
        }
      }
      
      // å°†åŒ¹é…åˆ†æ•°è½¬æ¢ä¸ºè·ç¦»ï¼ˆåŒ¹é…åº¦è¶Šé«˜ï¼Œè·ç¦»è¶Šå°ï¼‰
      const patternMatch = totalPatterns > 0 ? matchScore / totalPatterns : 0;
      const patternDistance = 1 - patternMatch;
      
      return patternDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—æ¨¡å¼åŒ¹é…è·ç¦»å¤±è´¥", error);
      return 0.5; // è¿”å›ä¸­ç­‰è·ç¦»
    }
  }
  
  static calculateTrendMatch(currentRecord, historyRecord, patterns) {
    try {
      let trendDistance = 0.5; // é»˜è®¤ä¸­ç­‰è·ç¦»
      
      if (patterns.trendPatterns && patterns.trendPatterns.trendClusters) {
        // æ£€æŸ¥å½“å‰è¶‹åŠ¿
        const isUp = historyRecord.special > currentRecord.special;
        const isDown = historyRecord.special < currentRecord.special;
        const isStable = historyRecord.special === currentRecord.special;
        
        // è·å–è¶‹åŠ¿ç»Ÿè®¡
        const trendStats = patterns.trendPatterns.trendClusters.overall || {};
        const totalTrends = (trendStats.up || 0) + (trendStats.down || 0) + (trendStats.stable || 0);
        
        if (totalTrends > 0) {
          // è®¡ç®—å½“å‰è¶‹åŠ¿çš„æ¦‚ç‡
          const upProb = (trendStats.up || 0) / totalTrends;
          const downProb = (trendStats.down || 0) / totalTrends;
          const stableProb = (trendStats.stable || 0) / totalTrends;
          
          // æ ¹æ®è¶‹åŠ¿æ¦‚ç‡è°ƒæ•´è·ç¦»
          if (isUp) {
            trendDistance = 1 - upProb;
          } else if (isDown) {
            trendDistance = 1 - downProb;
          } else if (isStable) {
            trendDistance = 1 - stableProb;
          }
        }
      }
      
      return trendDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—è¶‹åŠ¿åŒ¹é…å¤±è´¥", error);
      return 0.5;
    }
  }
  
  static calculateClusterMatch(currentRecord, historyRecord, patterns) {
    try {
      let clusterDistance = 0.5; // é»˜è®¤ä¸­ç­‰è·ç¦»
      
      if (patterns.clusterPatterns && patterns.clusterPatterns.numberClusters) {
        const numberClusters = patterns.clusterPatterns.numberClusters;
        
        // æ£€æŸ¥å½“å‰æ•°å­—å¯¹æ˜¯å¦åœ¨èšç±»ä¸­
        const pairKey = `${Math.min(currentRecord.special, historyRecord.special)}-${Math.max(currentRecord.special, historyRecord.special)}`;
        
        if (numberClusters[pairKey]) {
          // å¦‚æœåœ¨èšç±»ä¸­ï¼Œæ ¹æ®å¼ºåº¦è°ƒæ•´è·ç¦»
          const strength = numberClusters[pairKey].strength || 0;
          clusterDistance = 1 - Math.min(1, strength * 2); // å¼ºåº¦è¶Šå¤§ï¼Œè·ç¦»è¶Šå°
        }
      }
      
      return clusterDistance;
    } catch (error) {
      Logger.error("EnhancedKNN", "è®¡ç®—èšç±»åŒ¹é…å¤±è´¥", error);
      return 0.5;
    }
  }
  
  static findKNearestNeighbors(currentRecord, historyRecords, patterns, k = CONFIG.SYSTEM.KNN_K_VALUE) {
    try {
      if (!historyRecords || historyRecords.length < k) {
        return [];
      }
      
      const distances = [];
      
      for (let i = 0; i < historyRecords.length; i++) {
        const historyRecord = historyRecords[i];
        
        // ç¡®ä¿æœ‰ä¸‹ä¸€æœŸæ•°æ®
        if (!historyRecord.nextSpecial) {
          continue;
        }
        
        const distance = this.calculateDistance(currentRecord, historyRecord, patterns);
        
        distances.push({
          index: i,
          distance: distance,
          nextSpecial: historyRecord.nextSpecial,
          nextNormals: historyRecord.nextNormals || [],
          nextZodiac: Formatter.getAttributes(historyRecord.nextSpecial).zodiac,
          nextColor: Formatter.getAttributes(historyRecord.nextSpecial).color,
          nextSize: Formatter.getAttributes(historyRecord.nextSpecial).size,
          nextParity: Formatter.getAttributes(historyRecord.nextSpecial).parity,
          nextTail: Formatter.getTail(historyRecord.nextSpecial),
          record: historyRecord
        });
      }
      
      // æŒ‰è·ç¦»æ’åºï¼ˆä»å°åˆ°å¤§ï¼‰
      distances.sort((a, b) => a.distance - b.distance);
      
      // è¿”å›æœ€è¿‘çš„kä¸ªé‚»å±…
      return distances.slice(0, Math.min(k, distances.length));
    } catch (error) {
      Logger.error("EnhancedKNN", "æŸ¥æ‰¾æœ€è¿‘é‚»å¤±è´¥", error);
      return [];
    }
  }
  
  static predictNextNumbers(currentRecord, historyRecords, patterns, k = CONFIG.SYSTEM.KNN_K_VALUE) {
    try {
      const neighbors = this.findKNearestNeighbors(currentRecord, historyRecords, patterns, k);
      
      if (neighbors.length === 0) {
        return {
          special: null,
          normals: [],
          zodiac: null,
          color: null,
          size: null,
          parity: null,
          tail: null,
          confidence: 0,
          neighborCount: 0,
          patternBased: false
        };
      }
      
      // ç»Ÿè®¡é‚»å±…çš„ä¸‹ä¸€æœŸæ•°æ®
      const specialFrequency = {};
      const zodiacFrequency = {};
      const colorFrequency = {};
      const sizeFrequency = {};
      const parityFrequency = {};
      const tailFrequency = {};
      const normalFrequency = {};
      
      for (const neighbor of neighbors) {
        // ç‰¹ç ç»Ÿè®¡
        const special = neighbor.nextSpecial;
        specialFrequency[special] = (specialFrequency[special] || 0) + 1;
        
        // ç”Ÿè‚–ç»Ÿè®¡
        zodiacFrequency[neighbor.nextZodiac] = (zodiacFrequency[neighbor.nextZodiac] || 0) + 1;
        
        // é¢œè‰²ç»Ÿè®¡
        colorFrequency[neighbor.nextColor] = (colorFrequency[neighbor.nextColor] || 0) + 1;
        
        // å¤§å°ç»Ÿè®¡
        sizeFrequency[neighbor.nextSize] = (sizeFrequency[neighbor.nextSize] || 0) + 1;
        
        // å•åŒç»Ÿè®¡
        parityFrequency[neighbor.nextParity] = (parityFrequency[neighbor.nextParity] || 0) + 1;
        
        // å°¾æ•°ç»Ÿè®¡
        tailFrequency[neighbor.nextTail] = (tailFrequency[neighbor.nextTail] || 0) + 1;
        
        // å¹³ç ç»Ÿè®¡
        if (neighbor.nextNormals && Array.isArray(neighbor.nextNormals)) {
          for (const normal of neighbor.nextNormals) {
            normalFrequency[normal] = (normalFrequency[normal] || 0) + 1;
          }
        }
      }
      
      // æ‰¾å‡ºæœ€é¢‘ç¹çš„ç‰¹ç 
      let predictedSpecial = null;
      let maxSpecialFrequency = 0;
      let specialCandidates = [];
      
      for (const [special, frequency] of Object.entries(specialFrequency)) {
        const num = parseInt(special);
        if (frequency > maxSpecialFrequency) {
          maxSpecialFrequency = frequency;
          predictedSpecial = num;
        }
        
        // æ”¶é›†æ‰€æœ‰å€™é€‰ç‰¹ç ï¼ˆé¢‘ç‡å¤§äº0çš„ï¼‰
        if (frequency > 0) {
          specialCandidates.push({
            number: num,
            frequency: frequency,
            probability: frequency / neighbors.length
          });
        }
      }
      
      // æ‰¾å‡ºæœ€é¢‘ç¹çš„ç”Ÿè‚–
      let predictedZodiac = null;
      let maxZodiacFrequency = 0;
      for (const [zodiac, frequency] of Object.entries(zodiacFrequency)) {
        if (frequency > maxZodiacFrequency) {
          maxZodiacFrequency = frequency;
          predictedZodiac = zodiac;
        }
      }
      
      // æ‰¾å‡ºæœ€é¢‘ç¹çš„é¢œè‰²
      let predictedColor = null;
      let maxColorFrequency = 0;
      for (const [color, frequency] of Object.entries(colorFrequency)) {
        if (frequency > maxColorFrequency) {
          maxColorFrequency = frequency;
          predictedColor = color;
        }
      }
      
      // è·å–é¢‘ç‡æœ€é«˜çš„6ä¸ªå¹³ç 
      const predictedNormals = Object.entries(normalFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6)
        .map(([num, freq]) => ({
          number: parseInt(num),
          frequency: freq,
          probability: freq / neighbors.length
        }));
      
      // è®¡ç®—ç½®ä¿¡åº¦
      const specialConfidence = Math.min(95, Math.round((maxSpecialFrequency / neighbors.length) * 100));
      
      // è€ƒè™‘æ¨¡å¼åˆ†æçš„ç½®ä¿¡åº¦
      let patternConfidence = 0;
      if (patterns && patterns.confidence) {
        patternConfidence = patterns.confidence * 0.35; // æ¨¡å¼åˆ†æå 35%æƒé‡
      }
      
      // è€ƒè™‘é‚»å±…è´¨é‡ï¼ˆè·ç¦»è¶Šè¿‘ï¼Œè´¨é‡è¶Šé«˜ï¼‰
      let neighborQuality = 0;
      if (neighbors.length > 0) {
        const avgDistance = neighbors.reduce((sum, n) => sum + n.distance, 0) / neighbors.length;
        neighborQuality = Math.max(0, 1 - avgDistance) * 100;
      }
      
      // ç»¼åˆç½®ä¿¡åº¦
      const totalConfidence = Math.min(98, Math.round(
        specialConfidence * 0.5 + 
        patternConfidence * 0.35 + 
        neighborQuality * 0.15
      ));
      
      return {
        special: predictedSpecial,
        specialCandidates: specialCandidates.sort((a, b) => b.frequency - a.frequency).slice(0, 5),
        normals: predictedNormals,
        zodiac: predictedZodiac,
        color: predictedColor,
        size: sizeFrequency['å¤§'] > sizeFrequency['å°'] ? 'å¤§' : 'å°',
        parity: parityFrequency['å•'] > parityFrequency['åŒ'] ? 'å•' : 'åŒ',
        tail: Object.keys(tailFrequency).reduce((a, b) => tailFrequency[a] > tailFrequency[b] ? a : b),
        confidence: totalConfidence,
        neighborCount: neighbors.length,
        patternBased: true,
        neighborQuality: Math.round(neighborQuality),
        analysisDetails: {
          specialFrequency: specialFrequency,
          zodiacFrequency: zodiacFrequency,
          colorFrequency: colorFrequency,
          patternConfidence: patterns?.confidence || 0,
          avgDistance: neighbors.length > 0 ? neighbors.reduce((sum, n) => sum + n.distance, 0) / neighbors.length : 1
        }
      };
    } catch (error) {
      Logger.error("EnhancedKNN", "é¢„æµ‹ä¸‹ä¸€æœŸå·ç å¤±è´¥", error);
      return {
        special: null,
        specialCandidates: [],
        normals: [],
        zodiac: null,
        color: null,
        size: null,
        parity: null,
        tail: null,
        confidence: 0,
        neighborCount: 0,
        patternBased: false
      };
    }
  }
  
  static preprocessHistory(history) {
    try {
      const processed = [];
      
      // å°†å†å²è®°å½•æŒ‰expectå‡åºæ’åˆ—ï¼ˆä»æ—§åˆ°æ–°ï¼‰
      const sortedHistory = [...history].sort((a, b) => 
        Formatter.compareExpect(a.expect, b.expect)
      );
      
      for (let i = 0; i < sortedHistory.length - 1; i++) {
        const currentRecord = sortedHistory[i];
        const nextRecord = sortedHistory[i + 1];
        
        if (currentRecord && currentRecord.open_code && nextRecord && nextRecord.open_code) {
          const currentNums = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const nextNums = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          
          if (currentNums.length >= 7 && nextNums.length >= 7) {
            const currentSpecial = currentNums[6] || 1;
            const nextSpecial = nextNums[6] || 1;
            const nextNormals = nextNums.slice(0, 6);
            
            const currentAttr = Formatter.getAttributes(currentSpecial);
            const nextAttr = Formatter.getAttributes(nextSpecial);
            
            processed.push({
              expect: currentRecord.expect,
              numbers: currentNums,
              special: currentSpecial,
              normals: currentNums.slice(0, 6),
              zodiac: currentAttr.zodiac,
              color: currentAttr.color,
              size: currentAttr.size,
              parity: currentAttr.parity,
              head: currentAttr.head,
              tail: currentAttr.tail,
              nextSpecial: nextSpecial,
              nextNormals: nextNormals,
              nextZodiac: nextAttr.zodiac,
              nextColor: nextAttr.color,
              nextSize: nextAttr.size,
              nextParity: nextAttr.parity
            });
          }
        }
      }
      
      Logger.info("EnhancedKNN", `é¢„å¤„ç†å†å²æ•°æ®å®Œæˆï¼Œå…± ${processed.length} æ¡æœ‰æ•ˆè®°å½•`);
      return processed;
    } catch (error) {
      Logger.error("EnhancedKNN", "é¢„å¤„ç†å†å²æ•°æ®å¤±è´¥", error);
      return [];
    }
  }
  
  static clearCache() {
    try {
      this.distanceCache.clear();
      this.patternCache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 8. é¢„æµ‹å¼•æ“ï¼ˆåŸºäºå¢å¼ºKNNå’Œæ¨¡å¼åˆ†æï¼‰
// ==============================================================================

class AdvancedPredictionEngine {
  static predictionCache = new Map();
  
  static async generate(env, history, weights, useKNN = true) {
    try {
      if (!history || history.length < 2) {
        return this.generateStaticFallback();
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      // è®¡ç®—ä¸‹ä¸€æœŸæœŸå·
      let nextExpect = "2025001";
      const latestExpect = lastRecord.expect;
      if (latestExpect && Formatter.isValidExpect(latestExpect)) {
        const latestNum = Formatter.safeInt(latestExpect, 2025000);
        nextExpect = (latestNum + 1).toString();
      }
      
      const cacheKey = `prediction_${lastSpecial}_${history.length}_${weights._version || '1.0'}_${useKNN}`;
      const cached = this.predictionCache.get(cacheKey);
      
      if (cached) {
        cached.nextExpect = nextExpect;
        return cached;
      }
      
      // åˆ†æå†å²æ¨¡å¼
      const patterns = PatternAnalysisEngine.analyzeHistoricalPatterns(history);
      
      // æ›´æ–°åˆ†æç»Ÿè®¡
      await DB.incrementAnalysisCount(env);
      
      // é¢„å¤„ç†å†å²æ•°æ®
      const processedHistory = EnhancedKNNAgorithm.preprocessHistory(history);
      
      if (processedHistory.length === 0) {
        return this.generateStaticFallback();
      }
      
      // è·å–æœ€æ–°ä¸€æœŸä½œä¸ºå½“å‰è®°å½•
      const currentRecord = processedHistory[processedHistory.length - 1];
      
      // ä½¿ç”¨å¢å¼ºKNNç®—æ³•é¢„æµ‹
      const knnResult = EnhancedKNNAgorithm.predictNextNumbers(
        currentRecord, 
        processedHistory, 
        patterns,
        CONFIG.SYSTEM.KNN_K_VALUE
      );
      
      // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹ç»“æœ
      const prediction = this.generateFinalPrediction(
        knnResult, 
        patterns, 
        history, 
        nextExpect, 
        lastRecord,
        useKNN
      );
      
      // æ›´æ–°é¢„æµ‹ç»Ÿè®¡
      await DB.incrementPredictionCount(env);
      
      this.predictionCache.set(cacheKey, prediction);
      return prediction;
      
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback();
    }
  }
  
  static generateFinalPrediction(knnResult, patterns, history, nextExpect, lastRecord, useKNN) {
    try {
      // å¦‚æœKNNé¢„æµ‹å¤±è´¥ï¼Œä½¿ç”¨æ¨¡å¼åˆ†æç”Ÿæˆé¢„æµ‹
      if (!knnResult.special || knnResult.confidence < 35) {
        return this.generatePredictionFromPatterns(patterns, history, nextExpect, lastRecord);
      }
      
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      // ç”Ÿæˆç‰¹ç æ¨èï¼ˆåŸºäºKNNç»“æœå’Œæ¨¡å¼åˆ†æï¼‰
      const specialNumbers = this.generateSpecialNumbers(knnResult, patterns);
      
      // ç”Ÿæˆå¹³ç æ¨è
      const normalNumbers = this.generateNormalNumbers(knnResult, patterns, specialNumbers);
      
      // ç”Ÿæˆç”Ÿè‚–æ¨è
      const zodiacPrediction = this.generateZodiacPrediction(knnResult, patterns);
      
      // ç”Ÿæˆé¢œè‰²æ¨è
      const colorPrediction = this.generateColorPrediction(knnResult, patterns);
      
      // ç”Ÿæˆå½¢æ€åˆ†æ
      const bestSpecial = specialNumbers[0]?.number || knnResult.special || 1;
      const bestAttr = Formatter.getAttributes(bestSpecial);
      const isBig = bestSpecial >= 25;
      const isOdd = bestSpecial % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestSpecial / 10);
      
      // ç”Ÿæˆå°¾æ•°æ¨è
      const tailRecommendations = this.generateTailRecommendations(patterns);
      
      // ç”Ÿæˆçƒ­å·å†·å·åˆ†æ
      const hotColdAnalysis = this.generateHotColdAnalysis(patterns);
      
      // ç”Ÿæˆè¶‹åŠ¿åˆ†æ
      const trendAnalysis = this.generateTrendAnalysis(patterns);
      
      // ç”Ÿæˆæ¨¡å¼å¼ºåº¦åˆ†æ
      const patternStrength = this.generatePatternStrengthAnalysis(patterns);
      
      // è®¡ç®—ç»¼åˆç½®ä¿¡åº¦
      let confidence = knnResult.confidence || 35;
      
      // æ ¹æ®å†å²æ•°æ®é‡è°ƒæ•´ç½®ä¿¡åº¦
      if (history.length > 200) {
        confidence = Math.min(98, confidence + 8);
      } else if (history.length > 100) {
        confidence = Math.min(95, confidence + 5);
      } else if (history.length > 50) {
        confidence = Math.min(90, confidence + 3);
      }
      
      // æ ¹æ®æ¨¡å¼åˆ†æè´¨é‡è°ƒæ•´ç½®ä¿¡åº¦
      if (patterns.confidence > 60) {
        confidence = Math.min(98, Math.round(confidence * 0.7 + patterns.confidence * 0.3));
      }
      
      // æ ¹æ®é‚»å±…è´¨é‡è°ƒæ•´ç½®ä¿¡åº¦
      if (knnResult.neighborQuality > 70) {
        confidence = Math.min(98, confidence + 3);
      }
      
      return {
        nextExpect: nextExpect,
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        tailRecommendations: tailRecommendations,
        hotColdAnalysis: hotColdAnalysis,
        trendAnalysis: trendAnalysis,
        patternStrength: patternStrength,
        confidence: confidence,
        analysisBased: true,
        knnUsed: useKNN,
        patternAnalysisUsed: true,
        totalHistoryRecords: history.length,
        patternConfidence: patterns.confidence || 0,
        neighborQuality: knnResult.neighborQuality || 0,
        neighborCount: knnResult.neighborCount || 0,
        basedOnLastRecord: {
          expect: lastRecord.expect || "æœªçŸ¥",
          openCode: lastOpenCode,
          special: lastSpecial,
          zodiac: lastAttr.zodiac,
          color: lastAttr.color,
          size: lastAttr.size,
          parity: lastAttr.parity
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V14.0-EnhancedPrediction"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆæœ€ç»ˆé¢„æµ‹å¤±è´¥", error);
      return this.generateStaticFallback();
    }
  }
  
  static generateSpecialNumbers(knnResult, patterns) {
    try {
      const specialNumbers = [];
      const usedNumbers = new Set();
      
      // æ·»åŠ KNNé¢„æµ‹çš„ç‰¹ç å€™é€‰
      if (knnResult.specialCandidates && knnResult.specialCandidates.length > 0) {
        for (const candidate of knnResult.specialCandidates) {
          if (candidate.number >= 1 && candidate.number <= 49 && !usedNumbers.has(candidate.number)) {
            const attr = Formatter.getAttributes(candidate.number);
            const score = Math.round(candidate.probability * 100);
            
            specialNumbers.push({
              number: candidate.number,
              score: score,
              probability: candidate.probability,
              zodiac: attr.zodiac,
              color: attr.color,
              size: attr.size,
              parity: attr.parity,
              source: "KNNé¢„æµ‹"
            });
            
            usedNumbers.add(candidate.number);
            
            if (specialNumbers.length >= 5) break;
          }
        }
      }
      
      // ä»æ¨¡å¼åˆ†æä¸­è·å–çƒ­å·
      if (patterns.frequencyPatterns && patterns.frequencyPatterns.hotNumbers) {
        const hotNumbers = patterns.frequencyPatterns.hotNumbers;
        for (const hotItem of hotNumbers) {
          const hotNum = hotItem.number;
          if (!usedNumbers.has(hotNum) && specialNumbers.length < 5) {
            const attr = Formatter.getAttributes(hotNum);
            const heat = hotItem.heat || 0;
            const score = Math.round(85 + (heat * 10));
            
            specialNumbers.push({
              number: hotNum,
              score: Math.min(95, score),
              probability: heat,
              zodiac: attr.zodiac,
              color: attr.color,
              size: attr.size,
              parity: attr.parity,
              source: "è¿‘æœŸçƒ­å·"
            });
            
            usedNumbers.add(hotNum);
          }
        }
      }
      
      // ä»å°¾æ•°æ¨¡å¼ä¸­è·å–æ¨è
      if (patterns.tailPatterns && patterns.tailPatterns.tailStats) {
        const tailStats = patterns.tailPatterns.tailStats;
        
        // æ‰¾å‡ºé—æ¼æœŸæ•°è¾ƒé•¿çš„å°¾æ•°
        const overdueTails = Object.entries(tailStats)
          .filter(([_, stats]) => stats.overdue > (stats.avgGap || 0) * 1.5) // é—æ¼è¶…è¿‡å¹³å‡é—´éš”1.5å€
          .sort((a, b) => b[1].overdue - a[1].overdue)
          .slice(0, 3);
        
        for (const [tailStr, stats] of overdueTails) {
          const tail = parseInt(tailStr);
          // ç”Ÿæˆè¯¥å°¾æ•°çš„å·ç ï¼ˆ1-49ä¸­å°¾æ•°ä¸ºtailçš„æ•°å­—ï¼‰
          const numbersWithTail = Array.from({length: 5}, (_, i) => tail + i * 10)
            .filter(num => num >= 1 && num <= 49 && !usedNumbers.has(num));
          
          for (const num of numbersWithTail) {
            if (!usedNumbers.has(num) && specialNumbers.length < 5) {
              const attr = Formatter.getAttributes(num);
              const probability = 0.65 + (stats.overdue / 100);
              const score = Math.round(probability * 100);
              
              specialNumbers.push({
                number: num,
                score: score,
                probability: probability,
                zodiac: attr.zodiac,
                color: attr.color,
                size: attr.size,
                parity: attr.parity,
                source: `å°¾æ•°${tail}é—æ¼`
              });
              
              usedNumbers.add(num);
              break;
            }
          }
        }
      }
      
      // ä»ç”Ÿè‚–æ¨¡å¼ä¸­è·å–æ¨è
      if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacStats) {
        const zodiacStats = patterns.zodiacPatterns.zodiacStats;
        
        // æ‰¾å‡ºé—æ¼æœŸæ•°è¾ƒé•¿çš„ç”Ÿè‚–
        const overdueZodiacs = Object.entries(zodiacStats)
          .filter(([_, stats]) => stats.overdue > (stats.avgGap || 0) * 1.5)
          .sort((a, b) => b[1].overdue - a[1].overdue)
          .slice(0, 2);
        
        for (const [zodiac, stats] of overdueZodiacs) {
          // è·å–è¯¥ç”Ÿè‚–çš„æ‰€æœ‰æ•°å­—
          const zodiacNumbers = CONFIG.ZODIAC_MAP[zodiac] || [];
          const availableNumbers = zodiacNumbers.filter(num => !usedNumbers.has(num));
          
          if (availableNumbers.length > 0) {
            const num = availableNumbers[0];
            const attr = Formatter.getAttributes(num);
            const probability = 0.6 + (stats.overdue / 100);
            const score = Math.round(probability * 100);
            
            specialNumbers.push({
              number: num,
              score: score,
              probability: probability,
              zodiac: attr.zodiac,
              color: attr.color,
              size: attr.size,
              parity: attr.parity,
              source: `ç”Ÿè‚–${zodiac}é—æ¼`
            });
            
            usedNumbers.add(num);
            
            if (specialNumbers.length >= 5) break;
          }
        }
      }
      
      // å¦‚æœè¿˜ä¸å¤Ÿï¼Œè¡¥å……ä¸€äº›åŸºäºé¢‘ç‡çš„æ¨è
      if (specialNumbers.length < 5 && patterns.frequencyPatterns && patterns.frequencyPatterns.frequencyClusters) {
        const frequencyClusters = patterns.frequencyPatterns.frequencyClusters;
        
        // ä»ä¸­ç­‰é¢‘ç‡çš„æ•°å­—ä¸­é€‰æ‹©
        if (frequencyClusters.medium && frequencyClusters.medium.length > 0) {
          const mediumNumbers = frequencyClusters.medium
            .filter(item => !usedNumbers.has(item.number))
            .slice(0, 5 - specialNumbers.length);
          
          for (const item of mediumNumbers) {
            const attr = Formatter.getAttributes(item.number);
            const probability = 0.55 + (item.percentile * 0.2);
            const score = Math.round(probability * 100);
            
            specialNumbers.push({
              number: item.number,
              score: score,
              probability: probability,
              zodiac: attr.zodiac,
              color: attr.color,
              size: attr.size,
              parity: attr.parity,
              source: "é¢‘ç‡åˆ†æ"
            });
            
            usedNumbers.add(item.number);
          }
        }
      }
      
      // æŒ‰åˆ†æ•°æ’åº
      specialNumbers.sort((a, b) => b.score - a.score);
      
      return specialNumbers.slice(0, 5);
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆç‰¹ç å¤±è´¥", error);
      return [];
    }
  }
  
  static generateNormalNumbers(knnResult, patterns, specialNumbers) {
    try {
      const normalNumbers = [];
      const usedNumbers = new Set(specialNumbers.map(item => item.number));
      
      // æ·»åŠ KNNé¢„æµ‹çš„å¹³ç 
      if (knnResult.normals && Array.isArray(knnResult.normals)) {
        for (const normal of knnResult.normals) {
          const num = normal.number;
          if (!usedNumbers.has(num) && num >= 1 && num <= 49) {
            const attr = Formatter.getAttributes(num);
            const score = Math.round(normal.probability * 100);
            
            normalNumbers.push({
              number: num,
              score: score,
              probability: normal.probability,
              zodiac: attr.zodiac,
              color: attr.color,
              source: "KNNé¢„æµ‹"
            });
            
            usedNumbers.add(num);
            if (normalNumbers.length >= 6) break;
          }
        }
      }
      
      // ä»æ¨¡å¼åˆ†æä¸­è¡¥å……å¹³ç 
      if (patterns.normalTailPatterns && patterns.normalTailPatterns.normalTailDistribution) {
        const tailDistribution = patterns.normalTailPatterns.normalTailDistribution;
        const sortedTails = Object.entries(tailDistribution)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 4);
        
        for (const [tailStr, count] of sortedTails) {
          const tail = parseInt(tailStr);
          // ç”Ÿæˆè¯¥å°¾æ•°çš„å·ç 
          const numbersWithTail = Array.from({length: 5}, (_, i) => tail + i * 10)
            .filter(num => num >= 1 && num <= 49 && !usedNumbers.has(num));
          
          for (const num of numbersWithTail) {
            if (normalNumbers.length < 6) {
              const attr = Formatter.getAttributes(num);
              const frequency = count / (patterns.totalRecords * 6); // å¹³ç æ€»å‡ºç°æ¬¡æ•°
              const score = Math.round(75 + (frequency * 20));
              
              normalNumbers.push({
                number: num,
                score: score,
                probability: frequency,
                zodiac: attr.zodiac,
                color: attr.color,
                source: `å¹³ç å°¾æ•°${tail}é«˜é¢‘`
              });
              
              usedNumbers.add(num);
              break;
            }
          }
        }
      }
      
      // ä»ç”Ÿè‚–æ¨¡å¼ä¸­è¡¥å……å¹³ç 
      if (patterns.normalZodiacPatterns && patterns.normalZodiacPatterns.normalZodiacDistribution) {
        const zodiacDistribution = patterns.normalZodiacPatterns.normalZodiacDistribution;
        const sortedZodiacs = Object.entries(zodiacDistribution)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3);
        
        for (const [zodiac, count] of sortedZodiacs) {
          // è·å–è¯¥ç”Ÿè‚–çš„æ‰€æœ‰æ•°å­—
          const zodiacNumbers = CONFIG.ZODIAC_MAP[zodiac] || [];
          const availableNumbers = zodiacNumbers.filter(num => !usedNumbers.has(num));
          
          if (availableNumbers.length > 0 && normalNumbers.length < 6) {
            const num = availableNumbers[0];
            const attr = Formatter.getAttributes(num);
            const frequency = count / (patterns.totalRecords * 6);
            const score = Math.round(70 + (frequency * 20));
            
            normalNumbers.push({
              number: num,
              score: score,
              probability: frequency,
              zodiac: attr.zodiac,
              color: attr.color,
              source: `å¹³ç ç”Ÿè‚–${zodiac}é«˜é¢‘`
            });
            
            usedNumbers.add(num);
          }
        }
      }
      
      // ä»èšç±»æ¨¡å¼ä¸­è¡¥å……å¹³ç 
      if (patterns.clusterPatterns && patterns.clusterPatterns.numberClusters && normalNumbers.length < 6) {
        const numberClusters = patterns.clusterPatterns.numberClusters;
        
        // æ‰¾å‡ºæœ€å¼ºçš„æ•°å­—å¯¹
        const topPairs = Object.entries(numberClusters)
          .sort((a, b) => b[1].strength - a[1].strength)
          .slice(0, 3);
        
        for (const [pairKey, cluster] of topPairs) {
          const [num1, num2] = pairKey.split("-").map(Number);
          
          // é€‰æ‹©ä¸€ä¸ªæœªä½¿ç”¨çš„æ•°å­—
          const candidates = [num1, num2].filter(num => !usedNumbers.has(num) && num >= 1 && num <= 49);
          
          if (candidates.length > 0 && normalNumbers.length < 6) {
            const num = candidates[0];
            const attr = Formatter.getAttributes(num);
            const score = Math.round(65 + (cluster.strength * 30));
            
            normalNumbers.push({
              number: num,
              score: score,
              probability: cluster.strength,
              zodiac: attr.zodiac,
              color: attr.color,
              source: "èšç±»åˆ†æ"
            });
            
            usedNumbers.add(num);
          }
        }
      }
      
      // å¦‚æœè¿˜æ˜¯ä¸å¤Ÿï¼Œä»é¢‘ç‡åˆ†å¸ƒä¸­è¡¥å……
      if (normalNumbers.length < 6 && patterns.frequencyPatterns && patterns.frequencyPatterns.numberFrequency) {
        const numberFrequency = patterns.frequencyPatterns.numberFrequency;
        const sortedNumbers = Object.entries(numberFrequency)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 20);
        
        for (const [numStr, freq] of sortedNumbers) {
          const num = parseInt(numStr);
          if (!usedNumbers.has(num) && normalNumbers.length < 6) {
            const attr = Formatter.getAttributes(num);
            const probability = freq / patterns.totalRecords;
            const score = Math.round(60 + (probability * 30));
            
            normalNumbers.push({
              number: num,
              score: score,
              probability: probability,
              zodiac: attr.zodiac,
              color: attr.color,
              source: "å†å²é«˜é¢‘"
            });
            
            usedNumbers.add(num);
          }
        }
      }
      
      // æŒ‰åˆ†æ•°æ’åº
      normalNumbers.sort((a, b) => b.score - a.score);
      
      return normalNumbers.slice(0, 6);
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆå¹³ç å¤±è´¥", error);
      return [];
    }
  }
  
  static generateZodiacPrediction(knnResult, patterns) {
    try {
      const zodiacRecommendations = {
        main: [],
        guard: [],
        avoid: [],
        scores: {}
      };
      
      // ä»KNNç»“æœè·å–
      if (knnResult.zodiac) {
        zodiacRecommendations.main.push(knnResult.zodiac);
      }
      
      // ä»æ¨¡å¼åˆ†æè·å–
      if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacStats) {
        const zodiacStats = patterns.zodiacPatterns.zodiacStats;
        
        // æŒ‰é—æ¼æœŸæ•°æ’åºï¼ˆé—æ¼è¶Šé•¿ï¼Œè¶Šå¯èƒ½å‡ºç°ï¼‰
        const sortedByOverdue = Object.entries(zodiacStats)
          .filter(([_, stats]) => stats.overdue > 0)
          .sort((a, b) => b[1].overdue - a[1].overdue)
          .slice(0, 6);
        
        for (const [zodiac, stats] of sortedByOverdue) {
          if (!zodiacRecommendations.main.includes(zodiac)) {
            if (zodiacRecommendations.main.length < 3) {
              zodiacRecommendations.main.push(zodiac);
            } else if (zodiacRecommendations.guard.length < 3) {
              zodiacRecommendations.guard.push(zodiac);
            }
          }
          
          // è®°å½•åˆ†æ•°
          zodiacRecommendations.scores[zodiac] = {
            overdue: stats.overdue || 0,
            avgGap: stats.avgGap || 0,
            frequency: stats.frequency || 0,
            probability: stats.probability || 0
          };
        }
        
        // å¦‚æœä¸»æ¨ç”Ÿè‚–ä¸å¤Ÿï¼Œè¡¥å……ä¸€äº›é«˜é¢‘ç”Ÿè‚–
        if (zodiacRecommendations.main.length < 3) {
          const sortedByFrequency = Object.entries(zodiacStats)
            .sort((a, b) => b[1].frequency - a[1].frequency)
            .slice(0, 6);
          
          for (const [zodiac, stats] of sortedByFrequency) {
            if (!zodiacRecommendations.main.includes(zodiac) && !zodiacRecommendations.guard.includes(zodiac)) {
              if (zodiacRecommendations.main.length < 3) {
                zodiacRecommendations.main.push(zodiac);
              }
            }
          }
        }
      }
      
      // é¿å…è¿‘æœŸåˆšå‡ºç°è¿‡çš„ç”Ÿè‚–
      if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacStats) {
        const zodiacStats = patterns.zodiacPatterns.zodiacStats;
        const recentlySeen = Object.entries(zodiacStats)
          .filter(([_, stats]) => stats.overdue === 0) // åˆšå‡ºç°è¿‡çš„
          .map(([zodiac, _]) => zodiac);
        
        zodiacRecommendations.avoid = recentlySeen.slice(0, 2);
      }
      
      return zodiacRecommendations;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆç”Ÿè‚–æ¨èå¤±è´¥", error);
      return {
        main: [],
        guard: [],
        avoid: [],
        scores: {}
      };
    }
  }
  
  static generateColorPrediction(knnResult, patterns) {
    try {
      const colorRecommendations = {
        main: "",
        guard: "",
        avoid: "",
        scores: {}
      };
      
      // ä»KNNç»“æœè·å–
      if (knnResult.color) {
        colorRecommendations.main = knnResult.color;
      }
      
      // ä»æ¨¡å¼åˆ†æè·å–
      if (patterns.colorPatterns && patterns.colorPatterns.colorStats) {
        const colorStats = patterns.colorPatterns.colorStats;
        
        // æŒ‰é—æ¼æœŸæ•°æ’åº
        const sortedByOverdue = Object.entries(colorStats)
          .filter(([_, stats]) => stats.overdue > 0)
          .sort((a, b) => b[1].overdue - a[1].overdue);
        
        if (sortedByOverdue.length > 0) {
          if (!colorRecommendations.main) {
            colorRecommendations.main = sortedByOverdue[0][0];
          }
          if (sortedByOverdue.length > 1) {
            colorRecommendations.guard = sortedByOverdue[1][0];
          }
        }
        
        // å¦‚æœè¿˜æ²¡æœ‰ä¸»æ¨é¢œè‰²ï¼Œé€‰æ‹©é«˜é¢‘é¢œè‰²
        if (!colorRecommendations.main) {
          const sortedByFrequency = Object.entries(colorStats)
            .sort((a, b) => b[1].frequency - a[1].frequency);
          
          if (sortedByFrequency.length > 0) {
            colorRecommendations.main = sortedByFrequency[0][0];
            colorRecommendations.guard = sortedByFrequency.length > 1 ? sortedByFrequency[1][0] : "blue";
          }
        }
        
        // é¿å…è¿‘æœŸåˆšå‡ºç°è¿‡çš„é¢œè‰²
        const recentlySeen = Object.entries(colorStats)
          .filter(([_, stats]) => stats.overdue === 0)
          .map(([color, _]) => color);
        
        if (recentlySeen.length > 0) {
          colorRecommendations.avoid = recentlySeen[0];
        }
        
        // è®°å½•åˆ†æ•°
        Object.entries(colorStats).forEach(([color, stats]) => {
          colorRecommendations.scores[color] = {
            overdue: stats.overdue || 0,
            avgGap: stats.avgGap || 0,
            frequency: stats.frequency || 0,
            probability: stats.probability || 0
          };
        });
      }
      
      // å¦‚æœè¿˜æ²¡æœ‰ä¸»æ¨é¢œè‰²ï¼Œé€‰æ‹©ä¸€ä¸ª
      if (!colorRecommendations.main) {
        const colors = ['red', 'blue', 'green'];
        colorRecommendations.main = colors[Math.floor(Math.random() * colors.length)];
      }
      
      return colorRecommendations;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢œè‰²æ¨èå¤±è´¥", error);
      return {
        main: "red",
        guard: "blue",
        avoid: "green",
        scores: {}
      };
    }
  }
  
  static generateTailRecommendations(patterns) {
    try {
      const recommendations = {
        main: [],
        guard: [],
        scores: {}
      };
      
      if (patterns.tailPatterns && patterns.tailPatterns.tailStats) {
        const tailStats = patterns.tailPatterns.tailStats;
        
        // æŒ‰é—æ¼æœŸæ•°æ’åºï¼ˆé—æ¼è¶Šé•¿ï¼Œè¶Šå¯èƒ½å‡ºç°ï¼‰
        const sortedByOverdue = Object.entries(tailStats)
          .filter(([_, stats]) => stats.overdue > 0)
          .sort((a, b) => b[1].overdue - a[1].overdue)
          .slice(0, 10);
        
        // å‰4ä¸ªä¸ºä¸»æ¨
        recommendations.main = sortedByOverdue.slice(0, 4).map(([tail, _]) => parseInt(tail));
        
        // ä¸­é—´3ä¸ªä¸ºé˜²å®ˆ
        recommendations.guard = sortedByOverdue.slice(4, 7).map(([tail, _]) => parseInt(tail));
        
        // è®°å½•åˆ†æ•°
        sortedByOverdue.forEach(([tail, stats]) => {
          recommendations.scores[tail] = {
            overdue: stats.overdue || 0,
            avgGap: stats.avgGap || 0,
            frequency: stats.frequency || 0,
            probability: stats.probability || 0
          };
        });
      }
      
      return recommendations;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆå°¾æ•°æ¨èå¤±è´¥", error);
      return {
        main: [],
        guard: [],
        scores: {}
      };
    }
  }
  
  static generateHotColdAnalysis(patterns) {
    try {
      const analysis = {
        hotNumbers: [],
        coldNumbers: [],
        overdueNumbers: [],
        analysis: ""
      };
      
      if (patterns.frequencyPatterns) {
        analysis.hotNumbers = patterns.frequencyPatterns.hotNumbers || [];
        analysis.coldNumbers = patterns.frequencyPatterns.coldNumbers || [];
        analysis.overdueNumbers = patterns.frequencyPatterns.overdueNumbers || [];
        
        // ç”Ÿæˆåˆ†ææ–‡æœ¬
        let analysisText = "";
        
        if (analysis.hotNumbers.length > 0) {
          const hotList = analysis.hotNumbers.slice(0, 4).map(item => item.number).join(", ");
          analysisText += `${CONFIG.EMOJI.fire} çƒ­å·: ${hotList}\n`;
        }
        
        if (analysis.coldNumbers.length > 0) {
          const coldList = analysis.coldNumbers.slice(0, 4).map(item => item.number).join(", ");
          analysisText += `${CONFIG.EMOJI.snowflake || "â„ï¸"} å†·å·: ${coldList}\n`;
        }
        
        if (analysis.overdueNumbers.length > 0) {
          const overdueList = analysis.overdueNumbers.slice(0, 4).map(item => item.number).join(", ");
          analysisText += `${CONFIG.EMOJI.clock} é—æ¼: ${overdueList}`;
        }
        
        analysis.analysis = analysisText;
      }
      
      return analysis;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆçƒ­å†·å·åˆ†æå¤±è´¥", error);
      return {
        hotNumbers: [],
        coldNumbers: [],
        overdueNumbers: [],
        analysis: ""
      };
    }
  }
  
  static generateTrendAnalysis(patterns) {
    try {
      const analysis = {
        trend: "å¹³ç¨³",
        strength: 0,
        direction: "æ— ",
        analysis: ""
      };
      
      if (patterns.trendPatterns && patterns.trendPatterns.trendClusters) {
        const trendClusters = patterns.trendPatterns.trendClusters;
        
        if (trendClusters.overall) {
          const up = trendClusters.overall.up || 0;
          const down = trendClusters.overall.down || 0;
          const stable = trendClusters.overall.stable || 0;
          const total = up + down + stable;
          
          if (total > 0) {
            const upPercent = (up / total) * 100;
            const downPercent = (down / total) * 100;
            const stablePercent = (stable / total) * 100;
            
            // ç¡®å®šä¸»è¦è¶‹åŠ¿
            if (upPercent > downPercent && upPercent > stablePercent) {
              analysis.trend = "ä¸Šå‡";
              analysis.strength = Math.round(upPercent);
              analysis.direction = "å‘ä¸Š";
            } else if (downPercent > upPercent && downPercent > stablePercent) {
              analysis.trend = "ä¸‹é™";
              analysis.strength = Math.round(downPercent);
              analysis.direction = "å‘ä¸‹";
            } else {
              analysis.trend = "å¹³ç¨³";
              analysis.strength = Math.round(stablePercent);
              analysis.direction = "æ¨ªå‘";
            }
            
            analysis.analysis = `${analysis.trend}è¶‹åŠ¿ (å¼ºåº¦: ${analysis.strength}%)`;
          }
        }
      }
      
      return analysis;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆè¶‹åŠ¿åˆ†æå¤±è´¥", error);
      return {
        trend: "æœªçŸ¥",
        strength: 0,
        direction: "æ— ",
        analysis: ""
      };
    }
  }
  
  static generatePatternStrengthAnalysis(patterns) {
    try {
      const analysis = {
        strongPatterns: [],
        moderatePatterns: [],
        weakPatterns: [],
        strength: 0,
        analysis: ""
      };
      
      if (patterns) {
        let strongCount = 0;
        let moderateCount = 0;
        let weakCount = 0;
        
        // è¯„ä¼°å„ç§æ¨¡å¼çš„å¼ºåº¦
        if (patterns.tailPatterns && patterns.tailPatterns.tailStats) {
          const tailStats = patterns.tailPatterns.tailStats;
          const hasStrongTailPatterns = Object.values(tailStats).some(stat => 
            stat.stdDev < stat.avgGap * 0.4 // æ ‡å‡†å·®å°äºå¹³å‡é—´éš”çš„40%ï¼Œè¯´æ˜è§„å¾‹æ€§å¼º
          );
          
          if (hasStrongTailPatterns) {
            strongCount++;
            analysis.strongPatterns.push("å°¾æ•°æ¨¡å¼");
          } else {
            moderateCount++;
            analysis.moderatePatterns.push("å°¾æ•°æ¨¡å¼");
          }
        }
        
        if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacStats) {
          const zodiacStats = patterns.zodiacPatterns.zodiacStats;
          const zodiacVariety = Object.keys(zodiacStats).filter(zodiac => 
            zodiacStats[zodiac].frequency > patterns.totalRecords * 0.05
          ).length;
          
          if (zodiacVariety >= 8) {
            strongCount++;
            analysis.strongPatterns.push("ç”Ÿè‚–æ¨¡å¼");
          } else {
            moderateCount++;
            analysis.moderatePatterns.push("ç”Ÿè‚–æ¨¡å¼");
          }
        }
        
        if (patterns.colorPatterns && patterns.colorPatterns.colorStats) {
          const colorStats = patterns.colorPatterns.colorStats;
          const colorBalance = Math.max(
            colorStats.red?.frequency || 0,
            colorStats.blue?.frequency || 0,
            colorStats.green?.frequency || 0
          ) / patterns.totalRecords;
          
          if (colorBalance > 0.45) {
            strongCount++;
            analysis.strongPatterns.push("é¢œè‰²æ¨¡å¼");
          } else {
            moderateCount++;
            analysis.moderatePatterns.push("é¢œè‰²æ¨¡å¼");
          }
        }
        
        if (patterns.periodPatterns && patterns.periodPatterns.periodClusters) {
          const periodClusters = patterns.periodPatterns.periodClusters;
          const strongPeriods = Object.values(periodClusters).filter(item => 
            item.strength > 1.5
          ).length;
          
          if (strongPeriods >= 2) {
            strongCount++;
            analysis.strongPatterns.push("å‘¨æœŸæ¨¡å¼");
          } else if (strongPeriods >= 1) {
            moderateCount++;
            analysis.moderatePatterns.push("å‘¨æœŸæ¨¡å¼");
          } else {
            weakCount++;
            analysis.weakPatterns.push("å‘¨æœŸæ¨¡å¼");
          }
        }
        
        // è®¡ç®—æ€»ä½“å¼ºåº¦
        const totalPatterns = strongCount + moderateCount + weakCount;
        if (totalPatterns > 0) {
          analysis.strength = Math.round((strongCount * 3 + moderateCount * 2 + weakCount) / (totalPatterns * 3) * 100);
          
          if (analysis.strength >= 70) {
            analysis.analysis = `æ¨¡å¼å¼ºåº¦: å¼º (${analysis.strength}%)`;
          } else if (analysis.strength >= 40) {
            analysis.analysis = `æ¨¡å¼å¼ºåº¦: ä¸­ (${analysis.strength}%)`;
          } else {
            analysis.analysis = `æ¨¡å¼å¼ºåº¦: å¼± (${analysis.strength}%)`;
          }
        }
      }
      
      return analysis;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆæ¨¡å¼å¼ºåº¦åˆ†æå¤±è´¥", error);
      return {
        strongPatterns: [],
        moderatePatterns: [],
        weakPatterns: [],
        strength: 0,
        analysis: ""
      };
    }
  }
  
  static generatePredictionFromPatterns(patterns, history, nextExpect, lastRecord) {
    try {
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      // åŸºäºæ¨¡å¼åˆ†æç”Ÿæˆé¢„æµ‹
      const specialNumbers = [];
      const normalNumbers = [];
      const usedNumbers = new Set();
      
      // ç”Ÿæˆç‰¹ç æ¨è
      if (patterns.frequencyPatterns && patterns.frequencyPatterns.hotNumbers) {
        const hotNumbers = patterns.frequencyPatterns.hotNumbers;
        for (let i = 0; i < Math.min(5, hotNumbers.length); i++) {
          const item = hotNumbers[i];
          const num = item.number;
          const attr = Formatter.getAttributes(num);
          
          specialNumbers.push({
            number: num,
            score: 90 - i * 8,
            probability: item.heat || (0.9 - i * 0.1),
            zodiac: attr.zodiac,
            color: attr.color,
            size: attr.size,
            parity: attr.parity,
            source: "æ¨¡å¼åˆ†æçƒ­å·"
          });
          
          usedNumbers.add(num);
        }
      }
      
      // ä»é—æ¼å·ç ä¸­è¡¥å……ç‰¹ç 
      if (specialNumbers.length < 5 && patterns.frequencyPatterns && patterns.frequencyPatterns.overdueNumbers) {
        const overdueNumbers = patterns.frequencyPatterns.overdueNumbers;
        for (let i = 0; i < Math.min(3, overdueNumbers.length) && specialNumbers.length < 5; i++) {
          const item = overdueNumbers[i];
          const num = item.number;
          
          if (!usedNumbers.has(num)) {
            const attr = Formatter.getAttributes(num);
            const probability = 0.6 + (item.overdue / 100);
            const score = Math.round(probability * 100);
            
            specialNumbers.push({
              number: num,
              score: score,
              probability: probability,
              zodiac: attr.zodiac,
              color: attr.color,
              size: attr.size,
              parity: attr.parity,
              source: "é•¿æœŸé—æ¼"
            });
            
            usedNumbers.add(num);
          }
        }
      }
      
      // ç”Ÿæˆå¹³ç æ¨è
      if (patterns.normalTailPatterns && patterns.normalTailPatterns.normalTailDistribution) {
        const tailDistribution = patterns.normalTailPatterns.normalTailDistribution;
        const sortedTails = Object.entries(tailDistribution)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 6);
        
        for (const [tailStr, count] of sortedTails) {
          const tail = parseInt(tailStr);
          const numbersWithTail = Array.from({length: 5}, (_, i) => tail + i * 10)
            .filter(num => num >= 1 && num <= 49 && !usedNumbers.has(num));
          
          if (numbersWithTail.length > 0 && normalNumbers.length < 6) {
            const num = numbersWithTail[0];
            const attr = Formatter.getAttributes(num);
            const frequency = count / (patterns.totalRecords * 6);
            const score = Math.round(75 + (frequency * 20));
            
            normalNumbers.push({
              number: num,
              score: score,
              probability: frequency,
              zodiac: attr.zodiac,
              color: attr.color,
              source: "å¹³ç é«˜é¢‘å°¾æ•°"
            });
            
            usedNumbers.add(num);
          }
        }
      }
      
      // ç”Ÿæˆç”Ÿè‚–æ¨è
      const zodiacPrediction = {
        main: [],
        guard: [],
        avoid: [],
        scores: {}
      };
      
      if (patterns.zodiacPatterns && patterns.zodiacPatterns.zodiacStats) {
        const zodiacStats = patterns.zodiacPatterns.zodiacStats;
        const sortedByOverdue = Object.entries(zodiacStats)
          .filter(([_, stats]) => stats.overdue > 0)
          .sort((a, b) => b[1].overdue - a[1].overdue)
          .slice(0, 6);
        
        zodiacPrediction.main = sortedByOverdue.slice(0, 3).map(([zodiac, _]) => zodiac);
        zodiacPrediction.guard = sortedByOverdue.slice(3, 6).map(([zodiac, _]) => zodiac);
        
        // é¿å…è¿‘æœŸåˆšå‡ºç°è¿‡çš„ç”Ÿè‚–
        const recentlySeen = Object.entries(zodiacStats)
          .filter(([_, stats]) => stats.overdue === 0)
          .map(([zodiac, _]) => zodiac)
          .slice(0, 2);
        
        zodiacPrediction.avoid = recentlySeen;
      }
      
      // ç”Ÿæˆé¢œè‰²æ¨è
      const colorPrediction = {
        main: "red",
        guard: "blue",
        avoid: "green",
        scores: {}
      };
      
      if (patterns.colorPatterns && patterns.colorPatterns.colorStats) {
        const colorStats = patterns.colorPatterns.colorStats;
        const sortedByOverdue = Object.entries(colorStats)
          .filter(([_, stats]) => stats.overdue > 0)
          .sort((a, b) => b[1].overdue - a[1].overdue);
        
        if (sortedByOverdue.length > 0) {
          colorPrediction.main = sortedByOverdue[0][0];
          colorPrediction.guard = sortedByOverdue.length > 1 ? sortedByOverdue[1][0] : "blue";
          
          // é¿å…è¿‘æœŸåˆšå‡ºç°è¿‡çš„é¢œè‰²
          const recentlySeen = Object.entries(colorStats)
            .filter(([_, stats]) => stats.overdue === 0)
            .map(([color, _]) => color);
          
          if (recentlySeen.length > 0) {
            colorPrediction.avoid = recentlySeen[0];
          }
        }
      }
      
      // å½¢æ€åˆ†æ
      const bestSpecial = specialNumbers[0]?.number || 1;
      const bestAttr = Formatter.getAttributes(bestSpecial);
      const isBig = bestSpecial >= 25;
      const isOdd = bestSpecial % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestSpecial / 10);
      
      // ç”Ÿæˆå°¾æ•°æ¨è
      const tailRecommendations = {
        main: [],
        guard: [],
        scores: {}
      };
      
      if (patterns.tailPatterns && patterns.tailPatterns.tailStats) {
        const tailStats = patterns.tailPatterns.tailStats;
        const sortedByOverdue = Object.entries(tailStats)
          .filter(([_, stats]) => stats.overdue > 0)
          .sort((a, b) => b[1].overdue - a[1].overdue)
          .slice(0, 7);
        
        tailRecommendations.main = sortedByOverdue.slice(0, 4).map(([tail, _]) => parseInt(tail));
        tailRecommendations.guard = sortedByOverdue.slice(4, 7).map(([tail, _]) => parseInt(tail));
      }
      
      // ç”Ÿæˆçƒ­å†·å·åˆ†æ
      const hotColdAnalysis = {
        hotNumbers: [],
        coldNumbers: [],
        overdueNumbers: [],
        analysis: ""
      };
      
      if (patterns.frequencyPatterns) {
        hotColdAnalysis.hotNumbers = patterns.frequencyPatterns.hotNumbers || [];
        hotColdAnalysis.coldNumbers = patterns.frequencyPatterns.coldNumbers || [];
        hotColdAnalysis.overdueNumbers = patterns.frequencyPatterns.overdueNumbers || [];
        
        if (hotColdAnalysis.hotNumbers.length > 0) {
          const hotList = hotColdAnalysis.hotNumbers.slice(0, 3).map(item => item.number).join(", ");
          hotColdAnalysis.analysis = `çƒ­å·: ${hotList}`;
        }
      }
      
      return {
        nextExpect: nextExpect,
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        tailRecommendations: tailRecommendations,
        hotColdAnalysis: hotColdAnalysis,
        confidence: patterns.confidence || 35,
        analysisBased: true,
        knnUsed: false,
        patternAnalysisUsed: true,
        totalHistoryRecords: history.length,
        patternConfidence: patterns.confidence || 0,
        basedOnLastRecord: {
          expect: lastRecord.expect || "æœªçŸ¥",
          openCode: lastOpenCode,
          special: lastSpecial,
          zodiac: lastAttr.zodiac,
          color: lastAttr.color
        },
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V14.0-PatternAnalysis"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "åŸºäºæ¨¡å¼ç”Ÿæˆé¢„æµ‹å¤±è´¥", error);
      return this.generateStaticFallback();
    }
  }
  
  static generateStaticFallback() {
    try {
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = Math.floor(Math.random() * allZodiacs.length);
      const colorIndex = Math.floor(Math.random() * colors.length);
      
      const mainZodiac = allZodiacs[zodiacIndex] || "é¼ ";
      const mainColor = colors[colorIndex] || "red";
      
      // ç”Ÿæˆç‰¹ç æ¨è
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        const num = Math.floor(Math.random() * 49) + 1;
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 30) + 50,
          probability: 0.5 + Math.random() * 0.3,
          zodiac: attr.zodiac,
          color: attr.color,
          size: attr.size,
          parity: attr.parity,
          source: "éšæœºç”Ÿæˆ"
        });
      }
      
      // ç”Ÿæˆå¹³ç æ¨è
      const normalNumbers = [];
      const usedNumbers = new Set(specialNumbers.map(item => item.number));
      
      for (let i = 0; i < 6; i++) {
        let num;
        do {
          num = Math.floor(Math.random() * 49) + 1;
        } while (usedNumbers.has(num) && usedNumbers.size < 49);
        
        if (!usedNumbers.has(num)) {
          const attr = Formatter.getAttributes(num);
          normalNumbers.push({
            number: num,
            score: Math.floor(Math.random() * 30) + 50,
            probability: 0.5 + Math.random() * 0.3,
            zodiac: attr.zodiac,
            color: attr.color,
            source: "éšæœºç”Ÿæˆ"
          });
          usedNumbers.add(num);
        }
      }
      
      const bestSpecial = specialNumbers[0]?.number || 1;
      const isBig = bestSpecial >= 25;
      const isOdd = bestSpecial % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestSpecial / 10);
      
      return {
        nextExpect: "2025001",
        zodiac: {
          main: [mainZodiac, allZodiacs[(zodiacIndex + 1) % allZodiacs.length]],
          guard: [allZodiacs[(zodiacIndex + 2) % allZodiacs.length]],
          avoid: [],
          scores: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length],
          avoid: colors[(colorIndex + 2) % colors.length],
          scores: {}
        },
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        confidence: 30,
        analysisBased: false,
        knnUsed: false,
        patternAnalysisUsed: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V14.0-Static"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé™æ€å›é€€é¢„æµ‹æ—¶å‡ºé”™", error);
      
      return {
        nextExpect: "2025001",
        zodiac: { main: ["é¼ ", "é¾™", "çŒ´"], guard: ["ç‰›", "è›‡"], avoid: [], scores: {} },
        color: { main: "red", guard: "blue", avoid: "green", scores: {} },
        head: "0å¤´",
        shape: "å°å•",
        specialNumbers: [
          { number: 1, score: 50, probability: 0.5, zodiac: "è›‡", color: "red", size: "å°", parity: "å•", source: "ç³»ç»Ÿ" },
          { number: 13, score: 45, probability: 0.45, zodiac: "è›‡", color: "blue", size: "å°", parity: "å•", source: "ç³»ç»Ÿ" },
          { number: 25, score: 40, probability: 0.4, zodiac: "è›‡", color: "green", size: "å¤§", parity: "å•", source: "ç³»ç»Ÿ" },
          { number: 37, score: 35, probability: 0.35, zodiac: "è›‡", color: "red", size: "å¤§", parity: "å•", source: "ç³»ç»Ÿ" },
          { number: 49, score: 30, probability: 0.3, zodiac: "è›‡", color: "blue", size: "å¤§", parity: "å•", source: "ç³»ç»Ÿ" }
        ],
        normalNumbers: [
          { number: 2, score: 45, probability: 0.45, zodiac: "é¾™", color: "red", source: "ç³»ç»Ÿ" },
          { number: 3, score: 40, probability: 0.4, zodiac: "å…”", color: "blue", source: "ç³»ç»Ÿ" },
          { number: 4, score: 35, probability: 0.35, zodiac: "è™", color: "blue", source: "ç³»ç»Ÿ" },
          { number: 5, score: 30, probability: 0.3, zodiac: "ç‰›", color: "green", source: "ç³»ç»Ÿ" },
          { number: 6, score: 25, probability: 0.25, zodiac: "é¼ ", color: "green", source: "ç³»ç»Ÿ" },
          { number: 7, score: 20, probability: 0.2, zodiac: "çŒª", color: "red", source: "ç³»ç»Ÿ" }
        ],
        confidence: 25,
        analysisBased: false,
        knnUsed: false,
        patternAnalysisUsed: false,
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V14.0-Emergency"
      };
    }
  }
  
  static clearCache() {
    try {
      this.predictionCache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 9. æ¶ˆæ¯æ¸²æŸ“å™¨
// ==============================================================================

class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME} - å‘½ä»¤æ¨¡æ¿</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `${CONFIG.EMOJI.refresh} <i>é˜²åˆ·å±æ¨¡å¼ï¼Œæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</i>\n\n`;
      
      message += `<b>${CONFIG.EMOJI.rocket} ä¸»è¦å‘½ä»¤ï¼š</b>\n`;
      message += `<code>/predict</code> - ç”Ÿæˆ/æ›´æ–°é¢„æµ‹ç»“æœ\n`;
      message += `<code>/history [é¡µç ]</code> - æŸ¥çœ‹å†å²è®°å½•\n`;
      message += `<code>/ccc</code> - æ˜¾ç¤ºæ­¤å‘½ä»¤æ¨¡æ¿\n`;
      message += `<code>/stats</code> - æŸ¥çœ‹ç³»ç»Ÿç»Ÿè®¡\n`;
      message += `<code>/clear_cache</code> - æ¸…ç†ç³»ç»Ÿç¼“å­˜\n`;
      
      if (isAdmin) {
        message += `\n<b>${CONFIG.EMOJI.crown} ç®¡ç†å‘˜å‘½ä»¤ï¼š</b>\n`;
        message += `<code>/sync</code> - æ‰‹åŠ¨åŒæ­¥å†å²æ•°æ®\n`;
        message += `<code>/push</code> - æ‰‹åŠ¨æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
        message += `<code>/delete [æœŸå·]</code> - åˆ é™¤å•æœŸè®°å½•\n`;
        message += `<code>/delete [å¼€å§‹æœŸå·]-[ç»“æŸæœŸå·]</code> - åˆ é™¤æœŸå·èŒƒå›´\n`;
      }
      
      message += `\n<b>${CONFIG.EMOJI.lightning} ä½¿ç”¨ç¤ºä¾‹ï¼š</b>\n`;
      message += `<code>/predict</code> - ç”Ÿæˆæ–°é¢„æµ‹\n`;
      message += `<code>/history 1</code> - æŸ¥çœ‹ç¬¬1é¡µå†å²\n`;
      message += `<code>/stats</code> - æŸ¥çœ‹ç³»ç»Ÿç»Ÿè®¡\n`;
      message += `<code>/delete 2025001</code> - åˆ é™¤å•æœŸè®°å½•\n`;
      message += `<code>/delete 2025001-2025010</code> - åˆ é™¤æœŸå·èŒƒå›´\n`;
      
      message += `\n${CONFIG.EMOJI.refresh} <b>é˜²åˆ·å±ç‰¹æ€§ï¼š</b>\n`;
      message += `â€¢ æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `â€¢ å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `â€¢ ä¿æŒèŠå¤©ç•Œé¢æ•´æ´\n`;
      message += `â€¢ é˜²æ­¢æ¶ˆæ¯å †ç§¯\n`;
      
      message += `\n${CONFIG.EMOJI.brain_circuit} <b>å¢å¼ºç®—æ³•ç‰¹æ€§ï¼š</b>\n`;
      message += `â€¢ åŸºäºå¢å¼ºKNNç®—æ³• + æ¨¡å¼åˆ†æé¢„æµ‹\n`;
      message += `â€¢ æ•´åˆ16ç§å†å²è§„å¾‹åˆ†æ\n`;
      message += `â€¢ å¤šç»´åº¦é¢„æµ‹ï¼ˆç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ã€å¤§å°å•åŒã€è¶‹åŠ¿ï¼‰\n`;
      message += `â€¢ åŸºäºå…¨éƒ¨å†å²è®°å½•åˆ†æ\n`;
      message += `â€¢ æ™ºèƒ½ç½®ä¿¡åº¦è®¡ç®—\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å‘½ä»¤æ¨¡æ¿å¤±è´¥", error);
      return `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME}</b>\n\nä½¿ç”¨ /ccc æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨ã€‚`;
    }
  }

  static renderWelcomeMessage(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.home} <b>æ¬¢è¿ä½¿ç”¨ ${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `${CONFIG.EMOJI.brain_circuit} <b>å¢å¼ºé¢„æµ‹ç®—æ³•å·²å°±ç»ª</b>\n\n`;
      message += `â€¢ 16ç§å†å²è§„å¾‹åˆ†ææ¨¡å¼\n`;
      message += `â€¢ å¢å¼ºKNNç®—æ³• + æ¨¡å¼åˆ†æ\n`;
      message += `â€¢ å¤šç»´åº¦æ™ºèƒ½é¢„æµ‹\n`;
      message += `â€¢ æ™ºèƒ½ç½®ä¿¡åº¦è¯„ä¼°\n\n`;
      message += `${CONFIG.EMOJI.refresh} <b>é˜²åˆ·å±æ¨¡å¼å·²å¯ç”¨</b>\n\n`;
      message += `æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `å‘é€ç›¸åŒå‘½ä»¤ä¼šè‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `\nä½¿ç”¨ <code>/ccc</code> æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨\n`;
      message += `ä½¿ç”¨ <code>/predict</code> ç”Ÿæˆæ–°é¢„æµ‹\n`;
      message += `ä½¿ç”¨ <code>/stats</code> æŸ¥çœ‹ç³»ç»Ÿç»Ÿè®¡\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¬¢è¿æ¶ˆæ¯å¤±è´¥", error);
      return `${CONFIG.EMOJI.home} <b>${CONFIG.SYSTEM.NAME}</b>\n\nç³»ç»Ÿè¿è¡Œæ­£å¸¸ã€‚`;
    }
  }

  static renderPrediction(prediction) {
    try {
      if (!prediction) {
        return `${CONFIG.EMOJI.warning} é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚`;
      }
      
      const nextExpect = Formatter.safeString(prediction.nextExpect, "æœªçŸ¥");
      const confidence = Formatter.safeInt(prediction.confidence, 0);
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const basedOnLastRecord = prediction.basedOnLastRecord || {};
      const analysisBased = prediction.analysisBased || false;
      const knnUsed = prediction.knnUsed || false;
      const patternAnalysisUsed = prediction.patternAnalysisUsed || false;
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      const zodiac = prediction.zodiac || { main: [], guard: [], avoid: [], scores: {} };
      const color = prediction.color || { main: "red", guard: "blue", avoid: "green", scores: {} };
      const tailRecommendations = prediction.tailRecommendations || { main: [], guard: [], scores: {} };
      const hotColdAnalysis = prediction.hotColdAnalysis || { hotNumbers: [], coldNumbers: [], overdueNumbers: [], analysis: "" };
      const trendAnalysis = prediction.trendAnalysis || { trend: "æœªçŸ¥", strength: 0, direction: "æ— ", analysis: "" };
      const patternStrength = prediction.patternStrength || { strongPatterns: [], moderatePatterns: [], weakPatterns: [], strength: 0, analysis: "" };
      const head = Formatter.safeString(prediction.head, "æœªçŸ¥");
      const shape = Formatter.safeString(prediction.shape, "æœªçŸ¥");
      const patternConfidence = Formatter.safeInt(prediction.patternConfidence, 0);
      const neighborQuality = Formatter.safeInt(prediction.neighborQuality, 0);
      const neighborCount = Formatter.safeInt(prediction.neighborCount, 0);
      
      // ç®—æ³•æ ‡è¯†
      let algorithmInfo = "";
      if (knnUsed && patternAnalysisUsed) {
        algorithmInfo = `${CONFIG.EMOJI.brain_circuit} <b>å¢å¼ºKNNç®—æ³• + æ¨¡å¼åˆ†æé¢„æµ‹</b>\n`;
      } else if (patternAnalysisUsed) {
        algorithmInfo = `${CONFIG.EMOJI.pattern} <b>æ¨¡å¼åˆ†æé¢„æµ‹</b>\n`;
      } else if (knnUsed) {
        algorithmInfo = `${CONFIG.EMOJI.knn} <b>KNNç®—æ³•é¢„æµ‹</b>\n`;
      } else {
        algorithmInfo = `${CONFIG.EMOJI.brain} <b>ä¼ ç»Ÿç®—æ³•é¢„æµ‹</b>\n`;
      }
      
      let dataSource = "";
      if (analysisBased && totalHistoryRecords > 0) {
        dataSource = `${CONFIG.EMOJI.database} åŸºäº ${totalHistoryRecords} æœŸå†å²æ•°æ®åˆ†æ\n`;
        if (patternConfidence > 0) {
          dataSource += `${CONFIG.EMOJI.chart} æ¨¡å¼åˆ†æç½®ä¿¡åº¦: ${patternConfidence}%\n`;
        }
        if (neighborCount > 0 && neighborQuality > 0) {
          dataSource += `${CONFIG.EMOJI.target} é‚»å±…è´¨é‡: ${neighborQuality}% (${neighborCount}ä¸ª)\n`;
        }
      } else {
        dataSource = `${CONFIG.EMOJI.warning} åŸºäºé™æ€ç®—æ³•ç”Ÿæˆ\n`;
      }
      
      let basedOnInfo = "";
      if (basedOnLastRecord.expect) {
        const { expect, special, zodiac: lastZodiac, color: lastColor, size, parity } = basedOnLastRecord;
        basedOnInfo = `${CONFIG.EMOJI.history} åŸºäº: ç¬¬ ${expect} æœŸ (ç‰¹ç ${special} | ${lastZodiac}${CONFIG.EMOJI[lastColor]} | ${size}${parity})\n`;
      }
      
      // è¶‹åŠ¿å’Œæ¨¡å¼å¼ºåº¦
      let trendPatternInfo = "";
      if (trendAnalysis.analysis || patternStrength.analysis) {
        trendPatternInfo = `${CONFIG.EMOJI.trend} ${trendAnalysis.analysis}\n`;
        if (patternStrength.analysis) {
          trendPatternInfo += `${CONFIG.EMOJI.algorithm} ${patternStrength.analysis}\n`;
        }
      }
      
      // æ ¼å¼åŒ–å¹³ç æ˜¾ç¤º
      let normalDisplay = "æš‚æ— æ•°æ®";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      // æ ¼å¼åŒ–ç‰¹ç æ˜¾ç¤ºï¼ˆå¸¦æ¦‚ç‡ï¼‰
      let specialDisplay = "æš‚æ— æ•°æ®";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.slice(0, 5).map(num => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.score ? `(${num.score}%)` : "";
          const source = num?.source ? `[${num.source}]` : "";
          
          return `${numStr}(${zodiacStr}${colorEmoji})${prob}${source}`;
        }).join("\n");
      }
      
      const zodiacMain = Array.isArray(zodiac.main) ? zodiac.main : [];
      const zodiacGuard = Array.isArray(zodiac.guard) ? zodiac.guard : [];
      const zodiacAvoid = Array.isArray(zodiac.avoid) ? zodiac.avoid : [];
      
      const tailMain = Array.isArray(tailRecommendations.main) ? tailRecommendations.main : [];
      const tailGuard = Array.isArray(tailRecommendations.guard) ? tailRecommendations.guard : [];
      
      const content = `
${CONFIG.EMOJI.fire} <b>${CONFIG.SYSTEM.NAME} - å¢å¼ºé¢„æµ‹ V14.0</b>
${algorithmInfo}ç¬¬ <b>${nextExpect}</b> æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${basedOnInfo}${trendPatternInfo}
${CONFIG.EMOJI.star} <b>ç”Ÿè‚–æ¨è</b>
ä¸»æ¨: ${zodiacMain.join(" ") || "æš‚æ— "}
é˜²å®ˆ: ${zodiacGuard.join(" ") || "æš‚æ— "}
${zodiacAvoid.length > 0 ? `é¿å…: ${zodiacAvoid.join(" ")}\n` : ''}

${CONFIG.EMOJI.diamond} <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[color.main] || ""} / é˜²${CONFIG.EMOJI[color.guard] || ""} ${color.avoid ? `/ é¿${CONFIG.EMOJI[color.avoid]}` : ''}

${CONFIG.EMOJI.target} <b>å°¾æ•°æ¨è</b>
ä¸»æ¨: ${tailMain.join(" ") || "æš‚æ— "}
é˜²å®ˆ: ${tailGuard.join(" ") || "æš‚æ— "}

${hotColdAnalysis.analysis ? `${CONFIG.EMOJI.trend} <b>çƒ­å†·å·åˆ†æ</b>\n${hotColdAnalysis.analysis}\n` : ''}

${CONFIG.EMOJI.rocket} <b>ç‰¹ç å‚è€ƒ</b>
å¤´æ•°: ${head} | å½¢æ€: ${shape}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ç²¾é€‰å¹³ç </b>
${normalDisplay}

<b>ç‰¹ç æ¨è (æ¦‚ç‡/æ¥æº)</b>
${specialDisplay}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ç½®ä¿¡åº¦</b>: ${confidence}%
<b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
<b>ç®—æ³•ç‰ˆæœ¬</b>: ${prediction.algorithmVersion || "V14.0"}
<b>KNNç®—æ³•</b>: ${knnUsed ? "å·²ä½¿ç”¨" : "æœªä½¿ç”¨"}
<b>æ¨¡å¼åˆ†æ</b>: ${patternAnalysisUsed ? "å·²ä½¿ç”¨" : "æœªä½¿ç”¨"}
<b>å†å²æ•°æ®</b>: ${totalHistoryRecords} æœŸ
<b>æ¶ˆæ¯æ¨¡å¼</b>: ${CONFIG.EMOJI.refresh} æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„æµ‹æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.database} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]} (${attr.size}${attr.parity})\n`;
          }
        });
      }

      message += `\nä½¿ç”¨ <code>/history ${page + 1}</code> æŸ¥çœ‹ä¸‹ä¸€é¡µ`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /history å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.database} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `${CONFIG.EMOJI.check} <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\n${CONFIG.EMOJI.fire} <b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
      } else {
        message += `${CONFIG.EMOJI.warning} <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /sync å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderPushResult(success, prediction, channelPushSuccess = false) {
    try {
      let message = `${CONFIG.EMOJI.fire} <b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `${CONFIG.EMOJI.check} <b>æ¨é€æˆåŠŸ</b>\n`;
        message += `æœŸå·: ${prediction?.nextExpect || "æœªçŸ¥"}\n`;
        message += `ç½®ä¿¡åº¦: ${prediction?.confidence || 0}%\n`;
        
        if (channelPushSuccess) {
          message += `é¢‘é“æ¨é€: æˆåŠŸ ${CONFIG.EMOJI.check}\n`;
        } else {
          message += `é¢‘é“æ¨é€: å¤±è´¥ ${CONFIG.EMOJI.warning}\n`;
        }
      } else {
        message += `${CONFIG.EMOJI.warning} <b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /push å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteConfirmation(expectRange, impactInfo) {
    try {
      const { toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤</b>\n\n`;
      
      if (expectRange.includes('-')) {
        const [start, end] = expectRange.split('-');
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(start)}</b> æœŸåˆ°ç¬¬ <b>${Formatter.safeString(end)}</b> æœŸçš„è®°å½•\n`;
      } else {
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(expectRange)}</b> æœŸçš„è®°å½•\n`;
      }
      
      message += `æ¶‰åŠ <b>${toDeleteCount || 0}</b> æ¡å†å²è®°å½•\n\n`;
      
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        message += `åˆ é™¤åï¼Œæœ€æ–°è®°å½•ä¸º:\n`;
        message += `ç¬¬ <b>${latestAfterDelete.expect || "æœªçŸ¥"}</b> æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]} (${attr.size}${attr.parity})\n`;
      } else {
        message += `åˆ é™¤åå°†æ— å†å²è®°å½•\n`;
      }
      
      message += `\n${CONFIG.EMOJI.warning} <b>è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼</b>\n\n`;
      message += `è¯·å›å¤ <code>ç¡®è®¤åˆ é™¤ ${Formatter.safeString(expectRange)}</code> ä»¥ç¡®è®¤åˆ é™¤ã€‚`;
      
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç¡®è®¤å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤å¤±è´¥</b>\n\næ— æ³•ç”Ÿæˆç¡®è®¤ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `${CONFIG.EMOJI.check} <b>åˆ é™¤æˆåŠŸ</b>\n`;
        message += `åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
        message += `åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
        
        if (result.total !== undefined) {
          message += `èŒƒå›´å†…è®°å½•æ•°: ${result.total} æ¡\n`;
        }
        
        // æ˜¾ç¤ºåˆ é™¤åçš„æœ€æ–°è®°å½•
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          message += `\n${CONFIG.EMOJI.check} <b>åˆ é™¤åæœ€æ–°è®°å½•</b>\n`;
          message += `ç¬¬ ${latestAfterDelete.expect} æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]} (${attr.size}${attr.parity})\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `${CONFIG.EMOJI.warning} <b>åˆ é™¤å¤±è´¥</b>\n`;
        message += `é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\næ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\nå¤„ç†åˆ é™¤ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderStats(stats, historyCount, latestExpect, totalPredictions, totalAnalysis) {
    try {
      let message = `${CONFIG.EMOJI.bar_chart} <b>ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      
      message += `<b>${CONFIG.EMOJI.database} æ•°æ®ç»Ÿè®¡</b>\n`;
      message += `å†å²è®°å½•æ•°: ${historyCount} æ¡\n`;
      message += `æœ€æ–°æœŸå·: ${latestExpect || "æ— "}\n`;
      
      if (stats.last_sync) {
        const lastSync = new Date(stats.last_sync.value).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'});
        message += `æœ€ååŒæ­¥: ${lastSync}\n`;
      }
      
      message += `\n<b>${CONFIG.EMOJI.calculator} åˆ†æç»Ÿè®¡</b>\n`;
      message += `æ€»é¢„æµ‹æ¬¡æ•°: ${totalPredictions} æ¬¡\n`;
      message += `æ€»åˆ†ææ¬¡æ•°: ${totalAnalysis} æ¬¡\n`;
      
      if (stats.total_syncs) {
        message += `æ€»åŒæ­¥æ¬¡æ•°: ${stats.total_syncs.value || 0} æ¬¡\n`;
      }
      
      if (stats.total_pushes) {
        message += `æ€»æ¨é€æ¬¡æ•°: ${stats.total_pushes.value || 0} æ¬¡\n`;
      }
      
      if (stats.total_deletions) {
        message += `æ€»åˆ é™¤æ¬¡æ•°: ${stats.total_deletions.value || 0} æ¬¡\n`;
      }
      
      message += `\n<b>${CONFIG.EMOJI.gear} ç³»ç»ŸçŠ¶æ€</b>\n`;
      message += `KNNç®—æ³•: å¯ç”¨ (K=${CONFIG.SYSTEM.KNN_K_VALUE})\n`;
      message += `æ¨¡å¼åˆ†æ: å¯ç”¨ (16ç§æ¨¡å¼)\n`;
      message += `é˜²åˆ·å±: å¯ç”¨\n`;
      message += `ç¼“å­˜çŠ¶æ€: æ­£å¸¸\n`;
      
      message += `\n<b>${CONFIG.EMOJI.algorithm} ç®—æ³•ç‰¹æ€§</b>\n`;
      message += `â€¢ å¢å¼ºKNNç®—æ³• + æ¨¡å¼åˆ†æ\n`;
      message += `â€¢ 16ç§å†å²è§„å¾‹åˆ†ææ¨¡å¼\n`;
      message += `â€¢ å¤šç»´åº¦æ™ºèƒ½é¢„æµ‹\n`;
      message += `â€¢ æ™ºèƒ½ç½®ä¿¡åº¦è¯„ä¼°\n`;
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /stats å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“ç»Ÿè®¡ä¿¡æ¯å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} è·å–ç»Ÿè®¡ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderClearCacheResult(success) {
    try {
      let message = `${CONFIG.EMOJI.memory} <b>ç¼“å­˜æ¸…ç†ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `${CONFIG.EMOJI.check} <b>æ¸…ç†æˆåŠŸ</b>\n`;
        message += `å·²æ¸…ç†ä»¥ä¸‹ç¼“å­˜ï¼š\n`;
        message += `â€¢ é¢„æµ‹ç¼“å­˜\n`;
        message += `â€¢ æ¨¡å¼åˆ†æç¼“å­˜\n`;
        message += `â€¢ KNNè·ç¦»ç¼“å­˜\n`;
        message += `â€¢ ç³»ç»Ÿç¼“å­˜\n`;
        message += `\nç³»ç»Ÿæ€§èƒ½å·²ä¼˜åŒ–ï¼Œå¯ä»¥é‡æ–°ç”Ÿæˆé¢„æµ‹ã€‚`;
      } else {
        message += `${CONFIG.EMOJI.warning} <b>æ¸…ç†å¤±è´¥</b>\n`;
        message += `æ¸…ç†ç¼“å­˜æ—¶å‘ç”Ÿé”™è¯¯ã€‚\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /clear_cache å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“ç¼“å­˜æ¸…ç†ç»“æœå¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†ç¼“å­˜æ¸…ç†ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }
}

// ==============================================================================
// 10. å¤–éƒ¨æ¥å£å°è£…
// ==============================================================================

class ExternalService {
  static async sendMessage(env, chatId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  static async editMessage(env, chatId, messageId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  static async deleteMessage(env, chatId, messageId) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage?chat_id=${chatId}&message_id=${messageId}`;

      const response = await fetch(url, {
        method: "POST"
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.warn("Telegram", `deleteMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "deleteMessage network error", error);
      return null;
    }
  }

  static async sendAndDeleteOldMessage(env, chatId, messageType, text) {
    try {
      const oldMessageId = MessageManager.getUserMessage(chatId, messageType);
      
      if (oldMessageId) {
        this.deleteMessage(env, chatId, oldMessageId).then(result => {
          if (result && result.ok) {
            Logger.info("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          } else {
            Logger.warn("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¤±è´¥æˆ–æ¶ˆæ¯å·²ä¸å­˜åœ¨: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          }
        }).catch(error => {
          Logger.error("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¼‚å¸¸: chatId=${chatId}, type=${messageType}`, error);
        });
      }
      
      const sendResult = await this.sendMessage(env, chatId, text);
      
      if (sendResult && sendResult.ok && sendResult.result) {
        const newMessageId = sendResult.result.message_id;
        
        MessageManager.setUserMessage(chatId, messageType, newMessageId);
        
        MessageManager.cleanupOldMessages(chatId, 10);
        
        Logger.info("Telegram", `å‘é€æ–°æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${newMessageId}, æ—§æ¶ˆæ¯ID=${oldMessageId || 'æ— '}`);
        
        return { 
          success: true, 
          messageId: newMessageId, 
          oldMessageId: oldMessageId,
          message: oldMessageId ? "å·²åˆ é™¤æ—§æ¶ˆæ¯å¹¶å‘é€æ–°æ¶ˆæ¯" : "å‘é€æ–°æ¶ˆæ¯"
        };
      }
      
      return { 
        success: false, 
        error: "æ¶ˆæ¯å‘é€å¤±è´¥",
        oldMessageId: oldMessageId
      };
    } catch (error) {
      Logger.error("Telegram", "sendAndDeleteOldMessageå¤±è´¥", error);
      return { 
        success: false, 
        error: error.message,
        method: "error"
      };
    }
  }

  static async sendTemporaryMessage(env, chatId, text, parseMode = "HTML") {
    return await this.sendMessage(env, chatId, text, parseMode);
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/14.0',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      const data = await response.json();
      let records = [];

      if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
        
        // æ¸…é™¤ç¼“å­˜
        CacheManager.clear();
        PatternAnalysisEngine.clearCache();
        EnhancedKNNAgorithm.clearCache();
        AdvancedPredictionEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 11. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨
// ==============================================================================

class Controller {
  static pendingDeletions = new Map();

  // å¤„ç†å¼€å§‹å‘½ä»¤
  static async handleStart(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†startå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  // å¤„ç†å‘½ä»¤æ¨¡æ¿
  static async handleCommandTemplate(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†cccå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  // å¤„ç†é¢„æµ‹
  static async handlePredict(env, chatId, useKNN = true) {
    try {
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await AdvancedPredictionEngine.generate(env, history, weights, useKNN);
      
      const message = MessageRenderer.renderPrediction(prediction);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†predictå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>ç”Ÿæˆé¢„æµ‹å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†å†å²è®°å½•
  static async handleHistory(env, chatId, pageStr = "1") {
    try {
      const page = Math.max(1, Formatter.safeInt(pageStr, 1));
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†historyå‘½ä»¤å¤±è´¥", error);
      const errorMessage = "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†åŒæ­¥
  static async handleSync(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åŒæ­¥æ•°æ®ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.database} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      const message = MessageRenderer.renderSyncResult(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†æ¨é€
  static async handlePush(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥æ¨é€é¢„æµ‹ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    if (!env.TG_CHANNEL_ID) {
      const message = "âŒ <b>é¢‘é“IDæœªé…ç½®</b>\n\næ— æ³•æ¨é€åˆ°é¢‘é“ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.fire} <b>æ­£åœ¨ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆæ¨é€ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await AdvancedPredictionEngine.generate(env, history, weights, true);
      
      let channelPushSuccess = false;
      try {
        const channelMessage = MessageRenderer.renderPrediction(prediction);
        await ExternalService.sendTemporaryMessage(env, env.TG_CHANNEL_ID, channelMessage);
        channelPushSuccess = true;
        Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${prediction.nextExpect}`);
        
        // æ›´æ–°æ¨é€è®¡æ•°
        const totalPushes = Formatter.safeInt(await DB.getSetting(env, "TOTAL_PUSHES", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_PUSHES", totalPushes.toString());
      } catch (error) {
        Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
        channelPushSuccess = false;
      }
      
      const message = MessageRenderer.renderPushResult(true, prediction, channelPushSuccess);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
    } catch (error) {
      Logger.error("Push", "æ¨é€å¤„ç†å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†åˆ é™¤
  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åˆ é™¤è®°å½•ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        const message = `âŒ <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        const message = "âŒ <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        const message = `âš ï¸ <b>æœªæ‰¾åˆ°è®°å½•</b>\n\nåœ¨ ${expectRange} èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å†å²è®°å½•ã€‚`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, confirmMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, confirmMessage);
      }
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // ç¡®è®¤åˆ é™¤
  static async confirmDelete(env, chatId, userId, confirmText) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const pendingDeletion = this.pendingDeletions.get(deletionKey);
      
      if (!pendingDeletion) {
        const message = "âŒ <b>åˆ é™¤æ“ä½œå·²è¿‡æœŸæˆ–æ— æ•ˆ</b>\n\nè¯·é‡æ–°å‘èµ·åˆ é™¤å‘½ä»¤ã€‚";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectedConfirm = `ç¡®è®¤åˆ é™¤ ${pendingDeletion.expectRange}`;
      if (confirmText !== expectedConfirm) {
        const message = `âŒ <b>ç¡®è®¤æ–‡æœ¬ä¸æ­£ç¡®</b>\n\nè¯·å›å¤: <code>${expectedConfirm}</code>`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      this.pendingDeletions.delete(deletionKey);
      
      const processingMessage = `${CONFIG.EMOJI.trash} <b>æ­£åœ¨åˆ é™¤è®°å½•...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await DB.deleteHistoryByRange(
        env, 
        pendingDeletion.start, 
        pendingDeletion.end,
        Formatter.safeString(userId),
        "æ‰‹åŠ¨åˆ é™¤"
      );
      
      if (!result.success) {
        const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange);
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        return;
      }
      
      CacheManager.clear();
      PatternAnalysisEngine.clearCache();
      EnhancedKNNAgorithm.clearCache();
      AdvancedPredictionEngine.clearCache();
      
      const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange, pendingDeletion.impactInfo);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå®Œæˆ: ${pendingDeletion.expectRange}, åˆ é™¤è®°å½•æ•°: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "ç¡®è®¤åˆ é™¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>åˆ é™¤æ“ä½œå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†ç»Ÿè®¡
  static async handleStats(env, chatId) {
    try {
      const historyCount = await DB.getHistoryCount(env);
      const latestExpect = await DB.getLatestExpect(env);
      const stats = await DB.getStats(env);
      const totalPredictions = await DB.getSetting(env, "TOTAL_PREDICTIONS", "0");
      const totalAnalysis = await DB.getSetting(env, "TOTAL_ANALYSIS", "0");
      
      const message = MessageRenderer.renderStats(stats, historyCount, latestExpect, totalPredictions, totalAnalysis);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATS, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†statså‘½ä»¤å¤±è´¥", error);
      const errorMessage = "âŒ <b>è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.STATS, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  // å¤„ç†æ¸…ç†ç¼“å­˜
  static async handleClearCache(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥æ¸…ç†ç¼“å­˜ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.CLEAR_CACHE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      CacheManager.clear();
      PatternAnalysisEngine.clearCache();
      EnhancedKNNAgorithm.clearCache();
      AdvancedPredictionEngine.clearCache();
      MessageManager.userMessages.clear();
      
      const message = MessageRenderer.renderClearCacheResult(true);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.CLEAR_CACHE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†clear_cacheå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ¸…ç†ç¼“å­˜å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.CLEAR_CACHE, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
}

// ==============================================================================
// 12. äº‹ä»¶å¤„ç†å™¨
// ==============================================================================

async function handleUpdate(env, payload) {
  try {
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId, isAdmin });
    
    // å¤„ç†ç¡®è®¤åˆ é™¤
    if (text.startsWith('ç¡®è®¤åˆ é™¤ ')) {
      if (isAdmin) {
        await Controller.confirmDelete(env, chatId, userId, text);
      } else {
        const message = "âŒ <b>æƒé™ä¸è¶³</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, "permission_error", message
        );
      }
      return;
    }
    
    // å¤„ç†å‘½ä»¤
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
          
        case '/predict':
        case '/p':
          await Controller.handlePredict(env, chatId, true);
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        case '/stats':
          await Controller.handleStats(env, chatId);
          break;
          
        case '/clear_cache':
        case '/clearcache':
          await Controller.handleClearCache(env, chatId, isAdmin);
          break;
          
        default:
          // æœªçŸ¥å‘½ä»¤ï¼Œæ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
      }
    } else {
      // éå‘½ä»¤æ¶ˆæ¯ï¼Œæ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿
      await Controller.handleCommandTemplate(env, chatId, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}

// ==============================================================================
// 13. Worker å…¥å£ç‚¹
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(`Missing required environment variables: ${missingVars.join(', ')}`, { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "YOUR_CHANNEL_ID_HERE";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "YOUR_ADMIN_ID_HERE";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response("Database Initialization Failed. Please check D1 binding.", { 
          status: 500,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
      
      // å¥åº·æ£€æŸ¥
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const latestExpect = await DB.getLatestExpect(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              beijingTime: Formatter.calculateBeijingTime().toLocaleString('zh-CN'),
              database: {
                historyCount: historyCount,
                latestExpect: latestExpect
              },
              config: {
                knnKValue: CONFIG.SYSTEM.KNN_K_VALUE,
                historyLimit: CONFIG.SYSTEM.HISTORY_LIMIT,
                patternAnalysis: "16ç§æ¨¡å¼",
                algorithm: "å¢å¼ºKNN + æ¨¡å¼åˆ†æ"
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            PatternAnalysisEngine.clearCache();
            EnhancedKNNAgorithm.clearCache();
            AdvancedPredictionEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤"
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/test-pattern") {
          try {
            const history = await DB.getAllHistory(env);
            const patterns = PatternAnalysisEngine.analyzeHistoricalPatterns(history);
            
            return new Response(JSON.stringify({
              status: "OK",
              patternCount: Object.keys(patterns).length,
              confidence: patterns.confidence || 0,
              historyCount: history.length,
              analysisDuration: patterns.analysisDuration || 0,
              tailPatterns: patterns.tailPatterns ? Object.keys(patterns.tailPatterns).length : 0,
              zodiacPatterns: patterns.zodiacPatterns ? Object.keys(patterns.zodiacPatterns).length : 0,
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/test-knn") {
          try {
            const history = await DB.getAllHistory(env);
            
            if (history.length < 10) {
              return new Response(JSON.stringify({
                status: "ERROR",
                message: "å†å²æ•°æ®ä¸è¶³ï¼Œè‡³å°‘éœ€è¦10æ¡è®°å½•"
              }, null, 2), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
              });
            }
            
            const weights = await DB.getWeights(env);
            const prediction = await AdvancedPredictionEngine.generate(env, history, weights, true);
            
            return new Response(JSON.stringify({
              status: "OK",
              nextExpect: prediction.nextExpect,
              confidence: prediction.confidence,
              knnUsed: prediction.knnUsed,
              patternAnalysisUsed: prediction.patternAnalysisUsed,
              specialNumbers: prediction.specialNumbers?.slice(0, 3) || [],
              historyCount: history.length,
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // ä¸»é¡µæ˜¾ç¤º
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .feature-list {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .feature-item {
                  margin-bottom: 10px;
                  color: #2d3748;
                }
                .feature-item:before {
                  content: "âœ… ";
                  margin-right: 8px;
                }
                .command-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .command {
                  margin-bottom: 8px;
                  color: #276749;
                  font-family: monospace;
                  background: #e6fffa;
                  padding: 5px 10px;
                  border-radius: 5px;
                  display: inline-block;
                }
                .algorithm-info {
                  background: linear-gradient(45deg, #667eea, #764ba2);
                  color: white;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                }
                .enhanced {
                  background: linear-gradient(45deg, #f56565, #ed8936);
                  color: white;
                  padding: 5px 10px;
                  border-radius: 5px;
                  font-weight: bold;
                  display: inline-block;
                  margin: 5px 0;
                }
                .pattern-badge {
                  background: linear-gradient(45deg, #48bb78, #38b2ac);
                  color: white;
                  padding: 3px 8px;
                  border-radius: 4px;
                  font-size: 0.8em;
                  margin-left: 5px;
                  display: inline-block;
                }
                .api-endpoints {
                  background: #f7fafc;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #2d3748;
                }
                .api-endpoint {
                  font-family: monospace;
                  background: #edf2f7;
                  padding: 3px 8px;
                  border-radius: 3px;
                  margin: 2px 0;
                  display: inline-block;
                }
                .anti-spam {
                  background: #e6fffa;
                  border: 1px solid #38b2ac;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #234e52;
                }
                .pattern-analysis {
                  background: linear-gradient(45deg, #f56565, #ed8936);
                  color: white;
                  padding: 15px;
                  border-radius: 8px;
                  margin-top: 20px;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION}</div>
                
                <div class="feature-list">
                  <h3>ç³»ç»Ÿç‰¹æ€§</h3>
                  <div class="feature-item">é˜²åˆ·å±æ¨¡å¼ï¼šæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</div>
                  <div class="feature-item"><span class="enhanced">å¢å¼ºKNNç®—æ³• + 16ç§æ¨¡å¼åˆ†æ</span></div>
                  <div class="feature-item"><span class="pattern-badge">å°¾æ•°æ¨¡å¼</span> <span class="pattern-badge">ç”Ÿè‚–æ¨¡å¼</span> <span class="pattern-badge">é¢œè‰²æ¨¡å¼</span> <span class="pattern-badge">å¤§å°å•åŒ</span></div>
                  <div class="feature-item"><span class="pattern-badge">è¶‹åŠ¿åˆ†æ</span> <span class="pattern-badge">èšç±»åˆ†æ</span> <span class="pattern-badge">å‘¨æœŸåˆ†æ</span> <span class="pattern-badge">é¢‘ç‡åˆ†æ</span></div>
                  <div class="feature-item">è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯ï¼Œä¿æŒç•Œé¢æ•´æ´</div>
                  <div class="feature-item">å³æ—¶é¢„æµ‹ï¼Œæ— éœ€ç­‰å¾…</div>
                  <div class="feature-item">çº¯æ–‡æœ¬å‘½ä»¤äº¤äº’</div>
                  <div class="feature-item">åŸºäºå…¨éƒ¨å†å²æ•°æ®åˆ†æ</div>
                  <div class="feature-item">ç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ã€å¤§å°å•åŒã€è¶‹åŠ¿å¤šç»´åº¦é¢„æµ‹</div>
                </div>
                
                <div class="command-list">
                  <h3>ä¸»è¦å‘½ä»¤</h3>
                  <div class="command">/start - æ¬¢è¿ä¿¡æ¯</div>
                  <div class="command">/ccc - æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿</div>
                  <div class="command">/predict - ç”Ÿæˆé¢„æµ‹</div>
                  <div class="command">/history [é¡µç ] - æŸ¥çœ‹å†å²</div>
                  <div class="command">/stats - æŸ¥çœ‹ç³»ç»Ÿç»Ÿè®¡</div>
                  <div class="command">/clear_cache - æ¸…ç†ç¼“å­˜</div>
                  <div class="command">/sync - æ‰‹åŠ¨åŒæ­¥æ•°æ®(ç®¡ç†å‘˜)</div>
                  <div class="command">/push - æ‰‹åŠ¨æ¨é€é¢„æµ‹(ç®¡ç†å‘˜)</div>
                  <div class="command">/delete [æœŸå·] - åˆ é™¤è®°å½•(ç®¡ç†å‘˜)</div>
                </div>
                
                <div class="pattern-analysis">
                  <strong>${CONFIG.EMOJI.brain_circuit} å¢å¼ºæ¨¡å¼åˆ†æï¼š</strong><br>
                  â€¢ å°¾æ•°æ¨¡å¼åˆ†æï¼šå¹³ç å°¾æ•°ä¸ç‰¹ç å°¾æ•°å…³ç³»ã€å°¾æ•°é—´éš”ã€è¶‹åŠ¿<br>
                  â€¢ ç”Ÿè‚–æ¨¡å¼åˆ†æï¼šç”Ÿè‚–è½¬ç§»ã€é—´éš”ã€ç»„åˆã€å…³ç³»ï¼ˆå…­åˆã€ä¸‰åˆï¼‰<br>
                  â€¢ é¢œè‰²æ¨¡å¼åˆ†æï¼šæ³¢è‰²åºåˆ—ã€é—´éš”ã€ç»„åˆ<br>
                  â€¢ å¤§å°å•åŒåˆ†æï¼šå½¢æ€åºåˆ—å’Œç»„åˆ<br>
                  â€¢ å¹³ç åˆ†æï¼šå¹³ç å°¾æ•°ã€ç”Ÿè‚–ã€é¢œè‰²åˆ†å¸ƒ<br>
                  â€¢ åºåˆ—åˆ†æï¼šè¿ç»­å¤šæœŸæ•°å­—ã€å°¾æ•°ã€ç”Ÿè‚–ã€é¢œè‰²åºåˆ—<br>
                  â€¢ å‘¨æœŸåˆ†æï¼š3æœŸã€5æœŸã€7æœŸã€10æœŸã€14æœŸã€21æœŸå‘¨æœŸ<br>
                  â€¢ é¢‘ç‡åˆ†æï¼šçƒ­å·ã€å†·å·ã€é—æ¼å·ç ã€é¢‘ç‡åˆ†å¸ƒ<br>
                  â€¢ ç»„åˆåˆ†æï¼šæ•°å­—å¯¹ã€ç”Ÿè‚–å¯¹ã€é¢œè‰²å¯¹ã€å¤§å°å•åŒç»„åˆ<br>
                  â€¢ ç‰¹æ®Šæ¨¡å¼ï¼šé‡å¤æ•°å­—ã€äº¤æ›¿æ¨¡å¼ã€è¶‹åŠ¿åˆ†æã€èšç±»æ¨¡å¼
                </div>
                
                <div class="anti-spam">
                  <strong>${CONFIG.EMOJI.refresh} é˜²åˆ·å±ç‰¹æ€§ï¼š</strong><br>
                  â€¢ æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯<br>
                  â€¢ å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯<br>
                  â€¢ ä¿æŒèŠå¤©ç•Œé¢æ•´æ´ï¼Œé˜²æ­¢æ¶ˆæ¯å †ç§¯<br>
                  â€¢ ç”¨æˆ·æ¯ä¸ªå‘½ä»¤ç±»å‹æœ€å¤šä¿ç•™10æ¡æœ€æ–°æ¶ˆæ¯
                </div>
                
                <div class="algorithm-info">
                  <strong>${CONFIG.EMOJI.algorithm} å¢å¼ºç®—æ³•æ¶æ„ï¼š</strong><br>
                  â€¢ åŸºäºKNNç®—æ³•æŸ¥æ‰¾å†å²ç›¸ä¼¼è®°å½•<br>
                  â€¢ æ•´åˆ16ç§æ¨¡å¼åˆ†æç»“æœ<br>
                  â€¢ åŠ æƒè·ç¦»è®¡ç®—ï¼ˆ17ä¸ªç‰¹å¾ç»´åº¦ï¼‰<br>
                  â€¢ æ™ºèƒ½ç½®ä¿¡åº¦è¯„ä¼°<br>
                  â€¢ å¤šç»´åº¦é¢„æµ‹è¾“å‡º
                </div>
                
                <div class="api-endpoints">
                  <strong>APIç«¯ç‚¹ï¼š</strong><br>
                  <div class="api-endpoint">GET /health - ç³»ç»Ÿå¥åº·æ£€æŸ¥</div>
                  <div class="api-endpoint">GET /reset-cache - é‡ç½®ç¼“å­˜</div>
                  <div class="api-endpoint">GET /test-pattern - æµ‹è¯•æ¨¡å¼åˆ†æ</div>
                  <div class="api-endpoint">GET /test-knn - æµ‹è¯•KNNé¢„æµ‹</div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 8px;">
                  <strong>æ›´æ–°å†…å®¹ï¼š</strong><br>
                  â€¢ ç§»é™¤å®šæ—¶åŒæ­¥å’Œæ¨é€åŠŸèƒ½<br>
                  â€¢ ä¿ç•™æ‰‹åŠ¨åŒæ­¥å’Œæ‰‹åŠ¨æ¨é€åŠŸèƒ½<br>
                  â€¢ å¢å¼ºKNNç®—æ³•å’Œæ¨¡å¼åˆ†æ<br>
                  â€¢ å¢åŠ è¶‹åŠ¿åˆ†æå’Œèšç±»åˆ†æ<br>
                  â€¢ ä¼˜åŒ–é¢„æµ‹é€»è¾‘ï¼Œæé«˜å‡†ç¡®æ€§<br>
                  â€¢ å®Œå–„ç”¨æˆ·äº¤äº’ç•Œé¢
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response("Internal Server Error", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};
