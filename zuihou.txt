/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V15.1 ç²¾ç®€å¢å¼ºç‰ˆ
 * 
 * ä¸»è¦æ”¹è¿›:
 * 1. ç§»é™¤KNNç®—æ³•åŠç›¸å…³ä»£ç 
 * 2. å¢å¼ºç»Ÿè®¡ç®—æ³•ï¼Œå¢åŠ æ›´å¤šç»Ÿè®¡ç»´åº¦
 * 3. ç§»é™¤æ‰€æœ‰å†—ä½™ä»£ç å’Œæœªä½¿ç”¨å‡½æ•°
 * 4. ä¼˜åŒ–ä»£ç ç»“æ„å’Œæ€§èƒ½
 * 5. å®Œå–„ç®—æ³•æƒé‡é…ç½®
 * 6. æ”¹è¿›é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

const CONFIG = {
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ¾³å…­é¢„æµ‹",
    VERSION: "V15.1 ç²¾ç®€å¢å¼ºç‰ˆ",
    TIMEZONE_OFFSET: 8,
    HISTORY_LIMIT: 2000,
    CACHE_TTL: 60 * 1000,
    MESSAGE_CACHE_SIZE: 50,
    MONTECARLO_SIMULATIONS: 10000,
    MAX_SIMULATIONS: 50000,
    MAX_RUNTIME_MS: 10000,
    MAX_SPECIAL_PREDICTIONS: 15,
    MAX_NORMAL_PREDICTIONS: 12,
    MONTE_CACHE_TTL: 5 * 60 * 1000,
    STATS_WINDOW_SIZE: 150,
    PREDICTION_TIMEOUT: 8000,
    ALGORITHM_TIMEOUTS: {
      traditional: 3000,
      stats: 6000,
      advanced: 10000,
      omission: 2000,
      association: 3000,
      math: 2000,
      zone: 2000
    },
    MIN_HISTORY_FOR_ALGORITHMS: {
      traditional: 2,
      stats: 20,
      advanced: 10,
      omission: 30,
      association: 25,
      math: 15,
      zone: 20
    },
    MESSAGE_MANAGER_MAX_USERS: 1000,
    MESSAGE_MANAGER_MAX_MESSAGES_PER_USER: 20,
    AUTO_CLEANUP_INTERVAL: 10 * 60 * 1000,
    USER_INACTIVITY_THRESHOLD: 30 * 60 * 1000,
    OMISSION_THRESHOLDS: {
      severe: 2.5,
      moderate: 1.8,
      recent: 0.3
    },
    ZONE_CONFIG: {
      zone7: [
        [1, 2, 3, 4, 5, 6, 7],
        [8, 9, 10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19, 20, 21],
        [22, 23, 24, 25, 26, 27, 28],
        [29, 30, 31, 32, 33, 34, 35],
        [36, 37, 38, 39, 40, 41, 42],
        [43, 44, 45, 46, 47, 48, 49]
      ],
      zone5: [
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
        [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],
        [41, 42, 43, 44, 45, 46, 47, 48, 49]
      ],
      zone12: [
        [1, 13, 25, 37, 49],
        [2, 14, 26, 38],
        [3, 15, 27, 39],
        [4, 16, 28, 40],
        [5, 17, 29, 41],
        [6, 18, 30, 42],
        [7, 19, 31, 43],
        [8, 20, 32, 44],
        [9, 21, 33, 45],
        [10, 22, 34, 46],
        [11, 23, 35, 47],
        [12, 24, 36, 48]
      ]
    }
  },

  DEFAULT_ALGO_WEIGHTS: {
    w_zodiac_transfer: 2.8,
    w_zodiac_relation: 2.3,
    w_color_transfer: 2.0,
    w_tail_correlation: 1.8,
    w_number_frequency: 1.5,
    w_monte_carlo: 2.7,
    w_number_pattern: 1.4,
    w_hot_cold: 1.2,
    w_statistics_analysis: 3.0,
    w_tail_pattern: 2.0,
    w_head_pattern: 1.7,
    w_size_pattern: 1.6,
    w_odd_even_pattern: 1.6,
    w_sum_pattern: 1.4,
    w_span_pattern: 1.3,
    w_ac_value_pattern: 1.2,
    w_prime_composite: 1.3,
    w_omission: 2.5,
    w_association: 2.2,
    w_math: 2.0,
    w_zone: 2.1,
    _version: "15.1"
  },

  ZODIAC_MAP: {
    "é¼ ": [6, 18, 30, 42],
    "ç‰›": [5, 17, 29, 41],
    "è™": [4, 16, 28, 40],
    "å…”": [3, 15, 27, 39],
    "é¾™": [2, 14, 26, 38],
    "è›‡": [1, 13, 25, 37, 49],
    "é©¬": [12, 24, 36, 48],
    "ç¾Š": [11, 23, 35, 47],
    "çŒ´": [10, 22, 34, 46],
    "é¸¡": [9, 21, 33, 45],
    "ç‹—": [8, 20, 32, 44],
    "çŒª": [7, 19, 31, 43]
  },

  ZODIAC_RELATIONS: {
    SIX_HARMONY: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ",
      "è™": "çŒª", "çŒª": "è™",
      "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™",
      "è›‡": "çŒ´", "çŒ´": "è›‡",
      "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    
    THREE_HARMONY: {
      "é¼ ": ["é¾™", "çŒ´"],
      "ç‰›": ["è›‡", "é¸¡"],
      "è™": ["é©¬", "ç‹—"],
      "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"],
      "è›‡": ["ç‰›", "é¸¡"],
      "é©¬": ["è™", "ç‹—"],
      "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"],
      "é¸¡": ["ç‰›", "è›‡"],
      "ç‹—": ["è™", "é©¬"],
      "çŒª": ["å…”", "ç¾Š"]
    }
  },

  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  NUMBER_PATTERNS: {
    prime: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47],
    composite: [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49],
    multiples_of_7: [7, 14, 21, 28, 35, 42, 49],
    multiples_of_8: [8, 16, 24, 32, 40, 48]
  },

  MATH_CONSTANTS: {
    GOLDEN_RATIO: 0.6180339887,
    FIBONACCI: [1, 2, 3, 5, 8, 13, 21, 34],
    MODULO_PATTERNS: {
      mod3: [[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48],
             [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49],
             [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47]],
      mod5: [[5, 10, 15, 20, 25, 30, 35, 40, 45],
             [1, 6, 11, 16, 21, 26, 31, 36, 41, 46],
             [2, 7, 12, 17, 22, 27, 32, 37, 42, 47],
             [3, 8, 13, 18, 23, 28, 33, 38, 43, 48],
             [4, 9, 14, 19, 24, 29, 34, 39, 44, 49]]
    }
  },

  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    chart: "ğŸ“Š",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    diamond: "ğŸ’",
    trophy: "ğŸ†",
    home: "ğŸ ",
    trash: "ğŸ—‘ï¸",
    warning: "âš ï¸",
    database: "ğŸ’¾",
    clock: "â°",
    check: "âœ”ï¸",
    speed: "âš¡",
    fix: "ğŸ”§",
    bell: "ğŸ””",
    star: "â­",
    rocket: "ğŸš€",
    refresh: "ğŸ”„",
    eye: "ğŸ‘ï¸",
    lock: "ğŸ”’",
    dice: "ğŸ²",
    calendar: "ğŸ“…",
    hourglass: "â³",
    money: "ğŸ’°",
    target: "ğŸ¯",
    brain: "ğŸ§ ",
    science: "ğŸ”¬",
    chart_up: "ğŸ“ˆ",
    clock2: "ğŸ•’",
    alarm: "â°",
    repeat: "ğŸ”",
    progress: "ğŸ“ˆ",
    batch: "ğŸ”¢",
    history: "ğŸ“œ",
    memory: "ğŸ’¾",
    cpu: "âš™ï¸",
    magic: "âœ¨",
    sparkles: "ğŸŒŸ",
    atom: "âš›ï¸",
    brain_circuit: "ğŸ§©",
    crystal_ball: "ğŸ”®",
    comet: "â˜„ï¸",
    infinity: "â™¾ï¸",
    statistics: "ğŸ“Š",
    tail: "ğŸ”Ÿ",
    head: "ğŸ“Œ",
    size: "âš–ï¸",
    odd_even: "ğŸ”„",
    lightning: "âš¡",
    bulb: "ğŸ’¡",
    gear: "âš™ï¸",
    hammer: "ğŸ”¨",
    zap: "âš¡",
    search: "ğŸ”",
    graph: "ğŸ“ˆ",
    medal: "ğŸ…",
    crown: "ğŸ‘‘",
    trophy2: "ğŸ†",
    first_place: "ğŸ¥‡",
    second_place: "ğŸ¥ˆ",
    third_place: "ğŸ¥‰",
    info: "â„¹ï¸",
    flag: "ğŸš©",
    chart2: "ğŸ“‰",
    up: "â¬†ï¸",
    down: "â¬‡ï¸",
    thermometer: "ğŸŒ¡ï¸",
    snowflake: "â„ï¸",
    puzzle: "ğŸ§©",
    link: "ğŸ”—",
    abacus: "ğŸ§®",
    ruler: "ğŸ“",
    balance: "âš–ï¸",
    target2: "ğŸ¯",
    brain2: "ğŸ§ ",
    math: "ğŸ§®",
    zone: "ğŸ—ºï¸",
    omission: "â³",
    association: "ğŸ”—",
    golden: "ğŸŒŸ",
    sum: "âˆ‘",
    span: "â†”ï¸",
    ac: "Î”",
    prime: "ğŸ”¢"
  },

  COMMAND_TYPES: {
    START: "start",
    COMMAND_TEMPLATE: "command_template",
    PREDICT: "prediction",
    HISTORY: "history",
    SYNC: "sync",
    PUSH: "push",
    DELETE: "delete",
    DELETE_CONFIRM: "delete_confirm",
    DELETE_RESULT: "delete_result"
  },

  ALGORITHM_NAMES: {
    traditional: "ä¼ ç»Ÿç®—æ³•",
    stats: "ç»Ÿè®¡ç®—æ³•",
    advanced: "å¢å¼ºç®—æ³•",
    omission: "é—æ¼å›è¡¥ä¸“å®¶",
    association: "å…³è”è§„åˆ™ä¸“å®¶",
    math: "é»„é‡‘åˆ†å‰²ä¸“å®¶",
    zone: "åŒºé—´å¹³è¡¡ä¸“å®¶"
  }
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•°ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class Logger {
  static info(context, message, extra = {}) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const extraStr = Object.keys(extra).length > 0 ? ` | ${JSON.stringify(extra)}` : '';
      console.log(`[${timestamp}] [INFO] [${context}] ${message}${extraStr}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.info] ${context} - ${message}:`, error);
    }
  }

  static error(context, message, error = null) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      const errorStr = error ? ` | ${error.message || String(error)}` : '';
      console.error(`[${timestamp}] [ERROR] [${context}] ${message}${errorStr}`);
    } catch (logError) {
      console.error(`[CRITICAL] Logger.error failed: ${context} - ${message}`, logError);
    }
  }

  static warn(context, message) {
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
      console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
    } catch (error) {
      console.error(`[ERROR] [Logger.warn] ${context} - ${message}:`, error);
    }
  }
}

class Formatter {
  static getAttributes(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
      }
      
      let zodiac = "æœªçŸ¥";
      for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          zodiac = zodiacName;
          break;
        }
      }
      
      let color = "æœªçŸ¥";
      for (const [colorName, numbers] of Object.entries(CONFIG.COLORS)) {
        if (Array.isArray(numbers) && numbers.includes(num)) {
          color = colorName;
          break;
        }
      }
      
      return { zodiac, color };
    } catch (error) {
      return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    }
  }

  static formatOpenCode(codeString) {
    try {
      if (!codeString || typeof codeString !== 'string') return "";
      return codeString.replace(/,/g, "-");
    } catch (error) {
      return "";
    }
  }

  static safeInt(value, defaultValue = 0) {
    try {
      if (value === null || value === undefined || value === '') return defaultValue;
      const num = parseInt(value);
      return isNaN(num) ? defaultValue : num;
    } catch (error) {
      return defaultValue;
    }
  }

  static safeString(value, defaultValue = "") {
    try {
      if (value === null || value === undefined) return defaultValue;
      return String(value);
    } catch (error) {
      return defaultValue;
    }
  }

  static parseExpectRange(rangeStr) {
    try {
      if (!rangeStr || typeof rangeStr !== 'string') return null;
      
      const trimmed = rangeStr.trim();
      
      if (/^\d+$/.test(trimmed)) {
        const num = parseInt(trimmed);
        return isNaN(num) ? null : { start: num, end: num, isSingle: true };
      }
      
      const rangeMatch = trimmed.match(/^(\d+)\s*-\s*(\d+)$/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          return { start, end, isSingle: false };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }

  static formatDateTime(date = new Date()) {
    try {
      const pad = n => n.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    } catch (error) {
      return "æœªçŸ¥æ—¶é—´";
    }
  }

  static shuffleArray(array) {
    try {
      if (!array || !Array.isArray(array)) return array;
      
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    } catch (error) {
      return array;
    }
  }

  static formatDuration(ms) {
    try {
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms/1000).toFixed(2)}ç§’`;
      if (ms < 3600000) return `${Math.floor(ms/60000)}åˆ†${Math.floor((ms%60000)/1000)}ç§’`;
      return `${Math.floor(ms/3600000)}å°æ—¶${Math.floor((ms%3600000)/60000)}åˆ†`;
    } catch (error) {
      return `${ms}ms`;
    }
  }

  static isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    
    for (let i = 5; i * i <= num; i += 6) {
      if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
  }

  static calculateNumberPattern(num) {
    try {
      const patterns = [];
      
      if (this.isPrime(num)) {
        patterns.push("è´¨æ•°");
      } else {
        patterns.push("åˆæ•°");
      }
      
      if (num % 7 === 0) {
        patterns.push("7å€æ•°");
      }
      
      if (num % 8 === 0) {
        patterns.push("8å€æ•°");
      }
      
      return patterns;
    } catch (error) {
      return [];
    }
  }

  static calculateHotColdStatus(numbers, history) {
    try {
      if (!Array.isArray(numbers) || !Array.isArray(history) || history.length < 10) {
        return {};
      }
      
      const frequency = {};
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }
      
      const recentHistory = history.slice(0, Math.min(100, history.length));
      for (const record of recentHistory) {
        if (record && record.open_code) {
          const nums = record.open_code.split(",").map(n => this.safeInt(n, 0));
          for (const num of nums) {
            if (num >= 1 && num <= 49) {
              frequency[num]++;
            }
          }
        }
      }
      
      const status = {};
      const maxFrequency = Math.max(...Object.values(frequency));
      const avgFrequency = Object.values(frequency).reduce((a, b) => a + b, 0) / 49;
      
      for (const num of numbers) {
        if (num >= 1 && num <= 49) {
          const freq = frequency[num] || 0;
          if (freq >= maxFrequency * 0.8) {
            status[num] = "ğŸ”¥ çƒ­é—¨";
          } else if (freq <= avgFrequency * 0.5) {
            status[num] = "â„ï¸ å†·é—¨";
          } else if (freq <= avgFrequency * 0.8) {
            status[num] = "ğŸŒ¡ï¸ æ¸©ç ";
          } else {
            status[num] = "âš¡ æ´»è·ƒ";
          }
        }
      }
      
      return status;
    } catch (error) {
      return {};
    }
  }

  static calculateFeatures(number) {
    try {
      const num = parseInt(number);
      if (isNaN(num) || num < 1 || num > 49) {
        return null;
      }
      
      const attr = this.getAttributes(num);
      
      return {
        number: num,
        zodiac: attr.zodiac,
        color: attr.color,
        tail: num % 10,
        head: Math.floor(num / 10),
        isBig: num >= 25,
        isOdd: num % 2 !== 0,
        isPrime: this.isPrime(num)
      };
    } catch (error) {
      return null;
    }
  }

  static isAlgorithmSupported(algorithm, historyLength) {
    try {
      const minHistory = CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS[algorithm] || 2;
      return historyLength >= minHistory;
    } catch (error) {
      return historyLength >= 2;
    }
  }

  static getAlgorithmTimeout(algorithm) {
    try {
      return CONFIG.SYSTEM.ALGORITHM_TIMEOUTS[algorithm] || CONFIG.SYSTEM.PREDICTION_TIMEOUT;
    } catch (error) {
      return CONFIG.SYSTEM.PREDICTION_TIMEOUT;
    }
  }
  
  static getZoneForNumber(number, zoneType = "zone7") {
    try {
      const zones = CONFIG.SYSTEM.ZONE_CONFIG[zoneType];
      if (!zones) return null;
      
      for (let i = 0; i < zones.length; i++) {
        if (zones[i].includes(number)) {
          return { zoneIndex: i, zoneType, zoneNumbers: zones[i] };
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  
  static normalizeScores(scores, algorithmName) {
    try {
      const scoreMap = new Map(scores);
      if (scoreMap.size === 0) return scoreMap;
      
      let maxScore = -Infinity;
      let minScore = Infinity;
      
      for (const score of scoreMap.values()) {
        if (score > maxScore) maxScore = score;
        if (score < minScore) minScore = score;
      }
      
      const range = maxScore - minScore;
      
      if (range === 0) {
        for (const [key, _] of scoreMap) {
          scoreMap.set(key, 50);
        }
      } else {
        for (const [key, value] of scoreMap) {
          const normalized = ((value - minScore) / range) * 100;
          scoreMap.set(key, normalized);
        }
      }
      
      return scoreMap;
    } catch (error) {
      Logger.error("Formatter", `å½’ä¸€åŒ–åˆ†æ•°å¤±è´¥ (${algorithmName})`, error);
      return new Map();
    }
  }

  static calculateACValue(numbers) {
    try {
      if (!Array.isArray(numbers) || numbers.length < 6) return 0;
      
      const sorted = [...numbers].sort((a, b) => a - b);
      const differences = new Set();
      
      for (let i = 0; i < sorted.length - 1; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          differences.add(Math.abs(sorted[j] - sorted[i]));
        }
      }
      
      return differences.size - (6 - 1);
    } catch (error) {
      return 0;
    }
  }

  static calculateSum(numbers) {
    try {
      if (!Array.isArray(numbers)) return 0;
      return numbers.reduce((sum, num) => sum + num, 0);
    } catch (error) {
      return 0;
    }
  }

  static calculateSpan(numbers) {
    try {
      if (!Array.isArray(numbers) || numbers.length < 2) return 0;
      const sorted = [...numbers].sort((a, b) => a - b);
      return sorted[sorted.length - 1] - sorted[0];
    } catch (error) {
      return 0;
    }
  }
}

// ==============================================================================
// 3. æ¶ˆæ¯ç®¡ç†å™¨ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class MessageManager {
  static userMessages = new Map();
  static lastCleanupTime = Date.now();
  
  static initUser(chatId) {
    if (!this.userMessages.has(chatId)) {
      this.userMessages.set(chatId, new Map());
    }
  }
  
  static getUserMessage(chatId, messageType) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    return userMap.get(messageType) || null;
  }
  
  static setUserMessage(chatId, messageType, messageId) {
    this.initUser(chatId);
    const userMap = this.userMessages.get(chatId);
    
    const oldMessageId = userMap.get(messageType);
    userMap.set(messageType, messageId);
    
    return oldMessageId;
  }
  
  static clearUserMessages(chatId) {
    return this.userMessages.delete(chatId);
  }
  
  static autoCleanup() {
    try {
      const now = Date.now();
      if (now - this.lastCleanupTime < CONFIG.SYSTEM.AUTO_CLEANUP_INTERVAL) {
        return;
      }
      
      Logger.info("MessageManager", "å¼€å§‹è‡ªåŠ¨æ¸…ç†ç”¨æˆ·æ¶ˆæ¯ç¼“å­˜");
      
      let totalCleaned = 0;
      
      for (const [chatId, userMap] of this.userMessages.entries()) {
        if (userMap.size > CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_MESSAGES_PER_USER) {
          const entries = Array.from(userMap.entries());
          const toRemove = entries.slice(0, entries.length - 10);
          
          for (const [key, _] of toRemove) {
            if (userMap.delete(key)) {
              totalCleaned++;
            }
          }
        }
      }
      
      this.lastCleanupTime = now;
      
      if (this.userMessages.size > CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_USERS) {
        const keysToDelete = Array.from(this.userMessages.keys())
          .slice(0, this.userMessages.size - CONFIG.SYSTEM.MESSAGE_MANAGER_MAX_USERS);
        
        keysToDelete.forEach(key => this.userMessages.delete(key));
        Logger.info("MessageManager", `æ¸…ç†äº† ${keysToDelete.length} ä¸ªä¸æ´»è·ƒç”¨æˆ·`);
      }
      
    } catch (error) {
      Logger.error("MessageManager", "è‡ªåŠ¨æ¸…ç†å¤±è´¥", error);
    }
  }
}

// ==============================================================================
// 4. ç¼“å­˜ç®¡ç†å™¨ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class CacheManager {
  static cache = new Map();
  
  static set(key, value, ttl = CONFIG.SYSTEM.CACHE_TTL) {
    try {
      const expireAt = Date.now() + ttl;
      this.cache.set(key, { value, expireAt });
      
      if (this.cache.size > 100) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    } catch (error) {
      Logger.error("CacheManager", "è®¾ç½®ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static get(key) {
    try {
      const item = this.cache.get(key);
      if (!item) return null;
      
      if (Date.now() > item.expireAt) {
        this.cache.delete(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      return null;
    }
  }
  
  static delete(key) {
    try {
      return this.cache.delete(key);
    } catch (error) {
      return false;
    }
  }
  
  static clear() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 5. æ•°æ®åº“æ“ä½œå±‚ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

const DB = {
  init: async function(env) {
    try {
      Logger.info("DB", "å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“");
      
      if (!env || !env.DB) {
        throw new Error("Database binding 'DB' not found");
      }
      
      const statements = [
        `CREATE TABLE IF NOT EXISTS lottery_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT, 
          expect TEXT UNIQUE, 
          open_code TEXT, 
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
        `CREATE TABLE IF NOT EXISTS lottery_settings (
          setting_key TEXT PRIMARY KEY, 
          value TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        `CREATE TABLE IF NOT EXISTS deletion_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          admin_id TEXT,
          expect_range TEXT,
          deleted_count INTEGER,
          reason TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      ];
      
      const batch = statements.map(sql => env.DB.prepare(sql));
      await env.DB.batch(batch);
      
      await this.initDefaultSettings(env);
      
      Logger.info("DB", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
      return true;
      
    } catch (e) {
      Logger.error("DB", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", e);
      return false;
    }
  },

  getHistory: async function(env, limit = null, offset = 0) {
    try {
      const cacheKey = `history_${limit}_${offset}`;
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      
      CacheManager.set(cacheKey, results || []);
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  getAllHistory: async function(env) {
    return await this.getHistory(env, CONFIG.SYSTEM.HISTORY_LIMIT, 0);
  },

  getHistoryCount: async function(env) {
    try {
      const cacheKey = "history_count";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      const count = result ? result.count : 0;
      CacheManager.set(cacheKey, count, 30000);
      return count;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  getLatestExpect: async function(env) {
    try {
      const cacheKey = "latest_expect";
      const cached = CacheManager.get(cacheKey);
      if (cached !== null) {
        return cached;
      }
      
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      
      const latestExpect = result ? result.expect : null;
      CacheManager.set(cacheKey, latestExpect, 10000);
      return latestExpect;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  getLatestHistory: async function(env, limit = 10) {
    return await this.getHistory(env, limit, 0);
  },

  batchAddHistory: async function(env, records) {
    try {
      if (!records || !Array.isArray(records) || records.length === 0) {
        return { success: true, added: 0, skipped: 0 };
      }
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const validChunk = chunk.filter(record => 
          record && 
          record.expect && 
          record.open_code
        );
        
        if (validChunk.length === 0) {
          totalSkipped += chunk.length;
          continue;
        }
        
        const batch = env.DB.batch(
          validChunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(
              Formatter.safeString(record.expect), 
              Formatter.safeString(record.open_code)
            )
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + (result.changes || 0), 0);
          totalAdded += chunkAdded;
          totalSkipped += (validChunk.length - chunkAdded);
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡æ’å…¥å¤±è´¥`, chunkError);
          
          for (const record of validChunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(
                Formatter.safeString(record.expect), 
                Formatter.safeString(record.open_code)
              ).run();
              
              totalAdded += (result.changes || 0);
              totalSkipped += (1 - (result.changes || 0));
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  getSetting: async function(env, key, def = "") {
    try {
      const cacheKey = `setting_${key}`;
      const cached = CacheManager.get(cacheKey);
      if (cached !== undefined) {
        return cached;
      }
      
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      
      const value = r ? r.value : def;
      CacheManager.set(cacheKey, value, 60000);
      return value;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  saveSetting: async function(env, key, val) {
    try {
      const result = await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, Formatter.safeString(val)).run();
      
      CacheManager.set(`setting_${key}`, val, 60000);
      return result;
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  getWeights: async function(env) {
    try {
      const cacheKey = "weights";
      const cached = CacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      const w = await this.getSetting(env, "ALGO_WEIGHTS", null);
      let weights;
      
      if (w) {
        try {
          const parsed = JSON.parse(w);
          const defaultWeights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
          
          weights = { ...defaultWeights, ...parsed };
          weights._version = weights._version || "15.1";
        } catch (parseError) {
          Logger.error("DB", "è§£ææƒé‡è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤", parseError);
          weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
        }
      } else {
        weights = { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
      }
      
      CacheManager.set(cacheKey, weights, 30000);
      return weights;
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  initDefaultSettings: async function(env) {
    try {
      const defaultSettings = {
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_DELETIONS": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  },

  deleteHistoryByRange: async function(env, startExpect, endExpect, adminId, reason = "æ‰‹åŠ¨åˆ é™¤") {
    try {
      Logger.info("DB", `å¼€å§‹åˆ é™¤è®°å½•: ${startExpect}-${endExpect}`);
      
      const checkResult = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).first();
      
      const recordCount = checkResult ? checkResult.count : 0;
      
      if (recordCount === 0) {
        return { 
          success: true, 
          deleted: 0, 
          total: 0,
          message: "æŒ‡å®šèŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°è®°å½•"
        };
      }
      
      const deleteResult = await env.DB.prepare(
        "DELETE FROM lottery_history WHERE expect >= ? AND expect <= ?"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).run();
      
      const deletedCount = deleteResult ? deleteResult.changes : 0;
      
      CacheManager.delete("history_count");
      CacheManager.delete("latest_expect");
      CacheManager.clear();
      
      if (deletedCount > 0) {
        await env.DB.prepare(
          "INSERT INTO deletion_log (admin_id, expect_range, deleted_count, reason) VALUES (?, ?, ?, ?)"
        ).bind(
          Formatter.safeString(adminId), 
          `${Formatter.safeString(startExpect)}-${Formatter.safeString(endExpect)}`, 
          deletedCount, 
          Formatter.safeString(reason)
        ).run();
        
        const totalDeletions = Formatter.safeInt(await this.getSetting(env, "TOTAL_DELETIONS", "0"), 0) + 1;
        await this.saveSetting(env, "TOTAL_DELETIONS", totalDeletions.toString());
        
        Logger.info("DB", `åˆ é™¤å®Œæˆ: åˆ é™¤äº† ${deletedCount} æ¡è®°å½•`);
      }
      
      return { 
        success: true, 
        deleted: deletedCount, 
        total: recordCount,
        message: `æˆåŠŸåˆ é™¤ ${deletedCount} æ¡è®°å½• (${startExpect}-${endExpect})`
      };
      
    } catch (e) {
      Logger.error("DB", "deleteHistoryByRange failed", e);
      return { 
        success: false, 
        deleted: 0,
        error: e.message || "åˆ é™¤æ“ä½œå¤±è´¥"
      };
    }
  },

  getDeletionImpact: async function(env, startExpect, endExpect) {
    try {
      const { results: toDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect >= ? AND expect <= ? ORDER BY expect DESC LIMIT 10"
      ).bind(
        Formatter.safeString(startExpect), 
        Formatter.safeString(endExpect)
      ).all();
      
      const { results: afterDelete } = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect < ? ORDER BY expect DESC LIMIT 5"
      ).bind(Formatter.safeString(startExpect)).all();
      
      return {
        toDelete: toDelete || [],
        afterDelete: afterDelete || [],
        toDeleteCount: toDelete ? toDelete.length : 0,
        latestAfterDelete: afterDelete && afterDelete.length > 0 ? afterDelete[0] : null
      };
    } catch (e) {
      Logger.error("DB", "getDeletionImpact failed", e);
      return { toDelete: [], afterDelete: [], toDeleteCount: 0, latestAfterDelete: null };
    }
  }
};

// ==============================================================================
// 6. å¢å¼ºçš„ç»Ÿè®¡ç®—æ³•ï¼ˆåŠ å¼ºç‰ˆï¼‰
// ==============================================================================

class EnhancedStatistics {
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        return this.createEmptyStats();
      }

      const stats = this.createEmptyStats();
      const maxRecords = Math.min(history.length, CONFIG.SYSTEM.STATS_WINDOW_SIZE);
      const historySlice = history.slice(0, maxRecords);
      
      const processedHistory = this.processHistoryData(historySlice);
      
      if (processedHistory.length < 5) {
        return this.createEmptyStats();
      }
      
      this.analyzeZodiacPatterns(stats, processedHistory);
      this.analyzeColorPatterns(stats, processedHistory);
      this.analyzeTailPatterns(stats, processedHistory);
      this.analyzeHeadPatterns(stats, processedHistory);
      this.analyzeSizePatterns(stats, processedHistory);
      this.analyzeOddEvenPatterns(stats, processedHistory);
      this.analyzeSumPatterns(stats, processedHistory);
      this.analyzeSpanPatterns(stats, processedHistory);
      this.analyzeACValuePatterns(stats, processedHistory);
      this.analyzePrimeCompositePatterns(stats, processedHistory);
      this.analyzeNormalToSpecialPatterns(stats, processedHistory);
      
      this.calculateFrequencies(stats, processedHistory);
      
      stats.totalRecords = processedHistory.length;
      stats.summary = this.generateSummary(stats);
      
      return stats;
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå†å²æ•°æ®æ—¶å‡ºé”™", error);
      return this.createEmptyStats();
    }
  }

  static processHistoryData(history) {
    const processed = [];
    
    for (const record of history) {
      if (record && record.open_code) {
        const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (nums.length >= 7) {
          const special = nums[6] || 1;
          const normals = nums.slice(0, 6);
          const attr = Formatter.getAttributes(special);
          const features = Formatter.calculateFeatures(special);
          
          const sum = Formatter.calculateSum(nums);
          const span = Formatter.calculateSpan(nums);
          const acValue = Formatter.calculateACValue(normals);
          const primeCount = normals.filter(n => Formatter.isPrime(n)).length;
          
          const normalFeatures = {
            zodiacs: normals.map(n => Formatter.getAttributes(n).zodiac),
            colors: normals.map(n => Formatter.getAttributes(n).color),
            tails: normals.map(n => n % 10),
            heads: normals.map(n => Math.floor(n / 10)),
            sizes: normals.map(n => n >= 25 ? "å¤§" : "å°"),
            oddEven: normals.map(n => n % 2 !== 0 ? "å•" : "åŒ"),
            primes: normals.map(n => Formatter.isPrime(n))
          };
          
          processed.push({
            numbers: nums,
            special: special,
            normals: normals,
            zodiac: attr.zodiac,
            color: attr.color,
            tail: special % 10,
            head: Math.floor(special / 10),
            size: special >= 25 ? "å¤§" : "å°",
            oddEven: special % 2 !== 0 ? "å•" : "åŒ",
            sum: sum,
            span: span,
            acValue: acValue,
            primeCount: primeCount,
            features: features,
            normalFeatures: normalFeatures,
            expect: record.expect
          });
        }
      }
    }
    
    return processed;
  }

  static createEmptyStats() {
    return {
      totalRecords: 0,
      zodiacPatterns: {
        sameZodiac: {},
        zodiacGap: {},
        consecutiveZodiac: {},
        zodiacCombinations: {}
      },
      colorPatterns: {
        sameColor: {},
        colorGap: {},
        consecutiveColor: {}
      },
      tailPatterns: {
        tailTransfer: {},
        tailFromNormal: {},
        tailGap: {},
        consecutiveTail: {}
      },
      headPatterns: {
        headTransfer: {},
        headGap: {},
        consecutiveHead: {}
      },
      sizePatterns: {
        sizeTransfer: {},
        sizeGap: {},
        consecutiveSize: {},
        sizeRatio: { big: 0, small: 0 }
      },
      oddEvenPatterns: {
        oddEvenTransfer: {},
        oddEvenGap: {},
        consecutiveOddEven: {},
        oddEvenRatio: { odd: 0, even: 0 }
      },
      sumPatterns: {
        sumRanges: {},
        sumTransfer: {},
        consecutiveSumRange: {}
      },
      spanPatterns: {
        spanRanges: {},
        spanTransfer: {},
        consecutiveSpanRange: {}
      },
      acValuePatterns: {
        acValueRanges: {},
        acValueTransfer: {},
        consecutiveAcValueRange: {}
      },
      primeCompositePatterns: {
        primeCountRanges: {},
        primeCountTransfer: {},
        consecutivePrimeCount: {}
      },
      normalToSpecial: {
        tailInNormals: {},
        zodiacInNormals: {},
        colorInNormals: {},
        numberInNormals: {}
      },
      frequencies: {
        specialFrequency: {},
        normalFrequency: {},
        zodiacFrequency: {},
        colorFrequency: {},
        tailFrequency: {},
        headFrequency: {},
        sizeFrequency: {},
        oddEvenFrequency: {},
        sumFrequency: {},
        spanFrequency: {},
        acValueFrequency: {},
        primeCountFrequency: {}
      },
      summary: {}
    };
  }

  static analyzeZodiacPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const key = `${current.zodiac}->${next.zodiac}`;
        stats.zodiacPatterns.sameZodiac[key] = (stats.zodiacPatterns.sameZodiac[key] || 0) + 1;
        
        if (current.zodiac === next.zodiac) {
          stats.zodiacPatterns.consecutiveZodiac[current.zodiac] = (stats.zodiacPatterns.consecutiveZodiac[current.zodiac] || 0) + 1;
        }
        
        for (const normalZodiac of current.normalFeatures.zodiacs) {
          const comboKey = `${normalZodiac}->${next.zodiac}`;
          stats.zodiacPatterns.zodiacCombinations[comboKey] = (stats.zodiacPatterns.zodiacCombinations[comboKey] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.zodiacPatterns.sameZodiac);
      this.calculateProbabilities(stats.zodiacPatterns.zodiacCombinations);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æç”Ÿè‚–æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeColorPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const key = `${current.color}->${next.color}`;
        stats.colorPatterns.sameColor[key] = (stats.colorPatterns.sameColor[key] || 0) + 1;
        
        if (current.color === next.color) {
          stats.colorPatterns.consecutiveColor[current.color] = (stats.colorPatterns.consecutiveColor[current.color] || 0) + 1;
        }
        
        for (const normalColor of current.normalFeatures.colors) {
          const comboKey = `${normalColor}->${next.color}`;
          stats.normalToSpecial.colorInNormals[comboKey] = (stats.normalToSpecial.colorInNormals[comboKey] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.colorPatterns.sameColor);
      this.calculateProbabilities(stats.normalToSpecial.colorInNormals);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æé¢œè‰²æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeTailPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const tailKey = `${current.tail}->${next.tail}`;
        stats.tailPatterns.tailTransfer[tailKey] = (stats.tailPatterns.tailTransfer[tailKey] || 0) + 1;
        
        for (const normalTail of current.normalFeatures.tails) {
          const tailFromNormalKey = `${normalTail}->${next.tail}`;
          stats.tailPatterns.tailFromNormal[tailFromNormalKey] = (stats.tailPatterns.tailFromNormal[tailFromNormalKey] || 0) + 1;
          
          stats.normalToSpecial.tailInNormals[normalTail] = (stats.normalToSpecial.tailInNormals[normalTail] || 0) + 1;
        }
        
        if (current.tail === next.tail) {
          stats.tailPatterns.consecutiveTail[current.tail] = (stats.tailPatterns.consecutiveTail[current.tail] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.tailPatterns.tailTransfer);
      this.calculateProbabilities(stats.tailPatterns.tailFromNormal);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå°¾æ•°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeHeadPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        const headKey = `${current.head}->${next.head}`;
        stats.headPatterns.headTransfer[headKey] = (stats.headPatterns.headTransfer[headKey] || 0) + 1;
        
        if (current.head === next.head) {
          stats.headPatterns.consecutiveHead[current.head] = (stats.headPatterns.consecutiveHead[current.head] || 0) + 1;
        }
      }
      
      this.calculateProbabilities(stats.headPatterns.headTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå¤´æ•°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeSizePatterns(stats, processedHistory) {
    try {
      let bigCount = 0;
      let smallCount = 0;
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        if (current.size === "å¤§") bigCount++;
        else smallCount++;
        
        const sizeKey = `${current.size}->${next.size}`;
        stats.sizePatterns.sizeTransfer[sizeKey] = (stats.sizePatterns.sizeTransfer[sizeKey] || 0) + 1;
        
        if (current.size === next.size) {
          stats.sizePatterns.consecutiveSize[current.size] = (stats.sizePatterns.consecutiveSize[current.size] || 0) + 1;
        }
      }
      
      stats.sizePatterns.sizeRatio = {
        big: bigCount / processedHistory.length,
        small: smallCount / processedHistory.length
      };
      
      this.calculateProbabilities(stats.sizePatterns.sizeTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå¤§å°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeOddEvenPatterns(stats, processedHistory) {
    try {
      let oddCount = 0;
      let evenCount = 0;
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        if (current.oddEven === "å•") oddCount++;
        else evenCount++;
        
        const oddEvenKey = `${current.oddEven}->${next.oddEven}`;
        stats.oddEvenPatterns.oddEvenTransfer[oddEvenKey] = (stats.oddEvenPatterns.oddEvenTransfer[oddEvenKey] || 0) + 1;
        
        if (current.oddEven === next.oddEven) {
          stats.oddEvenPatterns.consecutiveOddEven[current.oddEven] = (stats.oddEvenPatterns.consecutiveOddEven[current.oddEven] || 0) + 1;
        }
      }
      
      stats.oddEvenPatterns.oddEvenRatio = {
        odd: oddCount / processedHistory.length,
        even: evenCount / processedHistory.length
      };
      
      this.calculateProbabilities(stats.oddEvenPatterns.oddEvenTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå•åŒæ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeSumPatterns(stats, processedHistory) {
    try {
      // å’Œå€¼èŒƒå›´åˆ’åˆ†
      const sumRanges = [
        { min: 0, max: 100, label: "ä½å’Œ" },
        { min: 101, max: 150, label: "ä¸­å’Œ" },
        { min: 151, max: 300, label: "é«˜å’Œ" }
      ];
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        // ç¡®å®šå½“å‰å’Œå€¼å’Œå€¼èŒƒå›´
        let currentSumRange = "ä¸­å’Œ";
        let nextSumRange = "ä¸­å’Œ";
        
        for (const range of sumRanges) {
          if (current.sum >= range.min && current.sum <= range.max) {
            currentSumRange = range.label;
          }
          if (next.sum >= range.min && next.sum <= range.max) {
            nextSumRange = range.label;
          }
        }
        
        const sumRangeKey = `${currentSumRange}->${nextSumRange}`;
        stats.sumPatterns.sumTransfer[sumRangeKey] = (stats.sumPatterns.sumTransfer[sumRangeKey] || 0) + 1;
        
        if (currentSumRange === nextSumRange) {
          stats.sumPatterns.consecutiveSumRange[currentSumRange] = (stats.sumPatterns.consecutiveSumRange[currentSumRange] || 0) + 1;
        }
        
        // å’Œå€¼é¢‘ç‡ç»Ÿè®¡
        const sumBucket = Math.floor(current.sum / 20) * 20; // æ¯20åˆ†ä¸ºä¸€ä¸ªåŒºé—´
        stats.sumPatterns.sumRanges[sumBucket] = (stats.sumPatterns.sumRanges[sumBucket] || 0) + 1;
      }
      
      this.calculateProbabilities(stats.sumPatterns.sumTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå’Œå€¼æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeSpanPatterns(stats, processedHistory) {
    try {
      // è·¨åº¦èŒƒå›´åˆ’åˆ†
      const spanRanges = [
        { min: 0, max: 20, label: "å°è·¨" },
        { min: 21, max: 35, label: "ä¸­è·¨" },
        { min: 36, max: 48, label: "å¤§è·¨" }
      ];
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        let currentSpanRange = "ä¸­è·¨";
        let nextSpanRange = "ä¸­è·¨";
        
        for (const range of spanRanges) {
          if (current.span >= range.min && current.span <= range.max) {
            currentSpanRange = range.label;
          }
          if (next.span >= range.min && next.span <= range.max) {
            nextSpanRange = range.label;
          }
        }
        
        const spanRangeKey = `${currentSpanRange}->${nextSpanRange}`;
        stats.spanPatterns.spanTransfer[spanRangeKey] = (stats.spanPatterns.spanTransfer[spanRangeKey] || 0) + 1;
        
        if (currentSpanRange === nextSpanRange) {
          stats.spanPatterns.consecutiveSpanRange[currentSpanRange] = (stats.spanPatterns.consecutiveSpanRange[currentSpanRange] || 0) + 1;
        }
        
        // è·¨åº¦é¢‘ç‡ç»Ÿè®¡
        const spanBucket = Math.floor(current.span / 5) * 5; // æ¯5åˆ†ä¸ºä¸€ä¸ªåŒºé—´
        stats.spanPatterns.spanRanges[spanBucket] = (stats.spanPatterns.spanRanges[spanBucket] || 0) + 1;
      }
      
      this.calculateProbabilities(stats.spanPatterns.spanTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æè·¨åº¦æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeACValuePatterns(stats, processedHistory) {
    try {
      // ACå€¼èŒƒå›´åˆ’åˆ†
      const acValueRanges = [
        { min: 0, max: 4, label: "ä½AC" },
        { min: 5, max: 8, label: "ä¸­AC" },
        { min: 9, max: 15, label: "é«˜AC" }
      ];
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        let currentAcRange = "ä¸­AC";
        let nextAcRange = "ä¸­AC";
        
        for (const range of acValueRanges) {
          if (current.acValue >= range.min && current.acValue <= range.max) {
            currentAcRange = range.label;
          }
          if (next.acValue >= range.min && next.acValue <= range.max) {
            nextAcRange = range.label;
          }
        }
        
        const acRangeKey = `${currentAcRange}->${nextAcRange}`;
        stats.acValuePatterns.acValueTransfer[acRangeKey] = (stats.acValuePatterns.acValueTransfer[acRangeKey] || 0) + 1;
        
        if (currentAcRange === nextAcRange) {
          stats.acValuePatterns.consecutiveAcValueRange[currentAcRange] = (stats.acValuePatterns.consecutiveAcValueRange[currentAcRange] || 0) + 1;
        }
        
        // ACå€¼é¢‘ç‡ç»Ÿè®¡
        stats.acValuePatterns.acValueRanges[current.acValue] = (stats.acValuePatterns.acValueRanges[current.acValue] || 0) + 1;
      }
      
      this.calculateProbabilities(stats.acValuePatterns.acValueTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æACå€¼æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzePrimeCompositePatterns(stats, processedHistory) {
    try {
      // è´¨æ•°æ•°é‡èŒƒå›´åˆ’åˆ†
      const primeCountRanges = [
        { min: 0, max: 1, label: "å°‘è´¨æ•°" },
        { min: 2, max: 3, label: "ä¸­è´¨æ•°" },
        { min: 4, max: 6, label: "å¤šè´¨æ•°" }
      ];
      
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        let currentPrimeRange = "ä¸­è´¨æ•°";
        let nextPrimeRange = "ä¸­è´¨æ•°";
        
        for (const range of primeCountRanges) {
          if (current.primeCount >= range.min && current.primeCount <= range.max) {
            currentPrimeRange = range.label;
          }
          if (next.primeCount >= range.min && next.primeCount <= range.max) {
            nextPrimeRange = range.label;
          }
        }
        
        const primeRangeKey = `${currentPrimeRange}->${nextPrimeRange}`;
        stats.primeCompositePatterns.primeCountTransfer[primeRangeKey] = (stats.primeCompositePatterns.primeCountTransfer[primeRangeKey] || 0) + 1;
        
        if (currentPrimeRange === nextPrimeRange) {
          stats.primeCompositePatterns.consecutivePrimeCount[currentPrimeRange] = (stats.primeCompositePatterns.consecutivePrimeCount[currentPrimeRange] || 0) + 1;
        }
        
        // è´¨æ•°æ•°é‡é¢‘ç‡ç»Ÿè®¡
        stats.primeCompositePatterns.primeCountRanges[current.primeCount] = (stats.primeCompositePatterns.primeCountRanges[current.primeCount] || 0) + 1;
      }
      
      this.calculateProbabilities(stats.primeCompositePatterns.primeCountTransfer);
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æè´¨æ•°æ¨¡å¼å¤±è´¥", error);
    }
  }

  static analyzeNormalToSpecialPatterns(stats, processedHistory) {
    try {
      for (let i = 0; i < processedHistory.length - 1; i++) {
        const current = processedHistory[i];
        const next = processedHistory[i + 1];
        
        if (!current || !next) continue;
        
        for (const normalNum of current.normals) {
          if (normalNum === next.special) {
            stats.normalToSpecial.numberInNormals[normalNum] = (stats.normalToSpecial.numberInNormals[normalNum] || 0) + 1;
          }
        }
        
        for (const normalZodiac of current.normalFeatures.zodiacs) {
          if (normalZodiac === next.zodiac) {
            stats.normalToSpecial.zodiacInNormals[normalZodiac] = (stats.normalToSpecial.zodiacInNormals[normalZodiac] || 0) + 1;
          }
        }
      }
    } catch (error) {
      Logger.error("EnhancedStatistics", "åˆ†æå¹³ç åˆ°ç‰¹ç æ¨¡å¼å¤±è´¥", error);
    }
  }

  static calculateFrequencies(stats, processedHistory) {
    try {
      // åˆå§‹åŒ–é¢‘ç‡ç»Ÿè®¡
      for (let i = 1; i <= 49; i++) {
        stats.frequencies.specialFrequency[i] = 0;
        stats.frequencies.normalFrequency[i] = 0;
      }
      
      // åˆå§‹åŒ–å…¶ä»–é¢‘ç‡
      Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
        stats.frequencies.zodiacFrequency[zodiac] = 0;
      });
      
      ['red', 'blue', 'green'].forEach(color => {
        stats.frequencies.colorFrequency[color] = 0;
      });
      
      for (let i = 0; i <= 9; i++) {
        stats.frequencies.tailFrequency[i] = 0;
      }
      
      for (let i = 0; i <= 4; i++) {
        stats.frequencies.headFrequency[i] = 0;
      }
      
      stats.frequencies.sizeFrequency = { å¤§: 0, å°: 0 };
      stats.frequencies.oddEvenFrequency = { å•: 0, åŒ: 0 };
      stats.frequencies.sumFrequency = {};
      stats.frequencies.spanFrequency = {};
      stats.frequencies.acValueFrequency = {};
      stats.frequencies.primeCountFrequency = {};
      
      // ç»Ÿè®¡é¢‘ç‡
      for (const record of processedHistory) {
        stats.frequencies.specialFrequency[record.special]++;
        
        for (const num of record.normals) {
          stats.frequencies.normalFrequency[num]++;
        }
        
        stats.frequencies.zodiacFrequency[record.zodiac]++;
        stats.frequencies.colorFrequency[record.color]++;
        stats.frequencies.tailFrequency[record.tail]++;
        stats.frequencies.headFrequency[record.head]++;
        stats.frequencies.sizeFrequency[record.size]++;
        stats.frequencies.oddEvenFrequency[record.oddEven]++;
        
        // å’Œå€¼é¢‘ç‡
        const sumBucket = Math.floor(record.sum / 20) * 20;
        stats.frequencies.sumFrequency[sumBucket] = (stats.frequencies.sumFrequency[sumBucket] || 0) + 1;
        
        // è·¨åº¦é¢‘ç‡
        const spanBucket = Math.floor(record.span / 5) * 5;
        stats.frequencies.spanFrequency[spanBucket] = (stats.frequencies.spanFrequency[spanBucket] || 0) + 1;
        
        // ACå€¼é¢‘ç‡
        stats.frequencies.acValueFrequency[record.acValue] = (stats.frequencies.acValueFrequency[record.acValue] || 0) + 1;
        
        // è´¨æ•°æ•°é‡é¢‘ç‡
        stats.frequencies.primeCountFrequency[record.primeCount] = (stats.frequencies.primeCountFrequency[record.primeCount] || 0) + 1;
      }
      
      // è®¡ç®—æ¦‚ç‡
      const total = processedHistory.length;
      
      for (let i = 1; i <= 49; i++) {
        stats.frequencies.specialFrequency[i] /= total;
        stats.frequencies.normalFrequency[i] /= (total * 6);
      }
      
      Object.keys(stats.frequencies.zodiacFrequency).forEach(zodiac => {
        stats.frequencies.zodiacFrequency[zodiac] /= total;
      });
      
      Object.keys(stats.frequencies.colorFrequency).forEach(color => {
        stats.frequencies.colorFrequency[color] /= total;
      });
      
      Object.keys(stats.frequencies.sizeFrequency).forEach(size => {
        stats.frequencies.sizeFrequency[size] /= total;
      });
      
      Object.keys(stats.frequencies.oddEvenFrequency).forEach(oe => {
        stats.frequencies.oddEvenFrequency[oe] /= total;
      });
      
    } catch (error) {
      Logger.error("EnhancedStatistics", "è®¡ç®—é¢‘ç‡å¤±è´¥", error);
    }
  }

  static calculateProbabilities(patternMap) {
    try {
      const totals = {};
      
      Object.keys(patternMap).forEach(key => {
        const [from] = key.split('->');
        totals[from] = (totals[from] || 0) + patternMap[key];
      });
      
      Object.keys(patternMap).forEach(key => {
        const [from] = key.split('->');
        if (totals[from] > 0) {
          patternMap[key] = patternMap[key] / totals[from];
        }
      });
    } catch (error) {
      Logger.error("EnhancedStatistics", "è®¡ç®—æ¦‚ç‡å¤±è´¥", error);
    }
  }

  static generateSummary(stats) {
    const summary = {
      strongPatterns: [],
      recommendations: [],
      statistics: {}
    };
    
    try {
      // ç”Ÿè‚–è½¬ç§»æ¨¡å¼
      const topZodiacTransfers = Object.entries(stats.zodiacPatterns.sameZodiac)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      topZodiacTransfers.forEach(([key, prob]) => {
        if (prob > 0.2) {
          const [from, to] = key.split('->');
          summary.strongPatterns.push(`ä¸ŠæœŸå¼€${from}ï¼Œä¸‹æœŸå¼€${to}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
          summary.recommendations.push(`ä¸ŠæœŸ${from}ï¼Œé‡ç‚¹å…³æ³¨${to}`);
        }
      });
      
      // é¢œè‰²è½¬ç§»æ¨¡å¼
      const topColorTransfers = Object.entries(stats.colorPatterns.sameColor)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2);
      
      topColorTransfers.forEach(([key, prob]) => {
        if (prob > 0.3) {
          const [from, to] = key.split('->');
          summary.strongPatterns.push(`${from}è‰²è½¬åˆ°${to}è‰²çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        }
      });
      
      // å°¾æ•°ä»å¹³ç è½¬ç§»æ¨¡å¼
      const topTailFromNormal = Object.entries(stats.tailPatterns.tailFromNormal)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      topTailFromNormal.forEach(([key, prob]) => {
        if (prob > 0.15) {
          const [normalTail, specialTail] = key.split('->');
          summary.strongPatterns.push(`å¹³ç å°¾${normalTail}æå¤§å¯èƒ½ä¸‹æœŸç‰¹ç å°¾${specialTail} (${(prob * 100).toFixed(1)}%)`);
          summary.recommendations.push(`å…³æ³¨å¹³ç å°¾æ•°${normalTail}å¯¹åº”çš„ç‰¹ç å°¾æ•°${specialTail}`);
        }
      });
      
      // å¤§å°æ¯”ä¾‹
      summary.statistics.sizeRatio = {
        big: (stats.sizePatterns.sizeRatio.big * 100).toFixed(1) + '%',
        small: (stats.sizePatterns.sizeRatio.small * 100).toFixed(1) + '%'
      };
      
      // å•åŒæ¯”ä¾‹
      summary.statistics.oddEvenRatio = {
        odd: (stats.oddEvenPatterns.oddEvenRatio.odd * 100).toFixed(1) + '%',
        even: (stats.oddEvenPatterns.oddEvenRatio.even * 100).toFixed(1) + '%'
      };
      
      // çƒ­é—¨å°¾æ•°
      const topTails = Object.entries(stats.frequencies.tailFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([tail, prob]) => ({ tail, prob: prob * 100 }));
      
      if (topTails.length > 0) {
        summary.statistics.topTails = topTails;
        summary.recommendations.push(`å¸¸è§å°¾æ•°: ${topTails.map(t => t.tail).join(', ')}`);
      }
      
      // çƒ­é—¨å·ç 
      const hotNumbers = Object.entries(stats.frequencies.specialFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, prob]) => ({ number: parseInt(num), prob: prob * 100 }));
      
      if (hotNumbers.length > 0) {
        summary.statistics.hotNumbers = hotNumbers;
        summary.recommendations.push(`çƒ­é—¨å·ç : ${hotNumbers.map(n => n.number).join(', ')}`);
      }
      
      // å†·é—¨å·ç 
      const coldNumbers = Object.entries(stats.frequencies.specialFrequency)
        .sort((a, b) => a[1] - b[1])
        .slice(0, 5)
        .map(([num, prob]) => ({ number: parseInt(num), prob: prob * 100 }));
      
      if (coldNumbers.length > 0) {
        summary.statistics.coldNumbers = coldNumbers;
      }
      
      // å’Œå€¼èŒƒå›´ç»Ÿè®¡
      const topSumRanges = Object.entries(stats.sumPatterns.sumRanges)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      if (topSumRanges.length > 0) {
        summary.statistics.topSumRanges = topSumRanges.map(([range, count]) => ({
          range: `${range}-${parseInt(range)+19}`,
          count: count
        }));
      }
      
      // ACå€¼ç»Ÿè®¡
      const topAcValues = Object.entries(stats.acValuePatterns.acValueRanges)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      if (topAcValues.length > 0) {
        summary.statistics.topAcValues = topAcValues.map(([ac, count]) => ({
          ac: ac,
          count: count
        }));
      }
      
    } catch (error) {
      Logger.error("EnhancedStatistics", "ç”Ÿæˆç»Ÿè®¡æ‘˜è¦å¤±è´¥", error);
    }
    
    return summary;
  }

  static getPredictionFromStatistics(stats, lastRecord) {
    try {
      if (!stats || !lastRecord) {
        return null;
      }
      
      const prediction = {
        specialNumbers: [],
        zodiacRecommendations: [],
        colorRecommendations: [],
        tailRecommendations: [],
        headRecommendations: [],
        sizePrediction: "",
        oddEvenPrediction: "",
        sumPrediction: "",
        spanPrediction: "",
        acValuePrediction: "",
        primeCountPrediction: "",
        analysis: []
      };
      
      const lastZodiac = lastRecord.zodiac;
      const lastColor = lastRecord.color;
      const lastTail = lastRecord.tail;
      const lastHead = lastRecord.head;
      const lastSize = lastRecord.size;
      const lastOddEven = lastRecord.oddEven;
      const lastSum = lastRecord.sum;
      const lastSpan = lastRecord.span;
      const lastAcValue = lastRecord.acValue;
      const lastPrimeCount = lastRecord.primeCount;
      
      // ç”Ÿè‚–é¢„æµ‹
      if (stats.zodiacPatterns.sameZodiac) {
        const zodiacKeys = Object.keys(stats.zodiacPatterns.sameZodiac)
          .filter(key => key.startsWith(`${lastZodiac}->`))
          .sort((a, b) => stats.zodiacPatterns.sameZodiac[b] - stats.zodiacPatterns.sameZodiac[a])
          .slice(0, 3);
        
        zodiacKeys.forEach(key => {
          const toZodiac = key.split('->')[1];
          const prob = stats.zodiacPatterns.sameZodiac[key];
          
          prediction.zodiacRecommendations.push({
            zodiac: toZodiac,
            probability: prob,
            reason: `ä¸ŠæœŸå¼€${lastZodiac}`
          });
          
          const numbers = CONFIG.ZODIAC_MAP[toZodiac] || [];
          numbers.forEach(num => {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (!existing) {
              prediction.specialNumbers.push({
                number: num,
                probability: prob * 0.5,
                reason: `ç”Ÿè‚–${toZodiac} (ä¸ŠæœŸ${lastZodiac})`
              });
            }
          });
        });
      }
      
      // é¢œè‰²é¢„æµ‹
      if (stats.colorPatterns.sameColor) {
        const colorKeys = Object.keys(stats.colorPatterns.sameColor)
          .filter(key => key.startsWith(`${lastColor}->`))
          .sort((a, b) => stats.colorPatterns.sameColor[b] - stats.colorPatterns.sameColor[a])
          .slice(0, 2);
        
        colorKeys.forEach(key => {
          const toColor = key.split('->')[1];
          const prob = stats.colorPatterns.sameColor[key];
          
          prediction.colorRecommendations.push({
            color: toColor,
            probability: prob,
            reason: `ä¸ŠæœŸ${lastColor}è‰²`
          });
          
          prediction.analysis.push(`é¢œè‰²ä»${lastColor}è½¬åˆ°${toColor}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        });
      }
      
      // å°¾æ•°é¢„æµ‹
      if (stats.tailPatterns.tailTransfer) {
        const tailKeys = Object.keys(stats.tailPatterns.tailTransfer)
          .filter(key => key.startsWith(`${lastTail}->`))
          .sort((a, b) => stats.tailPatterns.tailTransfer[b] - stats.tailPatterns.tailTransfer[a])
          .slice(0, 3);
        
        tailKeys.forEach(key => {
          const toTail = parseInt(key.split('->')[1]);
          const prob = stats.tailPatterns.tailTransfer[key];
          
          prediction.tailRecommendations.push({
            tail: toTail,
            probability: prob,
            reason: `ä¸ŠæœŸå°¾${lastTail}`
          });
          
          for (let num = toTail; num <= 49; num += 10) {
            if (num >= 1 && num <= 49) {
              const existing = prediction.specialNumbers.find(item => item.number === num);
              if (existing) {
                existing.probability += prob * 0.3;
              } else {
                prediction.specialNumbers.push({
                  number: num,
                  probability: prob * 0.3,
                  reason: `å°¾æ•°${toTail} (ä¸ŠæœŸå°¾${lastTail})`
                });
              }
            }
          }
        });
      }
      
      // å¹³ç å°¾æ•°è½¬ç‰¹ç å°¾æ•°
      if (stats.tailPatterns.tailFromNormal && lastRecord.normalFeatures) {
        const normalTails = lastRecord.normalFeatures.tails || [];
        normalTails.forEach(tail => {
          const tailKeys = Object.keys(stats.tailPatterns.tailFromNormal)
            .filter(key => key.startsWith(`${tail}->`))
            .sort((a, b) => stats.tailPatterns.tailFromNormal[b] - stats.tailPatterns.tailFromNormal[a])
            .slice(0, 2);
          
          tailKeys.forEach(key => {
            const toTail = parseInt(key.split('->')[1]);
            const prob = stats.tailPatterns.tailFromNormal[key];
            
            if (prob > 0.1) {
              prediction.analysis.push(`å¹³ç å°¾æ•°${tail}æå¤§å¯èƒ½ä¸‹æœŸç‰¹ç å°¾æ•°${toTail} (${(prob * 100).toFixed(1)}%)`);
              
              for (let num = toTail; num <= 49; num += 10) {
                if (num >= 1 && num <= 49) {
                  const existing = prediction.specialNumbers.find(item => item.number === num);
                  if (existing) {
                    existing.probability += prob * 0.4;
                    existing.reason += `, å¹³ç å°¾${tail}è½¬`;
                  } else {
                    prediction.specialNumbers.push({
                      number: num,
                      probability: prob * 0.4,
                      reason: `å¹³ç å°¾${tail}è½¬å°¾${toTail}`
                    });
                  }
                }
              }
            }
          });
        });
      }
      
      // å¤§å°é¢„æµ‹
      if (stats.sizePatterns.sizeTransfer) {
        const sizeKey = `${lastSize}->å¤§`;
        const sizeProb = stats.sizePatterns.sizeTransfer[sizeKey] || 0;
        
        if (sizeProb > 0.5) {
          prediction.sizePrediction = "å¤§";
          prediction.analysis.push(`ä¸ŠæœŸ${lastSize}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€å¤§ (${(sizeProb * 100).toFixed(1)}%)`);
          
          for (let num = 25; num <= 49; num++) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€å¤§`
              });
            }
          }
        } else if (sizeProb < 0.5) {
          prediction.sizePrediction = "å°";
          prediction.analysis.push(`ä¸ŠæœŸ${lastSize}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€å° (${(100 - sizeProb * 100).toFixed(1)}%)`);
          
          for (let num = 1; num <= 24; num++) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€å°`
              });
            }
          }
        }
      }
      
      // å•åŒé¢„æµ‹
      if (stats.oddEvenPatterns.oddEvenTransfer) {
        const oeKey = `${lastOddEven}->å•`;
        const oeProb = stats.oddEvenPatterns.oddEvenTransfer[oeKey] || 0;
        
        if (oeProb > 0.5) {
          prediction.oddEvenPrediction = "å•";
          prediction.analysis.push(`ä¸ŠæœŸ${lastOddEven}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€å• (${(oeProb * 100).toFixed(1)}%)`);
          
          for (let num = 1; num <= 49; num += 2) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€å•`
              });
            }
          }
        } else if (oeProb < 0.5) {
          prediction.oddEvenPrediction = "åŒ";
          prediction.analysis.push(`ä¸ŠæœŸ${lastOddEven}ï¼Œä¸‹æœŸå¤§æ¦‚ç‡å¼€åŒ (${(100 - oeProb * 100).toFixed(1)}%)`);
          
          for (let num = 2; num <= 49; num += 2) {
            const existing = prediction.specialNumbers.find(item => item.number === num);
            if (existing) {
              existing.probability += 0.1;
            } else {
              prediction.specialNumbers.push({
                number: num,
                probability: 0.1,
                reason: `å¤§æ¦‚ç‡å¼€åŒ`
              });
            }
          }
        }
      }
      
      // å’Œå€¼é¢„æµ‹
      if (stats.sumPatterns.sumTransfer && lastSum !== undefined) {
        let sumRange = "ä¸­å’Œ";
        if (lastSum <= 100) sumRange = "ä½å’Œ";
        else if (lastSum >= 151) sumRange = "é«˜å’Œ";
        
        const sumKeys = Object.keys(stats.sumPatterns.sumTransfer)
          .filter(key => key.startsWith(`${sumRange}->`))
          .sort((a, b) => stats.sumPatterns.sumTransfer[b] - stats.sumPatterns.sumTransfer[a]);
        
        if (sumKeys.length > 0) {
          const topKey = sumKeys[0];
          const toSumRange = topKey.split('->')[1];
          const prob = stats.sumPatterns.sumTransfer[topKey];
          
          prediction.sumPrediction = toSumRange;
          prediction.analysis.push(`å’Œå€¼ä»${sumRange}è½¬åˆ°${toSumRange}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        }
      }
      
      // è·¨åº¦é¢„æµ‹
      if (stats.spanPatterns.spanTransfer && lastSpan !== undefined) {
        let spanRange = "ä¸­è·¨";
        if (lastSpan <= 20) spanRange = "å°è·¨";
        else if (lastSpan >= 36) spanRange = "å¤§è·¨";
        
        const spanKeys = Object.keys(stats.spanPatterns.spanTransfer)
          .filter(key => key.startsWith(`${spanRange}->`))
          .sort((a, b) => stats.spanPatterns.spanTransfer[b] - stats.spanPatterns.spanTransfer[a]);
        
        if (spanKeys.length > 0) {
          const topKey = spanKeys[0];
          const toSpanRange = topKey.split('->')[1];
          const prob = stats.spanPatterns.spanTransfer[topKey];
          
          prediction.spanPrediction = toSpanRange;
          prediction.analysis.push(`è·¨åº¦ä»${spanRange}è½¬åˆ°${toSpanRange}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        }
      }
      
      // ACå€¼é¢„æµ‹
      if (stats.acValuePatterns.acValueTransfer && lastAcValue !== undefined) {
        let acRange = "ä¸­AC";
        if (lastAcValue <= 4) acRange = "ä½AC";
        else if (lastAcValue >= 9) acRange = "é«˜AC";
        
        const acKeys = Object.keys(stats.acValuePatterns.acValueTransfer)
          .filter(key => key.startsWith(`${acRange}->`))
          .sort((a, b) => stats.acValuePatterns.acValueTransfer[b] - stats.acValuePatterns.acValueTransfer[a]);
        
        if (acKeys.length > 0) {
          const topKey = acKeys[0];
          const toAcRange = topKey.split('->')[1];
          const prob = stats.acValuePatterns.acValueTransfer[topKey];
          
          prediction.acValuePrediction = toAcRange;
          prediction.analysis.push(`ACå€¼ä»${acRange}è½¬åˆ°${toAcRange}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        }
      }
      
      // è´¨æ•°æ•°é‡é¢„æµ‹
      if (stats.primeCompositePatterns.primeCountTransfer && lastPrimeCount !== undefined) {
        let primeRange = "ä¸­è´¨æ•°";
        if (lastPrimeCount <= 1) primeRange = "å°‘è´¨æ•°";
        else if (lastPrimeCount >= 4) primeRange = "å¤šè´¨æ•°";
        
        const primeKeys = Object.keys(stats.primeCompositePatterns.primeCountTransfer)
          .filter(key => key.startsWith(`${primeRange}->`))
          .sort((a, b) => stats.primeCompositePatterns.primeCountTransfer[b] - stats.primeCompositePatterns.primeCountTransfer[a]);
        
        if (primeKeys.length > 0) {
          const topKey = primeKeys[0];
          const toPrimeRange = topKey.split('->')[1];
          const prob = stats.primeCompositePatterns.primeCountTransfer[topKey];
          
          prediction.primeCountPrediction = toPrimeRange;
          prediction.analysis.push(`è´¨æ•°æ•°é‡ä»${primeRange}è½¬åˆ°${toPrimeRange}çš„æ¦‚ç‡ä¸º${(prob * 100).toFixed(1)}%`);
        }
      }
      
      // åŸºäºé¢‘ç‡è°ƒæ•´æ¦‚ç‡
      prediction.specialNumbers.forEach(item => {
        const freq = stats.frequencies.specialFrequency[item.number] || 0;
        if (freq > 0.03) {
          item.probability *= 1.2;
          item.reason += `, çƒ­é—¨å·ç `;
        } else if (freq < 0.01) {
          item.probability *= 0.8;
          item.reason += `, å†·é—¨å·ç `;
        }
      });
      
      // æ’åºå’Œå»é‡
      prediction.specialNumbers.sort((a, b) => b.probability - a.probability);
      
      const seen = new Set();
      prediction.specialNumbers = prediction.specialNumbers.filter(item => {
        if (seen.has(item.number) || item.probability < 0.01) {
          return false;
        }
        seen.add(item.number);
        return true;
      }).slice(0, 15);
      
      return prediction;
    } catch (error) {
      Logger.error("EnhancedStatistics", "ä»ç»Ÿè®¡ç”Ÿæˆé¢„æµ‹å¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 7. ä¼˜åŒ–çš„è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¼•æ“ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class OptimizedMonteCarloEngine {
  static cache = new Map();
  
  static async runOptimizedSimulation(history, targetSimulations = 10000) {
    try {
      if (!history || history.length < 10) {
        return null;
      }
      
      const cacheKey = `monte_opt_${targetSimulations}_${history.length}_${history[0]?.expect || '0'}`;
      const cached = this.cache.get(cacheKey);
      
      if (cached && (Date.now() - cached.timestamp < 45000)) {
        Logger.info("OptimizedMonteCarlo", "ä½¿ç”¨ç¼“å­˜ç»“æœ");
        return cached.result;
      }
      
      const startTime = Date.now();
      
      const processedHistory = this.preprocessHistory(history.slice(0, Math.min(150, history.length)));
      
      if (processedHistory.length < 8) {
        Logger.warn("OptimizedMonteCarlo", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡æ¨¡æ‹Ÿ");
        return null;
      }
      
      const optimalSimulations = Math.min(targetSimulations, 8000);
      
      const specialFrequency = {};
      const normalFrequency = {};
      
      for (let i = 1; i <= 49; i++) {
        specialFrequency[i] = 0;
        normalFrequency[i] = 0;
      }
      
      const batchSize = 1000;
      const batches = Math.ceil(optimalSimulations / batchSize);
      
      Logger.info("OptimizedMonteCarlo", "å¼€å§‹æ‰¹æ¬¡æ¨¡æ‹Ÿ", {
        target: targetSimulations,
        optimal: optimalSimulations,
        batches: batches,
        historySize: processedHistory.length
      });
      
      for (let batch = 0; batch < batches; batch++) {
        const batchStart = Date.now();
        
        for (let i = 0; i < batchSize; i++) {
          const baseRecord = this.selectBaseRecord(processedHistory, batch, i);
          
          const simulated = this.simulateNextNumbersSmart(baseRecord, processedHistory);
          
          if (simulated.special >= 1 && simulated.special <= 49) {
            specialFrequency[simulated.special]++;
          }
          
          simulated.normals.forEach(num => {
            if (num >= 1 && num <= 49) {
              normalFrequency[num]++;
            }
          });
        }
        
        const batchTime = Date.now() - batchStart;
        
        if (batch < batches - 1 && batchTime < 50) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
        
        if (Date.now() - startTime > 8000) {
          Logger.warn("OptimizedMonteCarlo", "æ¨¡æ‹Ÿè¶…æ—¶ï¼Œæå‰ç»“æŸ");
          break;
        }
      }
      
      const completedSimulations = Object.values(specialFrequency).reduce((a, b) => a + b, 0);
      
      if (completedSimulations === 0) {
        Logger.warn("OptimizedMonteCarlo", "æ¨¡æ‹Ÿæœªç”Ÿæˆä»»ä½•ç»“æœ");
        return null;
      }
      
      const specialProbs = {};
      const normalProbs = {};
      
      for (let i = 1; i <= 49; i++) {
        specialProbs[i] = specialFrequency[i] / completedSimulations;
        normalProbs[i] = normalFrequency[i] / completedSimulations;
      }
      
      const result = {
        specialPredictions: Object.entries(specialProbs)
          .map(([num, prob]) => ({
            number: Formatter.safeInt(num),
            probability: prob,
            score: prob * 10000,
            frequency: specialFrequency[num]
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 12),
        
        normalPredictions: Object.entries(normalProbs)
          .map(([num, prob]) => ({
            number: Formatter.safeInt(num),
            probability: prob,
            score: prob * 8000,
            frequency: normalFrequency[num]
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 15),
        
        simulations: completedSimulations,
        batches: batches,
        duration: Date.now() - startTime,
        cacheKey: cacheKey
      };
      
      this.cache.set(cacheKey, {
        result: result,
        timestamp: Date.now()
      });
      
      this.cleanupCache();
      
      Logger.info("OptimizedMonteCarlo", "æ¨¡æ‹Ÿå®Œæˆ", {
        simulations: completedSimulations,
        duration: result.duration
      });
      
      return result;
    } catch (error) {
      Logger.error("OptimizedMonteCarlo", "ä¼˜åŒ–æ¨¡æ‹Ÿå¤±è´¥", error);
      return null;
    }
  }
  
  static selectBaseRecord(processedHistory, batch, index) {
    const total = processedHistory.length;
    const selectionMethod = (batch * 100 + index) % 5;
    
    switch (selectionMethod) {
      case 0:
        return processedHistory[Math.floor(Math.random() * total)];
      case 1:
        return processedHistory[0];
      case 2:
        return processedHistory[Math.min(10, total - 1)];
      case 3:
        return processedHistory[Math.floor(total / 2)];
      default:
        const weights = processedHistory.map((_, i) => Math.exp(-i / 10));
        const sum = weights.reduce((a, b) => a + b, 0);
        let rand = Math.random() * sum;
        for (let i = 0; i < weights.length; i++) {
          rand -= weights[i];
          if (rand <= 0) return processedHistory[i];
        }
        return processedHistory[0];
    }
  }
  
  static simulateNextNumbersSmart(baseRecord, processedHistory) {
    const result = {
      normals: [],
      special: 0
    };
    
    const simulationStrategy = Math.random();
    
    if (simulationStrategy < 0.3) {
      const zodiacNumbers = CONFIG.ZODIAC_MAP[baseRecord.zodiac] || [];
      if (zodiacNumbers.length > 0) {
        result.special = zodiacNumbers[Math.floor(Math.random() * zodiacNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    } else if (simulationStrategy < 0.6) {
      const colorNumbers = CONFIG.COLORS[baseRecord.color] || [];
      if (colorNumbers.length > 0) {
        result.special = colorNumbers[Math.floor(Math.random() * colorNumbers.length)];
      } else {
        result.special = baseRecord.special;
      }
    } else {
      const similarIndex = Math.floor(Math.random() * Math.min(10, processedHistory.length));
      result.special = processedHistory[similarIndex]?.special || baseRecord.special;
    }
    
    if (result.special < 1 || result.special > 49) {
      result.special = Math.floor(Math.random() * 49) + 1;
    }
    
    const usedNumbers = new Set([result.special]);
    
    let normalsNeeded = 6;
    
    for (const normal of baseRecord.normals) {
      if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
        result.normals.push(normal);
        usedNumbers.add(normal);
        normalsNeeded--;
        if (normalsNeeded <= 0) break;
      }
    }
    
    if (normalsNeeded > 0) {
      const similarRecords = processedHistory.slice(0, 5);
      for (const record of similarRecords) {
        if (normalsNeeded <= 0) break;
        
        for (const normal of record.normals) {
          if (!usedNumbers.has(normal) && normal >= 1 && normal <= 49) {
            result.normals.push(normal);
            usedNumbers.add(normal);
            normalsNeeded--;
            if (normalsNeeded <= 0) break;
          }
        }
      }
    }
    
    while (normalsNeeded > 0) {
      let num;
      let attempts = 0;
      do {
        num = Math.floor(Math.random() * 49) + 1;
        attempts++;
      } while (usedNumbers.has(num) && attempts < 20);
      
      if (!usedNumbers.has(num)) {
        result.normals.push(num);
        usedNumbers.add(num);
        normalsNeeded--;
      } else {
        for (let i = 1; i <= 49; i++) {
          if (!usedNumbers.has(i)) {
            result.normals.push(i);
            usedNumbers.add(i);
            normalsNeeded--;
            break;
          }
        }
      }
    }
    
    return result;
  }
  
  static preprocessHistory(history) {
    const processed = [];
    
    for (const record of history) {
      if (record && record.open_code) {
        const nums = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (nums.length >= 7) {
          const special = nums[6] || 1;
          const normals = nums.slice(0, 6);
          const attr = Formatter.getAttributes(special);
          
          processed.push({
            numbers: nums,
            special: special,
            normals: normals,
            zodiac: attr.zodiac,
            color: attr.color,
            tail: special % 10,
            head: Math.floor(special / 10),
            size: special >= 25 ? "å¤§" : "å°",
            oddEven: special % 2 !== 0 ? "å•" : "åŒ",
            expect: record.expect
          });
        }
      }
    }
    
    return processed;
  }
  
  static cleanupCache() {
    try {
      const now = Date.now();
      const maxCacheSize = 30;
      
      if (this.cache.size > maxCacheSize) {
        const keys = Array.from(this.cache.keys());
        const keysToDelete = keys.slice(0, Math.floor(keys.length / 2));
        
        for (const key of keysToDelete) {
          this.cache.delete(key);
        }
      }
      
      for (const [key, value] of this.cache.entries()) {
        if (now - value.timestamp > 120000) {
          this.cache.delete(key);
        }
      }
    } catch (error) {
      Logger.error("OptimizedMonteCarlo", "æ¸…ç†ç¼“å­˜å¤±è´¥", error);
    }
  }
  
  static clearCache() {
    try {
      this.cache.clear();
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

// ==============================================================================
// 8. é—æ¼å›è¡¥ä¸“å®¶ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class OmissionExpert {
  static async runOmission(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.omission) {
        Logger.warn("OmissionExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡é—æ¼åˆ†æ");
        return new Map();
      }
      
      const scores = new Map();
      
      const occurrenceCount = {};
      const currentGaps = {};
      
      for (let i = 1; i <= 49; i++) {
        occurrenceCount[i] = 0;
        currentGaps[i] = 0;
      }
      
      const maxRecords = Math.min(history.length, 200);
      let recordCount = 0;
      
      for (let i = 0; i < maxRecords; i++) {
        const record = history[i];
        if (!record || !record.open_code) continue;
        
        recordCount++;
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        for (let num = 1; num <= 49; num++) {
          if (numbers.includes(num)) {
            occurrenceCount[num]++;
            currentGaps[num] = 0;
          } else {
            currentGaps[num]++;
          }
        }
      }
      
      if (recordCount === 0) {
        return new Map();
      }
      
      const threshold = CONFIG.SYSTEM.OMISSION_THRESHOLDS;
      
      for (let num = 1; num <= 49; num++) {
        const avgGap = recordCount / Math.max(1, occurrenceCount[num]);
        const curGap = currentGaps[num];
        const ratio = avgGap > 0 ? curGap / avgGap : 0;
        
        let score = 50;
        
        if (ratio > threshold.severe) {
          score = 100;
        } else if (ratio > threshold.moderate) {
          score = 80;
        } else if (ratio < threshold.recent) {
          score = 30;
        }
        
        if (curGap > avgGap * 3) {
          score += 20;
        }
        
        scores.set(num, score * weights.w_omission);
      }
      
      const normalizedScores = Formatter.normalizeScores(scores, "omission");
      
      Logger.info("OmissionExpert", "é—æ¼åˆ†æå®Œæˆ", {
        analyzedNumbers: 49,
        maxGap: Math.max(...Object.values(currentGaps))
      });
      
      return normalizedScores;
    } catch (error) {
      Logger.error("OmissionExpert", "é—æ¼åˆ†æå¤±è´¥", error);
      return new Map();
    }
  }
  
  static getOmissionAnalysis(scores) {
    try {
      if (!scores || scores.size === 0) {
        return null;
      }
      
      const topOmissions = Array.from(scores.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, score]) => ({ number: num, score }));
      
      const analysis = {
        topRecommendations: topOmissions.map(item => ({
          number: item.number,
          zodiac: Formatter.getAttributes(item.number).zodiac,
          score: Math.round(item.score),
          reason: "ä¸¥é‡é—æ¼éœ€å›è¡¥"
        })),
        analysis: `åˆ†æäº†49ä¸ªå·ç çš„é—æ¼æƒ…å†µï¼Œæ¨èé‡ç‚¹å…³æ³¨ä¸¥é‡é—æ¼å·ç `
      };
      
      return analysis;
    } catch (error) {
      Logger.error("OmissionExpert", "è·å–é—æ¼åˆ†æå¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 9. å…³è”è§„åˆ™ä¸“å®¶ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class AssociationExpert {
  static async runAssociation(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.association) {
        Logger.warn("AssociationExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡å…³è”åˆ†æ");
        return new Map();
      }
      
      const scores = new Map();
      for (let i = 1; i <= 49; i++) {
        scores.set(i, 0);
      }
      
      const lastRecord = history[0];
      if (!lastRecord || !lastRecord.open_code) {
        return new Map();
      }
      
      const lastNumbers = lastRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (lastNumbers.length < 7) {
        return new Map();
      }
      
      const maxRecords = Math.min(history.length, 100);
      const associationStrength = {};
      
      for (let i = 1; i <= 49; i++) {
        associationStrength[i] = {};
        for (let j = 1; j <= 49; j++) {
          associationStrength[i][j] = 0;
        }
      }
      
      for (let i = 0; i < maxRecords - 1; i++) {
        const currentRecord = history[i];
        const nextRecord = history[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNumbers = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNumbers = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNumbers.length < 7 || nextNumbers.length < 7) {
          continue;
        }
        
        for (const currNum of currentNumbers) {
          for (const nextNum of nextNumbers) {
            if (currNum >= 1 && currNum <= 49 && nextNum >= 1 && nextNum <= 49) {
              associationStrength[currNum][nextNum]++;
            }
          }
        }
      }
      
      for (const lastNum of lastNumbers) {
        if (lastNum < 1 || lastNum > 49) continue;
        
        const associations = associationStrength[lastNum];
        if (!associations) continue;
        
        const sortedAssociations = Object.entries(associations)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10);
        
        for (const [nextNum, strength] of sortedAssociations) {
          const num = Formatter.safeInt(nextNum);
          if (num >= 1 && num <= 49 && strength > 0) {
            const currentScore = scores.get(num) || 0;
            const newScore = currentScore + (strength * 10);
            scores.set(num, newScore);
          }
        }
      }
      
      const lastSpecial = lastNumbers[6] || 1;
      const specialAssociations = associationStrength[lastSpecial];
      
      if (specialAssociations) {
        const sortedSpecialAssocs = Object.entries(specialAssociations)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 15);
        
        for (const [nextNum, strength] of sortedSpecialAssocs) {
          const num = Formatter.safeInt(nextNum);
          if (num >= 1 && num <= 49 && strength > 0) {
            const currentScore = scores.get(num) || 0;
            const newScore = currentScore + (strength * 15);
            scores.set(num, newScore);
          }
        }
      }
      
      for (const [num, score] of scores) {
        scores.set(num, score * weights.w_association);
      }
      
      const normalizedScores = Formatter.normalizeScores(scores, "association");
      
      Logger.info("AssociationExpert", "å…³è”åˆ†æå®Œæˆ");
      
      return normalizedScores;
    } catch (error) {
      Logger.error("AssociationExpert", "å…³è”åˆ†æå¤±è´¥", error);
      return new Map();
    }
  }
  
  static getAssociationAnalysis(scores, lastNumbers) {
    try {
      if (!scores || scores.size === 0 || !lastNumbers) {
        return null;
      }
      
      const topAssociations = Array.from(scores.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, score]) => ({ number: num, score }));
      
      const lastSpecial = lastNumbers[6] || 1;
      
      const analysis = {
        topAssociations: topAssociations.map(item => ({
          number: item.number,
          zodiac: Formatter.getAttributes(item.number).zodiac,
          score: Math.round(item.score),
          reason: `ä¸ä¸ŠæœŸç‰¹ç ${lastSpecial}å¼ºå…³è”`
        })),
        analysis: `åŸºäºå…³è”è§„åˆ™åˆ†æï¼Œæ¨èä¸ä¸ŠæœŸå·ç å¼ºå…³è”çš„å·ç `
      };
      
      return analysis;
    } catch (error) {
      Logger.error("AssociationExpert", "è·å–å…³è”åˆ†æå¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 10. é»„é‡‘åˆ†å‰²ä¸æ•°åˆ—ä¸“å®¶ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class MathExpert {
  static async runMathLogic(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.math) {
        Logger.warn("MathExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡æ•°å­¦åˆ†æ");
        return new Map();
      }
      
      const scores = new Map();
      for (let i = 1; i <= 49; i++) {
        scores.set(i, 50);
      }
      
      const lastRecord = history[0];
      if (!lastRecord || !lastRecord.open_code) {
        return scores;
      }
      
      const lastNumbers = lastRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (lastNumbers.length < 7) {
        return scores;
      }
      
      const lastSpecial = lastNumbers[6] || 1;
      
      const goldenRatio = CONFIG.MATH_CONSTANTS.GOLDEN_RATIO;
      
      const goldenPoint1 = Math.round(lastSpecial * goldenRatio);
      const goldenPoint2 = Math.round(lastSpecial / goldenRatio);
      const goldenPoint3 = Math.round(lastSpecial * (1 + goldenRatio)) % 49 || 49;
      
      const goldenPoints = [
        goldenPoint1, goldenPoint2, goldenPoint3
      ].filter(p => p >= 1 && p <= 49);
      
      goldenPoints.forEach(point => {
        const currentScore = scores.get(point) || 0;
        scores.set(point, currentScore + 30 * weights.w_math);
      });
      
      const fibonacci = CONFIG.MATH_CONSTANTS.FIBONACCI;
      
      for (const fibNum of fibonacci) {
        const fibPoint1 = (lastSpecial + fibNum) % 49 || 49;
        const fibPoint2 = Math.abs(lastSpecial - fibNum) || 1;
        
        [fibPoint1, fibPoint2].forEach(point => {
          if (point >= 1 && point <= 49) {
            const currentScore = scores.get(point) || 0;
            scores.set(point, currentScore + 20 * weights.w_math);
          }
        });
      }
      
      const recentHistory = history.slice(0, Math.min(20, history.length));
      
      const mod3Count = { 0: 0, 1: 0, 2: 0 };
      const mod5Count = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
      
      for (const record of recentHistory) {
        if (!record || !record.open_code) continue;
        
        const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        if (numbers.length < 7) continue;
        
        const special = numbers[6] || 1;
        
        mod3Count[special % 3]++;
        mod5Count[special % 5]++;
        
        const normals = numbers.slice(0, 6);
        for (const num of normals) {
          mod3Count[num % 3] += 0.3;
          mod5Count[num % 5] += 0.3;
        }
      }
      
      const totalRecords = recentHistory.length;
      const expectedMod3 = totalRecords * 1.3;
      const expectedMod5 = totalRecords * 1.3;
      
      const missingMod3 = [];
      const missingMod5 = [];
      
      for (let i = 0; i < 3; i++) {
        if (mod3Count[i] < expectedMod3 * 0.5) {
          missingMod3.push(i);
        }
      }
      
      for (let i = 0; i < 5; i++) {
        if (mod5Count[i] < expectedMod5 * 0.5) {
          missingMod5.push(i);
        }
      }
      
      for (let num = 1; num <= 49; num++) {
        let mod3Bonus = 0;
        let mod5Bonus = 0;
        
        if (missingMod3.includes(num % 3)) {
          mod3Bonus = 25;
        }
        
        if (missingMod5.includes(num % 5)) {
          mod5Bonus = 20;
        }
        
        const currentScore = scores.get(num) || 0;
        scores.set(num, currentScore + (mod3Bonus + mod5Bonus) * weights.w_math);
      }
      
      const normalizedScores = Formatter.normalizeScores(scores, "math");
      
      Logger.info("MathExpert", "æ•°å­¦åˆ†æå®Œæˆ");
      
      return normalizedScores;
    } catch (error) {
      Logger.error("MathExpert", "æ•°å­¦åˆ†æå¤±è´¥", error);
      return new Map();
    }
  }
  
  static getMathAnalysis(scores, lastSpecial) {
    try {
      if (!scores || scores.size === 0) {
        return null;
      }
      
      const topMathNumbers = Array.from(scores.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, score]) => ({ number: num, score }));
      
      const analysis = {
        goldenRatioRecommendations: topMathNumbers.filter((_, index) => index < 3).map(item => ({
          number: item.number,
          zodiac: Formatter.getAttributes(item.number).zodiac,
          score: Math.round(item.score),
          reason: "é»„é‡‘åˆ†å‰²ä¼˜é€‰"
        })),
        lastSpecial: lastSpecial,
        analysis: `åŸºäºé»„é‡‘åˆ†å‰²ã€æ–æ³¢é‚£å¥‘æ•°åˆ—å’Œæ¨¡è¿ç®—åˆ†æçš„æ•°å­¦ä¼˜é€‰å·ç `
      };
      
      return analysis;
    } catch (error) {
      Logger.error("MathExpert", "è·å–æ•°å­¦åˆ†æå¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 11. åŒºé—´å¹³è¡¡ä¸“å®¶ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class ZoneExpert {
  static async runZoneAnalysis(history, weights) {
    try {
      if (!history || history.length < CONFIG.SYSTEM.MIN_HISTORY_FOR_ALGORITHMS.zone) {
        Logger.warn("ZoneExpert", "å†å²æ•°æ®ä¸è¶³ï¼Œè·³è¿‡åŒºé—´åˆ†æ");
        return new Map();
      }
      
      const scores = new Map();
      for (let i = 1; i <= 49; i++) {
        scores.set(i, 50);
      }
      
      const maxRecords = Math.min(history.length, 50);
      const recentHistory = history.slice(0, maxRecords);
      
      const zone7Stats = this.analyzeZoneDistribution(recentHistory, "zone7");
      const zone7Heat = this.calculateZoneHeat(zone7Stats);
      
      for (let num = 1; num <= 49; num++) {
        let zoneBonus = 0;
        
        const zone7Info = Formatter.getZoneForNumber(num, "zone7");
        if (zone7Info) {
          const zoneHeat = zone7Heat[zone7Info.zoneIndex] || 0;
          if (zoneHeat < 0.3) {
            zoneBonus += 40;
          } else if (zoneHeat > 0.7) {
            zoneBonus -= 15;
          }
        }
        
        const currentScore = scores.get(num) || 0;
        scores.set(num, currentScore + zoneBonus * weights.w_zone);
      }
      
      const zone7Continuity = this.analyzeZoneContinuity(recentHistory, "zone7");
      
      for (let num = 1; num <= 49; num++) {
        let continuityBonus = 0;
        
        const zone7Info = Formatter.getZoneForNumber(num, "zone7");
        if (zone7Info) {
          const continuity = zone7Continuity[zone7Info.zoneIndex] || 0;
          if (continuity >= 3) {
            continuityBonus += continuity * 10;
          }
        }
        
        if (continuityBonus > 0) {
          const currentScore = scores.get(num) || 0;
          scores.set(num, currentScore + continuityBonus * weights.w_zone);
        }
      }
      
      const normalizedScores = Formatter.normalizeScores(scores, "zone");
      
      Logger.info("ZoneExpert", "åŒºé—´åˆ†æå®Œæˆ");
      
      return normalizedScores;
    } catch (error) {
      Logger.error("ZoneExpert", "åŒºé—´åˆ†æå¤±è´¥", error);
      return new Map();
    }
  }
  
  static analyzeZoneDistribution(history, zoneType) {
    const zones = CONFIG.SYSTEM.ZONE_CONFIG[zoneType];
    if (!zones) return {};
    
    const zoneStats = {};
    zones.forEach((zone, index) => {
      zoneStats[index] = {
        zoneIndex: index,
        zoneNumbers: zone,
        occurrenceCount: 0
      };
    });
    
    for (const record of history) {
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (numbers.length < 7) continue;
      
      const allNumbers = numbers;
      
      for (const num of allNumbers) {
        for (let zoneIndex = 0; zoneIndex < zones.length; zoneIndex++) {
          if (zones[zoneIndex].includes(num)) {
            zoneStats[zoneIndex].occurrenceCount++;
            break;
          }
        }
      }
    }
    
    return zoneStats;
  }
  
  static calculateZoneHeat(zoneStats) {
    const zoneHeat = {};
    const totalOccurrences = Object.values(zoneStats).reduce((sum, stats) => sum + stats.occurrenceCount, 0);
    
    if (totalOccurrences === 0) return zoneHeat;
    
    Object.entries(zoneStats).forEach(([zoneIndex, stats]) => {
      const expected = totalOccurrences / Object.keys(zoneStats).length;
      const actual = stats.occurrenceCount;
      zoneHeat[zoneIndex] = actual / expected;
    });
    
    return zoneHeat;
  }
  
  static analyzeZoneContinuity(history, zoneType) {
    const zones = CONFIG.SYSTEM.ZONE_CONFIG[zoneType];
    if (!zones || history.length === 0) return {};
    
    const zoneContinuity = {};
    zones.forEach((_, index) => {
      zoneContinuity[index] = 0;
    });
    
    for (let i = 0; i < Math.min(10, history.length); i++) {
      const record = history[i];
      if (!record || !record.open_code) continue;
      
      const numbers = record.open_code.split(",").map(n => Formatter.safeInt(n, 0));
      if (numbers.length < 7) continue;
      
      const allNumbers = numbers;
      
      const appearedZones = new Set();
      for (const num of allNumbers) {
        for (let zoneIndex = 0; zoneIndex < zones.length; zoneIndex++) {
          if (zones[zoneIndex].includes(num)) {
            appearedZones.add(zoneIndex);
            break;
          }
        }
      }
      
      for (let zoneIndex = 0; zoneIndex < zones.length; zoneIndex++) {
        if (!appearedZones.has(zoneIndex)) {
          zoneContinuity[zoneIndex]++;
        } else {
          if (i === 0) {
            zoneContinuity[zoneIndex] = 0;
          }
        }
      }
    }
    
    return zoneContinuity;
  }
  
  static getZoneAnalysis(scores, history) {
    try {
      if (!scores || scores.size === 0 || !history || history.length === 0) {
        return null;
      }
      
      const topZoneNumbers = Array.from(scores.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([num, score]) => ({ number: num, score }));
      
      const recentHistory = history.slice(0, Math.min(20, history.length));
      const zone7Heat = this.calculateZoneHeat(this.analyzeZoneDistribution(recentHistory, "zone7"));
      const coldZones7 = Object.entries(zone7Heat)
        .filter(([_, heat]) => heat < 0.3)
        .map(([zoneIndex]) => parseInt(zoneIndex));
      
      const analysis = {
        zoneRecommendations: topZoneNumbers.map(item => ({
          number: item.number,
          zodiac: Formatter.getAttributes(item.number).zodiac,
          score: Math.round(item.score),
          reason: "åŒºé—´å¹³è¡¡ä¼˜é€‰"
        })),
        zoneAnalysis: {
          coldZones7: coldZones7,
          recommendation: coldZones7.length > 0 ? 
            `é‡ç‚¹å…³æ³¨å†·åŒº${coldZones7.join(',')}å›è¡¥` : 
            "åŒºé—´åˆ†å¸ƒç›¸å¯¹å‡è¡¡"
        },
        analysis: `åŸºäºä¸ƒåŒºåˆ†å¸ƒçš„ç©ºé—´å¹³è¡¡åˆ†æ`
      };
      
      return analysis;
    } catch (error) {
      Logger.error("ZoneExpert", "è·å–åŒºé—´åˆ†æå¤±è´¥", error);
      return null;
    }
  }
}

// ==============================================================================
// 12. æ”¹è¿›çš„é¢„æµ‹å¼•æ“ï¼ˆç²¾ç®€å¢å¼ºç‰ˆï¼‰
// ==============================================================================

class PredictionEngine {
  static async generate(env, history, weights, algorithm = "traditional") {
    try {
      if (!history || history.length < 2) {
        return this.generateStaticFallback();
      }
      
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      if (!Formatter.isAlgorithmSupported(algorithm, history.length)) {
        Logger.warn("PredictionEngine", `ç®—æ³• ${algorithm} éœ€è¦æ›´å¤šå†å²æ•°æ®ï¼Œä½¿ç”¨ä¼ ç»Ÿç®—æ³•æ›¿ä»£`);
        
        if (algorithm !== "traditional") {
          algorithm = "traditional";
        }
      }
      
      let nextExpect = "2025001";
      const latestExpect = lastRecord.expect;
      if (latestExpect) {
        const latestNum = Formatter.safeInt(latestExpect, 2025000);
        nextExpect = (latestNum + 1).toString();
      }
      
      let prediction;
      const algorithmTimeout = Formatter.getAlgorithmTimeout(algorithm);
      
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error(`é¢„æµ‹ç”Ÿæˆè¶…æ—¶ (${algorithmTimeout}ms)`)), algorithmTimeout);
        });
        
        const predictionPromise = (async () => {
          switch (algorithm) {
            case "stats":
              return await this.generateStatsPrediction(history, weights);
            case "advanced":
              return await this.generateAdvancedPrediction(env, history, weights);
            case "traditional":
            default:
              return await this.generateTraditionalPrediction(history, weights);
          }
        })();
        
        prediction = await Promise.race([predictionPromise, timeoutPromise]);
      } catch (timeoutError) {
        Logger.error("PredictionEngine", `é¢„æµ‹ç”Ÿæˆè¶…æ—¶ï¼Œç®—æ³•: ${algorithm}`, timeoutError);
        
        prediction = await this.generateTraditionalPrediction(history, weights);
        
        prediction.algorithmTimeout = true;
        prediction.originalAlgorithm = algorithm;
      }
      
      if (!prediction || !prediction.specialNumbers || prediction.specialNumbers.length === 0) {
        Logger.warn("PredictionEngine", `ç®—æ³• ${algorithm} è¿”å›æ— æ•ˆé¢„æµ‹ï¼Œä½¿ç”¨ä¼ ç»Ÿç®—æ³•æ›¿ä»£`);
        prediction = await this.generateTraditionalPrediction(history, weights);
      }
      
      prediction.nextExpect = nextExpect;
      prediction.basedOnLastRecord = {
        expect: lastRecord.expect || "æœªçŸ¥",
        openCode: lastOpenCode,
        special: lastSpecial,
        zodiac: Formatter.getAttributes(lastSpecial).zodiac,
        color: Formatter.getAttributes(lastSpecial).color
      };
      
      prediction.totalHistoryRecords = history.length;
      prediction.generatedAt = new Date().toISOString();
      prediction.algorithmVersion = `V15.1-${CONFIG.ALGORITHM_NAMES[algorithm] || algorithm}`;
      prediction.algorithmUsed = algorithm;
      
      if (prediction.algorithmTimeout) {
        prediction.algorithmUsed = `timeout_fallback_${prediction.originalAlgorithm}_to_traditional`;
      }
      
      return prediction;
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé¢„æµ‹æ—¶å‡ºé”™", error);
      return this.generateStaticFallback();
    }
  }
  
  static async generateTraditionalPrediction(history, weights) {
    try {
      const lastRecord = history[0] || {};
      const lastOpenCode = lastRecord.open_code || "1,2,3,4,5,6,7";
      const lastSpecial = Formatter.safeInt(lastOpenCode.split(",")[6], 1);
      
      const stats = this.analyzeHistoryStatistics(history);
      
      const scores = this.generateTraditionalScores(lastSpecial, stats, weights);
      
      const topSpecialNumbers = this.getTopSpecialPredictions(scores, 10);
      const zodiacPrediction = this.getZodiacPredictions(scores);
      const colorPrediction = this.getColorPredictions(scores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = this.generateNormalPredictions(stats, weights, excludeSpecials);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestNumber / 10);
      
      const confidence = this.calculateTraditionalConfidence(topSpecialNumbers, history.length);
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));
      
      const formattedNormals = normalPredictions.slice(0, 6).map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      return {
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: confidence,
        analysisBased: true,
        algorithmUsed: "traditional"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ä¼ ç»Ÿé¢„æµ‹ç”Ÿæˆå¤±è´¥", error);
      return this.generateStaticFallback();
    }
  }
  
  static async generateStatsPrediction(history, weights) {
    try {
      const lastRecord = history[0];
      if (!lastRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const stats = EnhancedStatistics.analyzeHistoryStatistics(history);
      
      const processedHistory = EnhancedStatistics.processHistoryData([lastRecord]);
      const lastProcessedRecord = processedHistory[0];
      
      if (!lastProcessedRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const statisticsResult = EnhancedStatistics.getPredictionFromStatistics(stats, lastProcessedRecord);
      
      if (!statisticsResult) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const baseScores = this.generateTraditionalScores(
        lastProcessedRecord.special,
        this.analyzeHistoryStatistics(history),
        weights
      );
      
      if (statisticsResult.specialNumbers) {
        for (const item of statisticsResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            baseScores[item.number].score += item.probability * 200 * weights.w_statistics_analysis;
            baseScores[item.number].probability = item.probability;
          }
        }
      }
      
      if (statisticsResult.tailRecommendations) {
        for (const item of statisticsResult.tailRecommendations) {
          if (item.tail >= 0 && item.tail <= 9) {
            for (let num = item.tail; num <= 49; num += 10) {
              if (num >= 1 && num <= 49) {
                baseScores[num].score += item.probability * 150 * weights.w_tail_pattern;
              }
            }
          }
        }
      }
      
      const topSpecialNumbers = this.getTopSpecialPredictions(baseScores, 10);
      const zodiacPrediction = this.getZodiacPredictions(baseScores);
      const colorPrediction = this.getColorPredictions(baseScores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      const normalPredictions = this.generateNormalPredictions(
        this.analyzeHistoryStatistics(history),
        weights,
        excludeSpecials
      );
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestNumber / 10);
      
      let confidence = this.calculateTraditionalConfidence(topSpecialNumbers, history.length);
      confidence += statisticsResult.analysis ? Math.min(20, statisticsResult.analysis.length * 4) : 0;
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color
      }));
      
      const formattedNormals = normalPredictions.slice(0, 6).map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      const statisticalAnalysis = {
        summary: stats.summary || {},
        recommendations: statisticsResult.analysis || [],
        sizePrediction: statisticsResult.sizePrediction || "",
        oddEvenPrediction: statisticsResult.oddEvenPrediction || "",
        sumPrediction: statisticsResult.sumPrediction || "",
        spanPrediction: statisticsResult.spanPrediction || "",
        acValuePrediction: statisticsResult.acValuePrediction || "",
        primeCountPrediction: statisticsResult.primeCountPrediction || "",
        patterns: statisticsResult.analysis || []
      };
      
      return {
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: Math.min(95, confidence),
        analysisBased: true,
        algorithmUsed: "statistics",
        statisticalAnalysis: statisticalAnalysis
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç»Ÿè®¡é¢„æµ‹ç”Ÿæˆå¤±è´¥", error);
      return await this.generateTraditionalPrediction(history, weights);
    }
  }
  
  static async generateAdvancedPrediction(env, history, weights) {
    try {
      const lastRecord = history[0];
      if (!lastRecord) {
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      Logger.info("PredictionEngine", "å¼€å§‹ç”Ÿæˆå¢å¼ºé¢„æµ‹", { 
        historyLength: history.length,
        weightsVersion: weights._version || "default"
      });
      
      const algorithmChecks = {
        traditional: Formatter.isAlgorithmSupported("traditional", history.length),
        stats: Formatter.isAlgorithmSupported("stats", history.length),
        omission: Formatter.isAlgorithmSupported("omission", history.length),
        association: Formatter.isAlgorithmSupported("association", history.length),
        math: Formatter.isAlgorithmSupported("math", history.length),
        zone: Formatter.isAlgorithmSupported("zone", history.length)
      };
      
      Logger.info("PredictionEngine", "ç®—æ³•æ”¯æŒæ£€æŸ¥", algorithmChecks);
      
      const adjustedWeights = { ...weights };
      if (!algorithmChecks.stats) {
        adjustedWeights.w_statistics_analysis = adjustedWeights.w_statistics_analysis * 0.3;
      }
      if (!algorithmChecks.omission) {
        adjustedWeights.w_omission = adjustedWeights.w_omission * 0.3;
      }
      if (!algorithmChecks.association) {
        adjustedWeights.w_association = adjustedWeights.w_association * 0.3;
      }
      if (!algorithmChecks.math) {
        adjustedWeights.w_math = adjustedWeights.w_math * 0.3;
      }
      if (!algorithmChecks.zone) {
        adjustedWeights.w_zone = adjustedWeights.w_zone * 0.3;
      }
      
      const algorithmPromises = [];
      
      algorithmPromises.push(
        this.generateTraditionalPrediction(history, adjustedWeights)
          .catch(error => {
            Logger.error("PredictionEngine", "ä¼ ç»Ÿç®—æ³•å¤±è´¥", error);
            return this.generateStaticFallback();
          })
      );
      
      if (algorithmChecks.stats) {
        algorithmPromises.push(
          this.generateStatsPrediction(history, adjustedWeights)
            .catch(error => {
              Logger.error("PredictionEngine", "ç»Ÿè®¡ç®—æ³•å¤±è´¥", error);
              return null;
            })
        );
      }
      
      const montePromise = new Promise((resolve) => {
        const timeout = setTimeout(() => {
          Logger.warn("PredictionEngine", "è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿè¶…æ—¶");
          resolve(null);
        }, 4000);
        
        OptimizedMonteCarloEngine.runOptimizedSimulation(history, 6000)
          .then(result => {
            clearTimeout(timeout);
            resolve(result);
          })
          .catch(error => {
            clearTimeout(timeout);
            Logger.error("PredictionEngine", "è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¤±è´¥", error);
            resolve(null);
          });
      });
      
      algorithmPromises.push(montePromise);
      
      const results = await Promise.allSettled(algorithmPromises);
      
      const [traditionalResult, statsResult, monteResult] = results.map(r => 
        r.status === 'fulfilled' ? r.value : null
      );
      
      const algorithmsUsed = {
        traditional: !!traditionalResult,
        statistics: !!statsResult,
        monteCarlo: !!monteResult,
        algorithmsCount: [traditionalResult, statsResult, monteResult].filter(Boolean).length,
        algorithmChecks: algorithmChecks
      };
      
      Logger.info("PredictionEngine", "ç®—æ³•å®Œæˆæƒ…å†µ", algorithmsUsed);
      
      if (algorithmsUsed.algorithmsCount === 0) {
        Logger.warn("PredictionEngine", "æ‰€æœ‰ç®—æ³•å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿç®—æ³•åå¤‡");
        return await this.generateTraditionalPrediction(history, weights);
      }
      
      const fallbackResult = traditionalResult || this.generateStaticFallback();
      
      const integratedScores = {};
      
      for (let i = 1; i <= 49; i++) {
        integratedScores[i] = { score: 0, probability: 0, contributions: [] };
      }
      
      if (traditionalResult && traditionalResult.specialNumbers) {
        for (const item of traditionalResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 0.8 * adjustedWeights.w_zodiac_transfer;
            integratedScores[item.number].contributions.push({
              algorithm: 'traditional',
              score: item.score || 0,
              weight: adjustedWeights.w_zodiac_transfer
            });
          }
        }
      }
      
      if (statsResult && statsResult.specialNumbers) {
        for (const item of statsResult.specialNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 1.8 * adjustedWeights.w_statistics_analysis;
            integratedScores[item.number].contributions.push({
              algorithm: 'statistics',
              score: item.score || 0,
              weight: adjustedWeights.w_statistics_analysis
            });
          }
        }
      }
      
      if (monteResult && monteResult.specialPredictions) {
        for (const item of monteResult.specialPredictions) {
          if (item.number >= 1 && item.number <= 49) {
            integratedScores[item.number].score += (item.score || 0) * 2.0 * adjustedWeights.w_monte_carlo;
            integratedScores[item.number].probability = Math.max(
              integratedScores[item.number].probability,
              item.probability || 0
            );
            integratedScores[item.number].contributions.push({
              algorithm: 'montecarlo',
              score: item.score || 0,
              weight: adjustedWeights.w_monte_carlo,
              probability: item.probability
            });
          }
        }
      }
      
      const expertAnalyses = {};
      
      if (algorithmChecks.omission) {
        try {
          const omissionScores = await OmissionExpert.runOmission(history, adjustedWeights);
          if (omissionScores && omissionScores.size > 0) {
            for (const [num, score] of omissionScores) {
              if (num >= 1 && num <= 49) {
                integratedScores[num].score += score * 1.8 * adjustedWeights.w_omission;
                integratedScores[num].contributions.push({
                  algorithm: 'omission',
                  score: score,
                  weight: adjustedWeights.w_omission
                });
              }
            }
            expertAnalyses.omission = OmissionExpert.getOmissionAnalysis(omissionScores);
          }
        } catch (error) {
          Logger.error("PredictionEngine", "é—æ¼å›è¡¥ä¸“å®¶å¤±è´¥", error);
        }
      }
      
      if (algorithmChecks.association) {
        try {
          const lastNumbers = lastRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
          const associationScores = await AssociationExpert.runAssociation(history, adjustedWeights);
          if (associationScores && associationScores.size > 0) {
            for (const [num, score] of associationScores) {
              if (num >= 1 && num <= 49) {
                integratedScores[num].score += score * 1.9 * adjustedWeights.w_association;
                integratedScores[num].contributions.push({
                  algorithm: 'association',
                  score: score,
                  weight: adjustedWeights.w_association
                });
              }
            }
            expertAnalyses.association = AssociationExpert.getAssociationAnalysis(associationScores, lastNumbers);
          }
        } catch (error) {
          Logger.error("PredictionEngine", "å…³è”è§„åˆ™ä¸“å®¶å¤±è´¥", error);
        }
      }
      
      if (algorithmChecks.math) {
        try {
          const lastSpecial = Formatter.safeInt(lastRecord.open_code.split(",")[6] || 1);
          const mathScores = await MathExpert.runMathLogic(history, adjustedWeights);
          if (mathScores && mathScores.size > 0) {
            for (const [num, score] of mathScores) {
              if (num >= 1 && num <= 49) {
                integratedScores[num].score += score * 1.7 * adjustedWeights.w_math;
                integratedScores[num].contributions.push({
                  algorithm: 'math',
                  score: score,
                  weight: adjustedWeights.w_math
                });
              }
            }
            expertAnalyses.math = MathExpert.getMathAnalysis(mathScores, lastSpecial);
          }
        } catch (error) {
          Logger.error("PredictionEngine", "é»„é‡‘åˆ†å‰²ä¸“å®¶å¤±è´¥", error);
        }
      }
      
      if (algorithmChecks.zone) {
        try {
          const zoneScores = await ZoneExpert.runZoneAnalysis(history, adjustedWeights);
          if (zoneScores && zoneScores.size > 0) {
            for (const [num, score] of zoneScores) {
              if (num >= 1 && num <= 49) {
                integratedScores[num].score += score * 1.9 * adjustedWeights.w_zone;
                integratedScores[num].contributions.push({
                  algorithm: 'zone',
                  score: score,
                  weight: adjustedWeights.w_zone
                });
              }
            }
            expertAnalyses.zone = ZoneExpert.getZoneAnalysis(zoneScores, history);
          }
        } catch (error) {
          Logger.error("PredictionEngine", "åŒºé—´å¹³è¡¡ä¸“å®¶å¤±è´¥", error);
        }
      }
      
      const topSpecialNumbers = this.getTopSpecialPredictions(integratedScores, 10);
      const zodiacPrediction = this.getZodiacPredictions(integratedScores);
      const colorPrediction = this.getColorPredictions(integratedScores);
      
      const excludeSpecials = topSpecialNumbers.slice(0, 5).map(item => item.number);
      
      const integratedNormals = {};
      for (let i = 1; i <= 49; i++) {
        integratedNormals[i] = { score: 0, probability: 0 };
      }
      
      if (traditionalResult && traditionalResult.normalNumbers) {
        for (const item of traditionalResult.normalNumbers) {
          if (item.number >= 1 && item.number <= 49) {
            integratedNormals[item.number].score += (item.score || 0) * 0.8;
          }
        }
      }
      
      if (monteResult && monteResult.normalPredictions) {
        for (const item of monteResult.normalPredictions) {
          if (item.number >= 1 && item.number <= 49) {
            integratedNormals[item.number].score += (item.score || 0) * 1.5;
            integratedNormals[item.number].probability = item.probability || 0;
          }
        }
      }
      
      const excludeSet = new Set(excludeSpecials);
      const normalPredictions = Object.entries(integratedNormals)
        .filter(([num, _]) => !excludeSet.has(Formatter.safeInt(num)))
        .map(([num, data]) => ({
          number: Formatter.safeInt(num),
          score: data.score,
          probability: data.probability
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, 6);
      
      const bestNumber = topSpecialNumbers[0]?.number || 1;
      const isBig = bestNumber >= 25;
      const isOdd = bestNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(bestNumber / 10);
      
      let confidence = 40;
      
      if (traditionalResult) confidence += 15;
      if (statsResult) confidence += 15;
      if (monteResult) confidence += 15;
      
      if (expertAnalyses.omission) confidence += 8;
      if (expertAnalyses.association) confidence += 8;
      if (expertAnalyses.math) confidence += 7;
      if (expertAnalyses.zone) confidence += 7;
      
      if (history.length > 50) confidence += 10;
      if (history.length > 100) confidence += 5;
      
      confidence = Math.min(95, confidence);
      
      const formattedSpecials = topSpecialNumbers.slice(0, 5).map(item => ({
        number: item?.number || 1,
        score: item?.score || 0,
        probability: item?.probability || 0,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        contributions: integratedScores[item?.number]?.contributions || []
      }));
      
      const formattedNormals = normalPredictions.map(item => ({
        number: item?.number || 1,
        zodiac: Formatter.getAttributes(item?.number || 1).zodiac,
        color: Formatter.getAttributes(item?.number || 1).color,
        score: item?.score || 0,
        probability: item?.probability || 0
      }));
      
      const algorithmDetails = {
        traditional: {
          used: !!traditionalResult,
          supported: algorithmChecks.traditional,
          confidence: traditionalResult?.confidence || 0
        },
        statistics: {
          used: !!statsResult,
          supported: algorithmChecks.stats,
          patternsFound: statsResult?.statisticalAnalysis?.patterns?.length || 0
        },
        monteCarlo: {
          used: !!monteResult,
          simulations: monteResult?.simulations || 0
        },
        omission: {
          used: !!expertAnalyses.omission,
          supported: algorithmChecks.omission
        },
        association: {
          used: !!expertAnalyses.association,
          supported: algorithmChecks.association
        },
        math: {
          used: !!expertAnalyses.math,
          supported: algorithmChecks.math
        },
        zone: {
          used: !!expertAnalyses.zone,
          supported: algorithmChecks.zone
        },
        totalAlgorithmsUsed: algorithmsUsed.algorithmsCount + Object.keys(expertAnalyses).length
      };
      
      const comprehensiveAnalysis = {
        traditionalConfidence: traditionalResult?.confidence || 0,
        statisticalPatterns: statsResult?.statisticalAnalysis?.patterns?.slice(0, 3) || [],
        monteCarloSimulations: monteResult?.simulations || 0,
        
        omissionAnalysis: expertAnalyses.omission || null,
        associationAnalysis: expertAnalyses.association || null,
        mathAnalysis: expertAnalyses.math || null,
        zoneAnalysis: expertAnalyses.zone || null,
        
        algorithmIntegration: `${algorithmDetails.totalAlgorithmsUsed}ç§ç®—æ³•åŠ æƒæ•´åˆ`,
        integrationDetails: `ä¼ ç»Ÿ(${traditionalResult ? 'âœ“' : 'âœ—'}) ç»Ÿè®¡(${statsResult ? 'âœ“' : 'âœ—'}) è’™ç‰¹å¡æ´›(${monteResult ? 'âœ“' : 'âœ—'}) é—æ¼(${expertAnalyses.omission ? 'âœ“' : 'âœ—'}) å…³è”(${expertAnalyses.association ? 'âœ“' : 'âœ—'}) æ•°å­¦(${expertAnalyses.math ? 'âœ“' : 'âœ—'}) åŒºé—´(${expertAnalyses.zone ? 'âœ“' : 'âœ—'})`,
        confidenceFactors: {
          algorithmCount: algorithmDetails.totalAlgorithmsUsed,
          historyRecords: history.length,
          weightedScore: confidence
        }
      };
      
      return {
        zodiac: zodiacPrediction,
        color: colorPrediction,
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: formattedSpecials,
        normalNumbers: formattedNormals,
        confidence: confidence,
        analysisBased: true,
        algorithmUsed: "advanced",
        algorithmsUsed: algorithmDetails,
        comprehensiveAnalysis: comprehensiveAnalysis,
        expertAnalyses: expertAnalyses,
        monteCarloUsed: !!monteResult,
        nextExpect: this.calculateNextExpect(lastRecord.expect || "2025000"),
        basedOnLastRecord: {
          expect: lastRecord.expect || "æœªçŸ¥",
          openCode: lastRecord.open_code || "æœªçŸ¥",
          special: Formatter.safeInt((lastRecord.open_code || "1,2,3,4,5,6,7").split(",")[6], 1),
          zodiac: Formatter.getAttributes(Formatter.safeInt((lastRecord.open_code || "1,2,3,4,5,6,7").split(",")[6], 1)).zodiac,
          color: Formatter.getAttributes(Formatter.safeInt((lastRecord.open_code || "1,2,3,4,5,6,7").split(",")[6], 1)).color
        },
        totalHistoryRecords: history.length,
        generatedAt: new Date().toISOString(),
        algorithmVersion: `V15.1-Advanced-${algorithmDetails.totalAlgorithmsUsed}Algos`,
        fallbackUsed: !traditionalResult
      };
    } catch (error) {
      Logger.error("PredictionEngine", "å¢å¼ºé¢„æµ‹ç”Ÿæˆå¤±è´¥", error);
      try {
        return await this.generateTraditionalPrediction(history, weights);
      } catch (fallbackError) {
        Logger.error("PredictionEngine", "ä¼ ç»Ÿç®—æ³•åå¤‡ä¹Ÿå¤±è´¥", fallbackError);
        return this.generateStaticFallback();
      }
    }
  }
  
  static calculateNextExpect(currentExpect) {
    try {
      if (!currentExpect) {
        return "2025001";
      }
      
      const currentNum = Formatter.safeInt(currentExpect, 2025000);
      return (currentNum + 1).toString();
    } catch (error) {
      return "2025001";
    }
  }
  
  static analyzeHistoryStatistics(history) {
    try {
      if (!history || !Array.isArray(history) || history.length < 2) {
        return this.createEmptyStats();
      }

      const stats = this.createEmptyStats();
      const maxRecords = Math.min(history.length, 200);
      const historySlice = history.slice(0, maxRecords);
      
      for (let i = 0; i < historySlice.length - 1; i++) {
        const currentRecord = historySlice[i];
        const nextRecord = historySlice[i + 1];
        
        if (!currentRecord || !nextRecord || !currentRecord.open_code || !nextRecord.open_code) {
          continue;
        }
        
        const currentNums = currentRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        const nextNums = nextRecord.open_code.split(",").map(n => Formatter.safeInt(n, 0));
        
        if (currentNums.length < 7 || nextNums.length < 7) {
          continue;
        }
        
        const currentSpecial = currentNums[6] || 1;
        const nextSpecial = nextNums[6] || 1;
        const nextNormals = nextNums.slice(0, 6);
        
        const currentAttr = Formatter.getAttributes(currentSpecial);
        const nextAttr = Formatter.getAttributes(nextSpecial);
        
        if (currentAttr.zodiac && nextAttr.zodiac) {
          const key = `${currentAttr.zodiac}->${nextAttr.zodiac}`;
          stats.zodiacTransfer[key] = (stats.zodiacTransfer[key] || 0) + 1;
        }
        
        if (currentAttr.color && nextAttr.color) {
          const key = `${currentAttr.color}->${nextAttr.color}`;
          stats.colorTransfer[key] = (stats.colorTransfer[key] || 0) + 1;
        }
        
        if (nextSpecial >= 1 && nextSpecial <= 49) {
          stats.specialFrequency[nextSpecial] = (stats.specialFrequency[nextSpecial] || 0) + 1;
        }
        
        nextNormals.forEach(num => {
          if (num >= 1 && num <= 49) {
            stats.normalFrequency[num] = (stats.normalFrequency[num] || 0) + 1;
          }
        });
      }

      this.normalizeStatistics(stats);
      stats.totalRecords = historySlice.length;
      
      return stats;
    } catch (error) {
      Logger.error("Stats", "åˆ†æå†å²æ•°æ®æ—¶å‡ºé”™", error);
      return this.createEmptyStats();
    }
  }

  static createEmptyStats() {
    try {
      const stats = {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: {},
        specialFrequency: {},
        normalFrequency: {}
      };
      
      this.initializeStatsStructure(stats);
      return stats;
    } catch (error) {
      return {
        totalRecords: 0,
        zodiacTransfer: {},
        colorTransfer: {},
        specialFrequency: {},
        normalFrequency: {}
      };
    }
  }

  static initializeStatsStructure(stats) {
    try {
      for (let i = 1; i <= 49; i++) {
        if (stats.specialFrequency[i] === undefined) {
          stats.specialFrequency[i] = 0;
        }
        if (stats.normalFrequency[i] === undefined) {
          stats.normalFrequency[i] = 0;
        }
      }
    } catch (error) {
      Logger.error("Stats", "åˆå§‹åŒ–ç»Ÿè®¡ç»“æ„å¤±è´¥", error);
    }
  }

  static normalizeStatistics(stats) {
    try {
      const zodiacTotals = {};
      Object.keys(stats.zodiacTransfer).forEach(key => {
        const [from] = key.split('->');
        zodiacTotals[from] = (zodiacTotals[from] || 0) + stats.zodiacTransfer[key];
      });
      
      Object.keys(stats.zodiacTransfer).forEach(key => {
        const [from] = key.split('->');
        if (zodiacTotals[from] > 0) {
          stats.zodiacTransfer[key] = stats.zodiacTransfer[key] / zodiacTotals[from];
        }
      });
      
      const colorTotals = {};
      Object.keys(stats.colorTransfer).forEach(key => {
        const [from] = key.split('->');
        colorTotals[from] = (colorTotals[from] || 0) + stats.colorTransfer[key];
      });
      
      Object.keys(stats.colorTransfer).forEach(key => {
        const [from] = key.split('->');
        if (colorTotals[from] > 0) {
          stats.colorTransfer[key] = stats.colorTransfer[key] / colorTotals[from];
        }
      });
    } catch (error) {
      Logger.error("Stats", "å½’ä¸€åŒ–ç»Ÿè®¡å¤±è´¥", error);
    }
  }

  static generateTraditionalScores(lastSpecial, stats, weights) {
    const scores = {};
    
    try {
      const lastAttr = Formatter.getAttributes(lastSpecial);
      
      for (let num = 1; num <= 49; num++) {
        const attr = Formatter.getAttributes(num);
        let score = 0;
        
        if (lastAttr.zodiac && attr.zodiac) {
          const key = `${lastAttr.zodiac}->${attr.zodiac}`;
          if (stats.zodiacTransfer[key]) {
            score += stats.zodiacTransfer[key] * 120 * weights.w_zodiac_transfer;
          }
        }
        
        if (CONFIG.ZODIAC_RELATIONS.SIX_HARMONY[lastAttr.zodiac] === attr.zodiac) {
          score += 90 * weights.w_zodiac_relation;
        }
        
        const threeHarmony = CONFIG.ZODIAC_RELATIONS.THREE_HARMONY[lastAttr.zodiac];
        if (threeHarmony && threeHarmony.includes(attr.zodiac)) {
          score += 70 * weights.w_zodiac_relation;
        }
        
        if (lastAttr.color && attr.color) {
          const key = `${lastAttr.color}->${attr.color}`;
          if (stats.colorTransfer[key]) {
            const colorProb = stats.colorTransfer[key];
            score += colorProb * 110 * weights.w_color_transfer;
          }
        }
        
        const lastTail = lastSpecial % 10;
        const currentTail = num % 10;
        
        if (lastTail === currentTail) {
          score += 90 * weights.w_tail_correlation;
        } else if (Math.abs(lastTail - currentTail) === 1) {
          score += 50 * weights.w_tail_correlation;
        }
        
        if (stats.specialFrequency[num]) {
          const freq = stats.specialFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 70 * weights.w_number_frequency;
        }
        
        const patterns = Formatter.calculateNumberPattern(num);
        if (patterns.length > 0) {
          score += patterns.length * 15 * weights.w_number_pattern;
        }
        
        const randomFactor = 0.95 + Math.random() * 0.1;
        score *= randomFactor;
        
        scores[num] = {
          score: score,
          probability: 0
        };
      }
      
      return scores;
    } catch (error) {
      Logger.error("Stats", "ç”Ÿæˆé¢„æµ‹åˆ†æ•°å¤±è´¥", error);
      
      for (let num = 1; num <= 49; num++) {
        scores[num] = {
          score: Math.random() * 100,
          probability: 0
        };
      }
      
      return scores;
    }
  }

  static getTopSpecialPredictions(scores, topN = 10) {
    try {
      const scoreArray = Object.entries(scores || {})
        .map(([num, data]) => ({
          number: Formatter.safeInt(num, 0),
          score: data.score,
          probability: data.probability
        }))
        .filter(item => item.number >= 1 && item.number <= 49);
      
      scoreArray.sort((a, b) => b.score - a.score);
      return scoreArray.slice(0, topN);
    } catch (error) {
      Logger.error("Stats", "è·å–ç‰¹ç é¢„æµ‹å¤±è´¥", error);
      return [];
    }
  }

  static getZodiacPredictions(scores) {
    try {
      const zodiacScores = {};
      
      for (let num = 1; num <= 49; num++) {
        const zodiac = Formatter.getAttributes(num).zodiac;
        const scoreData = scores[num] || { score: 0, probability: 0 };
        
        if (!zodiacScores[zodiac]) {
          zodiacScores[zodiac] = { total: 0, count: 0, numbers: [] };
        }
        zodiacScores[zodiac].total += scoreData.score;
        zodiacScores[zodiac].count++;
        zodiacScores[zodiac].numbers.push(num);
      }
      
      const zodiacAvgScores = {};
      Object.keys(zodiacScores).forEach(zodiac => {
        const data = zodiacScores[zodiac];
        zodiacAvgScores[zodiac] = {
          average: data.total / Math.max(1, data.count),
          total: data.total,
          count: data.count,
          numbers: data.numbers
        };
      });
      
      const sortedZodiacs = Object.entries(zodiacAvgScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedZodiacs.slice(0, 3),
        guard: sortedZodiacs.slice(3, 6),
        scores: zodiacAvgScores
      };
    } catch (error) {
      Logger.error("Stats", "è·å–ç”Ÿè‚–é¢„æµ‹å¤±è´¥", error);
      return {
        main: [],
        guard: [],
        scores: {}
      };
    }
  }

  static getColorPredictions(scores) {
    try {
      const colorScores = {};
      
      ['red', 'blue', 'green'].forEach(color => {
        const numbers = CONFIG.COLORS[color] || [];
        let total = 0;
        let maxScore = -Infinity;
        let bestNumber = 0;
        
        numbers.forEach(num => {
          const scoreData = scores[num] || { score: 0, probability: 0 };
          total += scoreData.score;
          if (scoreData.score > maxScore) {
            maxScore = scoreData.score;
            bestNumber = num;
          }
        });
        
        colorScores[color] = {
          average: total / Math.max(1, numbers.length),
          total: total,
          count: numbers.length,
          bestNumber: bestNumber,
          maxScore: maxScore
        };
      });
      
      const sortedColors = Object.entries(colorScores)
        .sort((a, b) => b[1].average - a[1].average)
        .map(entry => entry[0]);
      
      return {
        main: sortedColors[0],
        guard: sortedColors[1],
        scores: colorScores
      };
    } catch (error) {
      Logger.error("Stats", "è·å–é¢œè‰²é¢„æµ‹å¤±è´¥", error);
      return {
        main: "red",
        guard: "blue",
        scores: {}
      };
    }
  }

  static generateNormalPredictions(stats, weights, excludeNumbers = []) {
    const normalScores = {};
    const excludeSet = new Set(excludeNumbers || []);
    
    try {
      for (let num = 1; num <= 49; num++) {
        if (excludeSet.has(num)) {
          normalScores[num] = { score: -999999, probability: 0 };
          continue;
        }
        
        let score = 0;
        
        if (stats.normalFrequency[num]) {
          const freq = stats.normalFrequency[num] / Math.max(1, stats.totalRecords);
          score += freq * 160 * weights.w_number_frequency;
        }
        
        const patterns = Formatter.calculateNumberPattern(num);
        if (patterns.length > 0) {
          score += patterns.length * 18 * weights.w_number_pattern;
        }
        
        const randomFactor = 0.96 + Math.random() * 0.08;
        score *= randomFactor;
        
        normalScores[num] = { score: score, probability: 0 };
      }
      
      const scoreArray = Object.entries(normalScores)
        .filter(([_, data]) => data.score > -999999)
        .map(([num, data]) => ({
          number: Formatter.safeInt(num, 0),
          score: data.score,
          probability: data.probability
        }));
      
      scoreArray.sort((a, b) => b.score - a.score);
      
      return scoreArray.slice(0, 6);
    } catch (error) {
      Logger.error("Stats", "ç”Ÿæˆå¹³ç é¢„æµ‹å¤±è´¥", error);
      
      const randomNumbers = [];
      const used = new Set();
      
      while (randomNumbers.length < 6) {
        const num = Math.floor(Math.random() * 49) + 1;
        if (!used.has(num) && !excludeSet.has(num)) {
          used.add(num);
          randomNumbers.push({
            number: num,
            score: Math.random() * 100,
            probability: 0
          });
        }
      }
      
      return randomNumbers;
    }
  }

  static calculateTraditionalConfidence(topSpecialNumbers, historyCount) {
    try {
      let confidence = 25;
      
      if (topSpecialNumbers.length > 0) {
        const maxScore = topSpecialNumbers[0]?.score || 50;
        const avgScore = topSpecialNumbers.reduce((sum, item) => sum + (item?.score || 0), 0) / Math.max(1, topSpecialNumbers.length);
        const scoreRatio = maxScore / Math.max(1, avgScore);
        
        confidence += scoreRatio * 20;
      }
      
      confidence += Math.min(15, historyCount / 30);
      
      confidence = Math.min(90, Math.max(20, Math.floor(confidence)));
      
      return confidence;
    } catch (error) {
      Logger.error("PredictionEngine", "è®¡ç®—ç½®ä¿¡åº¦å¤±è´¥", error);
      return 50;
    }
  }

  static generateStaticFallback() {
    try {
      const date = new Date();
      const day = date.getDate();
      const hour = date.getHours();
      
      const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
      const colors = ['red', 'blue', 'green'];
      
      const zodiacIndex = (day * hour) % allZodiacs.length;
      const colorIndex = (day + hour) % colors.length;
      
      const mainZodiac = allZodiacs[zodiacIndex] || "é¼ ";
      const mainColor = colors[colorIndex] || "red";
      
      const candidates = CONFIG.ZODIAC_MAP[mainZodiac] || [1, 13, 25, 37, 49];
      const numIndex = hour % candidates.length;
      const exampleNumber = candidates[numIndex] || 1;
      
      let normalNumbers = [];
      const excludeNumbers = [exampleNumber];
      
      for (let i = 0; i < 6; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((excludeNumbers.includes(num) || normalNumbers.find(n => n.number === num)) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        normalNumbers.push({
          number: num,
          zodiac: attr.zodiac,
          color: attr.color,
          score: Math.floor(Math.random() * 100),
          probability: Math.random() * 0.05
        });
        excludeNumbers.push(num);
      }
      
      const specialNumbers = [];
      for (let i = 0; i < 5; i++) {
        let num;
        let attempts = 0;
        do {
          num = Math.floor(Math.random() * 49) + 1;
          attempts++;
        } while ((specialNumbers.find(n => n.number === num) || num === exampleNumber) && attempts < 20);
        
        const attr = Formatter.getAttributes(num);
        specialNumbers.push({
          number: num,
          score: Math.floor(Math.random() * 100),
          probability: Math.random() * 0.1,
          zodiac: attr.zodiac,
          color: attr.color
        });
      }
      
      const isBig = exampleNumber >= 25;
      const isOdd = exampleNumber % 2 !== 0;
      const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
      const head = Math.floor(exampleNumber / 10);
      
      return {
        nextExpect: "2025001",
        zodiac: {
          main: [
            mainZodiac, 
            allZodiacs[(zodiacIndex + 3) % allZodiacs.length] || "å…”",
            allZodiacs[(zodiacIndex + 6) % allZodiacs.length] || "é©¬"
          ],
          guard: [
            allZodiacs[(zodiacIndex + 1) % allZodiacs.length] || "ç‰›",
            allZodiacs[(zodiacIndex + 4) % allZodiacs.length] || "é¾™"
          ],
          scores: {}
        },
        color: {
          main: mainColor,
          guard: colors[(colorIndex + 1) % colors.length] || "blue",
          scores: {}
        },
        head: `${head}å¤´`,
        shape: shape,
        specialNumbers: specialNumbers,
        normalNumbers: normalNumbers,
        confidence: 20,
        analysisBased: false,
        algorithmUsed: "static",
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V15.1-Static"
      };
    } catch (error) {
      Logger.error("PredictionEngine", "ç”Ÿæˆé™æ€å›é€€é¢„æµ‹æ—¶å‡ºé”™", error);
      
      return {
        nextExpect: "2025001",
        zodiac: { main: ["é¼ ", "é¾™", "çŒ´"], guard: ["ç‰›", "è›‡"], scores: {} },
        color: { main: "red", guard: "blue", scores: {} },
        head: "0å¤´",
        shape: "å°å•",
        specialNumbers: [
          { number: 1, score: 50, probability: 0.1, zodiac: "è›‡", color: "red" },
          { number: 13, score: 45, probability: 0.09, zodiac: "è›‡", color: "blue" },
          { number: 25, score: 40, probability: 0.08, zodiac: "è›‡", color: "green" },
          { number: 37, score: 35, probability: 0.07, zodiac: "è›‡", color: "red" },
          { number: 49, score: 30, probability: 0.06, zodiac: "è›‡", color: "blue" }
        ],
        normalNumbers: [
          { number: 2, zodiac: "é¾™", color: "red", score: 45, probability: 0.05 },
          { number: 3, zodiac: "å…”", color: "blue", score: 40, probability: 0.04 },
          { number: 4, zodiac: "è™", color: "blue", score: 35, probability: 0.03 },
          { number: 5, zodiac: "ç‰›", color: "green", score: 30, probability: 0.02 },
          { number: 6, zodiac: "é¼ ", color: "green", score: 25, probability: 0.01 },
          { number: 7, zodiac: "çŒª", color: "red", score: 20, probability: 0.01 }
        ],
        confidence: 10,
        analysisBased: false,
        algorithmUsed: "emergency",
        totalHistoryRecords: 0,
        generatedAt: new Date().toISOString(),
        algorithmVersion: "V15.1-Emergency"
      };
    }
  }
}

// ==============================================================================
// 13. æ¶ˆæ¯æ¸²æŸ“å™¨ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class MessageRenderer {
  static renderCommandTemplate(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME} - å‘½ä»¤æ¨¡æ¿</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
      message += `${CONFIG.EMOJI.refresh} <i>é˜²åˆ·å±æ¨¡å¼ï¼Œæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</i>\n\n`;
      
      message += `<b>${CONFIG.EMOJI.magic} ä¸»è¦å‘½ä»¤ï¼š</b>\n`;
      message += `<code>/predict</code> - ä¼ ç»Ÿç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict stats</code> - ç»Ÿè®¡ç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹ï¼ˆæ•´åˆå…¨éƒ¨ç®—æ³•ï¼‰${CONFIG.EMOJI.crown}\n`;
      message += `<code>/history [é¡µç ]</code> - æŸ¥çœ‹å†å²è®°å½•\n`;
      message += `<code>/ccc</code> - æ˜¾ç¤ºæ­¤å‘½ä»¤æ¨¡æ¿\n`;
      
      if (isAdmin) {
        message += `\n<b>${CONFIG.EMOJI.lock} ç®¡ç†å‘˜å‘½ä»¤ï¼š</b>\n`;
        message += `<code>/sync</code> - åŒæ­¥å†å²æ•°æ®\n`;
        message += `<code>/push</code> - æ¨é€é¢„æµ‹åˆ°é¢‘é“\n`;
        message += `<code>/delete [æœŸå·]</code> - åˆ é™¤å•æœŸè®°å½•\n`;
      }
      
      message += `\n<b>${CONFIG.EMOJI.crystal_ball} å¢å¼ºé¢„æµ‹ç®—æ³•ï¼š</b>\n`;
      message += `${CONFIG.EMOJI.brain} ä¼ ç»Ÿç®—æ³• - åŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°\n`;
      message += `${CONFIG.EMOJI.statistics} ç»Ÿè®¡ç®—æ³• - ç”Ÿè‚–ã€é¢œè‰²ã€å°¾æ•°ã€å¤´æ•°ã€å¤§å°ã€å•åŒã€å’Œå€¼ã€è·¨åº¦ã€ACå€¼ã€è´¨æ•°å…¨é¢ç»Ÿè®¡\n`;
      message += `${CONFIG.EMOJI.omission} é—æ¼å›è¡¥ä¸“å®¶ - å‡å€¼å›å½’ï¼Œä¸¥é‡é—æ¼å·ç å›è¡¥\n`;
      message += `${CONFIG.EMOJI.association} å…³è”è§„åˆ™ä¸“å®¶ - å·ç å…³è”åˆ†æï¼Œå•¤é…’å°¿å¸ƒç†è®º\n`;
      message += `${CONFIG.EMOJI.math} é»„é‡‘åˆ†å‰²ä¸“å®¶ - æ•°å­¦å¸¸æ•°ã€æ•°åˆ—ã€æ¨¡è¿ç®—åˆ†æ\n`;
      message += `${CONFIG.EMOJI.zone} åŒºé—´å¹³è¡¡ä¸“å®¶ - ç©ºé—´åˆ†å¸ƒå‡åŒ€æ€§ï¼Œå†·çƒ­åŒºé—´å¹³è¡¡\n`;
      message += `${CONFIG.EMOJI.dice} è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ - æ¦‚ç‡æ¨¡æ‹Ÿï¼ŒéšæœºæŠ½æ ·é¢„æµ‹\n`;
      message += `${CONFIG.EMOJI.crown} å¢å¼ºé¢„æµ‹ - æ•´åˆæ‰€æœ‰ç®—æ³•çš„æœ€å¼ºé¢„æµ‹\n`;
      
      message += `\n<b>${CONFIG.EMOJI.rocket} ä½¿ç”¨ç¤ºä¾‹ï¼š</b>\n`;
      message += `<code>/predict</code> - ä¼ ç»Ÿç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict stats</code> - ç»Ÿè®¡ç®—æ³•é¢„æµ‹\n`;
      message += `<code>/predict advanced</code> - å¢å¼ºé¢„æµ‹ï¼ˆæ¨èï¼‰${CONFIG.EMOJI.rocket}\n`;
      message += `<code>/history 1</code> - æŸ¥çœ‹ç¬¬1é¡µå†å²\n`;
      
      message += `\n${CONFIG.EMOJI.atom} <b>V15.1 ç²¾ç®€å¢å¼ºç‰ˆç‰¹æ€§ï¼š</b>\n`;
      message += `${CONFIG.EMOJI.statistics} å¢å¼ºç»Ÿè®¡ç®—æ³•ï¼šå¢åŠ å’Œå€¼ã€è·¨åº¦ã€ACå€¼ã€è´¨æ•°ç»Ÿè®¡\n`;
      message += `${CONFIG.EMOJI.omission} é—æ¼å›è¡¥ä¸“å®¶ï¼šå‡å€¼å›å½’ç†è®º\n`;
      message += `${CONFIG.EMOJI.association} å…³è”è§„åˆ™ä¸“å®¶ï¼šAprioriç®—æ³•\n`;
      message += `${CONFIG.EMOJI.math} é»„é‡‘åˆ†å‰²ä¸“å®¶ï¼šæ•°å­¦æ¨¡å¼è¯†åˆ«\n`;
      message += `${CONFIG.EMOJI.zone} åŒºé—´å¹³è¡¡ä¸“å®¶ï¼šç©ºé—´åˆ†å¸ƒåˆ†æ\n`;
      message += `${CONFIG.EMOJI.trash} ç§»é™¤KNNç®—æ³•ï¼Œå‡å°‘å†—ä½™ä»£ç \n`;
      message += `${CONFIG.EMOJI.speed} æ€§èƒ½ä¼˜åŒ–ï¼Œå“åº”æ›´å¿«\n`;
      
      message += `\n${CONFIG.EMOJI.refresh} <b>é˜²åˆ·å±ç‰¹æ€§ï¼š</b>\n`;
      message += `${CONFIG.EMOJI.trash} æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°ä¸€æ¡æ¶ˆæ¯\n`;
      message += `${CONFIG.EMOJI.repeat} å‘é€ç›¸åŒå‘½ä»¤è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯\n`;
      message += `${CONFIG.EMOJI.eye} ä¿æŒèŠå¤©ç•Œé¢æ•´æ´\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å‘½ä»¤æ¨¡æ¿å¤±è´¥", error);
      return `${CONFIG.EMOJI.bell} <b>${CONFIG.SYSTEM.NAME}</b>\n\nä½¿ç”¨ /ccc æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨ã€‚`;
    }
  }

  static renderWelcomeMessage(isAdmin = false) {
    try {
      let message = `${CONFIG.EMOJI.home} <b>æ¬¢è¿ä½¿ç”¨ ${CONFIG.SYSTEM.NAME}</b>\n`;
      message += `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n\n`;
      message += `${CONFIG.EMOJI.sparkles} <b>ç²¾ç®€å¢å¼ºç‰ˆé¢„æµ‹ç³»ç»Ÿ</b>\n\n`;
      message += `${CONFIG.EMOJI.statistics} å¢å¼ºç»Ÿè®¡ç®—æ³•ï¼šå’Œå€¼ã€è·¨åº¦ã€ACå€¼ã€è´¨æ•°å…¨é¢åˆ†æ\n`;
      message += `${CONFIG.EMOJI.omission} é—æ¼å›è¡¥ä¸“å®¶ï¼šå‡å€¼å›å½’ç†è®º\n`;
      message += `${CONFIG.EMOJI.association} å…³è”è§„åˆ™ä¸“å®¶ï¼šAprioriç®—æ³•\n`;
      message += `${CONFIG.EMOJI.math} é»„é‡‘åˆ†å‰²ä¸“å®¶ï¼šæ•°å­¦æ¨¡å¼è¯†åˆ«\n`;
      message += `${CONFIG.EMOJI.zone} åŒºé—´å¹³è¡¡ä¸“å®¶ï¼šç©ºé—´åˆ†å¸ƒåˆ†æ\n`;
      message += `${CONFIG.EMOJI.trash} ç§»é™¤å†—ä½™ä»£ç ï¼Œæ€§èƒ½ä¼˜åŒ–\n`;
      message += `${CONFIG.EMOJI.refresh} é˜²åˆ·å±æ¶ˆæ¯ç®¡ç†\n`;
      message += `${CONFIG.EMOJI.clock} é¢„æµ‹è¶…æ—¶æ§åˆ¶\n\n`;
      message += `ä½¿ç”¨ <code>/ccc</code> æŸ¥çœ‹å®Œæ•´å‘½ä»¤åˆ—è¡¨\n`;
      message += `ä½¿ç”¨ <code>/predict advanced</code> ç”Ÿæˆå…¨ä¸“å®¶é¢„æµ‹${CONFIG.EMOJI.rocket}\n`;
      message += `ä½¿ç”¨ <code>/predict stats</code> æŸ¥çœ‹ç»Ÿè®¡é¢„æµ‹\n`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¬¢è¿æ¶ˆæ¯å¤±è´¥", error);
      return `${CONFIG.EMOJI.home} <b>${CONFIG.SYSTEM.NAME}</b>\n\nç³»ç»Ÿè¿è¡Œæ­£å¸¸ã€‚`;
    }
  }

  static renderPrediction(prediction) {
    try {
      if (!prediction) {
        return `${CONFIG.EMOJI.warning} é¢„æµ‹æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•ã€‚`;
      }
      
      const nextExpect = Formatter.safeString(prediction.nextExpect, "æœªçŸ¥");
      const confidence = Formatter.safeInt(prediction.confidence, 0);
      const specialNumbers = Array.isArray(prediction.specialNumbers) ? prediction.specialNumbers : [];
      const normalNumbers = Array.isArray(prediction.normalNumbers) ? prediction.normalNumbers : [];
      const basedOnLastRecord = prediction.basedOnLastRecord || {};
      const algorithmUsed = Formatter.safeString(prediction.algorithmUsed, "traditional");
      const totalHistoryRecords = Formatter.safeInt(prediction.totalHistoryRecords, 0);
      const zodiac = prediction.zodiac || { main: [], guard: [], scores: {} };
      const color = prediction.color || { main: "red", guard: "blue", scores: {} };
      const head = Formatter.safeString(prediction.head, "æœªçŸ¥");
      const shape = Formatter.safeString(prediction.shape, "æœªçŸ¥");
      const algorithmVersion = Formatter.safeString(prediction.algorithmVersion, "V15.1");
      const expertAnalyses = prediction.expertAnalyses || {};
      
      let algorithmInfo = "";
      if (algorithmUsed === "advanced") {
        algorithmInfo = `${CONFIG.EMOJI.crown} <b>å…¨ä¸“å®¶ç®—æ³•é¢„æµ‹ (æ•´åˆ7å¤§ç®—æ³•)</b>\n`;
      } else if (algorithmUsed === "stats") {
        algorithmInfo = `${CONFIG.EMOJI.statistics} <b>ç»Ÿè®¡ç®—æ³•é¢„æµ‹</b>\n`;
      } else if (algorithmUsed === "traditional") {
        algorithmInfo = `${CONFIG.EMOJI.brain} <b>ä¼ ç»Ÿç®—æ³•é¢„æµ‹</b>\n`;
      } else {
        algorithmInfo = `${CONFIG.EMOJI.magic} <b>é¢„æµ‹ç»“æœ</b>\n`;
      }
      
      if (prediction.algorithmTimeout) {
        algorithmInfo += `${CONFIG.EMOJI.warning} <i>æ³¨: ${CONFIG.ALGORITHM_NAMES[prediction.originalAlgorithm]}è¶…æ—¶ï¼Œå·²åˆ‡æ¢ä¸ºä¼ ç»Ÿç®—æ³•</i>\n`;
      }
      
      let algorithmDetails = "";
      if (algorithmUsed === "advanced" && prediction.algorithmsUsed) {
        const used = prediction.algorithmsUsed;
        algorithmDetails = `${CONFIG.EMOJI.gear} <b>ç®—æ³•æ•´åˆ:</b> `;
        const algorithms = [];
        if (used.traditional) algorithms.push("ä¼ ç»Ÿ");
        if (used.statistics) algorithms.push("ç»Ÿè®¡");
        if (used.monteCarlo) algorithms.push("è’™ç‰¹å¡æ´›");
        if (used.omission) algorithms.push("é—æ¼");
        if (used.association) algorithms.push("å…³è”");
        if (used.math) algorithms.push("æ•°å­¦");
        if (used.zone) algorithms.push("åŒºé—´");
        
        if (algorithms.length > 0) {
          algorithmDetails += `${algorithms.join("+")} (${used.totalAlgorithmsUsed || 0}ç§ç®—æ³•)\n`;
        }
      }
      
      let dataSource = "";
      if (prediction.analysisBased && totalHistoryRecords > 0) {
        dataSource = `${CONFIG.EMOJI.database} åŸºäº ${totalHistoryRecords} æœŸå†å²æ•°æ®åˆ†æ\n`;
      } else {
        dataSource = `${CONFIG.EMOJI.warning} åŸºäºé™æ€ç®—æ³•ç”Ÿæˆ\n`;
      }
      
      let basedOnInfo = "";
      if (basedOnLastRecord.expect) {
        const { expect, special } = basedOnLastRecord;
        const attr = Formatter.getAttributes(special);
        basedOnInfo = `${CONFIG.EMOJI.history} åŸºäº: ç¬¬ ${expect} æœŸ (ç‰¹ç ${special} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]})\n`;
      }
      
      let statsSummary = "";
      if (prediction.statisticalAnalysis) {
        const stats = prediction.statisticalAnalysis;
        
        if (stats.summary && stats.summary.strongPatterns && stats.summary.strongPatterns.length > 0) {
          statsSummary += `\n${CONFIG.EMOJI.statistics} <b>ç»Ÿè®¡è§„å¾‹</b>\n`;
          stats.summary.strongPatterns.slice(0, 2).forEach(pattern => {
            statsSummary += `${CONFIG.EMOJI.chart} ${pattern}\n`;
          });
        }
        
        if (stats.sumPrediction) {
          statsSummary += `${CONFIG.EMOJI.sum} å’Œå€¼é¢„æµ‹: ${stats.sumPrediction}\n`;
        }
        
        if (stats.spanPrediction) {
          statsSummary += `${CONFIG.EMOJI.span} è·¨åº¦é¢„æµ‹: ${stats.spanPrediction}\n`;
        }
        
        if (stats.acValuePrediction) {
          statsSummary += `${CONFIG.EMOJI.ac} ACå€¼é¢„æµ‹: ${stats.acValuePrediction}\n`;
        }
        
        if (stats.primeCountPrediction) {
          statsSummary += `${CONFIG.EMOJI.prime} è´¨æ•°é¢„æµ‹: ${stats.primeCountPrediction}\n`;
        }
      }
      
      let expertSummary = "";
      
      if (expertAnalyses.omission) {
        const omission = expertAnalyses.omission;
        if (omission.topRecommendations && omission.topRecommendations.length > 0) {
          expertSummary += `\n${CONFIG.EMOJI.omission} <b>é—æ¼å›è¡¥ä¸“å®¶</b>\n`;
          omission.topRecommendations.slice(0, 2).forEach(rec => {
            expertSummary += `${CONFIG.EMOJI.thermometer} ${rec.number}(${rec.zodiac}) - ${rec.reason}\n`;
          });
        }
      }
      
      if (expertAnalyses.association) {
        const association = expertAnalyses.association;
        if (association.topAssociations && association.topAssociations.length > 0) {
          if (!expertSummary.includes("ä¸“å®¶")) {
            expertSummary += `\n${CONFIG.EMOJI.association} <b>å…³è”è§„åˆ™ä¸“å®¶</b>\n`;
          } else {
            expertSummary += `${CONFIG.EMOJI.association} <b>å…³è”è§„åˆ™ä¸“å®¶</b>\n`;
          }
          association.topAssociations.slice(0, 2).forEach(assoc => {
            expertSummary += `${CONFIG.EMOJI.link} ${assoc.number}(${assoc.zodiac}) - ${assoc.reason}\n`;
          });
        }
      }
      
      if (expertAnalyses.math) {
        const math = expertAnalyses.math;
        if (math.goldenRatioRecommendations && math.goldenRatioRecommendations.length > 0) {
          if (!expertSummary.includes("ä¸“å®¶")) {
            expertSummary += `\n${CONFIG.EMOJI.math} <b>é»„é‡‘åˆ†å‰²ä¸“å®¶</b>\n`;
          } else {
            expertSummary += `${CONFIG.EMOJI.math} <b>é»„é‡‘åˆ†å‰²ä¸“å®¶</b>\n`;
          }
          math.goldenRatioRecommendations.slice(0, 2).forEach(rec => {
            expertSummary += `${CONFIG.EMOJI.golden} ${rec.number}(${rec.zodiac}) - ${rec.reason}\n`;
          });
        }
      }
      
      if (expertAnalyses.zone) {
        const zone = expertAnalyses.zone;
        if (zone.zoneRecommendations && zone.zoneRecommendations.length > 0) {
          if (!expertSummary.includes("ä¸“å®¶")) {
            expertSummary += `\n${CONFIG.EMOJI.zone} <b>åŒºé—´å¹³è¡¡ä¸“å®¶</b>\n`;
          } else {
            expertSummary += `${CONFIG.EMOJI.zone} <b>åŒºé—´å¹³è¡¡ä¸“å®¶</b>\n`;
          }
          zone.zoneRecommendations.slice(0, 2).forEach(rec => {
            expertSummary += `${CONFIG.EMOJI.target2} ${rec.number}(${rec.zodiac}) - ${rec.reason}\n`;
          });
        }
      }
      
      let advancedSummary = "";
      if (prediction.comprehensiveAnalysis) {
        const analysis = prediction.comprehensiveAnalysis;
        advancedSummary += `\n${CONFIG.EMOJI.crown} <b>å…¨ä¸“å®¶ç®—æ³•æ•´åˆ</b>\n`;
        
        if (analysis.algorithmIntegration) {
          advancedSummary += `${CONFIG.EMOJI.gear} ${analysis.algorithmIntegration}\n`;
        }
        
        if (analysis.monteCarloSimulations > 0) {
          advancedSummary += `${CONFIG.EMOJI.dice} è’™ç‰¹å¡æ´›: ${analysis.monteCarloSimulations} æ¬¡æ¨¡æ‹Ÿ\n`;
        }
        
        if (analysis.integrationDetails) {
          advancedSummary += `${CONFIG.EMOJI.info} ç®—æ³•è¯¦æƒ…: ${analysis.integrationDetails}\n`;
        }
      }
      
      let normalDisplay = "æš‚æ— æ•°æ®";
      if (normalNumbers.length > 0) {
        normalDisplay = normalNumbers.slice(0, 6).map(num => 
          `${num?.number || "?"}(${num?.zodiac || "?"}${CONFIG.EMOJI[num?.color] || ""})`
        ).join("  ");
      }
      
      let specialDisplay = "æš‚æ— æ•°æ®";
      if (specialNumbers.length > 0) {
        specialDisplay = specialNumbers.slice(0, 5).map((num, index) => {
          const numStr = `${num?.number || "?"}`;
          const zodiacStr = num?.zodiac || "?";
          const colorEmoji = CONFIG.EMOJI[num?.color] || "";
          const prob = num?.probability ? `(${(num.probability * 100).toFixed(1)}%)` : "";
          const rank = index + 1;
          
          return `${rank}. ${numStr}(${zodiacStr}${colorEmoji})${prob}`;
        }).join("\n");
      }
      
      const zodiacMain = Array.isArray(zodiac.main) ? zodiac.main : [];
      const zodiacGuard = Array.isArray(zodiac.guard) ? zodiac.guard : [];
      
      const content = `
${CONFIG.EMOJI.fire} <b>${CONFIG.SYSTEM.NAME} - é¢„æµ‹ç»“æœ</b>
${algorithmInfo}ç¬¬ <b>${nextExpect}</b> æœŸ
${algorithmDetails}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${basedOnInfo}
${CONFIG.EMOJI.star} <b>ç”Ÿè‚–æ¨è</b>
ä¸»æ¨: ${zodiacMain.join(" ") || "æš‚æ— "}
é˜²å®ˆ: ${zodiacGuard.join(" ") || "æš‚æ— "}

${CONFIG.EMOJI.diamond} <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[color.main] || ""} / é˜²${CONFIG.EMOJI[color.guard] || ""}

${CONFIG.EMOJI.rocket} <b>ç‰¹ç å‚è€ƒ (æ¦‚ç‡)</b>
${specialDisplay}

<b>ç²¾é€‰å¹³ç </b>
${normalDisplay}${statsSummary}${expertSummary}${advancedSummary}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${CONFIG.EMOJI.target} <b>å½¢æ€åˆ†æ</b>
å¤´æ•°: ${head} | å½¢æ€: ${shape}

${CONFIG.EMOJI.chart_up} <b>ç½®ä¿¡åº¦</b>: ${confidence}%
${CONFIG.EMOJI.clock} <b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt || Date.now()).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
${CONFIG.EMOJI.cpu} <b>ç®—æ³•ç‰ˆæœ¬</b>: ${algorithmVersion}
${CONFIG.EMOJI.memory} <b>å†å²æ•°æ®</b>: ${totalHistoryRecords} æœŸ
${CONFIG.EMOJI.refresh} <b>æ¶ˆæ¯æ¨¡å¼</b>: æ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯
      `.trim();

      return content;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“é¢„æµ‹æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} æ¸²æŸ“é¢„æµ‹æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderHistory(history, page, totalPages, totalRecords) {
    try {
      let message = `<b>${CONFIG.EMOJI.database} å†å²å¼€å¥–è®°å½•</b>\n`;
      message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
      message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

      if (!history || !Array.isArray(history) || history.length === 0) {
        message += "æš‚æ— å¼€å¥–è®°å½•\n";
      } else {
        history.forEach(r => {
          if (r && r.expect && r.open_code) {
            const special = Formatter.safeInt(r.open_code.split(",")[6], 0);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          }
        });
      }

      message += `\nä½¿ç”¨ <code>/history ${page + 1}</code> æŸ¥çœ‹ä¸‹ä¸€é¡µ`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /history å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“å†å²è®°å½•æ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} è·å–å†å²è®°å½•æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
    }
  }

  static renderSyncResult(result) {
    try {
      let message = `${CONFIG.EMOJI.database} <b>æ•°æ®åŒæ­¥ç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `${CONFIG.EMOJI.check} <b>åŒæ­¥æˆåŠŸ</b>\n`;
        message += `${CONFIG.EMOJI.info} æ•°æ®æºæ€»æ•°: ${result.total || 0} æ¡\n`;
        message += `${CONFIG.EMOJI.up} æˆåŠŸæ–°å¢: ${result.added || 0} æ¡\n`;
        message += `${CONFIG.EMOJI.repeat} è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\n${CONFIG.EMOJI.star} <b>å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</b>\n`;
        }
      } else {
        message += `${CONFIG.EMOJI.warning} <b>åŒæ­¥å¤±è´¥</b>\n`;
        message += `${CONFIG.EMOJI.info} é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /sync å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åŒæ­¥ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†åŒæ­¥ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderPushResult(success, prediction, channelPushSuccess = false) {
    try {
      let message = `${CONFIG.EMOJI.fire} <b>é¢„æµ‹æ¨é€ç»“æœ</b>\n\n`;
      
      if (success) {
        message += `${CONFIG.EMOJI.check} <b>æ¨é€æˆåŠŸ</b>\n`;
        message += `${CONFIG.EMOJI.info} æœŸå·: ${prediction?.nextExpect || "æœªçŸ¥"}\n`;
        message += `${CONFIG.EMOJI.chart} ç½®ä¿¡åº¦: ${prediction?.confidence || 0}%\n`;
        
        if (channelPushSuccess) {
          message += `${CONFIG.EMOJI.bell} é¢‘é“æ¨é€: æˆåŠŸ ${CONFIG.EMOJI.check}\n`;
        } else {
          message += `${CONFIG.EMOJI.bell} é¢‘é“æ¨é€: å¤±è´¥ ${CONFIG.EMOJI.warning}\n`;
        }
      } else {
        message += `${CONFIG.EMOJI.warning} <b>æ¨é€å¤±è´¥</b>\n`;
        message += `è¯·æ£€æŸ¥ç³»ç»ŸçŠ¶æ€å’Œé…ç½®\n`;
      }
      
      message += `\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /push å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°æ¶ˆæ¯</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“æ¨é€ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.warning} å¤„ç†æ¨é€ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }

  static renderDeleteConfirmation(expectRange, impactInfo) {
    try {
      const { toDeleteCount, latestAfterDelete } = impactInfo || {};
      
      let message = `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤</b>\n\n`;
      
      if (expectRange.includes('-')) {
        const [start, end] = expectRange.split('-');
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(start)}</b> æœŸåˆ°ç¬¬ <b>${Formatter.safeString(end)}</b> æœŸçš„è®°å½•\n`;
      } else {
        message += `æ‚¨å³å°†åˆ é™¤ç¬¬ <b>${Formatter.safeString(expectRange)}</b> æœŸçš„è®°å½•\n`;
      }
      
      message += `${CONFIG.EMOJI.info} æ¶‰åŠ <b>${toDeleteCount || 0}</b> æ¡å†å²è®°å½•\n\n`;
      
      if (latestAfterDelete && latestAfterDelete.open_code) {
        const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
        const attr = Formatter.getAttributes(special);
        message += `${CONFIG.EMOJI.eye} <b>åˆ é™¤åï¼Œæœ€æ–°è®°å½•ä¸º:</b>\n`;
        message += `ç¬¬ <b>${latestAfterDelete.expect || "æœªçŸ¥"}</b> æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
      } else {
        message += `${CONFIG.EMOJI.warning} åˆ é™¤åå°†æ— å†å²è®°å½•\n`;
      }
      
      message += `\n${CONFIG.EMOJI.warning} <b>è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼</b>\n\n`;
      message += `è¯·å›å¤ <code>ç¡®è®¤åˆ é™¤ ${Formatter.safeString(expectRange)}</code> ä»¥ç¡®è®¤åˆ é™¤ã€‚`;
      
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç¡®è®¤å¤±è´¥", error);
      return `${CONFIG.EMOJI.warning} <b>åˆ é™¤ç¡®è®¤å¤±è´¥</b>\n\næ— æ³•ç”Ÿæˆç¡®è®¤ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚`;
    }
  }

  static renderDeleteResult(result, expectRange, impactInfo = null) {
    try {
      let message = `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\n`;
      
      if (result?.success) {
        message += `${CONFIG.EMOJI.check} <b>åˆ é™¤æˆåŠŸ</b>\n`;
        message += `${CONFIG.EMOJI.info} åˆ é™¤èŒƒå›´: ${Formatter.safeString(expectRange)}\n`;
        message += `${CONFIG.EMOJI.info} åˆ é™¤è®°å½•æ•°: ${result.deleted || 0} æ¡\n`;
        
        if (result.total !== undefined) {
          message += `${CONFIG.EMOJI.info} èŒƒå›´å†…è®°å½•æ•°: ${result.total} æ¡\n`;
        }
        
        if (impactInfo && impactInfo.latestAfterDelete) {
          const { latestAfterDelete } = impactInfo;
          const special = Formatter.safeInt(latestAfterDelete.open_code.split(",")[6], 0);
          const attr = Formatter.getAttributes(special);
          message += `\n${CONFIG.EMOJI.eye} <b>åˆ é™¤åæœ€æ–°è®°å½•</b>\n`;
          message += `ç¬¬ ${latestAfterDelete.expect} æœŸ | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
        }
        
        if (result.message) {
          message += `\n${result.message}\n`;
        }
      } else {
        message += `${CONFIG.EMOJI.warning} <b>åˆ é™¤å¤±è´¥</b>\n`;
        message += `${CONFIG.EMOJI.info} é”™è¯¯ä¿¡æ¯: ${result?.error || 'æœªçŸ¥é”™è¯¯'}\n`;
      }
      
      message += `\n${CONFIG.EMOJI.clock} æ“ä½œæ—¶é—´: ${Formatter.formatDateTime()}`;
      message += `\n\n${CONFIG.EMOJI.refresh} <i>å†æ¬¡å‘é€ /delete å°†åˆ é™¤æ­¤æ¶ˆæ¯å¹¶åˆ›å»ºæ–°ç¡®è®¤</i>`;
      
      return message;
    } catch (error) {
      Logger.error("MessageRenderer", "æ¸²æŸ“åˆ é™¤ç»“æœæ—¶å‡ºé”™", error);
      return `${CONFIG.EMOJI.trash} <b>åˆ é™¤æ“ä½œç»“æœ</b>\n\nå¤„ç†åˆ é™¤ç»“æœæ—¶å‘ç”Ÿé”™è¯¯ã€‚`;
    }
  }
}

// ==============================================================================
// 14. å¤–éƒ¨æ¥å£å°è£…ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class ExternalService {
  static async sendMessage(env, chatId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true,
        disable_notification: false
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  static async editMessage(env, chatId, messageId, text, parseMode = "HTML") {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const body = {
        chat_id: chatId,
        message_id: messageId,
        text: text,
        parse_mode: parseMode,
        disable_web_page_preview: true
      };

      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  static async deleteMessage(env, chatId, messageId) {
    try {
      if (!env || !env.TG_BOT_TOKEN) {
        Logger.error("Telegram", "TG_BOT_TOKEN æœªé…ç½®");
        return null;
      }
      
      const url = `https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage?chat_id=${chatId}&message_id=${messageId}`;

      const response = await fetch(url, {
        method: "POST"
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.warn("Telegram", `deleteMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "deleteMessage network error", error);
      return null;
    }
  }

  static async sendAndDeleteOldMessage(env, chatId, messageType, text) {
    try {
      const oldMessageId = MessageManager.getUserMessage(chatId, messageType);
      
      if (oldMessageId) {
        this.deleteMessage(env, chatId, oldMessageId).then(result => {
          if (result && result.ok) {
            Logger.info("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          } else {
            Logger.warn("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¤±è´¥æˆ–æ¶ˆæ¯å·²ä¸å­˜åœ¨: chatId=${chatId}, type=${messageType}, messageId=${oldMessageId}`);
          }
        }).catch(error => {
          Logger.error("Telegram", `åˆ é™¤æ—§æ¶ˆæ¯å¼‚å¸¸: chatId=${chatId}, type=${messageType}`, error);
        });
      }
      
      const sendResult = await this.sendMessage(env, chatId, text);
      
      if (sendResult && sendResult.ok && sendResult.result) {
        const newMessageId = sendResult.result.message_id;
        
        MessageManager.setUserMessage(chatId, messageType, newMessageId);
        
        MessageManager.cleanupOldMessages(chatId, 10);
        
        Logger.info("Telegram", `å‘é€æ–°æ¶ˆæ¯æˆåŠŸ: chatId=${chatId}, type=${messageType}, messageId=${newMessageId}, æ—§æ¶ˆæ¯ID=${oldMessageId || 'æ— '}`);
        
        return { 
          success: true, 
          messageId: newMessageId, 
          oldMessageId: oldMessageId,
          message: oldMessageId ? "å·²åˆ é™¤æ—§æ¶ˆæ¯å¹¶å‘é€æ–°æ¶ˆæ¯" : "å‘é€æ–°æ¶ˆæ¯"
        };
      }
      
      return { 
        success: false, 
        error: "æ¶ˆæ¯å‘é€å¤±è´¥",
        oldMessageId: oldMessageId
      };
    } catch (error) {
      Logger.error("Telegram", "sendAndDeleteOldMessageå¤±è´¥", error);
      return { 
        success: false, 
        error: error.message,
        method: "error"
      };
    }
  }

  static async sendTemporaryMessage(env, chatId, text, parseMode = "HTML") {
    return await this.sendMessage(env, chatId, text, parseMode);
  }

  static async syncHistoryFromUrl(env) {
    if (!env || !env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'application/json, text/plain, */*',
          'Referer': 'https://1234kj.com/'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const text = await response.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        Logger.error("Sync", "JSONè§£æå¤±è´¥", { sample: text.substring(0, 50) });
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      let records = [];

      if (data.code === 0 && data.data && typeof data.data === 'object' && !Array.isArray(data.data)) {
        Logger.info("Sync", "è¯†åˆ«åˆ° 1234kj.com (Object) æ¥å£æ ¼å¼");
        const rawArray = Object.values(data.data);
        records = this.parseRecordsFormat2(rawArray);
      }
      else if (data.code === 0 && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      }
      else if (data.result === true && Array.isArray(data.data)) {
        records = this.parseRecordsFormat1(data.data);
      } 
      else if (Array.isArray(data)) {
        records = this.parseRecordsFormat2(data);
      } 
      else if (data.data && Array.isArray(data.data)) {
        records = this.parseRecordsFormat2(data.data);
      } 
      else {
        Logger.error("Sync", "ä¸æ”¯æŒçš„JSONæ ¼å¼", { keys: Object.keys(data) });
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      records.sort((a, b) => Formatter.compareExpect(b.expect, a.expect));

      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => Formatter.compareExpect(r.expect, latestInDB) > 0);
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      newRecords.sort((a, b) => Formatter.compareExpect(a.expect, b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        const totalSyncs = Formatter.safeInt(await DB.getSetting(env, "TOTAL_SYNCS", "0"), 0) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatDateTime());
        
        CacheManager.clear();
        OptimizedMonteCarloEngine.clearCache();
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        if (item && item.expect && item.openCode) {
          const expect = Formatter.safeString(item.expect).trim();
          const codeStr = Formatter.safeString(item.openCode).trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => Formatter.safeInt(n, 0))
            .filter(n => n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }

  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    if (!Array.isArray(dataArray)) {
      return records;
    }
    
    for (const item of dataArray) {
      try {
        const expect = Formatter.safeString(item.expect || item.issue || item.code, "").trim();
        const codeStr = Formatter.safeString(item.open_code || item.openCode || item.code_number || item.number, "").trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => Formatter.safeInt(n, 0))
          .filter(n => n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(",")
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥`);
      }
    }
    
    return records;
  }
}

// ==============================================================================
// 15. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

class Controller {
  static pendingDeletions = new Map();

  static async handleStart(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderWelcomeMessage(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.START, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†startå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  static async handleCommandTemplate(env, chatId, isAdmin) {
    try {
      const message = MessageRenderer.renderCommandTemplate(isAdmin);
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.COMMAND_TEMPLATE, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†cccå‘½ä»¤å¤±è´¥", error);
      await ExternalService.sendTemporaryMessage(
        env, chatId,
        "âŒ <b>ç³»ç»Ÿé”™è¯¯</b>\n\næ— æ³•æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿ï¼Œè¯·é‡è¯•ã€‚"
      );
    }
  }

  static async handlePredict(env, chatId, algorithm = "traditional") {
    try {
      const algorithmName = CONFIG.ALGORITHM_NAMES[algorithm] || "ä¼ ç»Ÿç®—æ³•";
      
      const processingMessage = `${CONFIG.EMOJI.hourglass} <b>æ­£åœ¨ç”Ÿæˆé¢„æµ‹...</b>\n\nç®—æ³•: ${algorithmName}\næ•°æ®: å…¨éƒ¨å†å²è®°å½•\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      const weights = await DB.getWeights(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆä½¿ç”¨ /sync å‘½ä»¤åŒæ­¥æ•°æ®ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const prediction = await PredictionEngine.generate(env, history, weights, algorithm);
      
      if (!prediction) {
        const message = "âŒ <b>é¢„æµ‹ç”Ÿæˆå¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
        );
        return;
      }
      
      const message = MessageRenderer.renderPrediction(prediction);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, message
      );
      
    } catch (error) {
      Logger.error("Controller", "å¤„ç†predictå‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>ç”Ÿæˆé¢„æµ‹å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message || "æœªçŸ¥é”™è¯¯"}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PREDICT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleHistory(env, chatId, pageStr = "1") {
    try {
      const page = Math.max(1, Formatter.safeInt(pageStr, 1));
      const RECORDS_PER_PAGE = 10;
      const offset = (page - 1) * RECORDS_PER_PAGE;

      const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
      const totalRecords = await DB.getHistoryCount(env);
      const totalPages = Math.max(1, Math.ceil(totalRecords / RECORDS_PER_PAGE));

      const message = MessageRenderer.renderHistory(history, page, totalPages, totalRecords);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
    } catch (error) {
      Logger.error("Controller", "å¤„ç†historyå‘½ä»¤å¤±è´¥", error);
      const errorMessage = "âŒ <b>è·å–å†å²è®°å½•å¤±è´¥</b>\n\nè¯·ç¨åé‡è¯•ã€‚";
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.HISTORY, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleSync(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åŒæ­¥æ•°æ®ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.database} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      const message = MessageRenderer.renderSyncResult(result);
      
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, message
      );
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.SYNC, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handlePush(env, chatId, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥æ¨é€é¢„æµ‹ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    if (!env.TG_CHANNEL_ID) {
      const message = "âŒ <b>é¢‘é“IDæœªé…ç½®</b>\n\næ— æ³•æ¨é€åˆ°é¢‘é“ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const processingMessage = `${CONFIG.EMOJI.fire} <b>æ­£åœ¨ç”Ÿæˆå¹¶æ¨é€é¢„æµ‹...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const history = await DB.getAllHistory(env);
      
      if (history.length === 0) {
        const message = "âŒ <b>æ— å†å²æ•°æ®</b>\n\næ— æ³•ç”Ÿæˆæ¨é€ã€‚";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
        );
        return;
      }
      
      const weights = await DB.getWeights(env);
      const prediction = await PredictionEngine.generate(env, history, weights, "advanced");
      
      let channelPushSuccess = false;
      try {
        const channelMessage = MessageRenderer.renderPrediction(prediction);
        await ExternalService.sendTemporaryMessage(env, env.TG_CHANNEL_ID, channelMessage);
        channelPushSuccess = true;
        Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${prediction.nextExpect}`);
      } catch (error) {
        Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
        channelPushSuccess = false;
      }
      
      const message = MessageRenderer.renderPushResult(true, prediction, channelPushSuccess);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, message
      );
      
    } catch (error) {
      Logger.error("Push", "æ¨é€å¤„ç†å¤±è´¥", error);
      const errorMessage = `âŒ <b>æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.PUSH, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async handleDelete(env, chatId, userId, commandText, isAdmin) {
    if (!isAdmin) {
      const message = "âŒ <b>æƒé™ä¸è¶³</b>\n\nåªæœ‰ç®¡ç†å‘˜å¯ä»¥åˆ é™¤è®°å½•ã€‚";
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, message);
      }
      return;
    }
    
    try {
      const parts = commandText.trim().split(/\s+/);
      if (parts.length < 2) {
        const message = `âŒ <b>å‘½ä»¤æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š\n<code>/delete 2025001</code> ï¼ˆåˆ é™¤å•ä¸ªæœŸå·ï¼‰\n<code>/delete 2025001-2025010</code> ï¼ˆåˆ é™¤æœŸå·èŒƒå›´ï¼‰`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectRange = parts[1];
      const rangeInfo = Formatter.parseExpectRange(expectRange);
      
      if (!rangeInfo) {
        const message = "âŒ <b>æœŸå·æ ¼å¼é”™è¯¯</b>\n\nè¯·ä½¿ç”¨æ­£ç¡®æ ¼å¼ï¼š\n<code>/delete 2025001</code> æˆ– <code>/delete 2025001-2025010</code>";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const impactInfo = await DB.getDeletionImpact(env, rangeInfo.start, rangeInfo.end);
      
      if (impactInfo.toDeleteCount === 0) {
        const message = `âš ï¸ <b>æœªæ‰¾åˆ°è®°å½•</b>\n\nåœ¨ ${expectRange} èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å†å²è®°å½•ã€‚`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const confirmMessage = MessageRenderer.renderDeleteConfirmation(expectRange, impactInfo);
      
      const deletionKey = `${chatId}:${userId}`;
      this.pendingDeletions.set(deletionKey, {
        expectRange: expectRange,
        start: rangeInfo.start,
        end: rangeInfo.end,
        impactInfo: impactInfo,
        timestamp: Date.now()
      });
      
      setTimeout(() => {
        this.pendingDeletions.delete(deletionKey);
      }, 10 * 60 * 1000);
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, confirmMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, confirmMessage);
      }
      
    } catch (error) {
      Logger.error("Delete", "å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>å¤„ç†åˆ é™¤å‘½ä»¤å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_CONFIRM, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }

  static async confirmDelete(env, chatId, userId, confirmText) {
    try {
      const deletionKey = `${chatId}:${userId}`;
      const pendingDeletion = this.pendingDeletions.get(deletionKey);
      
      if (!pendingDeletion) {
        const message = "âŒ <b>åˆ é™¤æ“ä½œå·²è¿‡æœŸæˆ–æ— æ•ˆ</b>\n\nè¯·é‡æ–°å‘èµ·åˆ é™¤å‘½ä»¤ã€‚";
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      const expectedConfirm = `ç¡®è®¤åˆ é™¤ ${pendingDeletion.expectRange}`;
      if (confirmText !== expectedConfirm) {
        const message = `âŒ <b>ç¡®è®¤æ–‡æœ¬ä¸æ­£ç¡®</b>\n\nè¯·å›å¤: <code>${expectedConfirm}</code>`;
        const result = await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        
        if (!result.success) {
          await ExternalService.sendTemporaryMessage(env, chatId, message);
        }
        return;
      }
      
      this.pendingDeletions.delete(deletionKey);
      
      const processingMessage = `${CONFIG.EMOJI.trash} <b>æ­£åœ¨åˆ é™¤è®°å½•...</b>\n\nè¯·ç¨å€™...`;
      const processingResult = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, processingMessage
      );
      
      if (!processingResult.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, processingMessage);
      }
      
      const result = await DB.deleteHistoryByRange(
        env, 
        pendingDeletion.start, 
        pendingDeletion.end,
        Formatter.safeString(userId),
        "æ‰‹åŠ¨åˆ é™¤"
      );
      
      if (!result.success) {
        const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange);
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
        );
        return;
      }
      
      CacheManager.clear();
      OptimizedMonteCarloEngine.clearCache();
      
      const message = MessageRenderer.renderDeleteResult(result, pendingDeletion.expectRange, pendingDeletion.impactInfo);
      await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, message
      );
      
      Logger.info("Delete", `åˆ é™¤æ“ä½œå®Œæˆ: ${pendingDeletion.expectRange}, åˆ é™¤è®°å½•æ•°: ${result.deleted || 0}`);
      
    } catch (error) {
      Logger.error("Delete", "ç¡®è®¤åˆ é™¤å¤±è´¥", error);
      const errorMessage = `âŒ <b>åˆ é™¤æ“ä½œå¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: ${error.message}`;
      
      const result = await ExternalService.sendAndDeleteOldMessage(
        env, chatId, CONFIG.COMMAND_TYPES.DELETE_RESULT, errorMessage
      );
      
      if (!result.success) {
        await ExternalService.sendTemporaryMessage(env, chatId, errorMessage);
      }
    }
  }
}

// ==============================================================================
// 16. äº‹ä»¶å¤„ç†å™¨ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

async function handleUpdate(env, payload) {
  try {
    if (Math.random() < 0.01) {
      MessageManager.autoCleanup();
    }
    
    const msg = payload.message;
    if (!msg || !msg.text) return;

    const chatId = msg.chat.id;
    const text = msg.text.trim();
    const userId = msg.from ? String(msg.from.id) : "UNKNOWN";
    const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
    
    Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}`, { chatId, userId, isAdmin });
    
    if (text.startsWith('ç¡®è®¤åˆ é™¤ ')) {
      if (isAdmin) {
        await Controller.confirmDelete(env, chatId, userId, text);
      } else {
        const message = "âŒ <b>æƒé™ä¸è¶³</b>";
        await ExternalService.sendAndDeleteOldMessage(
          env, chatId, "permission_error", message
        );
      }
      return;
    }
    
    if (text.startsWith('/')) {
      const command = text.toLowerCase().split(/\s+/)[0];
      
      switch (command) {
        case '/start':
          await Controller.handleStart(env, chatId, isAdmin);
          break;
          
        case '/ccc':
        case '/cmd':
        case '/commands':
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
          
        case '/predict':
        case '/p':
          const predictMatch = text.match(/\/predict\s+(stats|advanced)/i);
          if (predictMatch) {
            await Controller.handlePredict(env, chatId, predictMatch[1].toLowerCase());
          } else {
            await Controller.handlePredict(env, chatId, "traditional");
          }
          break;
          
        case '/history':
          const pageMatch = text.match(/\/history\s+(\d+)/);
          const page = pageMatch ? pageMatch[1] : "1";
          await Controller.handleHistory(env, chatId, page);
          break;
          
        case '/sync':
          await Controller.handleSync(env, chatId, isAdmin);
          break;
          
        case '/push':
          await Controller.handlePush(env, chatId, isAdmin);
          break;
          
        case '/delete':
          await Controller.handleDelete(env, chatId, userId, text, isAdmin);
          break;
          
        default:
          await Controller.handleCommandTemplate(env, chatId, isAdmin);
          break;
      }
    } else {
      await Controller.handleCommandTemplate(env, chatId, isAdmin);
    }
  } catch (error) {
    Logger.error("Update", "å¤„ç†æ›´æ–°å¤±è´¥", error);
  }
}

// ==============================================================================
// 17. Worker å…¥å£ç‚¹ï¼ˆç²¾ç®€ç‰ˆï¼‰
// ==============================================================================

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      
      Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
      
      const requiredEnvVars = ['TG_BOT_TOKEN', 'TG_ADMIN_ID'];
      const optionalEnvVars = ['TG_CHANNEL_ID', 'LOTTERY_DATA_URL'];
      
      const missingVars = requiredEnvVars.filter(key => !env[key]);
      
      if (missingVars.length > 0) {
        Logger.error("Worker", `ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${missingVars.join(', ')}`);
        return new Response(JSON.stringify({
          status: "ERROR",
          message: `Missing required environment variables: ${missingVars.join(', ')}`,
          required: requiredEnvVars,
          optional: optionalEnvVars,
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      const optionalMissing = optionalEnvVars.filter(key => !env[key]);
      if (optionalMissing.length > 0) {
        Logger.warn("Worker", `ç¼ºå°‘å¯é€‰ç¯å¢ƒå˜é‡: ${optionalMissing.join(', ')}`);
      }
      
      CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID || "";
      CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID || "";
      
      const initialized = await DB.init(env);
      if (!initialized) {
        return new Response(JSON.stringify({
          status: "ERROR",
          message: "Database Initialization Failed. Please check D1 binding.",
          system: CONFIG.SYSTEM.NAME,
          version: CONFIG.SYSTEM.VERSION
        }, null, 2), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      
      if (request.method === "GET") {
        if (url.pathname === "/health") {
          try {
            const historyCount = await DB.getHistoryCount(env);
            const weights = await DB.getWeights(env);
            
            return new Response(JSON.stringify({
              status: "OK",
              system: CONFIG.SYSTEM.NAME,
              version: CONFIG.SYSTEM.VERSION,
              timestamp: new Date().toISOString(),
              environment: {
                hasChannel: !!env.TG_CHANNEL_ID,
                hasLotteryUrl: !!env.LOTTERY_DATA_URL
              },
              database: {
                historyCount: historyCount
              },
              algorithms: {
                weights: weights,
                traditional: "Enabled",
                statistics: "Enhanced (å’Œå€¼/è·¨åº¦/ACå€¼/è´¨æ•°)",
                monteCarlo: "Integrated in Advanced",
                omission: "Enabled",
                association: "Enabled",
                math: "Enabled",
                zone: "Enabled",
                advanced: "Enabled (æ•´åˆ7å¤§ç®—æ³•)"
              },
              config: {
                historyLimit: CONFIG.SYSTEM.HISTORY_LIMIT,
                predictionTimeout: CONFIG.SYSTEM.PREDICTION_TIMEOUT
              }
            }, null, 2), {
              headers: { 
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
          } catch (error) {
            return new Response(JSON.stringify({
              status: "ERROR",
              error: error.message,
              version: CONFIG.SYSTEM.VERSION
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        if (url.pathname === "/reset-cache") {
          try {
            CacheManager.clear();
            OptimizedMonteCarloEngine.clearCache();
            MessageManager.userMessages.clear();
            
            return new Response(JSON.stringify({
              status: "OK",
              message: "æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤"
            }, null, 2), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ 
              status: "ERROR",
              error: error.message 
            }, null, 2), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        return new Response(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <title>${CONFIG.SYSTEM.NAME}</title>
              <style>
                body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                  color: #333;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                }
                .container {
                  background: white;
                  border-radius: 15px;
                  padding: 30px;
                  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                  margin-top: 20px;
                }
                h1 {
                  color: #2d3748;
                  text-align: center;
                  margin-bottom: 10px;
                  font-size: 2.5em;
                }
                .version {
                  text-align: center;
                  color: #4a5568;
                  margin-bottom: 30px;
                  font-size: 1.1em;
                }
                .feature-list {
                  background: #f7fafc;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .feature-item {
                  margin-bottom: 10px;
                  color: #2d3748;
                }
                .feature-item:before {
                  content: "âœ… ";
                  margin-right: 8px;
                }
                .command-list {
                  background: #f0fff4;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .command {
                  margin-bottom: 8px;
                  color: #276749;
                  font-family: monospace;
                  background: #e6fffa;
                  padding: 5px 10px;
                  border-radius: 5px;
                  display: inline-block;
                }
                .algorithm-info {
                  background: #e6fffa;
                  border: 2px solid #38b2ac;
                  border-radius: 10px;
                  padding: 20px;
                  margin-bottom: 20px;
                }
                .api-endpoints {
                  background: #f7fafc;
                  border-radius: 8px;
                  padding: 15px;
                  margin-top: 20px;
                  color: #2d3748;
                }
                .api-endpoint {
                  font-family: monospace;
                  background: #edf2f7;
                  padding: 3px 8px;
                  border-radius: 3px;
                  margin: 2px 0;
                  display: inline-block;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1>${CONFIG.SYSTEM.NAME}</h1>
                <div class="version">${CONFIG.SYSTEM.VERSION} - ç²¾ç®€å¢å¼ºç‰ˆ</div>
                
                <div class="feature-list">
                  <h3>ç³»ç»Ÿç‰¹æ€§</h3>
                  <div class="feature-item">é˜²åˆ·å±æ¨¡å¼ï¼šæ¯ä¸ªå‘½ä»¤åªä¿ç•™æœ€æ–°æ¶ˆæ¯</div>
                  <div class="feature-item">å¢å¼ºç»Ÿè®¡ç®—æ³•ï¼šå’Œå€¼ã€è·¨åº¦ã€ACå€¼ã€è´¨æ•°å…¨é¢åˆ†æ</div>
                  <div class="feature-item">å¢å¼ºé¢„æµ‹ï¼šæ•´åˆ7å¤§ç®—æ³•çš„æœ€å¼ºé¢„æµ‹</div>
                  <div class="feature-item">ä¼˜åŒ–æ€§èƒ½ï¼šé¢„æµ‹è¶…æ—¶æ§åˆ¶ï¼Œé¿å…Workerè¶…æ—¶</div>
                  <div class="feature-item">æ™ºèƒ½ç¼“å­˜ï¼šæé«˜å“åº”é€Ÿåº¦</div>
                  <div class="feature-item">è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯ï¼Œä¿æŒç•Œé¢æ•´æ´</div>
                  <div class="feature-item">å¤šç§é¢„æµ‹ç®—æ³•ï¼šä¼ ç»Ÿã€ç»Ÿè®¡ã€å¢å¼º</div>
                  <div class="feature-item">å³æ—¶é¢„æµ‹ï¼Œæ— éœ€ç­‰å¾…</div>
                  <div class="feature-item">çº¯æ–‡æœ¬å‘½ä»¤äº¤äº’</div>
                </div>
                
                <div class="command-list">
                  <h3>ä¸»è¦å‘½ä»¤</h3>
                  <div class="command">/start - æ¬¢è¿ä¿¡æ¯</div>
                  <div class="command">/ccc - æ˜¾ç¤ºå‘½ä»¤æ¨¡æ¿</div>
                  <div class="command">/predict - ä¼ ç»Ÿç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict stats - ç»Ÿè®¡ç®—æ³•é¢„æµ‹</div>
                  <div class="command">/predict advanced - å¢å¼ºé¢„æµ‹ï¼ˆæ•´åˆå…¨éƒ¨7å¤§ç®—æ³•ï¼‰</div>
                  <div class="command">/history [é¡µç ] - æŸ¥çœ‹å†å²</div>
                  <div class="command">/sync - åŒæ­¥æ•°æ®(ç®¡ç†å‘˜)</div>
                  <div class="command">/delete [æœŸå·] - åˆ é™¤è®°å½•(ç®¡ç†å‘˜)</div>
                </div>
                
                <div class="algorithm-info">
                  <strong>${CONFIG.EMOJI.crown} å¢å¼ºç®—æ³•ï¼š</strong><br>
                  â€¢ ä¼ ç»Ÿç®—æ³• - åŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°<br>
                  â€¢ å¢å¼ºç»Ÿè®¡ç®—æ³• - å’Œå€¼ã€è·¨åº¦ã€ACå€¼ã€è´¨æ•°å…¨é¢åˆ†æ<br>
                  â€¢ è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ - æ¦‚ç‡æ¨¡æ‹Ÿï¼ŒéšæœºæŠ½æ ·é¢„æµ‹<br>
                  â€¢ é—æ¼å›è¡¥ä¸“å®¶ - å‡å€¼å›å½’ç†è®ºï¼Œè¯†åˆ«ä¸¥é‡é—æ¼å·ç <br>
                  â€¢ å…³è”è§„åˆ™ä¸“å®¶ - Aprioriç®—æ³•ï¼Œå‘ç°å·ç å¼ºå…³è”<br>
                  â€¢ é»„é‡‘åˆ†å‰²ä¸“å®¶ - æ•°å­¦å¸¸æ•°ã€æ•°åˆ—ã€æ¨¡è¿ç®—åˆ†æ<br>
                  â€¢ åŒºé—´å¹³è¡¡ä¸“å®¶ - ç©ºé—´åˆ†å¸ƒåˆ†æï¼Œå†·çƒ­åŒºé—´è¯†åˆ«<br>
                  â€¢ åŸºäºå…¨éƒ¨å†å²è®°å½•ï¼ˆæœ€å¤š2000æœŸï¼‰<br>
                  â€¢ è¶…æ—¶æ§åˆ¶ï¼Œé¿å…Workerè¶…æ—¶<br>
                  â€¢ æ›´ç§‘å­¦çš„æ¦‚ç‡ç»Ÿè®¡å’Œç½®ä¿¡åº¦<br>
                  â€¢ å‘½ä»¤: <code>/predict advanced</code> (å…¨ä¸“å®¶ç®—æ³•æ•´åˆ - æ¨è)
                </div>
                
                <div class="api-endpoints">
                  <strong>APIç«¯ç‚¹ï¼š</strong><br>
                  <div class="api-endpoint">GET /health - ç³»ç»Ÿå¥åº·æ£€æŸ¥</div>
                  <div class="api-endpoint">GET /reset-cache - é‡ç½®ç¼“å­˜</div>
                </div>
              </div>
            </body>
          </html>
        `, {
          headers: { 
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache'
          }
        });
      }

      if (request.method === "POST") {
        try {
          const payload = await request.json();
          ctx.waitUntil(handleUpdate(env, payload));
          
          return new Response("OK", { 
            status: 200,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (e) {
          Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
          return new Response("OK", { status: 200 });
        }
      }
      
      return new Response("Method not allowed", { status: 405 });
    } catch (error) {
      Logger.error("Worker", "å¤„ç†è¯·æ±‚å¤±è´¥", error);
      return new Response(JSON.stringify({
        status: "ERROR",
        error: "Internal Server Error",
        message: error.message,
        system: CONFIG.SYSTEM.NAME,
        version: CONFIG.SYSTEM.VERSION
      }, null, 2), { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
};
